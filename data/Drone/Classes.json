{"name": "Classes", "artifacts": [{"id": "PriorityArea.java", "body": "package edu.nd.dronology.services.core.items;\n\npublic class PriorityArea extends MappedItem {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -1072606981502113567L;\n\n\tpublic PriorityArea(String id) {\n\t\tsuper(id);\n\t}\n\n}\n"}, {"id": "UAVEquipmentTypeRegistrationServiceRemoteFacade.java", "body": "package edu.nd.dronology.services.facades;\n\nimport java.rmi.RemoteException;\n\nimport java.util.Collection;\n\nimport org.apache.commons.lang.NotImplementedException;\n\nimport edu.nd.dronology.services.core.info.UAVEquipmentTypeRegistrationInfo;\nimport edu.nd.dronology.services.core.listener.IItemChangeListener;\nimport edu.nd.dronology.services.core.remote.IUAVEquipmentTypeRegistrationRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.instances.registration.equipment.UAVEquipmentTypeRegistrationService;\nimport edu.nd.dronology.services.remote.AbstractRemoteFacade;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class UAVEquipmentTypeRegistrationServiceRemoteFacade extends AbstractRemoteFacade implements IUAVEquipmentTypeRegistrationRemoteService {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -4580658378477037955L;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(UAVEquipmentTypeRegistrationServiceRemoteFacade.class);\n\tprivate static volatile UAVEquipmentTypeRegistrationServiceRemoteFacade INSTANCE;\n\n\tprotected UAVEquipmentTypeRegistrationServiceRemoteFacade() throws RemoteException {\n\t\tsuper(UAVEquipmentTypeRegistrationService.getInstance());\n\t}\n\n\tpublic static IUAVEquipmentTypeRegistrationRemoteService getInstance() throws RemoteException {\n\t\tif (INSTANCE == null) {\n\t\t\ttry {\n\t\t\t\tsynchronized (UAVEquipmentTypeRegistrationServiceRemoteFacade.class) {\n\t\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\t\tINSTANCE = new UAVEquipmentTypeRegistrationServiceRemoteFacade();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (RemoteException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tpublic byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException {\n\t\treturn UAVEquipmentTypeRegistrationService.getInstance().requestFromServer(id);\n\t}\n\n\t@Override\n\tpublic void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException {\n\t\tUAVEquipmentTypeRegistrationService.getInstance().transmitToServer(id, content);\n\n\t}\n\n\t@Override\n\tpublic boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException {\n\t\tthrow new NotImplementedException();\n\t}\n\n\t@Override\n\tpublic boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException {\n\t\tthrow new NotImplementedException();\n\t}\n\n\t@Override\n\tpublic Collection<UAVEquipmentTypeRegistrationInfo> getItems() throws RemoteException {\n\t\treturn UAVEquipmentTypeRegistrationService.getInstance().getItems();\n\t}\n\n\t@Override\n\tpublic UAVEquipmentTypeRegistrationInfo createItem() throws RemoteException, DronologyServiceException {\n\t\treturn UAVEquipmentTypeRegistrationService.getInstance().createItem();\n\t}\n\n\t@Override\n\tpublic void deleteItem(String itemid) throws RemoteException, DronologyServiceException {\n\t\t// TODO Auto-generated method stub\n\t\tthrow new NotImplementedException();\n\t}\n\n\n\n}"}, {"id": "IFileTransmitRemoteService.java", "body": "package edu.nd.dronology.services.core.remote;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\n\nimport edu.nd.dronology.services.core.api.IRemotable;\nimport edu.nd.dronology.services.core.info.UAVTypeRegistrationInfo;\nimport edu.nd.dronology.services.core.listener.IItemChangeListener;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic interface IFileTransmitRemoteService<ITEM_TYPE> extends IRemotable {\n\n\tbyte[] requestFromServer(String id) throws RemoteException, DronologyServiceException;\n\n\tvoid transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException;\n\n\tpublic boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException;\n\n\tpublic boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException;\n\n\t\n\tCollection<ITEM_TYPE> getItems() throws RemoteException;\n\n\tITEM_TYPE createItem() throws RemoteException, DronologyServiceException;\n\n\tvoid deleteItem(String itemid) throws RemoteException, DronologyServiceException;\n}\n"}, {"id": "FullMissionPlan.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.v1;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.json.JSONException;\n\nimport edu.nd.dronology.core.DronologyConstants;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;\nimport edu.nd.dronology.services.extensions.missionplanning.plan.IExecuteableMissionPlan;\nimport edu.nd.dronology.services.extensions.missionplanning.plan.MissionUtil;\nimport edu.nd.dronology.services.extensions.missionplanning.plan.UAVMissionPlan;\nimport edu.nd.dronology.services.extensions.missionplanning.sync.SynchronizationManager;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.TaskFactory;\nimport edu.nd.dronology.services.instances.dronesetup.DroneSetupService;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Manages a mission plan. Each Mission plan has one <code>FullMissionPlan</code> instance, and one <code>UAVMissionPlan</code> instance for each UAV in the Mission plan. <br>\n * Each of the UAV's individual mission plans are composed of MissionTasks. <br>\n * Once the entire mission plan is loaded, a thread is created which checks each of the individual UAVMissionPlans to determine if they can start the next task.\n * \n *@author Jane Cleland-Huang\n */\n@Deprecated\npublic class FullMissionPlan implements IExecuteableMissionPlan {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(FullMissionPlan.class);\n\n\tprivate Map<String, UAVMissionPlan> uavMissionPlans;\n\tprivate SynchronizationManager synchPointMgr;\n\tprivate String mission;\n\n\t/**\n\t * Constructs the CoordinatedMission instance. A mission consists of one or more UAVs, each of which has a set of assigned tasks and synchronization points.\n\t * \n\t * @param mission\n\t */\n\tpublic FullMissionPlan(String mission) {\n\t\tthis.mission = mission;\n\t\tuavMissionPlans = new HashMap<>();\n\t\tsynchPointMgr = SynchronizationManager.getInstance();\n\n\t}\n\n\t/**\n\t * Loads mission from JSON file. Currently hard coded. \n\t * \n\t * @param mission\n\t * @throws MissionExecutionException\n\t */\n\tprivate void loadMission(String mission) throws MissionExecutionException {\n\t\tJSONMissionPlanReader jsonReader = new JSONMissionPlanReader(this);\n\t\ttry {\n\t\t\tjsonReader.parseMission(mission);\n\t\t} catch (IOException | JSONException e) {\n\t\t\tthrow new MissionExecutionException(e.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * Adds an additional UAV to the mission plan. Creates the <code>UAVMissionTasks</code> instance and passes it a reference to the <code>synchPointMgr</code>\n\t * \n\t * @param uavID\n\t *          the ID of the UAV\n\t * @throws MissionExecutionException\n\t */\n\tpublic void addUAV(String uavID) throws MissionExecutionException {\n\t\tUAVMissionPlan plan = new UAVMissionPlan(uavID, synchPointMgr);\n\t\tif (uavMissionPlans.containsKey(uavID)) {\n\t\t\tthrow new MissionExecutionException(\"Mission Plan for UAV '\" + uavID + \"' already defined\");\n\t\t}\n\t\tuavMissionPlans.put(uavID, plan);\n\t}\n\n\tpublic void removeUAV(String uavID) {\n\t\tuavMissionPlans.remove(uavID);\n\t}\n\n\t/**\n\t * Assigns a task to a specific UAV\n\t * \n\t * @param uavID\n\t *          UAV Identifier\n\t * @param task\n\t *          Task to perform (e.g., Route, Waypoint, Synchronize, FlightPattern)\n\t * @param taskID\n\t *          Task specifics (e.g., specific waypoint, route name etc)\n\t * @throws MissionExecutionException\n\t */\n\tpublic void addTask(String uavID, String task, String taskID, Object... params) throws MissionExecutionException {\n\t\tfor (UAVMissionPlan plan : uavMissionPlans.values()) {\n\t\t\tif (plan.getUavID().equals(uavID)) {\n\t\t\t\tplan.addTask(TaskFactory.getTask(task, uavID, taskID, params), synchPointMgr);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow new MissionExecutionException(\"UAVMissionPlan '\" + uavID + \"' not available!\");\n\t}\n\n\t@Override\n\tpublic boolean isMissionActive() {\n\t\tfor (UAVMissionPlan plan : uavMissionPlans.values()) {\n\t\t\tif (plan.hasTasks()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Build all synch points\n\t */\n\tprivate void buildAllSynchPoints() {\n\t\tuavMissionPlans.forEach((uavId, plan) -> {\n\t\t\tplan.buildSynchPoints();\n\t\t});\n\t}\n\n\t/**\n\t * Activates next task in each UAV mission, if there is no unfinished active task\n\t * \n\t * @throws MissionExecutionException\n\t */\n\t@Override\n\tpublic void checkAndActivateTask() throws MissionExecutionException {\n\t\tfor (UAVMissionPlan plan : uavMissionPlans.values()) {\n\t\t\tif (!plan.hasActiveTask()) {\n\t\t\t\tplan.activateNextTask();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Expands flight pattern tasks (e.g., coordinatedTakeOff or coordinatedLanding)\n\t * \n\t * @throws MissionExecutionException\n\t *   \n\t */\n\tprivate void expandAllTasks() throws MissionExecutionException {\n\t\tfor (UAVMissionPlan plan : uavMissionPlans.values()) {\n\t\t\tplan.expandTaskList();\n\t\t}\n\t}\n\n\tpublic void build() throws MissionExecutionException {\n\t\tloadMission(mission);\n\t\texpandAllTasks();\n\t\tbuildAllSynchPoints();\n\t\tsynchPointMgr.activateAllSynchPoints();\n\t\trunPreChecks();\n\n\t}\n\n\tprivate void runPreChecks() throws MissionExecutionException {\n\t\tfor (Entry<String, UAVMissionPlan> e : uavMissionPlans.entrySet()) {\n\t\t\tcheckDistance(e.getKey(), e.getValue());\n\t\t}\n\t}\n\n\tprivate void checkDistance(String uavid, UAVMissionPlan plan) throws MissionExecutionException {\n\t\tLlaCoordinate coordinate = plan.getStartingRouteWaypoint();\n\t\tIUAVProxy uav = null;\n\t\tif (coordinate == null) {\n\t\t\tthrow new MissionExecutionException(\"Error when retrieving first waypoint for uav '\" + uavid + \"'\");\n\t\t}\n\t\ttry {\n\t\t\tuav = DroneSetupService.getInstance().getActiveUAV(uavid);\n\t\t} catch (DronologyServiceException e) {\n\t\t\tthrow new MissionExecutionException(e.getMessage());\n\t\t}\n\t\tdouble distanceToFirstWaypoint = uav.getCoordinates().distance(coordinate);\n\t\tif (distanceToFirstWaypoint > DronologyConstants.MISSION_MAX_STARTING_DISTANCE) {\n\t\t\tthrow new MissionExecutionException(\n\t\t\t\t\t\"Distance to first waypoint exceeds maximum safety distance: \" + distanceToFirstWaypoint + \"m\");\n\t\t}\n\t\tLOGGER.info(\"Precheck passed -- Distance to first waypoint: \" + distanceToFirstWaypoint);\n\n\t}\n\n\t@Override\n\tpublic void cancelMission() {\n\t\tLOGGER.missionError(\"Mission cancelled!\");\n\t\tfor (UAVMissionPlan plan : uavMissionPlans.values()) {\n\t\t\tString uavid = plan.getUavID();\n\t\t\tMissionUtil.stopUAV(uavid);\n\t\t}\n\t}\n\n}\n"}, {"id": "MetricsStatistics.java", "body": "package edu.nd.dronology.services.core.areamapping;\n\nimport java.util.Collections;\nimport java.util.List;\n\npublic class MetricsStatistics {\n\tprivate double equalityOfTasks;\n\tprivate double allocationCoverage;\n\tprivate double downstreamRatio;\n\tprivate boolean batteryFailed;\n\tprivate int collisions;\n\tprivate double allocationScore;\n\tprivate double totalDistance;\n\tprivate List<Double> droneDistances;\n\tprivate double allocationPriorityCoverage;\n\t\n\tpublic MetricsStatistics(double equalityOfTasks, double allocationCoverage, double downstreamRatio, boolean batteryFailed, int collisions, double totalDistance, \n\t\t\tList<Double> droneDistances, double priorityCoverage) {\n\t\tthis.equalityOfTasks = equalityOfTasks;\n\t\tthis.allocationCoverage = allocationCoverage;\n\t\tthis.downstreamRatio = downstreamRatio;\n\t\tthis.batteryFailed = batteryFailed;\n\t\tthis.collisions = collisions;\n\t\tthis.totalDistance = totalDistance;\n\t\tthis.droneDistances = droneDistances;\n\t\tthis.allocationPriorityCoverage = priorityCoverage;\n\t\tcalculateAllocationScore();\n\t}\n\t\n\t//score of all metrics combined here\n\tprivate void calculateAllocationScore() {\n\t\tif(batteryFailed) {\n\t\t\tallocationScore = 0;\n\t\t} else {\n\t\t\tallocationScore = 0.25*(equalityOfTasks + allocationCoverage + downstreamRatio - collisions / 5);\n\t\t}\n\t}\n\t\n\tpublic double getEqualityOfTasks() {\n\t\treturn equalityOfTasks;\n\t}\n\t\n\tpublic double getAllocationCoverage() {\n\t\treturn allocationCoverage;\n\t}\n\t\n\tpublic double getDownstreamToUpstreamRatio() {\n\t\treturn downstreamRatio;\n\t}\n\t\n\tpublic boolean getBatteryFailed() {\n\t\treturn batteryFailed;\n\t}\n\t\n\tpublic int getCollisions() {\n\t\treturn collisions;\n\t}\n\t\n\tpublic double getAllocationScore() {\n\t\treturn allocationScore;\n\t}\n\t\n\tpublic double getTotalDistance() {\n\t\treturn totalDistance;\n\t}\n\t\n\tpublic List<Double> getDroneDistances(){\n\t\treturn Collections.unmodifiableList(droneDistances);\n\t}\n\t\n\tpublic double getAllocationPriorityCoverage() {\n\t\treturn allocationPriorityCoverage;\n\t}\n}\n"}, {"id": "UAVListenerManager.java", "body": "package edu.nd.dronology.core.vehicle;\n\npublic class UAVListenerManager {\n\n\tprivate static volatile UAVListenerManager INSTANCE = null;\n\n\tpublic static UAVListenerManager getInstance() {\n\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (UAVListenerManager.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new UAVListenerManager();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\tpublic void notifyUAVFlightModeChanged(String id, String newState){\n\t\t//notify listeners...\n\t\n\t}\n\n}\n"}, {"id": "JSONMissionPlanReader.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.v1;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.json.JSONException;\n\nimport com.google.gson.Gson;\n\nimport edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;\n\n/**\n * Simple JSON Reader that converts a json String into a {@link FullMissionPlan} object.\n * \n * @author Jane Cleland-Huang\n *\n */\n@SuppressWarnings(\"rawtypes\")\npublic class JSONMissionPlanReader {\n\n\tFullMissionPlan coordinatedMission;\n\t// String fileName;\n\n\tpublic JSONMissionPlanReader(FullMissionPlan coordinatedMission) {\n\t\tthis.coordinatedMission = coordinatedMission;\n\t}\n\n\tpublic void parseMission(String content)\n\t\t\tthrows FileNotFoundException, IOException, JSONException, MissionExecutionException {\n\t\t// parsing input file\n\t\t// Object obj = new JSONParser().parse(content);\n\n\t\tMap valueMap = new Gson().fromJson(content, Map.class);\n\n\t\tList plans = (List) valueMap.get(\"plans\");\n\n\t\tfor (Object object : plans) {\n\t\t\tMap jo2 = (Map) object;\n\t\t\tString uavid = (String) jo2.get(\"id\");\n\t\t\tcoordinatedMission.addUAV(uavid);\n\n\t\t\tList tasks = (List) jo2.get(\"tasks\");\n\t\t\tfor (Object task : tasks) {\n\t\t\t\tparseTasks(task, uavid);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void parseTasks(Object item, String uavid) throws MissionExecutionException {\n\t\tMap jsnObject = (Map) item;\n\t\tString task = (String) jsnObject.get(\"task\");\n\t\tString taskID;\n\n\t\ttaskID = (String) jsnObject.get(\"name\");\n\t\tString duration = (String) jsnObject.get(\"duration\");\n\n\t\tif (duration != null) {\n\t\t\tcoordinatedMission.addTask(uavid, task, taskID, duration);\n\t\t} else {\n\t\t\tcoordinatedMission.addTask(uavid, task, taskID);\n\t\t}\n\t}\n\n}\n"}, {"id": "RemoteService.java", "body": "package edu.nd.dronology.services.remote;\n\nimport java.util.Collection;\n\nimport edu.nd.dronology.services.core.base.AbstractServerService;\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\nimport edu.nd.dronology.services.core.remote.RemoteInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.instances.remote.IRemoteConnectionServiceInstance;\nimport edu.nd.dronology.services.instances.remote.RemoteConnectionServiceInstance;\n\npublic class RemoteService extends AbstractServerService<IRemoteConnectionServiceInstance> {\n\n\tprivate static volatile RemoteService INSTANCE;\n\n\t@Override\n\tprotected IRemoteConnectionServiceInstance initServiceInstance() {\n\t\treturn new RemoteConnectionServiceInstance();\n\t}\n\n\t/**\n\t * @return The singleton RemoteService instance\n\t */\n\tpublic static RemoteService getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (RemoteService.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new RemoteService();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\tpublic void performCleanup() {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n\tpublic Collection<RemoteInfo> getRegisteredRemoteClients() {\n\t\treturn serviceInstance.getRegisteredRemoteClients();\n\t}\n\n\tpublic void register(RemoteInfo rInfo) {\n\t\tserviceInstance.register(rInfo);\n\t}\n\n\tpublic void unregister(RemoteInfo rInfo) {\n\t\tserviceInstance.unregister(rInfo);\n\t}\n\n\t// public void logExternal(LogEventAdapter event) {\n\t// serviceInstance.logExternal(event);\n\t// }\n\tpublic void addRemoteManager(IRemoteManager manager) throws DronologyServiceException {\n\t\tserviceInstance.addRemoteManager(manager);\n\n\t}\n\n}\n"}, {"id": "ServiceIds.java", "body": "package edu.nd.dronology.services.core.util;\n\n/**\n * \n * \n * @author Michael Vierhauser\n * \n */\npublic class ServiceIds {\n\n\n\tpublic static final String SERVICE_FLIGHROUTE = \"ROUTEPLANNING\";\n\tpublic static final String SERVICE_SIMULATOR = \"SIMULATOR\";\n\tpublic static final String SERVICE_REMOTE = \"REMOTE\";\n\n\tpublic static final String SERVICE_FLIGHTMANAGER = \"FLIGHTMANAGER\";\n\tpublic static final String SERVICE_DRONESETUP = \"DRONESETUP\";\n\tpublic static final String SERVICE_REGISTRATION = \"DRONEREGISTRATION\";\n\tpublic static final String SERVICE_EQUIP_TYPE_REGISTRATION = \"EQUIPDRONEREGISTRATION\";\n\tpublic static final String SERVICE_TYPEREGISTRATION = \"DRONETYPEREGISTRATION\";\n\tpublic static final String SERVICE_MISSIONPLANNING = \"MISSIONPLANNING\";\n\tpublic static final String SERVICE_AREAMAPPING = \"AREAMAPPING\";\n\t\n}\n"}, {"id": "VirtualDrone.java", "body": "package edu.nd.dronology.core.vehicle.internal;\n\nimport com.google.common.util.concurrent.RateLimiter;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.exceptions.FlightZoneException;\nimport edu.nd.dronology.core.simulator.IFlightSimulator;\nimport edu.nd.dronology.core.simulator.SimulatorFactory;\nimport edu.nd.dronology.core.vehicle.AbstractDrone;\nimport edu.nd.dronology.core.vehicle.IDrone;\nimport edu.nd.dronology.core.vehicle.commands.AbstractDroneCommand;\nimport edu.nd.dronology.util.NullUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\n/**\n * Representation of a virtual UAV which is controlled by the internal simulator.\n * \n * @author Jane Cleland-Huang\n * \n */ \npublic class VirtualDrone extends AbstractDrone implements IDrone {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(VirtualDrone.class);\n\tIFlightSimulator simulator;\n\n\t/**\n\t * Constructs drone without specifying its current position. This will be used by the physical drone (later) where positioning status will be acquired from the drone.\n\t * \n\t * @param drnName\n\t */\n\tpublic VirtualDrone(String drnName) {\n\t\tsuper(drnName);\n\t\tsimulator = SimulatorFactory.getSimulator(this);\n\t} \n\n\t@Override \n\tpublic void takeOff(double targetAltitude) throws FlightZoneException {\n\t\tsimulator.startBatteryDrain();\n\t\tdroneStatus.updateBatteryLevel(simulator.getVoltage()); // Need more\n\t\tsuper.setCoordinates(droneStatus.getLatitude(), droneStatus.getLongitude(), targetAltitude);\n\t\ttry {\n\t\t\tThread.sleep(new Double(targetAltitude).intValue() * 100); // Simulates\n\t\t} catch (InterruptedException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void flyTo(LlaCoordinate targetCoordinates, Double speed) {\n\t\tNullUtil.checkNull(targetCoordinates);\n\t\t// LOGGER.info(\"Flying to: \"+ targetCoordinates.toString());\n\t\tsimulator.setFlightPath(currentPosition, targetCoordinates);\n\t}\n\n\t@Override\n\tpublic void land() throws FlightZoneException {\n\t\ttry { \n\t\t\tThread.sleep(1500);\n\t\t\tsimulator.checkPoint();\n\t\t\tsimulator.stopBatteryDrain();\n\n\t\t} catch (Throwable e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic double getBatteryStatus() {\n\t\tdroneStatus.updateBatteryLevel(simulator.getVoltage());\n\t\treturn simulator.getVoltage();\n\t}\n\n\tRateLimiter limiter = RateLimiter.create(5);\n\n\t@Override\n\tpublic boolean move(double i) { // ALSO NEEDS THINKING ABOUT FOR non-VIRTUAL\n\t\tgetBatteryStatus();\n\t\t// limiter.acquire();\n\t\tboolean moveStatus = simulator.move(2);\n\t\tdroneStatus.updateCoordinates(getLatitude(), getLongitude(), getAltitude());\n\n\t\t// DroneCollectionStatus.getInstance().testStatus();\n\t\treturn moveStatus;\n\t}\n\n\t@Override\n\tpublic void setVoltageCheckPoint() {\n\t\tsimulator.checkPoint();\n\n\t}\n\n\t@Override\n\tpublic boolean isDestinationReached(int distanceMovedPerTimeStep) {\n\t\treturn simulator.isDestinationReached(distanceMovedPerTimeStep);\n\t}\n\n\t@Override\n\tpublic void setGroundSpeed(double speed) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n\t@Override\n\tpublic void setVelocity(double x, double y, double z) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n\t@Override\n\tpublic void sendCommand(AbstractDroneCommand command) throws DroneException {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n\t@Override\n\tpublic void resendCommand() {\n\t\t// TODO Auto-generated method stub\n\t}\n\n\t@Override\n\tpublic DroneSnapshotInternal getLatestDroneSnapshot() {\n\t\t//todo get velocity and attitude values\n\t\tVector3D velocity = new Vector3D(0, 0, 0);\n\t\tVector3D attitude = new Vector3D(0, 0, 0);\n\t\treturn new DroneSnapshotInternal(this.droneName, droneStatus.getCoordinates(), velocity, attitude);\n\t}\n}\n"}, {"id": "CoverageTest.java", "body": "package edu.nd.dronology.services.extensions.areamapping.output;\n\nimport org.junit.Test;\n\npublic class CoverageTest {\n\t\n\tfinal static double APERATURE_WIDTH = 10;\n\tfinal static double APERATURE_HEIGHT = APERATURE_WIDTH*0.8;\n\tfinal static double OVERLAP_FACTOR = 0.7;\n\t\n\t@Test\n\tpublic void testCalculateRouteCoverage() {\n//\t\tMapRiver riverMapper = new MapRiver();\n//\t\tList<RoutePrimitive> routes = riverMapper.generateRoutePrimitives();\n//\t\tMetricsRunner metricsRunner = new MetricsRunner(routes, riverMapper.getTotalRiverSegment(), riverMapper.getBankList(), APERATURE_WIDTH, APERATURE_HEIGHT, 4);\n//\t\tmetricsRunner.droneSetup();\n//\t\tMetricsStatistics statistics = metricsRunner.runMetrics();\n//\t\tSystem.out.println(statistics.getAllocationCoverage());\n//\t\tassertTrue(statistics.getAllocationCoverage() > 0.98);\n\t}\n\n}\n"}, {"id": "TaskList.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.patterns;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.IMissionTask;\n\n/**\n * Contains a list of {@link IMissionTask} part mission.\n * \n * @author Jane Cleland-Huang\n *\n */\npublic class TaskList {\n\n\tList<IMissionTask> tasks = new ArrayList<>();\n\n\tpublic List<IMissionTask> getTasks() {\n\t\treturn Collections.unmodifiableList(tasks);\n\t}\n\n\tpublic void addTask(IMissionTask task) {\n\t\ttasks.add(task);\n\n\t}\n\n}\n"}, {"id": "IMissionTask.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.tasks;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\n/**\n * \n * @author A specific task in a mission for a UAV.\n *\n */\npublic interface IMissionTask {\n\n\t/**\n\t * \n\t * @return The id of the UAV the task belongs to.\n\t */\n\tString getUAVId();\n\n\t/**\n\t * \n\t * @return The name of the task.\n\t */\n\tString getTaskName();\n\n\t/**\n\t * \n\t * @return The waypoint associated with the task.\n\t */\n\tLlaCoordinate getWaypoint();\n\n}"}, {"id": "CommandIds.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n/**\n * \n * \tIds for valid UAV commands \n * \n * @author Michael Vierhauser\n *\n */\npublic class CommandIds {\n\n\tpublic static final String SET_MODE_COMMAND = \"setMode\";\n\tpublic static final String GOTO_LOCATION_COMMAND = \"gotoLocation\";\n\tpublic static final String PING_PONG_COMMAND = \"pingpong\"; //unused\n\tpublic static final String TAKEOFF_COMMAND = \"takeoff\";\n\tpublic static final String STOP_COMMAND = \"stop\";\n\tpublic static final String SET_GROUND_SPEED_COMMAND = \"setGroundspeed\";\n\tpublic static final String SET_VELOCITY_COMMAND = \"setVelocity\";\n\tpublic static final String SET_MONITOR_FREQUENCY_COMMAND = \"setMonitorFrequency\";\n\tpublic static final String SET_STATE_FREQUENCY_COMMAND = \"setStateFrequency\";\n\tpublic static final String CONNECTION_RESPONSE = \"connectionResponse\";\n}\n"}, {"id": "IUAVEquipmentTypeRegistrationRemoteService.java", "body": "package edu.nd.dronology.services.core.remote;\n\nimport edu.nd.dronology.services.core.info.UAVEquipmentTypeRegistrationInfo;\n\npublic interface IUAVEquipmentTypeRegistrationRemoteService extends IRemoteableService, IFileTransmitRemoteService<UAVEquipmentTypeRegistrationInfo> {\n\n\t\n\t\n}\n"}, {"id": "SendToSubscriberCallable.java", "body": "package edu.nd.dronology.monitoring;\n\nimport java.util.concurrent.Callable;\n\nimport edu.nd.dronology.core.monitoring.IMonitorableMessage;\nimport edu.nd.dronology.monitoring.service.DroneMonitoringService;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class SendToSubscriberCallable implements Callable {\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(SendToSubscriberCallable.class);\n\n\tprivate IRemoteMonitoringMessageHandler handler;\n\tprivate IMonitorableMessage message;\n\n\tpublic SendToSubscriberCallable(IRemoteMonitoringMessageHandler handler, IMonitorableMessage message) {\n\t\tthis.handler = handler;\n\t\tthis.message = message;\n\t}\n\n\t@Override\n\tpublic Object call() throws Exception {\n\t\ttry {\n\t\t\thandler.notifyMonitoringMessage(message);\n\t\t} catch (java.rmi.RemoteException e) {\n\t\t\tLOGGER.error(e.getMessage() + \" Unregistering Handler\");\n\t\t\tDroneMonitoringService.getInstance().unsubscribeHandler(handler);\n\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n}\n"}, {"id": "ResultCreationUtil.java", "body": "package edu.nd.dronology.services.extensions.areamapping.selection;\n\nimport java.awt.geom.Point2D;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.services.core.areamapping.ExportAllocationInformation;\nimport edu.nd.dronology.services.core.areamapping.ExportDrone;\nimport edu.nd.dronology.services.core.items.FlightRoute;\nimport edu.nd.dronology.services.core.items.IFlightRoute;\nimport edu.nd.dronology.services.extensions.areamapping.internal.Geometry;\nimport edu.nd.dronology.services.extensions.areamapping.metrics.AllocationInformation;\nimport edu.nd.dronology.services.extensions.areamapping.metrics.Drone;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive.RouteType;\nimport edu.nd.dronology.services.extensions.areamapping.util.Utilities;\n\npublic class ResultCreationUtil {\n\n\tprivate static final double ALTITUDE = 20;\n\tprivate List<RoutePrimitive> routePrimitives;\n\tprivate Map<RouteType, AtomicInteger> typeCounter = new HashMap<>();\n\tprivate Map<RoutePrimitive, IFlightRoute> routeMap = new HashMap<>();\n\tprivate double avgLatitude;\n\n\tpublic ResultCreationUtil(List<RoutePrimitive> routePrimitives) {\n\t\tthis.routePrimitives = routePrimitives;\n\t}\n\n\tpublic void createRoutes(double avgLatitude) {\n\t\tthis.avgLatitude = avgLatitude;\n\t\tfor (RoutePrimitive pr : routePrimitives) {\n\t\t\tint val = 1;\n\t\t\tpr = Utilities.cartesianRouteToGpsRoute(pr, avgLatitude);\n\t\t\tRouteType type = pr.getRouteType();\n\t\t\tif (typeCounter.containsKey(type)) {\n\t\t\t\tval = typeCounter.get(type).incrementAndGet();\n\t\t\t} else {\n\t\t\t\ttypeCounter.put(type, new AtomicInteger(1));\n\t\t\t}\n\t\t\tmakeFlightRoute(pr, ALTITUDE, type.toString() + \"_\" + val);\n\n\t\t}\n\n\t}\n\n\t// edit to return IFlightRoute with name as something with type of route\n\tpublic IFlightRoute makeFlightRoute(RoutePrimitive route, double altitude, String name) {\n\t\tIFlightRoute newRoute = new FlightRoute();\n\t\tfor (Point2D.Double entry : route.getRoute()) {\n\t\t\tnewRoute.addWaypoint(new Waypoint(new LlaCoordinate(entry.getX(), entry.getY(), altitude)));\n\t\t}\n\t\tnewRoute.setName(name);\n\t\trouteMap.put(route, newRoute);\n\t\treturn newRoute;\n\t}\n\n\tpublic RouteSelectionResult createResult(List<AllocationInformation> allAllocations) {\n\t\tRouteSelectionResult result = new RouteSelectionResult();\n\t\t// List<RoutePrimitive> exportedRouteAssignments = new ArrayList<>();\n\t\tfor (AllocationInformation entry : allAllocations) {\n\t\t\tExportAllocationInformation ass = new ExportAllocationInformation();\n\t\t\tass.setMetricsStatistics(entry.getMetricStatistics());\n\t\t\tresult.add(ass);\n\t\t\tfor (Drone dr : entry.getDroneAllocations()) {\n\t\t\t\tExportDrone exp = new ExportDrone(dr.getUAVId());\n\t\t\t\tjava.awt.geom.Point2D.Double home = Geometry.cartesianToGPS(dr.getDroneHomeLocation(), avgLatitude);\n\t\t\t\tjava.awt.geom.Point2D.Double start = Geometry.cartesianToGPS(dr.getDroneStartPoint(), avgLatitude);\n\n\t\t\t\texp.setDroneHomeLocation(new LlaCoordinate(home.getX(), home.getY(), ALTITUDE));\n\t\t\t\texp.setDroneStartPoint(new LlaCoordinate(start.getX(), start.getY(), ALTITUDE));\n\n\t\t\t\tdr.getDroneRouteAssignment().get().forEach(pr -> {\n\t\t\t\t\texp.addRoute(routeMap.get(pr));\n\t\t\t\t});\n\t\t\t\tass.addDroneAllocation(exp);\n\t\t\t}\n\n\t\t}\n\t\t// result.setExportAllocationInformation(info);\n\t\treturn result;\n\t}\n\n}\n"}, {"id": "AFChooseMissionWindow.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\n\nimport java.io.ByteArrayInputStream;\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.vaadin.ui.Button;\nimport com.vaadin.ui.Component;\nimport com.vaadin.ui.HorizontalLayout;\nimport com.vaadin.ui.Notification;\nimport com.vaadin.ui.Notification.Type;\nimport com.vaadin.ui.UI;\nimport com.vaadin.ui.VerticalLayout;\nimport com.vaadin.ui.Window;\nimport com.vaadin.ui.themes.ValoTheme;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.info.MissionInfo;\nimport edu.nd.dronology.services.core.info.UAVMappingInfo;\nimport edu.nd.dronology.services.core.items.IMissionPlan;\nimport edu.nd.dronology.services.core.items.IUAVMissionDescription;\nimport edu.nd.dronology.services.core.persistence.MissionPlanningPersistenceProvider;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;\nimport edu.nd.dronology.services.core.remote.IMissionPlanningRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.extensions.missionplanning.persistence.PersistableMissionPlan;\nimport edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;\nimport edu.nd.dronology.ui.vaadin.missionplanning.MPControlsComponent;\nimport edu.nd.dronology.ui.vaadin.missionplanning.MPInfoBox;\nimport edu.nd.dronology.ui.vaadin.missionplanning.MPInfoPanel;\nimport edu.nd.dronology.ui.vaadin.missionplanning.MPMainLayout;\nimport edu.nd.dronology.ui.vaadin.missionplanning.MissionPlanningIntoNameComparator;\nimport edu.nd.dronology.ui.vaadin.start.MyUI;\n\n/*\n * This is a window that will allow users to choose a mission to execute from the list of missions in the mission planning\n * tab as opposed to having to choose a json on their computer\n * \n */\npublic class AFChooseMissionWindow extends Window {\n\t\n\tprivate static final long serialVersionUID=32682356984592L;\n\t\n\tprivate MPMainLayout mpLayout = new MPMainLayout();\n\tprivate HorizontalLayout buttonLayout = new HorizontalLayout();\n\tprivate MPControlsComponent controls = new MPControlsComponent(mpLayout);\n\tprivate MPInfoPanel infoPanel = new MPInfoPanel(controls);\n\tprivate Collection<IUAVProxy> drones = null;\n\t\n\tpublic AFChooseMissionWindow(AFInfoPanel AFinfo) {\n\t\t // update the info panel with all missions from dronology and remove all the buttons that allow for editing and deleting missions\n\t\t infoPanel.refreshMission();\n\t\t infoPanel.removeButton();\n\t\t\n\t\t // total layout for the whole page\n\t\t VerticalLayout allContent = new VerticalLayout();\n\t\t \n\t\t // remove the edit and delete buttons from each info box\n\t\t for (Component box : infoPanel.getMissions()) {\n\t\t\t ((MPInfoBox) box).removeButtons();\n\t\t }\n\t\t \n\t\t // execute and cancel buttons\n\t\t Button cancel = new Button(\"Cancel\");\n\t\t Button select = new Button(\"Select\");\n\t\t select.addStyleName(ValoTheme.BUTTON_PRIMARY);\n\t\t Button execute = new Button(\"Execute\");\n\t\t execute.addStyleName(\"btn-okay\");\n\t\t buttonLayout.addComponents(cancel, select, execute);\n\t\t \n\t\t // gets all active drones from dronology\n\t\t BaseServiceProvider provider = MyUI.getProvider();\n\t\tIDroneSetupRemoteService service1;\n\t\ttry {\n\t\t\tservice1 = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);\n\t\t\tCollection<IUAVProxy> activeDrones = service1.getActiveUAVs();\n\t\t\tdrones = new ArrayList<>(activeDrones);\n\t\t} catch (DronologyServiceException | RemoteException e1) {\n\t\t\tMyUI.setConnected(false);\n\t\t}\n\t\t \n\t\t// Listens for clicks on the panel and switches the highlighted mission accordingly\n\t\tVerticalLayout missions = infoPanel.getMissions();\n\t\tmissions.addLayoutClickListener(e -> {\n\t\t\tComponent childComponent = e.getChildComponent();\n\t\t\tint index = -1;\n\t\t\tif (childComponent != null && childComponent.getClass().equals(MPInfoBox.class)) {\n\t\t\t\tinfoPanel.unhighlightAllInfoBoxes();\n\t\t\t\tMissionInfo info = ((MPInfoBox) childComponent).getMissionInfo();\n\t\t\t\tindex = infoPanel.getMissionIndex(info);\n\t\t\t\tinfoPanel.highlightInfoBox(index);\n\t\t\t\t\n\t\t\t\t// same as pressing select button\n\t\t\t\tif (e.isDoubleClick()) {\n\t\t\t\t\tMPInfoBox highlighted = infoPanel.getHighlightedMPInfoBox();\n\t\t\t\t\tMissionInfo missionInfo = highlighted.getMissionInfo();\n\t\t\t\t\tMissionPlanningPersistenceProvider planPersistor = MissionPlanningPersistenceProvider.getInstance();\n\t\t\t\t\tByteArrayInputStream inStream;\n\t\t\t\t\tIMissionPlan missionPlan = null;\n\t\t\t\t\tIMissionPlanningRemoteService service;\n\t\t\t\t\tString id = missionInfo.getId();\n\t\t\t\t\t\n\t\t\t\t\t// pulls information from dronology, gets the info for the current mission\n\t\t\t\t\ttry {\n\t\t\t\t\t\tservice = (IMissionPlanningRemoteService) provider.getRemoteManager().getService(IMissionPlanningRemoteService.class);\n\t\t\t\t\t\tbyte[] information = service.requestFromServer(id);\n\t\t\t\t\t\tinStream = new ByteArrayInputStream(information);\n\t\t\t\t\t\tmissionPlan = planPersistor.loadItem(inStream);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (DronologyServiceException | RemoteException e1) {\n\t\t\t\t\t\te1.printStackTrace();\n\t\t\t\t\t\tMyUI.setConnected(false);\n\t\t\t\t\t} catch (PersistenceException e1) {\n\t\t\t\t\t\te1.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tList<IUAVMissionDescription> mission = ((PersistableMissionPlan) missionPlan).getMissionDescriptions();\n\t\t\t\t\t\n\t\t\t\t\t// let the user know that there are not currently enough active drones\n\t\t\t\t\tboolean enoughDrones = true;\n\t\t\t\t\tif (drones.size() < mission.size()) {\n\t\t\t\t\t\tenoughDrones = false;\n\t\t\t\t\t\tNotification.show(\"Sorry, but you do not have enough active UAVs to execute this mission.\", Type.ERROR_MESSAGE);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//MissionHandler handler = new MissionHandler();\n\t\t\t\t\t//handler.setMissionContent(info);\n\t\t\t\t\t//handler.executeMission();\n\t\t\t\t\tif (enoughDrones) {\n\t\t\t\t\t\tAFMapDrones mapDrones = new AFMapDrones(mission, missionInfo);\n\t\t\t\t\t\tUI.getCurrent().addWindow(mapDrones);\n\t\t\t\t\t\tUI.getCurrent().removeWindow(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t// Execute Button click listener\n\t\tselect.addClickListener(e -> {\n\t\t\tMPInfoBox highlighted = infoPanel.getHighlightedMPInfoBox();\n\t\t\tif (highlighted == null) {\n\t\t\t\tNotification.show(\"You must select a mission to execute.\", Type.WARNING_MESSAGE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMissionInfo missionInfo = highlighted.getMissionInfo();\n\t\t\t\tMissionPlanningPersistenceProvider planPersistor = MissionPlanningPersistenceProvider.getInstance();\n\t\t\t\tByteArrayInputStream inStream;\n\t\t\t\tIMissionPlan missionPlan = null;\n\t\t\t\tIMissionPlanningRemoteService service;\n\t\t\t\tString id = missionInfo.getId();\n\t\t\t\t\n\t\t\t\t// pulls information from dronology, gets the info for the current mission\n\t\t\t\ttry {\n\t\t\t\t\tservice = (IMissionPlanningRemoteService) provider.getRemoteManager().getService(IMissionPlanningRemoteService.class);\n\t\t\t\t\tbyte[] information = service.requestFromServer(id);\n\t\t\t\t\tinStream = new ByteArrayInputStream(information);\n\t\t\t\t\tmissionPlan = planPersistor.loadItem(inStream);\n\t\t\t\t}\n\t\t\t\tcatch (DronologyServiceException | RemoteException e1) {\n\t\t\t\t\te1.printStackTrace();\n\t\t\t\t\tMyUI.setConnected(false);\n\t\t\t\t} catch (PersistenceException e1) {\n\t\t\t\t\te1.printStackTrace();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tList<IUAVMissionDescription> mission = ((PersistableMissionPlan) missionPlan).getMissionDescriptions();\n\t\t\t\t\n\t\t\t\t// let the user know that there are not currently enough active drones\n\t\t\t\tboolean enoughDrones = true;\n\t\t\t\tif (drones.size() < mission.size()) {\n\t\t\t\t\tenoughDrones = false;\n\t\t\t\t\tNotification.show(\"Sorry, but you do not have enough active UAVs to execute this mission.\", Type.ERROR_MESSAGE);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//MissionHandler handler = new MissionHandler();\n\t\t\t\t//handler.setMissionContent(info);\n\t\t\t\t//handler.executeMission();\n\t\t\t\tif (enoughDrones) {\n\t\t\t\t\tAFMapDrones mapDrones = new AFMapDrones(mission, missionInfo);\n\t\t\t\t\tUI.getCurrent().addWindow(mapDrones);\n\t\t\t\t\tUI.getCurrent().removeWindow(this);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t// Execute Button click listener\n\t\texecute.addClickListener(e -> {\n\t\t\tMPInfoBox highlighted = infoPanel.getHighlightedMPInfoBox();\n\t\t\tif (highlighted == null) {\n\t\t\t\tNotification.show(\"You must select a mission to execute.\", Type.WARNING_MESSAGE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMissionInfo missionInfo = highlighted.getMissionInfo();\n\t\t\t\tMissionPlanningPersistenceProvider planPersistor = MissionPlanningPersistenceProvider.getInstance();\n\t\t\t\tByteArrayInputStream inStream;\n\t\t\t\tIMissionPlan missionPlan = null;\n\t\t\t\tIMissionPlanningRemoteService service = null;\n\t\t\t\tString id = missionInfo.getId();\n\t\t\t\t\n\t\t\t\t// pulls information from dronology, gets the info for the current mission\n\t\t\t\ttry {\n\t\t\t\t\tservice = (IMissionPlanningRemoteService) provider.getRemoteManager().getService(IMissionPlanningRemoteService.class);\n\t\t\t\t\tbyte[] information = service.requestFromServer(id);\n\t\t\t\t\tinStream = new ByteArrayInputStream(information);\n\t\t\t\t\tmissionPlan = planPersistor.loadItem(inStream);\n\t\t\t\t}\n\t\t\t\tcatch (DronologyServiceException | RemoteException e1) {\n\t\t\t\t\te1.printStackTrace();\n\t\t\t\t\tMyUI.setConnected(false);\n\t\t\t\t} catch (PersistenceException e1) {\n\t\t\t\t\te1.printStackTrace();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tList<IUAVMissionDescription> mission = ((PersistableMissionPlan) missionPlan).getMissionDescriptions();\n\t\t\t\t\n\t\t\t\t// let the user know that there are not currently enough active drones\n\t\t\t\tboolean enoughDrones = true;\n\t\t\t\tif (drones.size() < mission.size()) {\n\t\t\t\t\tenoughDrones = false;\n\t\t\t\t\tNotification.show(\"Sorry, but you do not have enough active UAVs to execute this mission.\", Type.ERROR_MESSAGE);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// execute the mission\n\t\t\t\tif (enoughDrones)  {\n\t\t\t\t\tArrayList<String> activeDroneNames = new ArrayList<>();\n\t\t\t\t\tfor (IUAVProxy drone : drones) {\n\t\t\t\t\t\tactiveDroneNames.add(drone.getID());\n\t\t\t\t\t}\n\t\t\t\t\t// match any uav that has the same name in the mission plan and active uav panel\n\t\t\t\t\tUAVMappingInfo mappingInfo = new UAVMappingInfo();\n\t\t\t\t\tArrayList<String> mappedNames = new ArrayList<>();\n\t\t\t\t\tfor (IUAVMissionDescription uav : mission) {\n\t\t\t\t\t\tif (activeDroneNames.contains(uav.getName())) {\n\t\t\t\t\t\t\tmappingInfo.addAttribute(uav.getName(), uav.getName());\n\t\t\t\t\t\t\tactiveDroneNames.remove(uav.getName());\n\t\t\t\t\t\t\tmappedNames.add(uav.getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// match the rest of the drones with whatever is first in the list of names\n\t\t\t\t\tfor (IUAVMissionDescription uav : mission) {\n\t\t\t\t\t\tif (!mappedNames.contains(uav.getName())) {\n\t\t\t\t\t\t\tmappingInfo.addAttribute(uav.getName(), activeDroneNames.get(0));\n\t\t\t\t\t\t\tactiveDroneNames.remove(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// use service to execute the mission with the mapping\n\t\t\t\t\ttry {\n\t\t\t\t\t\tservice.executeMissionPlan(missionInfo, mappingInfo);\n\t\t\t\t\t} catch (RemoteException | DronologyServiceException e1) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te1.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tUI.getCurrent().removeWindow(this);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t\n\t\t// Cancel Button click listener\n\t\tcancel.addClickListener(e -> {\n\t\t\tUI.getCurrent().removeWindow(this);\n\t\t});\n\t\t\n\t\t// Highlights missions selected with the search bar\n\t\tinfoPanel.setUsingOtherSearchBar();\n\t\tinfoPanel.refreshSearchBar();\n\t\t \n\t\tinfoPanel.getSearchBar().addValueChangeListener(event -> {\n        \tString name = infoPanel.getSearchBar().getValue();\n        \t\n        \t// go through all the missions in dronology and highlight the right one\n        \tIMissionPlanningRemoteService service;\n        \ttry {\n             \tservice=(IMissionPlanningRemoteService) provider.getRemoteManager().getService(IMissionPlanningRemoteService.class);\n             \tList<MissionInfo> allMissions=new ArrayList<>(service.getItems());\n             \tCollections.sort(allMissions, new MissionPlanningIntoNameComparator());\n        \t\n\t         \tfor(MissionInfo mission : allMissions )\n\t         \t{\n\t         \t\tif (name.equals(mission.getName())) {\n\t         \t\t\tinfoPanel.unhighlightAllInfoBoxes();\n\t        \t\t\tinfoPanel.highlightInfoBox(controls.getInfoPanel().getMissionIndex(mission));\n\t            \t\tbreak;\n\t         \t\t}\n\t    \t \t}\n         \t\n        \t} catch(RemoteException | DronologyServiceException e) {\n             \tMyUI.setConnected(false);\n             \te.printStackTrace();\n             }\n        \t\n        \tinfoPanel.getSearchBar().setValue(\"\");\n\t    });\n\t\t \n\t\t allContent.addComponents(infoPanel, buttonLayout);\n\t\t \n\t\t // format the window \n\t\t this.setContent(allContent);\n\t\t this.setResizable(false);\n\t\t this.setClosable(true);\n\t\t this.setModal(true);\n\t\t this.setHeight(\"950\");\n\t\t this.setWidth(\"420\");\n\t}\t\n\n}\n"}, {"id": "UAVRegistrationService.java", "body": "package edu.nd.dronology.services.instances.registration.uavs;\n\nimport edu.nd.dronology.services.core.base.AbstractFileTransmitServerService;\nimport edu.nd.dronology.services.core.info.UAVRegistrationInfo;\n\npublic class UAVRegistrationService\n\t\textends AbstractFileTransmitServerService<IUAVRegistrationServiceInstance, UAVRegistrationInfo> {\n\n\tprivate static volatile UAVRegistrationService INSTANCE;\n\n\tprotected UAVRegistrationService() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @return The singleton ConfigurationService instance\n\t */\n\tpublic static UAVRegistrationService getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (UAVRegistrationService.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new UAVRegistrationService();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\n\t}\n\n\t@Override\n\tprotected IUAVRegistrationServiceInstance initServiceInstance() {\n\t\treturn new UAVRegistrationServiceInstance();\n\t}\n\n\n\n}\n"}, {"id": "UAVEquipmentTypeRegistration.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class UAVEquipmentTypeRegistration implements IUAVEquipmentTypeRegistration {\n\n\tprivate String id;\n\tprivate String name;\n\tprivate String description;\n\tprivate Map<String, Serializable> attributes;\n\n\tpublic UAVEquipmentTypeRegistration() {\n\t\tid = UUID.randomUUID().toString();\n\t\tattributes = new HashMap<>();\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\t@Override\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\n\t}\n\n\t@Override\n\tpublic Serializable getAttribute(String key) {\n\t\treturn attributes.get(key);\n\t}\n\n\t@Override\n\tpublic void addAttribute(String key, Serializable value) {\n\t\tattributes.put(key, value);\n\t}\n\n}\n"}, {"id": "SimulatorScenarioInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\npublic class SimulatorScenarioInfo extends RemoteInfoObject {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -7327376857430499641L;\n\n\tprivate String category = \"Default\";\n\t\n\t\n\n\n\tpublic SimulatorScenarioInfo(String name, String id) {\n\t\tsuper(name, id);\n\t}\n\t\n\tpublic String getCategory() {\n\t\treturn category;\n\t}\n\n\n\tpublic void setCategory(String category) {\n\t\tthis.category = category;\n\t}\n\n\t\n\n}\n"}, {"id": "AreaMappingService.java", "body": "package edu.nd.dronology.services.extensions.areamapping.instances;\n\nimport java.util.Collection;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.areamapping.GeneratedMappedArea;\nimport edu.nd.dronology.services.core.base.AbstractFileTransmitServerService;\nimport edu.nd.dronology.services.core.info.AreaMappingCategoryInfo;\nimport edu.nd.dronology.services.core.info.AreaMappingInfo;\nimport edu.nd.dronology.services.core.info.FlightRouteCategoryInfo;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n/**\n * \n * \n * \n * \n * @author Michael Vierhauser\n *\n */\npublic class AreaMappingService\n\t\textends AbstractFileTransmitServerService<IAreaMappingServiceInstance, AreaMappingInfo> {\n\n\tprivate static volatile AreaMappingService INSTANCE;\n\n\tprotected AreaMappingService() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @return The singleton ConfigurationService instance\n\t */\n\tpublic static AreaMappingService getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (AreaMappingService.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new AreaMappingService();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tprotected IAreaMappingServiceInstance initServiceInstance() {\n\t\treturn new AreaMappingServiceInstance();\n\t}\n\n\tpublic Collection<AreaMappingCategoryInfo> getMappingPathCategories() {\n\t\treturn serviceInstance.getMappingPathCategories();\n\t}\n\n\tpublic AreaMappingInfo getItem(String name) throws DronologyServiceException {\n\t\treturn serviceInstance.getItem(name);\n\t}\n\n\tpublic AreaMappingInfo getMappingByName(String mappingName) throws DronologyServiceException {\n\t\treturn serviceInstance.getMappingByName(mappingName);\n\t}\n\n\tpublic GeneratedMappedArea generateAreaMapping(AreaMappingInfo info) throws DronologyServiceException {\n\t\treturn serviceInstance.generateAreaMapping(info);\n\t}\n\n\tpublic GeneratedMappedArea generateAreaMapping(AreaMappingInfo info, Collection<IUAVProxy> selectedUAVs)\n\t\t\tthrows DronologyServiceException {\n\t\treturn serviceInstance.generateAreaMapping(info, selectedUAVs);\n\t}\n\n\tpublic void executeAreaMapping(GeneratedMappedArea area) throws DronologyServiceException {\n\t\tserviceInstance.executeAreaMapping(area);\n\t}\n}\n"}, {"id": "AbstractRMIRemoteObject.java", "body": "package edu.nd.dronology.services.remote.rmi;\n\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\nimport java.rmi.server.UnicastRemoteObject;\n\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Abstract class for RMI remote objects taking care of registry re/unbind\n * \n * @author Michael Vierhauser\n * \n */\npublic abstract class AbstractRMIRemoteObject extends UnicastRemoteObject {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(AbstractRMIRemoteObject.class);\n\tprotected int port = 9753;\n\tprivate String bindingName;\n\tprotected Registry registry;\n\n\tprotected AbstractRMIRemoteObject(int port, String bindingName) throws RemoteException {\n\t\tsuper();\n\t\tthis.port = port;\n\t\tthis.bindingName = bindingName;\n\t}\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -1684918850552214903L;\n\n\tpublic void initialize() throws RemoteException {\n\t\tif (registry == null) {\n\t\t\ttry {\n\t\t\t\tregistry = LocateRegistry.createRegistry(port);\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tregistry = LocateRegistry.getRegistry(port);\n\t\t\t}\n\t\t}\n\t\tregistry.rebind(bindingName, this);\n\t\tLOGGER.info(\">> Binding '\"+bindingName+\"' established on port \"+port);\n\t}\n\n\tpublic void tearDown() throws Exception {\n\t\tregistry.unbind(bindingName);\n\t\tLOGGER.info(\">> Binding '\"+bindingName+\"' removed on port \"+port);\n\t}\n\n}\n"}, {"id": "RouteTask.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.tasks;\n\npublic class RouteTask extends AbstractMissionTask {\n\n\tprotected RouteTask(String uavID, String taskName) {\n\t\tsuper(uavID, taskName);\n\t}\n}"}, {"id": "WaypointCommand.java", "body": "package edu.nd.dronology.core.collisionavoidance.guidancecommands;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\n/**\n * A command that tells a UAV to fly to a specific place.\n */\npublic class WaypointCommand extends Command {\n\n    private final LlaCoordinate destination;\n    private final double speed;\n\n    /**\n     * <p>\n     * Creates a command that tells the UAV to fly to the given coordinates on Earth.\n     * </p>\n     * <p>\n     * For example, to command a UAV to fly to the Notre Dame Stadium (10m above the middle of the 50-yard line)\n     * <pre>\n     *         {@code\n     *         WaypointCommand nd = new WaypointCommand(new LlaCoordinate(41.698394, -86.233923, 236.0))\n     *         }\n     *     </pre>\n     * </p>\n     *\n     * @param destination the coordinates where the UAV should fly.\n     */\n    public WaypointCommand(LlaCoordinate destination, double speed) {\n        this.destination = destination;\n        this.speed = speed;\n    }\n\n    /**\n     * @return destination coordinates. The place where the UAV should go.\n     */\n    public LlaCoordinate getDestination() {\n        return destination;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    @Override\n    public String toString() {\n        return \"WaypointCommand(lat:\" + destination.getLatitude() + \", long:\" + destination.getLongitude() + \", alt:\" +\n                destination.getAltitude() + \", speed:\" + speed + \")\";\n    }\n}\n"}, {"id": "IDroneConnectorServiceInstance.java", "body": "package edu.nd.dronology.gstation.connector.service.connector;\n\nimport edu.nd.dronology.gstation.connector.GroundStationException;\nimport edu.nd.dronology.gstation.connector.GroundstationConnector;\nimport edu.nd.dronology.gstation.connector.messages.ConnectionRequestMessage;\nimport edu.nd.dronology.services.core.api.IServiceInstance;\n\npublic interface IDroneConnectorServiceInstance extends IServiceInstance {\n\n\tvoid unregisterConnection(String groundstationid) throws GroundStationException;\n\n\tvoid handleConnection(GroundstationConnector handler);\n\n\tvoid registerConnection(GroundstationConnector connector, ConnectionRequestMessage msg)\n\t\t\tthrows GroundStationException;\n\n}\n"}, {"id": "IRemoteTransferObject.java", "body": "package edu.nd.dronology.services.core.api;\n\nimport java.io.Serializable;\n\npublic interface IRemoteTransferObject extends Serializable{\n\n}\n"}, {"id": "UAVRegistrationPersistenceProvider.java", "body": "package edu.nd.dronology.services.core.persistence;\n\nimport edu.nd.dronology.services.core.items.IUAVRegistration;\nimport edu.nd.dronology.services.core.persistence.internal.UAVRegistrationXStreamPersistor;\n\n\n/**\n * Provider implementation for {@link IUAVRegistration}.<br>\n * Details see {@link AbstractItemPersistenceProvider}\n * \n * @author Michael Vierhauser\n * \n */\npublic class UAVRegistrationPersistenceProvider extends AbstractItemPersistenceProvider<IUAVRegistration> {\n\n\tpublic UAVRegistrationPersistenceProvider() {\n\t\tsuper();\n\t}\n\n\t@Override\n\tprotected void initPersistor() {\n\t\tPERSISTOR = new UAVRegistrationXStreamPersistor();\n\n\t}\n\n\t@Override\n\tprotected void initPersistor(String type) {\n\t\tinitPersistor();\n\t}\n\n\tpublic static UAVRegistrationPersistenceProvider getInstance() {\n\t\treturn new UAVRegistrationPersistenceProvider();\n\t}\n\n}\n"}, {"id": "DroneVoltageSimulator.java", "body": "package edu.nd.dronology.core.simulator.simplesimulator;\n\n/**\n * Voltage simulator.  For every minute of flight, the battery decreases by 0.25 volts.\n * @author Jane Cleland-Huang\n *\n */\npublic class DroneVoltageSimulator {\n\t\n\tprivate double voltage;\n\tprivate enum BatteryState {CHARGING, DEPLETING, STABLE}\n\tprivate BatteryState batteryState = BatteryState.STABLE;\n\tprivate static final double SIMULATOR_BATTERY_DRAIN_VOLTS = 0.25;\n   \n\tprivate long checkPointTime;\n\t\n\tpublic DroneVoltageSimulator(){\n\t\tvoltage = 15.0;\n\t\tcheckPointTime = 0;\n\t}\n\t\n\tpublic void rechargeBattery(){\n\t\tbatteryState = BatteryState.CHARGING;\n\t\tvoltage = 15.0;\n\t\tbatteryState = BatteryState.STABLE;\n\t}\n\t\n\tpublic void startBatteryDrain(){\n\t\tbatteryState = BatteryState.DEPLETING;\n\t\tcheckPointTime = System.currentTimeMillis();\n\t}\n\t\n\tpublic void stopBatteryDrain(){\n\t\tcheckPoint();\n\t\tbatteryState = BatteryState.STABLE;\t\t\n\t}\n\t \n\tpublic void checkPoint(){\n\t\tif(batteryState == BatteryState.DEPLETING){\n\t\t\tlong timeSinceLastCheckPoint = System.currentTimeMillis() - checkPointTime;\n\t\t\tif (timeSinceLastCheckPoint > 5000) {\n\t\t\t\tcheckPointTime = System.currentTimeMillis(); // Reset checkPoint time\n\t\t\t\n\t\t\t\t// Volts drained per second * number of elapsed seconds\n\t\t\t\tdouble voltageDrain = SIMULATOR_BATTERY_DRAIN_VOLTS/60 * (timeSinceLastCheckPoint/1000);\n\t\t\t\tvoltage = voltage - voltageDrain;\n\t\t\t}\n\t\t} \n\t}\n\t\n\tpublic double getVoltage(){\n\t\treturn voltage;\n\t}\n}\n"}, {"id": "GoToCommand.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\n/**\n * \n * Command sent to the GCS for sending a new waypoint.\n * \n * \n * @author Michael Vierhauser\n */\npublic class GoToCommand extends AbstractDroneCommand implements IDroneCommand {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 4420565617484849238L;\n\n\tpublic GoToCommand(String uavid, LlaCoordinate coord) {\n\t\tsuper(uavid, CommandIds.GOTO_LOCATION_COMMAND);\n\t\tdata.put(ATTRIBUTE_X, coord.getLatitude());\n\t\tdata.put(ATTRIBUTE_Y, coord.getLongitude());\n\t\tdata.put(ATTRIBUTE_Z, coord.getAltitude());\n\t}\n\n}\n"}, {"id": "CommandExecutorFactory.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal;\n\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.NedCommand;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand;\nimport edu.nd.dronology.core.vehicle.IDrone;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\n\n/**\n * Managed Drones create an instance of this factory when they are constructed. This factory takes collision avoidance\n * commands and and makes executors that are specially configured to carryout the commands.\n */\npublic class CommandExecutorFactory {\n    private IDrone drone;\n\n    /**\n     * Create a factory\n     * @param drone the drone that executors act upon\n     */\n    public CommandExecutorFactory(IDrone drone) {\n        this.drone = drone;\n    }\n\n    public CommandExecutor makeExecutor(Command cmd) {\n        if (cmd instanceof WaypointCommand) {\n            return new WaypointExecutor(this.drone, (WaypointCommand) cmd);\n        }\n        if (cmd instanceof StopCommand) {\n            return new StopExecutor(this.drone, (StopCommand) cmd);\n        }\n        if (cmd instanceof NedCommand) {\n            return new NedExecutor(this.drone, (NedCommand) cmd);\n        }\n        throw new IllegalArgumentException();\n    }\n}\n"}, {"id": "TestStatusDispatchThread.java", "body": "package edu.nd.dronology.gstation.connector.dispatch;\n\nimport edu.nd.dronology.core.IUAVPropertyUpdateNotifier;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.gstation.connector.messages.AbstractUAVMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVMessageFactory;\nimport edu.nd.dronology.gstation.connector.messages.UAVStateMessage;\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\nimport org.junit.Test;\nimport org.junit.Assert;\n\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class TestStatusDispatchThread {\n\n    class DispatchWrapper {\n        public volatile StatusDispatchThread dispatcher;\n    }\n\n    @Test\n    public void testCurrentBehavior() throws Throwable {\n        /*\n        Create a mock IUAVPropertyUpdateNotifier that checks the stubbed data gets passed in\n         */\n        final DispatchWrapper dispatchWrapper = new DispatchWrapper();\n        BlockingQueue<AbstractUAVMessage> queue = new LinkedBlockingQueue();\n        IUAVPropertyUpdateNotifier updateNotifier = new IUAVPropertyUpdateNotifier() {\n            @Override\n            public void update(LlaCoordinate location, double batteryLevel, double speed, Vector3D velocity, Vector3D attitude) {\n                updateCoordinates(location);\n                updateBatteryLevel(batteryLevel);\n                updateVelocity(speed);\n                updateCollisionAvoidance(location, velocity, attitude);\n            }\n\n            @Override\n            public void updateCoordinates(LlaCoordinate location) {\n                dispatchWrapper.dispatcher.tearDown();\n                LlaCoordinate expected = new LlaCoordinate(41.519495,-86.239937,266.19);\n                Assert.assertEquals(expected, location);\n            }\n\n            @Override\n            public void updateDroneState(String status) {\n                dispatchWrapper.dispatcher.tearDown();\n                //todo investigate if this is the behavior we want\n                Assert.fail(\"This isn't called\");\n            }\n\n            @Override\n            public void updateBatteryLevel(double batteryLevel) {\n                dispatchWrapper.dispatcher.tearDown();\n                Assert.assertEquals(100, batteryLevel, 0.0);\n\n            }\n\n            @Override\n            public void updateVelocity(double velocity) {\n                dispatchWrapper.dispatcher.tearDown();\n                Assert.assertEquals(5.0, velocity, 0.0);\n            }\n\n            @Override\n            public void updateCollisionAvoidance(LlaCoordinate position, Vector3D velocity, Vector3D attitude) {\n                LlaCoordinate expected = new LlaCoordinate(41.519495,-86.239937,266.19);\n                Assert.assertEquals(expected, position);\n\n                Vector3D expectedVelcity = new Vector3D(3.0, 4.0, 0.0);\n                Assert.assertEquals(expectedVelcity, velocity);\n\n                Vector3D expectedAttitude = new Vector3D(30.0, 31.0, 32.0);\n                Assert.assertEquals(expectedAttitude, attitude);\n            }\n\n\t\t\t@Override\n\t\t\tpublic void updateMode(String mode) {\n\t\t\t\t\n\t\t\t}\n        };\n\n        String batteryState = \"{\\n\" +\n                \"\\\"voltage\\\": 12.19,\\n\" +\n                \"\\\"current\\\": 27.15,\\n\" +\n                \"\\\"level\\\": 100\\n\" +\n                \"}\";\n        String gsString =\"{\\n\" +\n                \"\\\"type\\\": \\\"state\\\",\\n\" +\n                \"\\\"uavid\\\":\\\"TESTING\\\",\\n\" +\n                \"\\\"sendtimestamp\\\":\" + System.currentTimeMillis() + \",\\n\" +\n                \"\\\"data\\\":{\\n\" +\n                \"\\\"location\\\": {\\\"x\\\": 41.519495, \\\"y\\\": -86.239937, \\\"z\\\": 266.19},\\n\" +\n                \"\\\"attitude\\\": {\\\"x\\\": 30.0, \\\"y\\\": 31.0, \\\"z\\\": 32.0},\\n\" +\n                \"\\\"velocity\\\": {\\\"x\\\": 3, \\\"y\\\": 4, \\\"z\\\": 0},\\n\" +\n                \"\\\"status\\\": \\\"ACTIVE\\\",\\n\" +\n                \"\\\"heading\\\": 53.1301025195,\\n\" +\n                \"\\\"airspeed\\\": 5,\\n\" +\n                \"\\\"groundspeed\\\": 5,\\n\" +\n                \"\\\"armed\\\": true,\\n\" +\n                \"\\\"armable\\\": true,\\n\" +\n                \"\\\"mode\\\": \\\"GUIDED\\\",\\n\" +\n                \"\\\"batterystatus\\\": \" + batteryState + \"\\n\" +\n                \"}\\n\" +\n                \"}\";\n        final UAVStateMessage x = (UAVStateMessage) UAVMessageFactory.create(gsString);\n        queue.offer(x);\n        dispatchWrapper.dispatcher = new StatusDispatchThread(queue, updateNotifier);\n        dispatchWrapper.dispatcher.call();\n\n    }\n}\n"}, {"id": "StopExecutorViaWaypoint2.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal;\n\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.vehicle.IDrone;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/*\nThis variation pick a waypoint some number of meters behind the UAV\n*/\npublic class StopExecutorViaWaypoint2 implements CommandExecutor {\n\n    private static final ILogger LOGGER = LoggerProvider.getLogger(StopExecutorViaWaypoint2.class);\n\n    enum StopExecutionState {\n        RADIOING,\n        WATCHING_THE_CLOCK,\n        WAITING_FOREVER,\n        FINISHED;\n    }\n\n    private class UavData {\n        public LlaCoordinate position;\n        public Vector3D velocity;\n        public double speed;\n    }\n\n    // Number of meters to set the waypoint away in the opposite direction of velocity\n    private static final double WAYPOINT_DISTANCE = 20.0;\n\n    private IDrone drone;\n    StopExecutionState state = StopExecutionState.RADIOING;\n    StopCommand data;\n    long startTime;\n\n    public StopExecutorViaWaypoint2(IDrone drone, StopCommand data) {\n        this.drone = drone;\n        this.data = data;\n        LOGGER.debug(\"Creating stop executor for \" + drone.getDroneName());\n    }\n\n    @Override\n    public void process() {\n        switch (state) {\n            case RADIOING:\n                radioDrone();\n                break;\n\n            case WATCHING_THE_CLOCK:\n                checkClock();\n                break;\n\n            case WAITING_FOREVER:\n            case FINISHED:\n            default:\n                // Do nothing.\n                break;\n        }\n    }\n\n    private void radioDrone() {\n        LOGGER.debug(\"RADIOING STOP TO \" + drone.getDroneName());\n        UavData current = getUavData();\n        Vector3D deltaPosition = current.velocity.normalize().scalarMultiply(-1.0 * WAYPOINT_DISTANCE);\n        LlaCoordinate target = current.position.findLla(deltaPosition);\n        drone.flyTo(target, current.speed);\n\n        double waitDuration = data.getTime();\n        if (waitDuration > 0.0) {\n            startTime = System.nanoTime();\n            state = StopExecutionState.WATCHING_THE_CLOCK;\n        }\n        else {\n            state = StopExecutionState.WAITING_FOREVER;\n        }\n    }\n\n    private void checkClock() {\n        double waitDuration = data.getTime();\n        long deltaNano = System.nanoTime()- startTime;\n        double deltaT = deltaNano * 1.0e-9;\n        if (deltaT > waitDuration) {\n            state = StopExecutionState.FINISHED;\n        }\n    }\n\n    @Override\n    public boolean isFinished() {\n        return state == StopExecutionState.FINISHED;\n    }\n\n    private UavData getUavData() {\n        UavData result = new UavData();\n        DroneSnapshotInternal currentState = drone.getLatestDroneSnapshot();\n        result.position = currentState.getPosition();\n        result.speed = Vector3D.distance(Vector3D.ZERO, currentState.getVelocity());\n        result.velocity = currentState.getVelocity();\n        return result;\n    }\n\n}\n"}, {"id": "DroneFleetManager.java", "body": "package edu.nd.dronology.core.fleet;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.function.Consumer;\n\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.monitoring.DronologyMonitoringManager;\nimport edu.nd.dronology.core.monitoring.MessageMarshaller;\nimport edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * Holds a fleet of virtual or physical drones.<br>\n * When activated, UAVs are registered with the fleet manager and can be retrieved for assigning routes to them.\n * \n *  \n * @author Michael Vierhauser\n *\n */\npublic class DroneFleetManager {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(DroneFleetManager.class);\n\tprivate static volatile DroneFleetManager INSTANCE = null;\n\n\tprivate ConcurrentSkipListMap<String, ManagedDrone> registeredDrones;\n\tprivate Queue<ManagedDrone> availableDrones;\n\tprivate List<ManagedDrone> busyDrones;\n\tprivate List<DroneFleetListener> listeners;\n\n\tpublic static DroneFleetManager getInstance() {\n\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (DroneFleetManager.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new DroneFleetManager();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t/**\n\t * Specifies whether virtual or physical drones will be created according to the previously specified runtime drone type. (See RuntimeDroneTypes.java)\n\t */\n\tprotected DroneFleetManager() {\n\t\t// if (RuntimeDroneTypes.getInstance().isSimulation())\n\t\t// availableDrones = VirtualDroneFleetFactory.getInstance().getDrones();\n\t\t// else\n\t\t// availableDrones =\n\t\t// PhysicalDroneFleetFactory.getInstance().getDrones();\n\t\tregisteredDrones = new ConcurrentSkipListMap();\n\t\tavailableDrones = new ConcurrentLinkedQueue<>();\n\t\tbusyDrones = new ArrayList<>();\n\t\tlisteners = new ArrayList<>();\n\t}\n\n\t/**\n\t * Checks for an available drone from the fleet.\n\t * \n\t * @return true if drone is available, false if it is not.\n\t */\n\tpublic boolean hasAvailableDrone() {\n\t\tLOGGER.info(\"Drones available: \" + availableDrones.size());\n\t\treturn availableDrones.size() > 0;\n\n\t}\n\n\t/**\n\t * Returns the next available drone. Currently uses FIFO to recycle drones.\n\t * \n\t * @return\n\t */\n\tpublic ManagedDrone getAvailableDrone() {\n\t\tif (!availableDrones.isEmpty()) {\n\t\t\tManagedDrone drone = availableDrones.poll();\n\t\t\tbusyDrones.add(drone);\n\t\t\treturn drone;\n\t\t} else\n\t\t\treturn null;\n\t}\n\n\tpublic ManagedDrone getAvailableDrone(String designatedDroneId) {\n\t\tsynchronized (availableDrones) {\n\t\t\tManagedDrone found = null;\n\t\t\tif (!availableDrones.isEmpty()) {\n\t\t\t\tfor (ManagedDrone d : availableDrones) {\n\t\t\t\t\tif (d.getDroneName().equals(designatedDroneId)) {\n\t\t\t\t\t\tfound = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (found != null) {\n\t\t\t\t\tboolean success = availableDrones.remove(found);\n\t\t\t\t\tif (success) {\n\t\t\t\t\t\tbusyDrones.add(found);\n\t\t\t\t\t\treturn found;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOGGER.error(\"Error when queuing uav '\" + designatedDroneId + \"'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// LOGGER.error(\"Error when retrieving uav '\" + designatedDroneId + \"'\");\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate void notifyListeners(boolean add, ManagedDrone managedDrone) {\n\t\tConsumer<DroneFleetListener> update; \n\t\tif (add) {\n\t\t\tupdate = listener -> listener.droneAdded(managedDrone);\n\t\t} else {\n\t\t\tupdate = listener -> listener.droneRemoved(managedDrone);\n\t\t}\n\t\tlisteners.forEach(update);\n\t}\n\n\t/**\n\t * When a drone completes a mission, returns it to the pool of available drones.\n\t * \n\t * @param drone\n\t */\n\tpublic void returnDroneToAvailablePool(ManagedDrone drone) {\n\t\tif (busyDrones.contains(drone)) {\n\t\t\tbusyDrones.remove(drone);\n\t\t}\n\t\t// LOGGER.info(\"Drone '\"+drone.getDroneName()+\"' added to available drone\n\t\t// pool\");\n\t\tavailableDrones.offer(drone);\n\n\t}\n\n\tpublic void addDrone(ManagedDrone managedDrone) throws DroneException {\n\t\tif (registeredDrones.containsKey(managedDrone.getDroneName())) {\n\t\t\tthrow new DroneException(\"Drone '\" + managedDrone.getDroneName() + \"' already registered\");\n\t\t}\n\t\tregisteredDrones.put(managedDrone.getDroneName(), managedDrone);\n\t\treturnDroneToAvailablePool(managedDrone);\n\t\tnotifyListeners(true, managedDrone);\n\n\t}\n\n\tpublic void removeDrone(ManagedDrone managedDrone) throws DroneException {\n\t\tManagedDrone value = registeredDrones.remove(managedDrone.getDroneName());\n\t\tif (value == null) {\n\t\t\tthrow new DroneException(\"Drone '\" + managedDrone.getDroneName() + \"' not found registered\");\n\t\t}\n\t\tLOGGER.info(\"Drone '\" + managedDrone.getDroneName() + \"' removed from available drone pool\");\n\t\tDronologyMonitoringManager.getInstance()\n\t\t\t\t.publish(MessageMarshaller.createMessage(MessageType.PHYSICAL_UAV_DEACTIVATED, managedDrone.getDroneName()));\n\t\tavailableDrones.remove(value);\n\t\t// TODO change how this class uses managed drone. Stopping must be sent to the drone using a goal model.\n\t\tvalue.stop();\n\t\tnotifyListeners(false, managedDrone);\n\t}\n\n\tpublic ManagedDrone getRegisteredDrone(String uavid) throws DroneException {\n\t\tif (!registeredDrones.containsKey(uavid)) {\n\t\t\tthrow new DroneException(\"Drone '\" + uavid + \"' not found registered\");\n\t\t}\n\t\treturn registeredDrones.get(uavid);\n\n\t}\n\n\tpublic List<ManagedDrone> getRegisteredDrones() { \n\t\treturn new ArrayList<>(registeredDrones.values());\n\n\t}\n\n\tpublic void unregisterDroe(String id) throws DroneException {\n\t\tManagedDrone managedDrone = getRegisteredDrone(id);\n\t\tremoveDrone(managedDrone);\n\t}\n\n\tpublic void addDroneFleetListener(DroneFleetListener listener) {\n\t\tlisteners.add(listener);\n\t}\n\n}\n"}, {"id": "CollisionAvoider.java", "body": "package edu.nd.dronology.core.collisionavoidance;\n\nimport java.util.ArrayList;\n\n/**\n * <p>\n *     A collision avoidance strategy.\n * </p>\n * <p>\n *     This is the strategy pattern from Design Patterns (Gang of four) where all information is passed in as a\n *     parameter.\n * </p>\n *\n * <p>\n *     When implementing this class you need to use the data provided in the list of DroneSnapshotInternal(s) to figure out\n *     how to command each drone so that they don\u2019t crash into one another. You change where the drones will fly by\n *     changing the list of commands in each DroneSnapshotInternal(s). For example, if you want a drone to pause\n *     (hover in place) for 5 seconds before continuing with its mission, you would:\n * </p>\n * <pre>\n * {@code\n *\n * DroneSnapshotInternal drone = ...\n * drone.getCommands().add(0, new StopCommand(5.0));\n * }\n * </pre>\n *\n * <h2>FAQ</h2>\n * <h3>Who is this for?</h3>\n * <p>Developers who want to create a collision avoidance algorithm with Dronology.</p>\n * <h3>What do you need to know?</h3>\n * <p>You need to know how to read the state of each drone and how to command each drone to avoid crashing.</p>\n * <h3> How do you read the state of each drone?</h3>\n * <p>You iterate through the list of Drone Snapshots. Each Drone Snapshot includes getters for data sensed by each drone. For example, you can call the get position method to access the drone's position:</p>\n * <pre>\n *     {@code\n *     drone.getPosition();\n *     }\n * </pre>\n * <h3>How do you control each drone?</h3>\n * <p>Each drone snapshot includes a get Commands method that gives you access to an array list of commands. By changing this list you are changing the queue of actions a given drone will execute. For example, to have a drone pause for 5 seconds before continuing on with its mission, insert a stop command at the start of the commands list:</p>\n *\n * <pre>\n *     {@code\n *     drone.getCommands().add(0, new StopCommand(5.0));\n *     }\n * </pre>\n *\n * <p>This inserts the stop command at the start of the commands list. When Dronology sees this change, it will radio the drone's on board autopilot and tell it to hover in place for 5 seconds. After that Dronology will radio the autopilot again with the next command in the get commands list. Here are 3 examples of possible commands you can create:\n * <ul>\n *     <li>A NedCommand. This command tells a drone to fly at given North, East, and Down velocity for a specified amount of time. @see {@link edu.nd.dronology.core.collisionavoidance.guidancecommands.NedCommand}</li>\n *     <li>A StopCommand. This tells a drone to hover in place for a specified amount of time. @see {@link edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand}</li>\n *     <li>A WaypointCommand. This tells a drone to fly to a given waypoint. @see {@link edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand}</li>\n * </ul>\n * Finally, you can also remove commands from the commands list.\n * </p>\n */\npublic interface CollisionAvoider {\n    public void avoid(ArrayList<DroneSnapshot> drones);\n}\n"}, {"id": "IUAVMissionTask.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\npublic interface IUAVMissionTask {\n\n\tString getType();\n\n\tString getId();\n\n\tSerializable getAttribute(String key);\n\n\tMap<String, Serializable> getParameters();\n\n\n}\n"}, {"id": "AbstractStatusDispatchThread.java", "body": "package edu.nd.dronology.gstation.connector.dispatch;\n\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic abstract class AbstractStatusDispatchThread<MESSAGE_TYPE> implements Callable {\n\n\tprotected AtomicBoolean cont = new AtomicBoolean(true);\n\tprotected BlockingQueue<MESSAGE_TYPE> queue;\n\t\n\t\n\tpublic AbstractStatusDispatchThread(BlockingQueue<MESSAGE_TYPE> queue) {\n\t\tthis.queue = queue;\n\t}\n\n\tint getQueueSize() {\n\t\treturn queue.size();\n\t}\n\n\tpublic void tearDown() {\n\t\tcont.set(false);\n\t}\n\n\t\n\t\n}\n"}, {"id": "AMEditPrioritiesController.java", "body": "package edu.nd.dronology.ui.vaadin.areamapping;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Vector;\n\nimport com.vaadin.ui.Button;\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.HorizontalLayout;\nimport com.vaadin.ui.Label;\nimport com.vaadin.ui.Notification;\nimport com.vaadin.ui.UI;\n\nimport edu.nd.dronology.services.core.areamapping.EdgeLla;\nimport edu.nd.dronology.services.core.info.AreaMappingInfo;\nimport edu.nd.dronology.services.core.items.IAreaMapping;\nimport edu.nd.dronology.services.core.persistence.AreaMappingPersistenceProvider;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport edu.nd.dronology.services.core.remote.IAreaMappingRemoteService;\n\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.ui.vaadin.areamapping.windows.AMPriorityAreaCreationWindow;\nimport edu.nd.dronology.ui.vaadin.areamapping.windows.AMPrioritySideCreationWindow;\nimport edu.nd.dronology.ui.vaadin.areamapping.windows.AMSaveAreaWithoutFinishWindow;\nimport edu.nd.dronology.ui.vaadin.areamapping.windows.AMSaveSideWithoutFinishWindow;\nimport edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;\nimport edu.nd.dronology.ui.vaadin.start.MyUI;\n\n/**\n * This allows the user to create and edit mappings by changing the priority areas.\n * \n * @author Andrew Slavin\n *\n */\n\npublic class AMEditPrioritiesController extends CustomComponent {\n\t/**\n\t *  \n\t */\n\tprivate static final long serialVersionUID = 212323831233690123L;\n\tprivate AMMapComponent mapComponent;\n\tprivate AMSaveAreaWithoutFinishWindow saveAreaWithoutFinishWindow;\n\tprivate AMSaveSideWithoutFinishWindow saveSideWithoutFinishWindow;\n\tprivate AMPriorityAreaCreationWindow priorityAreaCreationWindow;\n\tprivate AMPrioritySideCreationWindow prioritySideCreationWindow;\n\tprivate HorizontalLayout totalLayout = new HorizontalLayout();\n\tprivate Button editSidesButton = new Button(\"Sides\");\n\tprivate Button editPrioritiesButton = new Button(\"Priorities\");\n\tprivate Button drawAreaButton = new Button();\n\tprivate Button drawSidesButton = new Button();\n\tprivate Button cancelButton = new Button(\"Cancel\");\n\tprivate Button saveButton = new Button(\"Save\");\n\tprivate Label smallText = new Label(\"Select sides or areas to edit.\");\n\n\tprivate List<UIEdgePoint> sidePoints0 = new ArrayList<>();\n\tprivate List<UIEdgePoint> sidePoints1 = new ArrayList<>();\n\tprivate String storedName = \"\";\n\tprivate String storedDescription = \"\";\n\tprivate Boolean drawingArea;\n\tprivate Boolean drawingSide;\n\tprivate Boolean finishAreaThenSave;\n\tprivate Boolean finishSideThenSave;\n\tprivate Boolean selectingUpstream;\n\n\tpublic AMEditPrioritiesController(AMMapComponent mapComponent) {\n\t\tthis.mapComponent = mapComponent;\n\t\tpriorityAreaCreationWindow = new AMPriorityAreaCreationWindow(mapComponent);\n\t\tprioritySideCreationWindow = new AMPrioritySideCreationWindow(mapComponent);\n\t\tsaveAreaWithoutFinishWindow = new AMSaveAreaWithoutFinishWindow(this);\n\t\tsaveSideWithoutFinishWindow = new AMSaveSideWithoutFinishWindow(this);\n\t\tdrawAreaButton.setCaption(\"Start Area\");\n\t\tdrawSidesButton.setCaption(\"Start Side\");\n\t\t\n\t\tdrawingArea = false;\n\t\tdrawingSide = false;\n\t\tfinishAreaThenSave = false;\n\t\tfinishSideThenSave = false;\n\t\tselectingUpstream = false;\n\n\t\tsetStyleName(\"am_edit_bar\");\n\t\tsmallText.setStyleName(\"small_text\");\n\n\t\tcancelButton.setHeight(\"25px\");\n\t\tsaveButton.setHeight(\"25px\");\n\t\teditSidesButton.setHeight(\"100px\");\n\t\teditSidesButton.addStyleName(\"sides_button\");\n\t\teditPrioritiesButton.setHeight(\"35px\");\n\t\teditPrioritiesButton.setEnabled(false);\n\t\teditSidesButton.addStyleName(\"toggle_button\");\n\t\teditPrioritiesButton.addStyleName(\"toggle_button\");\n\t\tdrawAreaButton.setHeight(\"25px\");\n\t\tdrawSidesButton.setHeight(\"25px\");\n\n\t\ttotalLayout.addComponents(editSidesButton, editPrioritiesButton, smallText, drawSidesButton, drawAreaButton, cancelButton, saveButton);\n\t\tsetCompositionRoot(totalLayout);\n\n\t\t// Click listeners for the cancel and saves buttons on edit bar\n\t\t\n\t\t// cancel button resets the other buttons and exits edit mode\n\t\tcancelButton.addClickListener(e -> {\n\t\t\tdrawAreaButton.setEnabled(true);\n\t\t\tdrawSidesButton.setEnabled(true);\n\t\t\texitEditMode();\n\t\t\tcancelClick();\n\t\t});\n\t\t\n\t\t// save changes to priorities. If still in a drawing mode, prompt user to finish\n\t\tsaveButton.addClickListener(e -> {\n\t\t\t\n\t\t\t// if the user hasn't selected upstream yet, prompt them to do so\n\t\t\tif (mapComponent.getMapUtilities().getUpstream() == null) {\n\t\t\t\tNotification.show(\"Please select the most upstream side A coordinate.\", Notification.Type.ERROR_MESSAGE);\n\t\t\t\tselectingUpstream = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tdrawAreaButton.setEnabled(true);\n\t\t\tdrawSidesButton.setEnabled(true);\n\t\t\tif (drawingArea) {\n\t\t\t\tif (mapComponent.getMapUtilities().getPolygonVertices().size() < 3) {\n\t\t\t\t\tNotification.show(\"Please finish your unfinished priority area.\", Notification.Type.ERROR_MESSAGE);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tUI.getCurrent().addWindow(saveAreaWithoutFinishWindow);\n\t\t\t}\n\t\t\telse if (drawingSide) {\n\t\t\t\tif (mapComponent.getMapUtilities().getNewPrioritySideLines().size() == 0) {\n\t\t\t\t\tNotification.show(\"Please finish your unfinished priority area.\", Notification.Type.ERROR_MESSAGE);\n\t\t\t\t}\n\t\t\t\tUI.getCurrent().addWindow(saveSideWithoutFinishWindow);\n\t\t\t}\n\t\t\telse\n\t\t\t\tsaveClick();\n\t\t});\n\t\t\n\t\t// switch over to editing sides rather than priorities\n\t\teditSidesButton.addClickListener(e -> {\n\t\t\texitEditMode();\n\t\t\tmapComponent.getEditSidesController().enterEditMode();\n\t\t});\n\t\t\n\t\t// on each click, alternate between drawingArea mode and finishing the area\n\t\tdrawAreaButton.addClickListener(e -> {\n\t\t\tif (!drawingArea) {// entering drawing mode\n\t\t\t\tdrawingArea = !drawingArea;\n\t\t\t\tdrawAreaButton.setCaption(\"Finish Area\");\n\t\t\t\tsmallText.setValue(\"Click or drag area points.\");\n\t\t\t\tdrawSidesButton.setEnabled(false);\n\t\t\t}\n\t\t\telse { // finishing polygon\n\t\t\t\tif (mapComponent.getMapUtilities().getPolygonVertices().size() < 3) {\n\t\t\t\t\tNotification.show(\"Priority area must be at least 3 sides.\", Notification.Type.ERROR_MESSAGE);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdrawingArea = !drawingArea;\n\t\t\t\tdrawAreaButton.setCaption(\"Start Area\");\n\t\t\t\tsmallText.setValue(\"Select sides or areas to edit.\");\n\t\t\t\t\n\t\t\t\t// window pops up for user to set info about polygon\n\t\t\t\tUI.getCurrent().addWindow(priorityAreaCreationWindow);\n\t\t\t\tdrawSidesButton.setEnabled(true);\n\t\t\t}\n\t\t});\n\t\t\n\t\t// alternate between drawingSide mode and finshing side\n\t\tdrawSidesButton.addClickListener(e -> {\n\t\t\tif (!drawingSide) {// entering drawing mode\n\t\t\t\tdrawingSide = !drawingSide;\n\t\t\t\tdrawSidesButton.setCaption(\"Finish Sides\");\n\t\t\t\tsmallText.setValue(\"Click consecutive side segments to prioritize.\");\n\t\t\t\tdrawAreaButton.setEnabled(false);\n\t\t\t}\n\t\t\telse { // finishing side\n\t\t\t\tif (mapComponent.getMapUtilities().getNewPrioritySideLines().size() == 0) {\n\t\t\t\t\tNotification.show(\"Please select at least one bank segment.\", Notification.Type.ERROR_MESSAGE);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdrawingSide = !drawingSide;\n\t\t\t\tdrawSidesButton.setCaption(\"Draw Side\");\n\t\t\t\tsmallText.setValue(\"Select sides or areas to edit.\");\n\t\t\t\tdrawAreaButton.setEnabled(true);\n\t\t\t\t\n\t\t\t\t// pop-up window so that the user can set info about the priority side\n\t\t\t\tUI.getCurrent().addWindow(prioritySideCreationWindow);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Called when the cancel button is clicked. Disables editing and reverts\n\t// changes back to the previous save\n\tpublic void cancelClick() {\n\t\t\n\t\t// if drawing an area or a side, clean it up\n\t\tif (drawingArea)\n\t\t\tcleanUnfinishedPolygon();\n\t\tif (drawingSide) {\n\t\t\tdrawingSide = false;\n\t\t\tdrawSidesButton.setCaption(\"Start Side\");\n\t\t}\n\n\t\t// Reverts the changes by clearing mapPoints and adding storedPoints.\n\t\tmapComponent.getMapUtilities().getNewPrioritySideLines().clear();\n\t\tmapComponent.getMapUtilities().getAllPrioritySides().clear();\n\t\tmapComponent.getMapUtilities().getAllPriorityLines().clear();\n\t\tmapComponent.getMapUtilities().removeAllPins();\n\t\tmapComponent.getMapUtilities().removeAllLines();\n\t\t\n\t\tfor (int i = 0; i < sidePoints0.size(); i++) {\n\t\t\tUIEdgePoint point = sidePoints0.get(i);\n\t\t\tmapComponent.getMapUtilities().addNewPin(point, -1);\n\t\t}\n\t\tfor (int i = 0; i < sidePoints1.size(); i++) {\n\t\t\tUIEdgePoint point = sidePoints1.get(i);\n\t\t\tmapComponent.getMapUtilities().addNewPin(point, -1);\n\t\t}\n \n\t\tmapComponent.getMetaInfo().setMappingName(storedName);\n\t\tmapComponent.getMetaInfo().setMappingDescription(storedDescription);\n\n\t\t\n\t\tmapComponent.updateLinesAndGrid();\n\t\tmapComponent.getMainLayout().getControls().getInfoPanel().refreshMappings();\n\t}\n\n\t/*\n\t * Called when the save button on the edit bar is clicked. It exits edit mode,\n\t * sends the points to dronology, and uses stored points to display the correct\n\t * waypoints on the map. \n\t */\n\tpublic void saveClick() {\n\t\t\n\t\tVector<List<UIEdgePoint>> newWaypoints = mapComponent.getMapUtilities().getOrderedWayPoints();\n\t\t\t\t\n\t\tAreaMappingPersistenceProvider mappingPersistor = AreaMappingPersistenceProvider.getInstance();\n\t\tByteArrayInputStream inStream;\n\t\tIAreaMapping amapping = null;\n\n\t\tIAreaMappingRemoteService service;\n\t\tBaseServiceProvider provider = MyUI.getProvider();\n\n\t\tString id = mapComponent.getMainLayout().getControls().getInfoPanel().getHighlightedAMInfoBox().getId();\n\n\t\t// Sends the information to dronology to be saved.\n\t\ttry {\n\t\t\tservice = (IAreaMappingRemoteService) provider.getRemoteManager()\n\t\t\t\t\t.getService(IAreaMappingRemoteService.class);\n\n\t\t\tbyte[] information = service.requestFromServer(id);\n\t\t\tinStream = new ByteArrayInputStream(information);\n\t\t\tamapping = mappingPersistor.loadItem(inStream);\n\n\t\t\tamapping.setName(mapComponent.getMetaInfo().getMappingName());\n\t\t\tamapping.setDescription(mapComponent.getMetaInfo().getMappingDescription());\n\n\t\t\t// differentiate between parts\n\t\t\tArrayList<EdgeLla> oldCoords0 = new ArrayList<>(amapping.getMappedPoints(0));\n\t\t\tfor (EdgeLla cord : oldCoords0) {\n\t\t\t\tamapping.removeCoordinate(0, cord);\n\t\t\t}\n\t\t\tArrayList<EdgeLla> oldCoords1 = new ArrayList<>(amapping.getMappedPoints(1));\n\t\t\tfor (EdgeLla cord : oldCoords1) {\n\t\t\t\tamapping.removeCoordinate(1, cord);\n\t\t\t}\n\n\t\t\t// add all the new waypoints to the area mapping\t\t\t\n\t\t\tfor (int i = 0; i < newWaypoints.size(); i++) {\n\t\t\t\tfor (UIEdgePoint way : newWaypoints.get(i)) {\n\t\t\t\t\tdouble lon = 0;\n\t\t\t\t\tdouble lat = 0; \n\t\t\t\t\tdouble side = 0;\n\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlon = Double.parseDouble(way.getLongitude());\n\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlat = Double.parseDouble(way.getLatitude());\n\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tside = (double)way.getSide();\n\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tamapping.addMappedArea(i, new EdgeLla(lat, lon, side));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// save upstream side and clear it in mapUtilities\n\t\t\tamapping.setUpstream(mapComponent.getMapUtilities().getUpstream());\n\t\t\tmapComponent.getMapUtilities().setUpstream(null);\n\t\t\t\n\t\t\t// clear old location mappings\n\t\t\tamapping.getLocationMappings().clear();\n\t\t\t\n\t\t\t// save priority areas\n\t\t\tif (mapComponent.getMapUtilities().getAllPriorityAreas().size() > 0) {\n\t\t\t\tfor (int i = 0; i < mapComponent.getMapUtilities().getAllPriorityAreas().size(); i++) {\n\t\t\t\t\tamapping.addMappedLocation(mapComponent.getMapUtilities().getAllPriorityAreas().get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// save priority sides\n\t\t\tif (mapComponent.getMapUtilities().getAllPrioritySides().size() > 0) {\n\t\t\t\tfor (int i = 0; i < mapComponent.getMapUtilities().getAllPrioritySides().size(); i++) {\n\t\t\t\t\tamapping.addMappedLocation(mapComponent.getMapUtilities().getAllPrioritySides().get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// clear old priority sides\n\t\t\tmapComponent.getMapUtilities().getAllPrioritySides().clear();\n\t\t\tmapComponent.getMapUtilities().getAllPriorityLines().clear();\n\t\t\tmapComponent.getMapUtilities().getNewPrioritySideLines().clear();\n\t\t\t\n\t\t\tByteArrayOutputStream outs = new ByteArrayOutputStream();\n\t\t\tmappingPersistor.saveItem(amapping, outs);\n\t\t\tbyte[] bytes = outs.toByteArray();\n\n\t\t\tservice.transmitToServer(amapping.getId(), bytes);\n\t\t} catch (DronologyServiceException | RemoteException e1) {\n\t\t\te1.printStackTrace();\n\t\t\tMyUI.setConnected(false);\n\t\t} catch (PersistenceException e1) {\n\t\t\te1.printStackTrace();\n\t\t}\n\n\t\t// differentiate between sides\n\t\tList<EdgeLla> newCoordinatesToSave0 = amapping.getMappedPoints(0);\n\t\tList<EdgeLla> newCoordinatesToSave1 = amapping.getMappedPoints(1);\n\t\tString newMappingNameToSave = amapping.getName();\n\t\tmapComponent.getMainLayout().getWaitingWindow().showWindow(\"Saving mapping...\", () -> {\n\t\t\t// Test if the mapping is updated in dronology\n\t\t\tCollection<AreaMappingInfo> mappings = mapComponent.getMainLayout().getControls().getInfoPanel()\n\t\t\t\t\t.getMappingsFromDronology();\n\t\t\tAreaMappingInfo mappingFromDronology = null;\n\t\t\tfor (AreaMappingInfo mapping : mappings) {\n\t\t\t\tif (mapping.getId().equals(id)) {\n\t\t\t\t\tmappingFromDronology = mapping;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// if the coordinate sizes are different, then it is not updated\n\t\t\tif (mappingFromDronology == null || mappingFromDronology.getCoordinates(0).size() != newCoordinatesToSave0.size() || \n\t\t\t\t\tmappingFromDronology.getCoordinates(1).size() != newCoordinatesToSave1.size() || !newMappingNameToSave.equals(mappingFromDronology.getName())) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < newCoordinatesToSave0.size(); ++i) {\n\t\t\t\t\t// if the waypoint info is different, then it is not updated\n\t\t\t\t\tif (!newCoordinatesToSave0.get(i).equals(mappingFromDronology.getCoordinates(0).get(i))) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < newCoordinatesToSave1.size(); ++i) {\n\t\t\t\t\t// if the waypoint info is different, then it is not updated\n\t\t\t\t\tif (!newCoordinatesToSave1.get(i).equals(mappingFromDronology.getCoordinates(1).get(i))) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// otherwise, it is updated\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t}, closeEvent -> {\n\t\t\t// upon closing, reset and refresh everything\n\t\t\tdrawingSide = false;\n\t\t\tdrawSidesButton.setCaption(\"Start Side\");\n\t\t\texitEditMode();\n\t\t\tmapComponent.getMainLayout().getControls().getInfoPanel().refreshMappings();\n\t\t\tmapComponent.getMainLayout().getControls().getInfoPanel().refreshSearchBar();\n\t\t\tmapComponent.getMainLayout()\n\t\t\t\t\t.switchMapping(mapComponent.getMainLayout().getControls().getInfoPanel().getMappingInfoBox(id));\n\t\t});\n\t}\n\n\t// remove the lines and points from an unfinished polygon\n\tpublic void cleanUnfinishedPolygon() {\n\t\tdrawingArea = false;\n\t\tdrawAreaButton.setCaption(\"Start Area\");\n\t\tmapComponent.getMapUtilities().clearPolygonVertices();\n\t}\n\t\n\t// Enables editing, gets the sides, and adds the edit bar\n\tpublic void enterEditMode() {\n\t\tsidePoints0 = mapComponent.getMapUtilities().getOrderedWayPoints().get(0);\n\t\tsidePoints1 = mapComponent.getMapUtilities().getOrderedWayPoints().get(1);\n\t\tstoredName = mapComponent.getMetaInfo().getMappingName();\n\t\tstoredDescription = mapComponent.getMetaInfo().getMappingDescription();\n\n\t\tmapComponent.getMapUtilities().setPrioritiesAreEditable(true);\n\t\tmapComponent.getMapUtilities().setSidesAreEditable(false);\n\t\tthis.setVisible(true);\n\t\tmapComponent.getMap().addStyleName(\"fr_leaflet_map_edit_mode\");\n\t}\n\n\t// Disables editing, clears the points, removes the edit bar, \n\t// and changes the component styles accordingly.\n\tpublic void exitEditMode() {\n\t\tsidePoints0.clear();\n\t\tsidePoints1.clear();\n\n\t\tstoredName = \"\";\n\t\tstoredDescription = \"\";\n\n\t\tmapComponent.getMapUtilities().setPrioritiesAreEditable(false);\n\t\tthis.setVisible(false);\n\t\tmapComponent.getEditSidesController().setVisible(false);\n\n\t\tmapComponent.getMap().removeStyleName(\"fr_leaflet_map_edit_mode\");\n\t}\n\t\n\t// returns true if an area is currently being drawn\n\tpublic Boolean getDrawingArea() {\n\t\treturn drawingArea;\n\t}\n\t\n\t// returns true if a priority side is currenty being drawn\n\tpublic Boolean getDrawingSide() {\n\t\treturn drawingSide;\n\t}\n\t\n\tpublic Button getDrawAreaButton() {\n\t\treturn drawAreaButton;\n\t}\n\t\n\tpublic Button getDrawSideButton() {\n\t\treturn drawSidesButton;\n\t}\n\t\n\t// ensures that a save click first finishes the area in progress\n\tpublic void setFinishAreaThenSave(Boolean finishThenSave) {\n\t\tthis.finishAreaThenSave = finishThenSave;\n\t}\n\n\tpublic Boolean getFinishAreaThenSave() {\n\t\treturn finishAreaThenSave;\n\t}\n\t\n\t// ensures that a save click first finishes the side in progress\n\tpublic void setFinishSideThenSave(Boolean finishThenSave) {\n\t\tthis.finishSideThenSave = finishThenSave;\n\t}\n\t\n\tpublic Boolean getFinishSideThenSave() {\n\t\treturn finishSideThenSave;\n\t}\n\t\n\tpublic AMMapComponent getMapComponent() {\n\t\treturn mapComponent;\n\t}\n\t\n\tpublic Boolean getSelectingUpstream() {\n\t\treturn selectingUpstream;\n\t}\n\t\n\tpublic void setSelectingUpstream(Boolean selectingUpstream) {\n\t\tthis.selectingUpstream = selectingUpstream;\n\t}\n\t\n\tpublic Button getSaveButton() {\n\t\treturn saveButton;\n\t}\n}\n"}, {"id": "IUAVRegistrationServiceInstance.java", "body": "package edu.nd.dronology.services.instances.registration.uavs;\n\nimport edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.info.UAVRegistrationInfo;\n\npublic interface IUAVRegistrationServiceInstance extends IFileTransmitServiceInstance<UAVRegistrationInfo> {\n\n\n}\n"}, {"id": "GoalUpdateMessage.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal.message; \nimport edu.nd.dronology.core.goal.AbstractGoal;\n\npublic class GoalUpdateMessage extends AbstractMessage {\n    public final AbstractGoal goal;\n    public GoalUpdateMessage(AbstractGoal goal) {\n        this.goal = goal;\n    }\n}"}, {"id": "SetMonitoringFrequencyCommand.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n\n/**\n * \n * Command sent to the GCS for adjusting the monitoring frequency.<br>\n * The frequency is sent in ms.\n *  \n * @author Michael Vierhauser\n */\npublic class SetMonitoringFrequencyCommand extends AbstractDroneCommand implements IDroneCommand {\n\n\tprivate static final long serialVersionUID = 4075558216191030210L;\n\n\tpublic SetMonitoringFrequencyCommand(String droneId, long frequency) {\n\t\tsuper(droneId, CommandIds.SET_MONITOR_FREQUENCY_COMMAND);\n\t\tdata.put(ATTRIBUTE_FREQUENCY, frequency);\n\t}\n\n}\n"}, {"id": "LlaCoordinate.java", "body": "/**\n * \n */\npackage edu.nd.dronology.core.coordinate;\n\nimport java.io.Serializable;\n\nimport com.google.gson.annotations.SerializedName;\n\n/**\n * A terrestrial position defined by latitude, longitude, and altitude (LLA)\n *  \n * @author Michael Murphy\n *\n */\npublic class LlaCoordinate  extends AbstractPosition  implements Serializable {\n \n\tprivate static final long serialVersionUID = 1261660925357051253L;\n\t@SerializedName(\"x\")\n\tprivate final double latitude;    \n\t@SerializedName(\"y\")\n\tprivate final double longitude;\n\t@SerializedName(\"z\")\n\tprivate final double altitude; \n\n\t/**\n\t * A terrestrial position defined by latitude, longitude, and altitude (LLA).\n\t * \n\t * @param latitude \n\t *          the angle north of the equator in degrees (negative angles define latitudes in the southern hemisphere). Must be a value within this interval: -90 <= latitude <= 90\n\t * @param longitude\n\t *          the angle east of the prime meridian in degrees (negative angles define longitudes in the western hemisphere). Must be a value within this interval: -180 < longitude <= 180\n\t * @param altitude\n\t *          the distance above sea level in meters or more precisely the distance above the surface of the WGS-84 reference ellipsoid.\n\t * @throws IllegalArgumentException\n\t *           when the latitude or longitude is outside the specified range\n\t */\n\tpublic LlaCoordinate(double latitude, double longitude, double altitude) {\n\t\tthis.latitude = checkLatitudeRange(latitude);\n\t\tthis.longitude = checkLongitudeRange(longitude);\n\t\tthis.altitude = checkAltitudeRange(altitude);\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (!(obj instanceof LlaCoordinate))\n\t\t\treturn false;\n\t\tLlaCoordinate other = (LlaCoordinate) obj;\n\t\tif (Double.doubleToLongBits(altitude) != Double.doubleToLongBits(other.altitude))\n\t\t\treturn false;\n\t\tif (Double.doubleToLongBits(latitude) != Double.doubleToLongBits(other.latitude))\n\t\t\treturn false;\n\t\tif (Double.doubleToLongBits(longitude) != Double.doubleToLongBits(other.longitude))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * The altitude\n\t * \n\t * @return the distance above sea level or more precisely the distance above the surface of the WGS-84 reference ellipsoid. For this project we need this distance in meters\n\t */\n\tpublic double getAltitude() {\n\t\treturn altitude;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn String.format(\"LlaCoordinate(%f, %f, %f)\", latitude, longitude, altitude);\n\t}\n\n\t/**\n\t * The latitude angle.\n\t * \n\t * @return the angle north of the equator in degrees (negative angles define latitudes in the southern hemisphere).\n\t */\n\tpublic double getLatitude() {\n\t\treturn latitude;\n\t}\n\n\t/**\n\t * The longitude angle\n\t * \n\t * @return the angle east of the prime meridian in degrees (negative angles define longitudes in the western hemisphere)\n\t */\n\tpublic double getLongitude() {\n\t\treturn longitude;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tlong temp;\n\t\ttemp = Double.doubleToLongBits(altitude);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\ttemp = Double.doubleToLongBits(latitude);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\ttemp = Double.doubleToLongBits(longitude);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\treturn result;\n\t}\n\n\t/**\n\t * @return a terrestrial position defined by an N-vector plus altitude\n\t */\n\t@Override\n\tpublic NVector toNVector() {\n\t\t/*\n\t\t * The formula this code is based on can be found in a journal article called: \"A Non-singular Horizontal Position Representation\" by Kenneth Gade. You can find it at https://goo.gl/iCqdCn (see\n\t\t * equation 3 in 5.2.1.)\n\t\t * \n\t\t * Note: equation 3 is unconventional as it swaps the z component with x component. This code follows the more common convention and returns z and x to their proper place\n\t\t */\n\t\tdouble lat = Math.toRadians(latitude);\n\t\tdouble lon = Math.toRadians(longitude);\n\t\tdouble cosLat = Math.cos(lat);\n\t\tdouble x = Math.cos(lon) * cosLat;\n\t\tdouble y = Math.sin(lon) * cosLat;\n\t\tdouble z = Math.sin(lat);\n\t\treturn new NVector(x, y, z, altitude);\n\t}\n\n\t/**\n\t * @return a terrestrial position defined by an x, y, and z coordinate in an Earth centered Earth fixed reference frame.\n\t */\n\t@Override\n\tpublic PVector toPVector() {\n\t\treturn this.toNVector().toPVector();\n\t}\n\n\tprivate double checkAltitudeRange(double altitude) {\n\t\t// on wrong side of the earth...\n\t\t// if (altitude < -6378137) {\n\t\t// throw new IllegalArgumentException(\"Invalid altitude\");\n\t\t// }\n\t\treturn altitude;\n\t}\n\n\tprivate double checkLatitudeRange(double latitude) {\n\t\tif (Math.abs(latitude) > 90) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid latitude\");\n\t\t}\n\t\treturn latitude;\n\t}\n\n\tprivate double checkLongitudeRange(double longitude) {\n\t\tif (longitude > 180 || longitude <= -180) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid longitude\");\n\t\t}\n\t\treturn longitude;\n\t}\n\n\t@Override\n\tpublic LlaCoordinate toLlaCoordinate() {\n\t\treturn this;\n\t}\n\n}\n"}, {"id": "TaskFactory.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.tasks;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;\n\npublic class TaskFactory {\n\n\tpublic static final String FLIGHTPATTERN = \"FLIGHTPATTERN\";\n\tpublic static final String ROUTE = \"ROUTE\";\n\tpublic static final String SYNC = \"SYNC\";\n\tpublic static final String WAYPOINT = \"WAYPOINT\";\n\tpublic static final String TAKEOFF = \"TAKEOFF\";\n\tpublic static final String LAND = \"LAND\";\n\tpublic static final String DELAY = \"DELAY\";\n\n\t@Deprecated\n\tpublic static IMissionTask getTask(String type, String uavid, String taskname, Object... params)\n\t\t\tthrows MissionExecutionException {\n\t\tswitch (type) {\n\t\tcase FLIGHTPATTERN:\n\t\t\treturn new PatternTask(uavid, taskname);\n\n\t\tcase ROUTE:\n\t\t\treturn new RouteTask(uavid, taskname);\n\n\t\tcase SYNC:\n\t\t\treturn new SyncTask(uavid, taskname);\n\n\t\tcase DELAY:\n\t\t\tif (params.length != 1) {\n\t\t\t\tthrow new MissionExecutionException(\"missing duration parameter\");\n\t\t\t}\n\t\t\tdouble duration = Double.parseDouble(params[0].toString());\n\t\t\treturn new DelayTask(uavid, taskname, duration);\n\n\t\tdefault:\n\t\t\tthrow new MissionExecutionException(\"Type \" + type + \" not supported\");\n\t\t}\n\t}\n\n\t\n\t\n\tpublic static IMissionTask getTask(String type, String uavid, String taskname,Map<String, Serializable> params)\n\t\t\tthrows MissionExecutionException {\n\t\tswitch (type) {\n\t\tcase FLIGHTPATTERN:\n\t\t\treturn new PatternTask(uavid, taskname);\n\n\t\tcase ROUTE:\n\t\t\treturn new RouteTask(uavid, taskname);\n\n\t\tcase SYNC:\n\t\t\treturn new SyncTask(uavid, taskname);\n\n\t\tcase DELAY:\n\t\t\tif (!params.containsKey(\"duration\")) {\n\t\t\t\tthrow new MissionExecutionException(\"missing duration parameer\");\n\t\t\t}\n\t\t\tdouble duration = Double.parseDouble(params.get(\"duration\").toString());\n\t\t\treturn new DelayTask(uavid, taskname, duration);\n\n\t\tdefault:\n\t\t\tthrow new MissionExecutionException(\"Type \" + type + \" not supported\");\n\t\t}\n\t}\n\n\tpublic static IMissionTask getTask(String type, String uavid, LlaCoordinate coordinate) {\n\t\tswitch (type) {\n\t\tcase WAYPOINT:\n\t\t\treturn new WaypointTask(uavid, coordinate);\n\n\t\tcase TAKEOFF:\n\t\t\treturn new TakeoffTask(uavid, coordinate);\n\n\t\tcase LAND:\n\t\t\treturn new LandTask(uavid, coordinate);\n\n\t\tdefault:\n\t\t\tthrow new IllegalArgumentException(\"Type \" + type + \" not supported\");\n\t\t}\n\t}\n\n}\n"}, {"id": "IRemotable.java", "body": "package edu.nd.dronology.services.core.api;\n\nimport java.io.Serializable;\nimport java.rmi.Remote;\n\npublic interface IRemotable extends Remote,Serializable {\n\n}\n"}, {"id": "SlowLayer.java", "body": "package edu.nd.dronology.core.collisionavoidance.strategy.onionbackend;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand;\nimport edu.nd.dronology.core.collisionavoidance.strategy.StopEveryone;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.goal.WaypointGoal;\nimport edu.nd.dronology.core.goal.WaypointGoalSnapshot;\n\npublic class SlowLayer implements ILayer {\n    private final double speed;\n    private final double distance;\n\n    public SlowLayer(double triggerDistance, double speed)  {\n        this.speed = speed;\n        this.distance = triggerDistance;\n    }\n\n\t@Override\n\tpublic void applyAction(DroneSnapshot snapshot) {\n        WaypointGoalSnapshot wpGoal = StopEveryone.findActiveWaypointGoal(snapshot.getGoals());\n        if (wpGoal != null) {\n            double cmdSpeed = Math.min(wpGoal.getSpeed(), this.speed);\n            flyToTargetAtSpeedIfNotAlready(snapshot, wpGoal.getPosition().toLlaCoordinate(), cmdSpeed);\n        }\n\t}\n\n\t@Override\n\tpublic boolean isTriggered(double distance) {\n\t\treturn distance < this.distance;\n\t}\n\n\t@Override\n\tpublic double getTriggerDistance() {\n\t\treturn distance;\n    }\n    \n    private void flyToTargetAtSpeedIfNotAlready(DroneSnapshot drone, LlaCoordinate target, double speed) {\n        if (drone.getCommands().size() == 1) {\n            if (drone.getCommands().get(0) instanceof WaypointCommand) {\n                WaypointCommand wp = (WaypointCommand) drone.getCommands().get(0);\n                boolean sameDest = wp.getDestination().toLlaCoordinate().equals(target);\n                boolean sameSpeed = wp.getSpeed() == speed;\n                if (sameDest && sameSpeed) {\n                    return;\n                }\n            }\n        }\n        drone.getCommands().clear();\n        WaypointCommand cmd = new WaypointCommand(target, speed);\n        drone.getCommands().add(cmd);\n    }\n\n}"}, {"id": "FlightZoneManager2.java", "body": "package edu.nd.dronology.core.flightzone;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport com.google.common.util.concurrent.RateLimiter;\n\nimport edu.nd.dronology.core.fleet.DroneFleetListener;\nimport edu.nd.dronology.core.DronologyConstants;\nimport edu.nd.dronology.core.collisionavoidance.CollisionAvoidanceBackend;\nimport edu.nd.dronology.core.collisionavoidance.CollisionAvoidanceCheckTask;\nimport edu.nd.dronology.core.collisionavoidance.CollisionAvoidanceMessenger;\nimport edu.nd.dronology.core.collisionavoidance.strategy.StopEveryone;\nimport edu.nd.dronology.core.collisionavoidance.strategy.StopEveryoneWaypoint;\nimport edu.nd.dronology.core.collisionavoidance.strategy.onionbackend.SlowLayer;\nimport edu.nd.dronology.core.collisionavoidance.strategy.onionbackend.StopLayer;\nimport edu.nd.dronology.core.collisionavoidance.strategy.FollowTheLeaderNed;\nimport edu.nd.dronology.core.collisionavoidance.strategy.FollowTheLeaderWaypoint;\nimport edu.nd.dronology.core.collisionavoidance.strategy.Onion;\nimport edu.nd.dronology.core.collisionavoidance.strategy.PassThrough;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.exceptions.FlightZoneException;\nimport edu.nd.dronology.core.fleet.DroneFleetManager;\nimport edu.nd.dronology.core.flight.FlightPlanFactory;\nimport edu.nd.dronology.core.flight.IFlightDirector;\nimport edu.nd.dronology.core.flight.IFlightPlan;\nimport edu.nd.dronology.core.flight.IPlanStatusChangeListener; \nimport edu.nd.dronology.core.flight.PlanPoolManager;\nimport edu.nd.dronology.core.flight.internal.SimpleTakeoffFlightPlan;\nimport edu.nd.dronology.core.flight.internal.SoloDirector;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider; \n\n/**\n * \n * Central management class for all UAV related actions. <br>\n * This includes take-off, and landing checks as well as assignment of flight plans to UAVs.\n * \n * @author Michael Vierhauser\n *  \n */ \npublic class FlightZoneManager2 implements IPlanStatusChangeListener {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(FlightZoneManager2.class);\n\n\tprivate PlanPoolManager planPoolManager;\n\tprivate DroneFleetManager droneFleet;\n\tprivate CollisionAvoidanceMessenger ca;\n\n\tprivate final AtomicInteger activeUAVS = new AtomicInteger(0);\n\n\tprivate final List<IFlightPlan> awaitingTakeOffFlights = Collections.synchronizedList(new ArrayList<>());\n\tprivate final List<IFlightPlan> awaitingLandingFlights = Collections.synchronizedList(new ArrayList<>());\n\n\tprivate final Timer timer = new Timer();\n\n\t/**\n\t * Constructs a new FlightZoneManager.\n\t * \n\t * @throws InterruptedException\n\t */\n\tpublic FlightZoneManager2() throws InterruptedException {\n\t\tdroneFleet = DroneFleetManager.getInstance();\n\t\tplanPoolManager = PlanPoolManager.getInstance();\n\t\tplanPoolManager.addPlanStatusChangeListener(this);\n\n\t\t// CollisionAvoidanceBackend backend = new CollisionAvoidanceBackend(new StopEveryone(10));\n\t\t// ca = backend.getMessenger();\n\n\t\t// timer.scheduleAtFixedRate(new AvoidanceCheckTask(), 100, DronologyConstants.FREQUENCY_COLLISION_CHECKS);\n\t\ttimer.scheduleAtFixedRate(new StatusCheckTask(), 100, DronologyConstants.FREQUENCY_STATUS_CHECKS);\n\t\t// CollisionAvoidanceCheckTask caTask = new CollisionAvoidanceCheckTask(new PassThrough());\n\t\t// CollisionAvoidanceCheckTask caTask = new CollisionAvoidanceCheckTask(new StopEveryone(0));\n\t\tCollisionAvoidanceCheckTask caTask = new CollisionAvoidanceCheckTask(new StopEveryoneWaypoint(20));\n\t\t// CollisionAvoidanceCheckTask caTask = new CollisionAvoidanceCheckTask(new FollowTheLeaderNed());\n\t\t// CollisionAvoidanceCheckTask caTask = new CollisionAvoidanceCheckTask(new FollowTheLeaderWaypoint(10, 10, -10));\n\t\t// CollisionAvoidanceCheckTask caTask = new CollisionAvoidanceCheckTask(new Onion(\n\t\t// \tnew StopLayer(5),\n\t\t// \tnew SlowLayer(10, 0.2),\n\t\t// \tnew SlowLayer(20, 0.5),\n\t\t// \tnew SlowLayer(40, 2.0),\n\t\t// \tnew SlowLayer(80, 4.0),\n\t\t// \tnew SlowLayer(160, 6.0)\n\t\t// ));\n\t\t\n\t\tThread caThread = new Thread(new Runnable(){\n\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(100);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tRateLimiter limiter = RateLimiter.create(DronologyConstants.FREQUENCY_COLLISION_CHECKS);\n\t\t\t\twhile(true) {\n\t\t\t\t\tlimiter.acquire();\n\t\t\t\t\tcaTask.run();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tcaThread.setDaemon(true);\n\t\tcaThread.start();\n\t\t// droneFleet.addDroneFleetListener(new DroneCARegistration());\n\t}\n\n\tprivate ManagedDrone tryAssignUAV() throws DroneException, FlightZoneException {\n\t\tIFlightPlan nextPlan = planPoolManager.getNextPendingPlan();\n\t\tManagedDrone drone;\n\t\tif (nextPlan.getDesignatedDroneId() == null) {\n\t\t\tdrone = droneFleet.getAvailableDrone();\n\t\t\tif (drone != null) {\n\t\t\t\tplanPoolManager.assignPlan(nextPlan, drone.getDroneName());\n\t\t\t}\n\t\t} else {\n\t\t\tdrone = droneFleet.getAvailableDrone(nextPlan.getDesignatedDroneId());\n\t\t}\n\n\t\t// TODO try to find a free uav from all plans..\n\t\tif (drone != null && (planPoolManager.getCurrentPlan(drone.getDroneName()) == null)) {\n\t\t\tplanPoolManager.activatePlan(nextPlan, drone.getDroneName());\n\t\t\tif (drone.getFlightModeState().isOnGround()) {\n\t\t\t\tawaitingTakeOffFlights.add(nextPlan);\n\t\t\t}\n\n\t\t\tIFlightDirector flightDirectives = new SoloDirector(drone);\n\t\t\tflightDirectives.setWayPoints(nextPlan.getWayPoints());\n\t\t\tdrone.getMessenger().assignFlight(flightDirectives);\n\t\t\t// // this needs to be moved to launch....\n\t\t\tnextPlan.setStatusToFlying(drone);\n\t\t\tif (drone.getFlightModeState().isInAir()) {\n\t\t\t\tdrone.getFlightModeState().setModeToFlying();\n\t\t\t} else {\n\t\t\t\tdrone.getFlightModeState().setModeToAwaitingTakeOffClearance();\n\t\t\t}\n\t\t\treturn drone;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate class DroneCARegistration implements DroneFleetListener {\n\t\t@Override\n\t\tpublic void droneAdded(ManagedDrone drone) {\n\t\t\tdrone.addObserver((observable, arg) -> {\n\t\t\t\tca.sendManagedDroneUpdate(drone.getDroneName(), null, null, null, drone);\n\t\t\t});\n\n\t\t}\n\n\t\t@Override\n\t\tpublic void droneRemoved(ManagedDrone drone) {\n\t\t\t\n\t\t}\n\t}\n\tprivate class AvoidanceCheckTask extends TimerTask {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tca.sendCheckTask();\n\t\t}\n\t}\n\n\tprivate class StatusCheckTask extends TimerTask {\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\t// checkForLandedFlights();\n\t\t\t\t\tcheckForCompletedPlans();\n\t\t\t\t} catch (DroneException e) {\n\t\t\t\t\tLOGGER.error(e);\n\t\t\t\t}\n\n\t\t\t\tif (activeUAVS.get() == DronologyConstants.MAX_IN_AIR) {\n\t\t\t\t\tcheckPendingForFlying();\n\n\t\t\t\t} else if (planPoolManager.hasPendingFlights()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttryAssignUAV();\n\t\t\t\t\t\tcheckPendingForFlyingWithTakeoff();\n\t\t\t\t\t} catch (DroneException e) {\n\t\t\t\t\t\tLOGGER.error(e);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (hasAwaitingTakeOff() && activeUAVS.get() < DronologyConstants.MAX_IN_AIR) {\n\t\t\t\t\tLOGGER.info(\"Awaiting Takeoff:\" + getAwaitingTakeOffFlights().get(0).getFlightID());\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcheckForTakeOffReadiness();\n\t\t\t\t\t} catch (FlightZoneException e1) {\n\t\t\t\t\t\tLOGGER.error(\"Failed Check for takeoff readiness.\", e1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasAwaitingLanding()) {\n\t\t\t\t\tcheckForLandingReadiness();\n\t\t\t\t}\n\n\t\t\t} catch (Throwable t) {\n\t\t\t\tLOGGER.error(t);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Checks if the next pending flight is able to takeoff. Currently takeoff occurs in order of pending list.\n\t * \n\t * @param droneFleet\n\t * @throws FlightZoneException\n\t */\n\tpublic void checkForTakeOffReadiness() throws FlightZoneException {\n\t\t// Technical debt.\n\t\t// Checks first waiting drone each time it is called.\n\t\tif (!awaitingTakeOffFlights.isEmpty()) {\n\t\t\tIFlightPlan awaitingFlightPlan = awaitingTakeOffFlights.get(0);\n\t\t\tManagedDrone drone = awaitingFlightPlan.getAssignedDrone();\n\t\t\tif (drone.permissionForTakeoff()) {\n\t\t\t\t// drone.setTargetAltitude(awaitingFlightPlan.getTakeoffAltitude());\n\t\t\t\tdrone.setTargetAltitude(DronologyConstants.TAKE_OFF_ALTITUDE);\n\t\t\t\tdrone.takeOff();\n\t\t\t\tactiveUAVS.incrementAndGet();\n\t\t\t\tawaitingTakeOffFlights.remove(awaitingFlightPlan);\n\t\t\t}\n\t\t}\n\t}\n \n\tpublic void checkPendingForFlying() {\n\t\tfor (IFlightPlan pendingPlan : planPoolManager.getPendingPlans()) {\n\t\t\ttry {\n\t\t\t\tcheckForScheduling(pendingPlan);\n\t\t\t} catch (DroneException | FlightZoneException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void checkPendingForFlyingWithTakeoff() {\n\t\tfor (IFlightPlan pendingPlan : planPoolManager.getPendingPlans()) {\n\t\t\ttry {\n\t\t\t\tcheckForSchedulingWithTakeoff(pendingPlan);\n\t\t\t} catch (DroneException | FlightZoneException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void checkForScheduling(IFlightPlan pendingPlan) throws DroneException, FlightZoneException {\n\t\tManagedDrone drone;\n\t\tif (pendingPlan.getDesignatedDroneId() == null) {\n\t\t\tdrone = droneFleet.getAvailableDrone();\n\t\t\tif (drone != null) {\n\t\t\t\tplanPoolManager.assignPlan(pendingPlan, drone.getDroneName());\n\t\t\t}\n\t\t} else {\n\t\t\tdrone = droneFleet.getAvailableDrone(pendingPlan.getDesignatedDroneId());\n\t\t}\n\n\t\tif (drone == null || !drone.getFlightModeState().isInAir()\n\t\t\t\t|| (planPoolManager.getCurrentPlan(drone.getDroneName()) != null)) {\n\t\t\tif (drone != null) {\n\t\t\t\tdroneFleet.returnDroneToAvailablePool(drone);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tplanPoolManager.activatePlan(pendingPlan, drone.getDroneName());\n\n\t\tIFlightDirector flightDirectives = new SoloDirector(drone);\n\t\tflightDirectives.setWayPoints(pendingPlan.getWayPoints());\n\t\tdrone.getMessenger().assignFlight(flightDirectives);\n\t\t// // this needs to be moved to launch....\n\t\tpendingPlan.setStatusToFlying(drone);\n\t\tif (drone.getFlightModeState().isInAir()) {\n\t\t\tdrone.getFlightModeState().setModeToFlying();\n\t\t}\n\t}\n\n\tprivate void checkForSchedulingWithTakeoff(IFlightPlan pendingPlan) throws DroneException, FlightZoneException {\n\t\tManagedDrone drone;\n\t\tif (pendingPlan.getDesignatedDroneId() == null) {\n\t\t\tdrone = droneFleet.getAvailableDrone();\n\t\t\tif (drone != null) {\n\t\t\t\tplanPoolManager.assignPlan(pendingPlan, drone.getDroneName());\n\t\t\t}\n\t\t} else {\n\t\t\tdrone = droneFleet.getAvailableDrone(pendingPlan.getDesignatedDroneId());\n\t\t}\n\n\t\tif (drone == null || (planPoolManager.getCurrentPlan(drone.getDroneName()) != null)) {\n\t\t\treturn;\n\t\t}\n\t\tplanPoolManager.activatePlan(pendingPlan, drone.getDroneName());\n\n\t\tIFlightDirector flightDirectives = new SoloDirector(drone);\n\t\tflightDirectives.setWayPoints(pendingPlan.getWayPoints());\n\t\tdrone.getMessenger().assignFlight(flightDirectives);\n\t\t// // this needs to be moved to launch....\n\t\tpendingPlan.setStatusToFlying(drone);\n\t\tif (drone.getFlightModeState().isInAir()) {\n\t\t\tdrone.getFlightModeState().setModeToFlying();\n\t\t} else if (drone.getFlightModeState().isOnGround()) {\n\t\t\tawaitingTakeOffFlights.add(pendingPlan);\n\t\t\tdrone.getFlightModeState().setModeToAwaitingTakeOffClearance();\n\t\t}\n\n\t}\n\n\tpublic void checkForLandingReadiness() {\n\t\tif (!awaitingLandingFlights.isEmpty() && awaitingLandingFlights.get(0).isCompleted()) {\n\t\t\ttry {\n\t\t\t\tIFlightPlan awaitingFlightPlan = awaitingLandingFlights.get(0);\n\t\t\t\tManagedDrone drone = droneFleet.getRegisteredDrone(awaitingFlightPlan.getDesignatedDroneId());\n\t\t\t\tLOGGER.info(\"Drone '\" + drone.getDroneName() + \"' ready to land\");\n\n\t\t\t\tdrone.land();\n\t\t\t\t// land after alt <1\n\t\t\t\tactiveUAVS.decrementAndGet();\n\t\t\t\tawaitingLandingFlights.remove(0);\n\t\t\t} catch (FlightZoneException | DroneException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tpublic boolean hasAwaitingLanding() {\n\t\treturn awaitingLandingFlights.size() > 0;\n\t}\n\n\tpublic List<IFlightPlan> getAwaitingTakeOffFlights() {\n\t\treturn Collections.unmodifiableList(awaitingTakeOffFlights);\n\t}\n\n\tpublic void checkForCompletedPlans() throws DroneException {\n\t\tplanPoolManager.checkFormCompletedPlans();\n\n\t}\n\n\tpublic boolean hasAwaitingTakeOff() {\n\t\treturn !awaitingTakeOffFlights.isEmpty();\n\n\t}\n\n\tpublic void planFlight(String uavid, String planName, List<Waypoint> waypoints) throws DroneException {\n\t\tIFlightPlan plan = FlightPlanFactory.create(uavid, planName, waypoints);\n\t\tPlanPoolManager.getInstance().addNewPlan(plan); \n\n\t}\n\n\tpublic void planFlight(String planName, List<Waypoint> waypoints) throws DroneException {\n \t\tIFlightPlan plan = FlightPlanFactory.create(planName, waypoints);\n\t\tPlanPoolManager.getInstance().addNewPlan(plan);\n\n\t}\n\n\t@Override\n\tpublic void notifyPlanChange(IFlightPlan changedPlan) {\n\t\tif (changedPlan.isCompleted()) {\n\t\t\tManagedDrone drone = changedPlan.getAssignedDrone();\n\t\t\tif (drone != null) {\n\t\t\t\tdroneFleet.returnDroneToAvailablePool(drone);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic void returnToHome(String uavid) throws DroneException {\n\t\tLOGGER.info(uavid + \" returning to home\");\n\t\tManagedDrone drone = droneFleet.getRegisteredDrone(uavid);\n\t\tLlaCoordinate baseCoordinate = drone.getBaseCoordinates();\n\n\t\tdouble currentAltitude = drone.getCoordinates().getAltitude();\n\t\tLlaCoordinate homeCoordinate = new LlaCoordinate(baseCoordinate.getLatitude(), baseCoordinate.getLongitude(),\n\t\t\t\tcurrentAltitude);\n\n\t\tLlaCoordinate homeCoordinateAltitude = new LlaCoordinate(baseCoordinate.getLatitude(),\n\t\t\t\tbaseCoordinate.getLongitude(), DronologyConstants.HOME_ALTITUDE);\n\n\t\tWaypoint wps = new Waypoint(homeCoordinate);\n\t\tWaypoint wps2 = new Waypoint(homeCoordinateAltitude);\n\t\tList<Waypoint> wpsList = new ArrayList<>();\n\t\twpsList.add(wps);\n\t\twpsList.add(wps2);\n\t\tIFlightPlan homePlane = FlightPlanFactory.create(uavid, \"Return to Home\", wpsList);\n\t\ttry {\n\t\t\tplanPoolManager.overridePlan(homePlane, uavid);\n\t\t\tif (drone.getFlightModeState().isFlying()) {\n\t\t\t\tdrone.getFlightModeState().setModeToInAir();\n\t\t\t}\n\t\t\tIFlightDirector flightDirectives = new SoloDirector(drone);\n\t\t\tflightDirectives.setWayPoints(homePlane.getWayPoints());\n\t\t\tdrone.getMessenger().assignFlight(flightDirectives);\n\t\t\tawaitingLandingFlights.add(homePlane);\n\n\t\t\tdrone.getFlightModeState().setModeToFlying();\n\t\t\tdrone.returnToHome();\n\t\t\thomePlane.setStatusToFlying(drone);\n\t\t} catch (FlightZoneException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\n\tpublic void cancelPendingFlights(String uavid) throws DroneException {\n\t\tPlanPoolManager.getInstance().cancelPendingPlans(uavid);\n\t}\n\n\tpublic void pauseFlight(String uavid) throws DroneException {\n\t\tManagedDrone drone = droneFleet.getRegisteredDrone(uavid);\n\t\tif (drone.getFlightSafetyModeState().isSafetyModeHalted()) {\n\t\t\treturn;\n\t\t}\n\t\tLOGGER.info(uavid + \" Pause current flight\");\n\t\tdrone.haltInPlace(300000);\n\t}\n\n\tpublic void resumeFlight(String uavid) throws DroneException, FlightZoneException {\n\t\tLOGGER.info(uavid + \" Resume current flight\");\n\t\tManagedDrone drone = droneFleet.getRegisteredDrone(uavid);\n\t\tdrone.resumeFlight();\n\t}\n\n\tpublic void takeoff(String uavid, double altitude) throws DroneException, FlightZoneException {\n\t\tLOGGER.info(uavid + \" Takeoff\");\n\t\tManagedDrone drone = droneFleet.getRegisteredDrone(uavid);\n\t\tPlanPoolManager.getInstance().addNewPlan(new SimpleTakeoffFlightPlan(drone, \"TAKE-OFF\", altitude));\n\t}\n\n\tpublic void emergencyStop(String uavid) throws DroneException {\n\t\tManagedDrone drone = droneFleet.getRegisteredDrone(uavid);\n\t\tdrone.emergencyStop();\n\t}\n}\n"}, {"id": "MockupProbe.java", "body": "package edu.nd.dronology.monitoring.reminds;\n\nimport java.util.UUID;\n\nimport at.jku.mevss.eventdistributor.core.commandsocket.AbstractCommand;\nimport at.jku.mevss.eventpublisher.core.api.AbstractProbePoint;\nimport at.jku.mevss.eventpublisher.core.internal.Publisher;\n\npublic class MockupProbe extends AbstractProbePoint {\n\n\t// private static final String SOURCE = \"CL2-MOCKUP\";\n\t// private EventGeneratorTask generator;\n\tprivate int nrOfEventsPerSend;\n\tprivate String id = UUID.randomUUID().toString();\n\t// private String source;\n\n\tpublic MockupProbe(String id, String container, String source) {\n\n\t\tsuper(id, container, source);\n\t\n\t}\n\n\t@Override\n\tprotected void doHandleCommand(AbstractCommand command) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n\tpublic void run() {\n\t\tsuper.start();\n\t}\n\n\t// public void publish(long timestamp, String typeName, List<Map<String, Serializable>> data) {\n\t// ArrayList<TransmittableEventDataObject> list = new ArrayList<>();\n\t// for (Map m : data) {\n\t// TransmittableEventDataObject eventdata = TransmittableObjectFactory.createEventData(m);\n\t// list.add(eventdata);\n\t// }\n\t//\n\t// if (nrOfEventsPerSend == 1) {\n\t// TransmittableEventObject obj = TransmittableObjectFactory.createEventObject(source, timestamp, typeName, list);\n\t// publish(source, obj);\n\t// } else {\n\t// List<TransmittableEventObject> events = new ArrayList<>();\n\t// for (int i = 0; i < nrOfEventsPerSend; i++) {\n\t// TransmittableEventObject obj = TransmittableObjectFactory.createEventObject(source, timestamp, typeName, new ArrayList(list));\n\t// events.add(obj);\n\t// }\n\t// sendData(source, events.toArray(new TransmittableEventObject[0]));\n\t// }\n\t//\n\t// }\n\n}\n"}, {"id": "PreciseTimestamp.java", "body": "package edu.nd.dronology.core.util;\n\nimport java.io.Serializable;\n\npublic class PreciseTimestamp implements Serializable {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 4565636114409035692L;\n\tprivate long nanotime;\n\tprivate long timestamp;\n\tprivate boolean isPrecise;\n\tstatic final long NUM_100NS_INTERVALS_SINCE_UUID_EPOCH = 0x01b21dd213814000L;\n\n\tpublic PreciseTimestamp(long timestamp, boolean isPrecise) {\n\t\tthis.timestamp = timestamp;\n\t\tthis.isPrecise = isPrecise;\n\t\tthis.nanotime = System.nanoTime();\n\t}\n\n\tpublic long getNanotime() {\n\t\treturn nanotime;\n\t}\n\n\tpublic long getTimestamp() {\n\t\treturn timestamp;\n\t}\n\n\tpublic int compareTo(PreciseTimestamp that) {\n\t\tint result = Long.compare(this.getTimestamp(), that.getTimestamp());\n\t\tif (result == 0) {\n\t\t\treturn compareTimeStamps(this.nanotime, that.nanotime);\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + (int) (nanotime ^ (nanotime >>> 32));\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (obj == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (getClass() != obj.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tPreciseTimestamp other = ((PreciseTimestamp) obj);\n\t\tif (timestamp != other.timestamp) {\n\t\t\treturn false;\n\t\t}\n\t\tif (nanotime != other.nanotime) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate  int compareTimeStamps(long start, long comp) {\n\t\tif (start == comp) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (comp - start > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Timestamp: \" + timestamp + \" nanotime:\" + nanotime;\n\t}\n\n\tpublic static synchronized PreciseTimestamp create(long timestamp) {\n\t\treturn new PreciseTimestamp(timestamp, true);\n\t}\n\n\tpublic static synchronized PreciseTimestamp create(long timestamp, boolean isPrecise) {\n\t\treturn new PreciseTimestamp(timestamp, isPrecise);\n\t}\n\n\tpublic static synchronized PreciseTimestamp create() {\n\t\treturn new PreciseTimestamp(System.currentTimeMillis(), true);\n\t}\n}"}, {"id": "IGoalSnapshot.java", "body": "package edu.nd.dronology.core.goal;\n\n/**\n * Read-only snapshot of a goal.\n */\npublic interface IGoalSnapshot {\n    public abstract AbstractGoal.GoalState getState();\n}\n"}, {"id": "IDroneMonitoringServiceInstance.java", "body": "package edu.nd.dronology.monitoring.service;\n\nimport java.util.Set;\n\nimport edu.nd.dronology.core.monitoring.ArtifactIdentifier;\nimport edu.nd.dronology.monitoring.IRemoteMonitoringMessageHandler;\nimport edu.nd.dronology.services.core.api.IServiceInstance;\n \npublic interface IDroneMonitoringServiceInstance extends IServiceInstance {\n\n\tvoid registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler);\n\n\tSet<IRemoteMonitoringMessageHandler> getSubscribedHandler(ArtifactIdentifier identifier);\n\n\tvoid registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler,\n\t\t\tArtifactIdentifier<IRemoteMonitoringMessageHandler> identifier);\n\n\tvoid unsubscribeHandler(IRemoteMonitoringMessageHandler handler);\n\n}\n"}, {"id": "SetGimbalRotationCommand.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n\nimport edu.nd.dronology.core.CoordinateChange;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\n@CoordinateChange\npublic class SetGimbalRotationCommand extends AbstractDroneCommand implements IDroneCommand {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -3345889656265155714L;\n\n\tpublic SetGimbalRotationCommand(String uavid, LlaCoordinate coord) {\n\t\tsuper(uavid, \"\");\n\t}\n\n}\n"}, {"id": "IFlightRouteplanningRemoteService.java", "body": "package edu.nd.dronology.services.core.remote;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\n\nimport edu.nd.dronology.services.core.info.FlightRouteCategoryInfo;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\n/**\n * Extends {@link IFileTransmitRemoteService} and provides methods for retrieving and saving models from the server.\n * \n * @author Michael Vierhauser\n * \n */\npublic interface IFlightRouteplanningRemoteService extends IRemoteableService, IFileTransmitRemoteService<FlightRouteInfo> {\n\n\t\n Collection<FlightRouteCategoryInfo> getFlightPathCategories() throws RemoteException;\n\t\n}\n"}, {"id": "PingPongCommand.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n\nimport edu.nd.dronology.core.CoordinateChange;\n\n@CoordinateChange\npublic class PingPongCommand extends AbstractDroneCommand implements IDroneCommand {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 4365284928942347912L;\n\n\tpublic PingPongCommand(String uavid) {\n\t\tsuper(uavid, CommandIds.PING_PONG_COMMAND);\n\t}\n\n}\n"}, {"id": "LandCommand.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n\npublic class LandCommand extends AbstractDroneCommand implements IDroneCommand {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -8475187449318434454L;\n\tpublic static final transient String MODE_LAND = \"LAND\";\n\n\tpublic LandCommand(String uavid, String mode) {\n\t\tsuper(uavid, CommandIds.SET_MODE_COMMAND);\n\t\tdata.put(ATTRIBUTE_MODE, mode);\n\t}\n\n}\n"}, {"id": "DroneAttribute.java", "body": "package edu.nd.dronology.core.vehicle;\n\npublic class DroneAttribute<T> implements IDroneAttribute<T> {\n\n\tprivate final String key;\n\tprivate final T value;\n\n\tpublic DroneAttribute(String key, T value) {\n\t\tthis.key = key;\n\t\tthis.value = value;\n\t}\n\n\t@Override\n\tpublic String getKey() {\n\t\treturn key;\n\t}\n\t@Override\n\tpublic T getValue() {\n\t\treturn value;\n\t}\n\n}\n"}, {"id": "RouteCreationRunner.java", "body": "package edu.nd.dronology.services.extensions.areamapping.unused;\n//package edu.nd.dronology.services.extensions.areamapping;\n//\n//import java.util.Collection;\n//import java.util.logging.Logger;\n//\n//import edu.nd.dronology.core.vehicle.IUAVProxy;\n//import edu.nd.dronology.services.core.areamapping.ExportAllocationInformation;\n//import edu.nd.dronology.services.core.items.IAreaMapping;\n//import edu.nd.dronology.services.core.util.DronologyServiceException;\n//import edu.nd.dronology.services.extensions.areamapping.creation.IRouteCreator;\n//import edu.nd.dronology.services.extensions.areamapping.creation.MapRiver;\n//import edu.nd.dronology.services.extensions.areamapping.selection.GeneratedRoutesInfo;\n//import edu.nd.dronology.services.extensions.areamapping.selection.IRouteSelectionStrategy;\n//import edu.nd.dronology.services.extensions.areamapping.selection.RouteSelectionResult;\n//\n//public class RouteCreationRunner {\n//\n//\tprivate IRouteCreator riverMapper;\n//\n//\tpublic RouteSelectionResult run(IAreaMapping mapping, Collection<IUAVProxy> uavs) {\n//\n////\t\triverMapper = new MapRiver(mapping);\n////\n////\t\tIRouteSelectionStrategy selector = StrategyFactory.getSelectionStrategy();\n////\n////\t\tlong startGenerate = System.currentTimeMillis();\n////\t\tGeneratedRoutesInfo gInfo = new GeneratedRoutesInfo(riverMapper.generateRoutePrimitives(),\n////\t\t\t\triverMapper.getAverageLatitude(), riverMapper.getTotalRiverSegment(), riverMapper.getBankList());\n////\t\tlong endGenerate = System.currentTimeMillis();\n////\n////\t\ttry {\n////\t\t\tselector.initialize(gInfo, uavs, mapping);\n////\n////\t\t\tlong startSelect = System.currentTimeMillis();\n////\t\t\tRouteSelectionResult createdRouteAssignments = selector.generateAssignments();\n////\t\t\tlong endSelect = System.currentTimeMillis();\n////\n////\t\t\tSystem.out.println(\"ROUTE Generation: \" + (endGenerate - startGenerate) / 1000);\n////\t\t\tSystem.out.println(\"ROUTE Selection: \" + (endSelect - startSelect) / 1000);\n////\t\t\tSystem.out.println(\"Specs: \");\n////\t\t\tExportAllocationInformation flight = createdRouteAssignments.getEportAllocationInformation().get(0);\n////\t\t\tSystem.out.println(\"Mission Score: \" + flight.getMetricStatistics().getAllocationScore());\n////\t\t\tSystem.out.println(\"Coverage: \" + flight.getMetricStatistics().getAllocationCoverage());\n////\t\t\tSystem.out.println(\"Equality of Tasks: \" + flight.getMetricStatistics().getEqualityOfTasks());\n////\t\t\tSystem.out.println(\"Collisions: \" + flight.getMetricStatistics().getCollisions());\n////\t\t\treturn createdRouteAssignments;\n////\t\t} catch (Throwable e) {\n////\t\t\te.printStackTrace();\n////\t\t\tSystem.out.println(e);\n////\t\t}\n////\t\t/// fix throw Exception...\n////\t\treturn new RouteSelectionResult();\n////\n////\t}\n//\n//}\n"}, {"id": "ExportDrone.java", "body": "package edu.nd.dronology.services.core.areamapping;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.services.core.items.IFlightRoute;\n\npublic class ExportDrone implements Serializable {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -6744520905964759937L;\n\tprivate LlaCoordinate startPoint;\n\tprivate LlaCoordinate homeLocation;\n\tprivate List<IFlightRoute> routeAssignment;\n\tprivate final String UAVId;\n\n\tpublic ExportDrone(String UAVId) {\n\t\tthis.UAVId = UAVId;\n\t\trouteAssignment = new ArrayList<>();\n\t}\n\n\tpublic LlaCoordinate getDroneStartPoint() {\n\t\treturn startPoint;\n\t}\n\n\tpublic LlaCoordinate getDroneHomeLocation() {\n\t\treturn homeLocation;\n\t}\n\n\tpublic List<IFlightRoute> getDroneRouteAssignment() {\n\t\treturn routeAssignment;\n\t}\n\n\tpublic void setDroneStartPoint(LlaCoordinate start) {\n\t\tstartPoint = start;\n\t}\n\n\tpublic void setDroneHomeLocation(LlaCoordinate home) {\n\t\thomeLocation = home;\n\t}\n\n\t// public void setDroneRouteAssignment(ExportDroneRouteAssignment route) {\n\t// routeAssignment = route;\n\t// }\n\n\tpublic String getUAVId() {\n\t\treturn UAVId;\n\t}\n\t//\n\t// public void setUAVId(String UAVId) {\n\t// this.UAVId = UAVId;\n\t// }\n\n\tpublic void addRoute(IFlightRoute route) {\n\t\trouteAssignment.add(route);\n\n\t}\n}\n"}, {"id": "DroneMonitoringServiceInstance.java", "body": "package edu.nd.dronology.monitoring.service;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport edu.nd.dronology.core.monitoring.ArtifactIdentifier;\nimport edu.nd.dronology.monitoring.IRemoteMonitoringMessageHandler;\nimport edu.nd.dronology.monitoring.tree.ArtifactIdentifierTree;\nimport edu.nd.dronology.services.core.base.AbstractServiceInstance;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n@SuppressWarnings(\"rawtypes\")\npublic class DroneMonitoringServiceInstance extends AbstractServiceInstance implements IDroneMonitoringServiceInstance {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(DroneMonitoringServiceInstance.class);\n\tprivate final ArtifactIdentifier ROOT_NODE = new ArtifactIdentifier(ArtifactIdentifier.ROOT);\n\tprivate final ArtifactIdentifierTree handlerTree = new ArtifactIdentifierTree(ROOT_NODE);\n\n\tpublic DroneMonitoringServiceInstance() {\n\t\tsuper(\"DRONEMONITORING\");\n\t}\n\n\t@Override\n\tprotected Class<?> getServiceClass() {\n\t\treturn DroneMonitoringService.class;\n\t}\n\n\t@Override\n\tprotected int getOrder() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 14;\n\t}\n\n\t@Override\n\tprotected String getPropertyPath() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void doStartService() throws Exception {\n\n\t}\n\n\t@Override\n\tprotected void doStopService() throws Exception {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n\t@Override\n\tpublic void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler) {\n\t\tregisterMonitoringMessageHandler(handler, new ArtifactIdentifier(ArtifactIdentifier.ROOT));\n\n\t}\n\n\t@Override\n\tpublic void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler,\n\t\t\tArtifactIdentifier<IRemoteMonitoringMessageHandler> identifier) {\n\t\tLOGGER.info(\"Attaching handler: \" + identifier.toString());\n\t\tidentifier.attachItem(handler);\n\t\thandlerTree.add(identifier);\n\n\t}\n\t@Override\n\tpublic Set<IRemoteMonitoringMessageHandler> getSubscribedHandler(ArtifactIdentifier identifier) {\n\t\tSet<ArtifactIdentifier> related = handlerTree.getParents(identifier);\n\t\tSet<IRemoteMonitoringMessageHandler> selectedHandler = new HashSet<>();\n\n\t\tfor (ArtifactIdentifier ident : related) {\n\t\t\tselectedHandler.addAll(ident.getAttachedItems());\n\t\t}\n\n\t\treturn selectedHandler;\n\t}\n\n\t@Override\n\tpublic void unsubscribeHandler(IRemoteMonitoringMessageHandler handler) {\n\t\tSet<ArtifactIdentifier> related = handlerTree.getAllRelatedIdentifier(ROOT_NODE);\n\t\tROOT_NODE.removeAttachedItem(handler);\n\t\tfor (ArtifactIdentifier id : related) {\n\t\t\tid.removeAttachedItem(handler);\n\t\t}\n\n\t}\n\n}\n"}, {"id": "TakeoffCommand.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n\npublic class TakeoffCommand extends AbstractDroneCommand implements IDroneCommand {\n\n\t/**\n\t * \n\t * Command sent to the GCS for taking off to a given alitude.<br>\n\t * The altitude is specified in meter.\n\t * \n\t * \n\t * @author Michael Vierhauser\n\t */ \n\tprivate static final long serialVersionUID = 7724695547149579828L;\n\n\tpublic TakeoffCommand(String droneId, double altitude) {\n\t\tsuper(droneId, CommandIds.TAKEOFF_COMMAND);\n\t\tdata.put(ATTRIBUTE_ALTITUDE, altitude);\n\t}\n\n}\n"}, {"id": "MapRiver.java", "body": "package edu.nd.dronology.services.extensions.areamapping.creation;\n\nimport com.google.gson.FieldNamingPolicy;\n\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\nimport java.awt.geom.*;\nimport java.io.IOException;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Vector;\n\nimport javax.rmi.CORBA.Util;\nimport javax.xml.transform.Source;\n\nimport org.apache.commons.collections4.Get;\n\nimport java.rmi.Naming;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\nimport edu.nd.dronology.services.extensions.areamapping.internal.AdaptedCreepingLinePrimitive;\nimport edu.nd.dronology.services.extensions.areamapping.internal.Geometry;\nimport edu.nd.dronology.services.extensions.areamapping.internal.PriorityPolygonPrimitive;\nimport edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;\nimport edu.nd.dronology.services.extensions.areamapping.internal.RiverBankPrimitive;\nimport edu.nd.dronology.services.extensions.areamapping.internal.RiverList;\nimport edu.nd.dronology.services.extensions.areamapping.internal.SearchPatternStrategy;\nimport edu.nd.dronology.services.extensions.areamapping.internal.SourcePoints;\nimport edu.nd.dronology.services.extensions.areamapping.metrics.MetricsRunner;\nimport edu.nd.dronology.services.extensions.areamapping.model.RiverSubsegment;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive.RouteType;\nimport edu.nd.dronology.services.extensions.areamapping.util.Utilities;\nimport edu.nd.dronology.services.core.areamapping.EdgeLla;\nimport edu.nd.dronology.services.core.items.IAreaMapping;\nimport edu.nd.dronology.services.core.items.IMappedItem;\nimport edu.nd.dronology.services.core.items.PriorityArea;\n\n\npublic class MapRiver implements IRouteCreator{\n\t/*\n\t * ASSUMPTIONS: APERATURE_WIDTH shall be measured in meters. MAX_RIVER_WIDTH\n\t * assumed to be 1000 meters.\n\t */\n\tfinal static double OVERLAP_FACTOR = 0.7;\n\tfinal static double APERATURE_WIDTH = 10;\n\tfinal static double APERATURE_HEIGHT = APERATURE_WIDTH*0.8;\n\tfinal static double MAX_RIVER_WIDTH = 10000;\n\tprivate static int dronesNum = 10;\n\tprivate static final String ADDRESS_SCHEME = \"rmi://%s:%s/Remote\";\n\tprivate Vector<Double> latitudeBounds;\n\tprivate List<RiverBank> bankList;\n\tprivate Path2D.Double totalRiverSegment;\n\tprivate RiverList bankMapping;\n\tprivate List<SourcePoints> priorityAreas;\n\n\t@Deprecated\n\tpublic MapRiver() {\n\t\tparseJSON();\n\t\tlatitudeBounds = new Vector<>();\n\t\tpreprocessRiverBanks(bankMapping);\n\t}\n\t\n\tpublic MapRiver(IAreaMapping mapping) {\n\t\tlatitudeBounds = new Vector<>();\n\t\tpriorityAreas = new ArrayList<>();\n\t\tbankList = Utilities.processDronologyInput(Utilities.edgeLlaToRiverBank(mapping.getMappedPoints(0)), Utilities.edgeLlaToRiverBank(mapping.getMappedPoints(1)), latitudeBounds);\n\t\tUtilities.verifyInputOrder(bankList.get(0), bankList.get(1));\n\t\tList<IMappedItem> prioritySpots = mapping.getLocationMappings();\n\t\tfor(IMappedItem area : prioritySpots) {\n\t\t\tpriorityAreas.add(Utilities.transformPriorityArea(area, getAverageLatitude()));\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic List<RiverBank> getBankList(){\n\t\treturn bankList;\n\t}\n\t\n\t@Override\n\tpublic Path2D.Double getTotalRiverSegment(){\n\t\treturn totalRiverSegment;\n\t}\n\t\n\t@Override\n\tpublic double getAverageLatitude() {\n\t\treturn Utilities.getAvgLatitude(latitudeBounds.get(0), latitudeBounds.get(1));\n\t}\n\t\n\t/**\n\t * This method uses the GSON library to automatically parse the riverbank JSON file\n\t */\n\tprivate void parseJSON() {\n\t\tGson GSON = new GsonBuilder().enableComplexMapKeySerialization()\n\t\t\t\t.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).serializeSpecialFloatingPointValues()\n\t\t\t\t.create();\n\n\t\ttry {\n\t\t\t// Importing JSON file\n\t\t\tList<String> jsonString = java.nio.file.Files.readAllLines(Paths.get(System.getProperty(\"user.dir\")\n\t\t\t\t\t+ \"/src/edu/nd/dronology/services/extensions/areamapping/json/riverSegment1.json\"));\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (String s : jsonString) {\n\t\t\t\tsb.append(s);\n\t\t\t}\n\t\t\t// Automatic parsing of JSON file with GSON library\n\t\t\tbankMapping = GSON.fromJson(sb.toString(), RiverList.class);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t/*private void parseAreaMapping(AreaMapping mappedRiverSegment) {\n\t\t\n\t}*/\n\t\n\t/**\n\t * This method preprocesses the riverbank nodes to ensure that they are in the necessary order for the route generation algorithms.\n\t * @param bankMapping\n\t * @return river banks in the required order\n\t */\n\tprivate void preprocessRiverBanks(RiverList bankMapping) {\n\t\tbankList = Utilities.makeBankVectors(bankMapping, latitudeBounds);\n\t\tUtilities.verifyInputOrder(bankList.get(0), bankList.get(1));\n\t}\n\t\n\t// Connect to dronology and send search routes to drones\n\t/**\n\t * This method exports the routes to the drones\n\t * @param routes\n\t */\n\tpublic void exportRoutes(List<RoutePrimitive> routes) {\n\t\tfor (int i = 0; i < routes.size(); i++) {\n\t\t\troutes.set(i, Utilities.cartesianRouteToGpsRoute(routes.get(i), Utilities.getAvgLatitude(latitudeBounds.get(0), latitudeBounds.get(1))));\n\t\t}\n\t\ttry {\n\t\t\tIRemoteManager manager = (IRemoteManager) Naming\n\t\t\t\t\t.lookup(String.format(ADDRESS_SCHEME, \"127.0.0.1\", 9779));\n\t\t\tIFlightManagerRemoteService managerService = (IFlightManagerRemoteService) manager\n\t\t\t\t\t.getService(IFlightManagerRemoteService.class);\n\t\t\tList<List<Waypoint>> waypointList = new ArrayList<>();\n\t\t\tfor (RoutePrimitive rlist : routes) {\n\t\t\t\tList<Waypoint> route1 = new ArrayList<>();\n\t\t\t\tfor (Point2D.Double entry : rlist.getRoute()) {\n\t\t\t\t\troute1.add(new Waypoint(new LlaCoordinate(entry.getX(), entry.getY(), 10)));\n\t\t\t\t}\n\t\t\t\twaypointList.add(route1);\n\t\t\t}\n\t\t\tSystem.out.println(\"route1: \" + waypointList.get(0));\n\t\t\tmanagerService.planFlight(\"VRTL0\", \"TestRoute1\", waypointList.get(0));\n\t\t\t//managerService.planFlight(\"VRTL1\", \"TestRoute2\", waypointList.get(1));\n\t\t\t// managerService.planFlight(\"ND-3\", \"TestRoute3\", waypointList.get(2));\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\t\n\t}\n\t\n\t\n\t/**\n\t * This method generates a variety of route primitive options for selection.\n\t * @return route primitives\n\t */\n\t@Override\n\tpublic List<RoutePrimitive> generateRoutePrimitives() {\n\t\t\t// Generate search route primitives\n\t\t\tList<SourcePoints> sourcePoints = new ArrayList<>();\n\t\t\tList<RoutePrimitive> routes = new ArrayList<>();\n\n\t\t\t\n\t\t\t//just for getting home location for drones in metrics runner\n\t\t\tSystem.out.println(bankList.get(0).get(0) + \", \" + bankList.get(0).get(1) + \", \" + bankList.get(0).get(2));\n\t\t\t\n\t\t\t//used for the printout\n\t\t\tVector<RiverSubsegment> riverVectors = new Vector<>();\n\t\t\triverVectors.add(new RiverSubsegment(bankList.get(0),bankList.get(1)));\n\t\t\t\n\t\t\tsourcePoints = Geometry.generateSourcePoints(APERATURE_WIDTH, APERATURE_HEIGHT, OVERLAP_FACTOR, bankList, false);\n\t\t\tSearchPatternStrategy bankRoutes = new RiverBankPrimitive();\n\t\t\tbankRoutes.setSourcePoints(sourcePoints);\n\t\t\tbankRoutes.setRouteType(RouteType.RIVERBANK);\n\t\t\troutes.addAll(bankRoutes.generateRoutePrimitive(APERATURE_HEIGHT, OVERLAP_FACTOR));\n\t\t\tUtilities.debugPrintOut(riverVectors, routes);\n\t\t\t\n\t\t\tSearchPatternStrategy creepingLine = new AdaptedCreepingLinePrimitive();\n\t\t\tcreepingLine.setSourcePoints(sourcePoints);\n\t\t\tcreepingLine.setRouteType(RouteType.CRISSCROSS);\n\t\t\troutes.addAll(creepingLine.generateRoutePrimitive(APERATURE_HEIGHT, OVERLAP_FACTOR));\n\t\t\t\n\t\t\tsourcePoints = Geometry.generateSourcePoints(APERATURE_WIDTH, APERATURE_HEIGHT, OVERLAP_FACTOR, bankList, true);\n\t\t\tSearchPatternStrategy innerCreepingLine = new AdaptedCreepingLinePrimitive();\n\t\t\tinnerCreepingLine.setSourcePoints(sourcePoints);\n\t\t\tinnerCreepingLine.setRouteType(RouteType.INNER_CRISSCROSS);\n\t\t\troutes.addAll(innerCreepingLine.generateRoutePrimitive(APERATURE_HEIGHT, OVERLAP_FACTOR));\n\t\t\t\n\t\t\tUtilities.debugPrintOut(riverVectors, routes);\n\t\t\t\n\t\t\ttotalRiverSegment = Utilities.makeTotalRiverSegment(bankList);\n\n\t\t\t//routes = Utilities.splitRoutePrimitives(routes, dronesNum, APERATURE_HEIGHT, OVERLAP_FACTOR);\n\t\t\tUtilities.debugPrintOut(riverVectors, routes);\n\t\t\t\n\t\t\t\n\t\t\tSearchPatternStrategy priorityArea = new PriorityPolygonPrimitive();\n\t\t\t//priorityArea.generateRoutePrimitive(APERATURE_HEIGHT, OVERLAP_FACTOR);\n\t\t\tpriorityArea.setSourcePoints(priorityAreas);\n\t\t\tpriorityArea.setRouteType(RouteType.PRIORITYAREA);\n\t\t\troutes.addAll(priorityArea.generateRoutePrimitive(APERATURE_HEIGHT, OVERLAP_FACTOR));\n\t\t\tfor(RoutePrimitive routePrimitive : routes) {\n\t\t\t\tSystem.out.println(\"route type: \" + routePrimitive.getRouteType());\n\t\t\t}\n\t\t\treturn routes;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMapRiver runRoute = new MapRiver();\n\t\tList<RoutePrimitive> routes = runRoute.generateRoutePrimitives();\n\t\t//MetricsRunner metricsRunner = new MetricsRunner(routes, runRoute.totalRiverSegment, runRoute.bankList, APERATURE_WIDTH, APERATURE_HEIGHT);\n\t\tlong startTime = System.currentTimeMillis();\n\t\tfor(int i = 0; i < 1; i ++) {\n\t\t\t//metricsRunner.runMetrics();\n\t\t}\n\t\tlong endTime = System.currentTimeMillis();\n\t\tSystem.out.println(\"That took \" + (endTime - startTime) + \" milliseconds\");\n\t\t//runRoute.exportRoutes(routes);\n\t}\n\n}"}, {"id": "ManagedHashTableList.java", "body": "package edu.nd.dronology.core.util;\n\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Hashtable;\nimport java.util.List;\n\n/**\n * \n * Managed Hashtable: stores a key and a list as value -> a query on the hashtable never returns null but an empty list. The list does not need to be created initially\n * \n * \n * @author Michael Vierhauser\n * @param <K>\n *          Key type.\n * @param <V>\n *          Value type.\n * \n */\npublic class ManagedHashTableList<K, V> extends Hashtable<K, List<V>> {\n\n\tprivate static final long serialVersionUID = -5755802656779154509L;\n\n\tpublic synchronized boolean removeAll(K key) {\n\t\tList<V> list = super.get(key);\n\t\tif(list!=null && list.size()>0){\n\t\t\tlist.clear();\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic synchronized List<V> get(Object key) {\n\t\tif (super.get(key) == null) {\n\t\t\treturn Collections.emptyList();\n\t\t} else {\n\t\t\treturn super.get(key);\n\t\t}\n\t}\n\n\tpublic synchronized void add(K hashCode, V elem) {\n\t\tif (super.get(hashCode) == null) {\n\t\t\tList<V> l = new ArrayList<>();\n\t\t\tl.add(elem);\n\t\t\tsuper.put(hashCode, l);\n\t\t} else {\n\t\t\tList<V> l = super.get(hashCode);\n\t\t\tl.add(elem);\n\t\t\t// super.put(hashCode, l);\n\t\t}\n\n\t}\n}\n"}, {"id": "RemoteRMIRemoteObject.java", "body": "package edu.nd.dronology.services.remote.rmi;\n\nimport java.rmi.RemoteException;\nimport java.util.List;\n\nimport edu.nd.dronology.services.core.api.ServiceInfo;\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\nimport edu.nd.dronology.services.core.remote.IRemoteServiceListener;\nimport edu.nd.dronology.services.core.remote.IRemoteableService;\nimport edu.nd.dronology.services.core.remote.RemoteInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.remote.RemoteManager;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class RemoteRMIRemoteObject extends AbstractRMIRemoteObject implements IRemoteManager {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -3719197265334713068L;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(RemoteRMIRemoteObject.class);\n\tprivate static int DEFAULT_PORT = 9779;\n\tprivate static String REG_BINDING = \"Registration\";\n\tprivate static IRemoteManager instance;\n\n\tprotected RemoteRMIRemoteObject(int port) throws RemoteException {\n\t\tsuper(port, \"Remote\");\n\t}\n\n\tprotected RemoteRMIRemoteObject() throws RemoteException {\n\t\tthis(DEFAULT_PORT);\n\t}\n\n\t@Override\n\tpublic void initialize() throws RemoteException {\n\t\tsuper.initialize();\n\t\t// registry.rebind(REG_BINDING,\n\t\t// RegistryServiceRemoteFacade.getInstance());\n\t\t// LOGGER.info(\">> Binding '\" + REG_BINDING + \"' established on port \" +\n\t\t// port);\n\t}\n\n\t@Override\n\tpublic Object getService(Class service) throws RemoteException, DronologyServiceException {\n\t\treturn RemoteManager.getInstance().getService(service);\n\n\t}\n\n\t@Override\n\tpublic void addServiceListener(IRemoteServiceListener processListener) throws RemoteException {\n\t\tRemoteManager.getInstance().addServiceListener(processListener);\n\n\t}\n\n\t@Override\n\tpublic void removeServiceListener(IRemoteServiceListener processListener) throws RemoteException {\n\t\tRemoteManager.getInstance().removeServiceListener(processListener);\n\t}\n\n\t@Override\n\tpublic List<ServiceInfo> getServices() throws RemoteException, DronologyServiceException {\n\t\treturn RemoteManager.getInstance().getServices();\n\t}\n\n\t@Override\n\tpublic List<ServiceInfo> getCoreServices() throws RemoteException, DronologyServiceException {\n\t\treturn RemoteManager.getInstance().getCoreServices();\n\t}\n\n\t@Override\n\tpublic List<ServiceInfo> getAllServices() throws RemoteException, DronologyServiceException {\n\t\treturn RemoteManager.getInstance().getAllServices();\n\t}\n\n\t@Override\n\tpublic List<ServiceInfo> getFileServices() throws RemoteException, DronologyServiceException {\n\t\treturn RemoteManager.getInstance().getFileServices();\n\t}\n\n\t@Override\n\tpublic void register(RemoteInfo rInfo) throws RemoteException {\n\t\tRemoteManager.getInstance().register(rInfo);\n\n\t}\n\n\t@Override\n\tpublic void unregister(RemoteInfo rInfo) throws RemoteException {\n\t\tRemoteManager.getInstance().unregister(rInfo);\n\t}\n\n\t@Override\n\tpublic void tearDown() throws RemoteException, DronologyServiceException {\n\t\ttry {\n\t\t\tsuper.tearDown();\n\t\t\tregistry.unbind(REG_BINDING);\n\t\t\tLOGGER.info(\">> Binding '\" + REG_BINDING + \"' removed on port \" + port);\n\t\t} catch (Exception e) {\n\t\t\tthrow new DronologyServiceException(e.getMessage());\n\t\t}\n\t}\n\n\tpublic static IRemoteManager getInstance(Integer port) {\n\t\tif (instance == null) {\n\t\t\tsynchronized (RemoteRMIRemoteObject.class) {\n\t\t\t\ttry {\n\t\t\t\t\tif (port == null) {\n\t\t\t\t\t\tinstance = new RemoteRMIRemoteObject();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinstance = new RemoteRMIRemoteObject(port);\n\t\t\t\t\t}\n\t\t\t\t} catch (RemoteException e) {\n\t\t\t\t\tLOGGER.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n\n\t@Override\n\tpublic void contributeService(Class service, IRemoteableService serviceInstance)\n\t\t\tthrows RemoteException, DronologyServiceException {\n\t\tRemoteManager.getInstance().contributeService(service,serviceInstance);\n\t\t\n\t}\n\n}\n"}, {"id": "StopExecutor.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal;\n\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.vehicle.IDrone;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\n\npublic class StopExecutor implements CommandExecutor {\n\n    enum StopExecutionState {\n        RADIOING,\n        WATCHING_THE_CLOCK,\n        WAITING_FOREVER,\n        FINISHED;\n    }\n\n    private IDrone drone;\n    StopExecutionState state = StopExecutionState.RADIOING;\n    StopCommand data;\n    long startTime;\n\n    public StopExecutor(IDrone drone, StopCommand data) {\n        this.drone = drone;\n        this.data = data;\n    }\n\n    @Override\n    public void process() {\n        switch (state) {\n            case RADIOING:\n                radioDrone();\n                break;\n\n            case WATCHING_THE_CLOCK:\n                checkClock();\n                break;\n\n            case WAITING_FOREVER:\n            case FINISHED:\n            default:\n                // Do nothing.\n                break;\n        }\n    }\n\n    private void radioDrone() {\n        drone.setVelocity(0.0, 0.0, 0.0);\n\n        double waitDuration = data.getTime();\n        if (waitDuration > 0.0) {\n            startTime = System.nanoTime();\n            state = StopExecutionState.WATCHING_THE_CLOCK;\n        }\n        else {\n            state = StopExecutionState.WAITING_FOREVER;\n        }\n    }\n\n    private void checkClock() {\n        double waitDuration = data.getTime();\n        long deltaNano = System.nanoTime()- startTime;\n        double deltaT = deltaNano * 1.0e-9;\n        if (deltaT > waitDuration) {\n            state = StopExecutionState.FINISHED;\n        }\n    }\n\n    @Override\n    public boolean isFinished() {\n        return state == StopExecutionState.FINISHED;\n    }\n\n}\n"}, {"id": "FlightRoutePersistenceProvider.java", "body": "package edu.nd.dronology.services.core.persistence;\n\nimport edu.nd.dronology.services.core.items.IFlightRoute;\nimport edu.nd.dronology.services.core.persistence.internal.FlightRouteXStreamPersistor;\n\n/**\n * Provider implementation for {@link IFlightRoute}.<br>\n * Details see {@link AbstractItemPersistenceProvider}\n * \n * @author Michael Vierhauser\n *  \n */\npublic class FlightRoutePersistenceProvider extends AbstractItemPersistenceProvider<IFlightRoute> {\n\n\tpublic FlightRoutePersistenceProvider() {\n\t\tsuper();\n\t}\n\n\t@Override\n\tprotected void initPersistor() {\n\t\tPERSISTOR = new FlightRouteXStreamPersistor();\n\n\t}\n\n\t@Override\n\tprotected void initPersistor(String type) {\n\t\tinitPersistor();\n\t}\n\n\tpublic static FlightRoutePersistenceProvider getInstance() {\n\t\treturn new FlightRoutePersistenceProvider();\n\t}\n\n}\n"}, {"id": "UAVRegistrationServiceInstance.java", "body": "package edu.nd.dronology.services.instances.registration.uavs;\n\nimport java.io.File;\nimport java.util.Set;\n\nimport edu.nd.dronology.services.core.api.IFileChangeNotifyable;\nimport edu.nd.dronology.services.core.api.ServiceInfo;\nimport edu.nd.dronology.services.core.base.AbstractFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.info.UAVRegistrationInfo;\nimport edu.nd.dronology.services.core.items.IUAVRegistration;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport edu.nd.dronology.services.core.persistence.UAVRegistrationPersistenceProvider;\nimport edu.nd.dronology.services.core.util.DronologyConstants;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.core.util.ServiceIds;\nimport edu.nd.dronology.services.instances.DronologyElementFactory;\nimport edu.nd.dronology.services.supervisor.SupervisorService;\nimport edu.nd.dronology.util.FileUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class UAVRegistrationServiceInstance extends AbstractFileTransmitServiceInstance<UAVRegistrationInfo>\n\t\timplements IFileChangeNotifyable, IUAVRegistrationServiceInstance {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(UAVRegistrationServiceInstance.class);\n\n\tprivate static final int ORDER = 2;\n\n\tpublic static final String EXTENSION = DronologyConstants.EXTENSION_REGISTRATION;\n\n\tpublic UAVRegistrationServiceInstance() {\n\t\tsuper(ServiceIds.SERVICE_REGISTRATION, \"UAV Rgistration Management\", EXTENSION);\n\t}\n\n\t@Override\n\tprotected Class<?> getServiceClass() {\n\t\treturn UAVRegistrationServiceInstance.class;\n\t}\n\n\t@Override\n\tprotected int getOrder() {\n\t\treturn ORDER;\n\t}\n\n\t@Override\n\tprotected String getPropertyPath() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void doStartService() throws Exception {\n\t\treloadItems();\n\t}\n\n\t@Override\n\tprotected void doStopService() throws Exception {\n\t\tfileManager.tearDown();\n\t}\n\n\t@Override\n\tpublic ServiceInfo getServiceInfo() {\n\t\tServiceInfo sInfo = super.getServiceInfo();\n\t\tsInfo.addAttribute(ServiceInfo.ATTRIBUTE_TYPE, ServiceInfo.ATTRIBUTE_FILE);\n\t\treturn sInfo;\n\t}\n\n\t@Override\n\tpublic UAVRegistrationInfo createItem() throws DronologyServiceException {\n\t\tUAVRegistrationPersistenceProvider persistor = UAVRegistrationPersistenceProvider.getInstance();\n\t\tIUAVRegistration specification = DronologyElementFactory.createNewUAVRegistration();\n\t\tspecification.setName(\"New-DroneSpecification\");\n\t\tString savePath = FileUtil.concat(storagePath, specification.getId(), EXTENSION);\n\n\t\ttry {\n\t\t\tpersistor.saveItem(specification, savePath);\n\t\t} catch (PersistenceException e) {\n\t\t\tthrow new DronologyServiceException(\"Error when creating drone euqipment: \" + e.getMessage());\n\t\t}\n\t\treturn new UAVRegistrationInfo(specification.getName(), specification.getId());\n\t}\n\n\t@Override\n\tprotected String getPath() {\n\t\tString path = SupervisorService.getInstance().getDroneSpecificationLocation();\n\t\treturn path;\n\t}\n\n\t@Override\n\tprotected UAVRegistrationInfo fromFile(String id, File file) throws Throwable {\n\t\tIUAVRegistration atm = UAVRegistrationPersistenceProvider.getInstance().loadItem(file.toURI().toURL());\n\t\tUAVRegistrationInfo info = new UAVRegistrationInfo(atm.getName(), id);\n\t\tinfo.setType(atm.getType());\n\t\treturn info;\n\t}\n\n\t@Override\n\tprotected boolean hasProperties() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void notifyFileChange(Set<String> changed) {\n\t\tfor (String s : changed) {\n\t\t\tupdateItem(s);\n\t\t}\n\t\tsuper.notifyFileChange(changed);\n\t\tfor (String s : changed) {\n\t\t\tString id = s.replace(\".\" + extension, \"\");\n\t\t\tif (!itemmap.containsKey(id)) {\n\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void updateItem(String s) {\n\t\tSystem.out.println(\"UPDATE\");\n\n\t}\n\n}\n"}, {"id": "SimpleSimulator.java", "body": "package edu.nd.dronology.core.simulator.simplesimulator;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.simulator.IFlightSimulator;\nimport edu.nd.dronology.core.vehicle.internal.VirtualDrone;\n\n/**\n * Simple simulator implementation containing a flight simulator and a battery simulator.\n */\npublic class SimpleSimulator implements IFlightSimulator {\n\n\tFlightSimulator flightSimulator; \n\tDroneVoltageSimulator voltageSimulator;\n\n\tpublic SimpleSimulator(VirtualDrone drone) {\n\t\tflightSimulator = new FlightSimulator(drone);\n\t\tvoltageSimulator = new DroneVoltageSimulator();\n\t}\n\n\t@Override\n\tpublic void startBatteryDrain() {\n\t\tvoltageSimulator.startBatteryDrain();\n\n\t}\n\n\t@Override\n\tpublic double getVoltage() {\n\t\treturn voltageSimulator.getVoltage();\n\t}\n\n\t@Override\n\tpublic void setFlightPath(LlaCoordinate currentPosition, LlaCoordinate targetCoordinates) {\n\t\tflightSimulator.setFlightPath(currentPosition, targetCoordinates);\n\n\t}\n\n\t@Override\n\tpublic void checkPoint() {\n\t\tvoltageSimulator.checkPoint();\n\n\t}\n\n\t@Override\n\tpublic boolean isDestinationReached(double distanceMovedPerTimeStep) {\n\t\treturn flightSimulator.isDestinationReached(distanceMovedPerTimeStep);\n\t}\n\n\t@Override\n\tpublic void stopBatteryDrain() {\n\t\tvoltageSimulator.startBatteryDrain();\n\n\t}\n\n\t@Override\n\tpublic boolean move(double step) {\n\t\treturn flightSimulator.move(step);\n\t}\n\n}\n"}, {"id": "SetStateFrequencyCommand.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n\n/**\n * \n * Command sent to the GCS for adjusting the state frequency.<br>\n * The frequency is sent in ms. \n * \n * @author Michael Vierhauser\n */\npublic class SetStateFrequencyCommand extends AbstractDroneCommand implements IDroneCommand {\n\n\tprivate static final long serialVersionUID = -3014662856674586911L;\n\n\tprotected SetStateFrequencyCommand(String droneId, long frequency) {\n\t\tsuper(droneId, CommandIds.SET_STATE_FREQUENCY_COMMAND);\n\t\tdata.put(ATTRIBUTE_FREQUENCY, frequency);\n\t}\n\n}\n"}, {"id": "DronologyListenerManager.java", "body": "package edu.nd.dronology.core.status;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DronologyListenerManager implements IDronologyChangeListener {\n\n\tprivate static final DronologyListenerManager INSTANCE = new DronologyListenerManager();\n\n\tpublic static DronologyListenerManager getInstance() {\n\t\treturn INSTANCE;\n\t}\n\n\tprivate List<IDronologyChangeListener> listeners = new ArrayList<>();\n\n\tpublic void addListener(IDronologyChangeListener listener) {\n\t\tlisteners.add(listener);\n\t}\n\n\t@Override\n\tpublic void notifyUAVRemoved(String uavid) {\n\t\tfor (IDronologyChangeListener l : listeners) {\n\t\t\tl.notifyUAVRemoved(uavid);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void notifyGCSShutdown(String groundstationid) {\n\t\tfor (IDronologyChangeListener l : listeners) {\n\t\t\tl.notifyGCSShutdown(groundstationid);\n\t\t}\n\t}\n\n\tpublic boolean removeListener(IDronologyChangeListener listener) {\n\t\treturn listeners.remove(listener);\n\n\t}\n\n}\n"}, {"id": "EmergencyStopCommand.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n\npublic class EmergencyStopCommand extends AbstractDroneCommand implements IDroneCommand {\n\n\t/**\n\t * \n\t * Command sent to the GCS for stopping immediately and remain hovering in place.\n\t * \n\t * \n\t * @author Michael Vierhauser\n\t */\n\tprivate static final long serialVersionUID = -8748426132223249721L;\n\n\tpublic EmergencyStopCommand(String droneId) {\n\t\tsuper(droneId, CommandIds.STOP_COMMAND);\n\t}\n\n}\n"}, {"id": "FlightRouteCategoryInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\npublic class FlightRouteCategoryInfo extends RemoteInfoObject {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -7327376857430499641L;\n\n\tpublic FlightRouteCategoryInfo(String name, String id) {\n\t\tsuper(name, id);\n\t}\n\n}\n"}, {"id": "IUAVPropertyUpdateNotifier.java", "body": "package edu.nd.dronology.core;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\n\npublic interface IUAVPropertyUpdateNotifier {\n\n\tvoid update(LlaCoordinate location, double batteryLevel, double speed, Vector3D velocity, Vector3D attitude);\n\n\tvoid updateCoordinates(LlaCoordinate location);\n\n\tvoid updateDroneState(String status);\n\n\tvoid updateBatteryLevel(double batteryLevel);\n\n\tvoid updateVelocity(double velocity);\n\n\tvoid updateCollisionAvoidance(LlaCoordinate position, Vector3D velocity, Vector3D attitude);\n\n\tvoid updateMode(String mode);\n\n}\n"}, {"id": "CoordinatedTakeoffPattern.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.patterns;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;\nimport edu.nd.dronology.services.extensions.missionplanning.plan.UAVMissionPlan;\nimport edu.nd.dronology.services.extensions.missionplanning.sync.SyncConstants;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.PatternTask;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.TaskFactory;\nimport edu.nd.dronology.services.extensions.missionplanning.v1.FullMissionPlan;\nimport edu.nd.dronology.util.NullUtil;\n\n/**\n * \n * Predefined pattern for coordinated take-off that is expanded as part of a\n * {@link PatternTask} in a {@link FullMissionPlan}.<br>\n * \n * @author Michael Vierhauser\n *\n */\npublic class CoordinatedTakeoffPattern extends AbstractFlightPattern implements IFlightPattern {\n\n\tCoordinatedTakeoffPattern() {\n\n\t}\n\n\t@Override\n\tpublic void expandFlightPattern(UAVMissionPlan uavMission, LlaCoordinate currentLocation,\n\t\t\tLlaCoordinate targetLocation) throws MissionExecutionException {\n\t\tNullUtil.checkNull(uavMission, currentLocation, targetLocation);\n\n\t\tif (uavMission.getCoordinationAltitude() == 0) {\n\t\t\tuavMission.setCoordinationAltitude(synchPointMgr.getNextAltitude());\n\t\t}\n\n\t\tLlaCoordinate wp1 = new LlaCoordinate(currentLocation.getLatitude(), currentLocation.getLongitude(),\n\t\t\t\tuavMission.getCoordinationAltitude());\n\n\t\tLlaCoordinate wp2 = new LlaCoordinate(targetLocation.getLatitude(), targetLocation.getLongitude(),\n\t\t\t\tuavMission.getCoordinationAltitude());\n\n\t\tLlaCoordinate wp3 = new LlaCoordinate(targetLocation.getLatitude(), targetLocation.getLongitude(),\n\t\t\t\ttargetLocation.getAltitude());\n\n\t\taddTask(TaskFactory.getTask(TaskFactory.TAKEOFF, uavMission.getUavID(), wp1));\n\t\taddTask(TaskFactory.getTask(TaskFactory.SYNC, uavMission.getUavID(), SyncConstants.TAKEOFF_ASC_REACHED));\n\n\t\taddTask(TaskFactory.getTask(TaskFactory.WAYPOINT, uavMission.getUavID(), wp2));\n\t\taddTask(TaskFactory.getTask(TaskFactory.SYNC, uavMission.getUavID(), SyncConstants.TAKEOFF_LATLON_REACHED));\n\n\t\taddTask(TaskFactory.getTask(TaskFactory.WAYPOINT, uavMission.getUavID(), wp3));\n\t\taddTask(TaskFactory.getTask(TaskFactory.SYNC, uavMission.getUavID(), SyncConstants.TAKEOFF_WP_REACHED));\n\n\t}\n\n\t@Override\n\tprotected void doCreateSyncPoints() {\n\t\taddSyncPoint(\"SP-TakeOff-AscentTargetReached\");\n\t\taddSyncPoint(\"SP-TakeOff-LonLatReached\");\n\t\taddSyncPoint(\"SP-TakeOff-FirstWayPointReached\");\n\n\t}\n\n}\n"}, {"id": "MappingInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class MappingInfo implements Serializable {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -1025240228593672234L;\n\n\tString artifactid;\n\tSet<String> mappedElements;\n\t\n\tpublic MappingInfo(String artifactid, Set<String> mappedElements){\n\t\tthis.artifactid = artifactid;\n\t\tthis.mappedElements = new HashSet<>(mappedElements);\n\t}\n\n\tpublic Collection<String> getMappedElementId() {\n\t\treturn Collections.unmodifiableCollection(mappedElements);\n\t}\n\n}\n"}, {"id": "DefaultDroneCollector.java", "body": "package edu.nd.dronology.core.collisionavoidance;\n\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\n\nimport java.util.Collections;\nimport java.util.List;\n\npublic class DefaultDroneCollector implements DroneCollector {\n    @Override\n    public List<ManagedDrone> getManagedDrones() {\n        return Collections.<ManagedDrone>emptyList();\n    }\n}\n"}, {"id": "StopMessage.java", "body": "package edu.nd.dronology.core.collisionavoidance.backendmessage;\n\npublic class StopMessage extends AbstractMessage {\n}\n"}, {"id": "SimpleChecker.java", "body": "package edu.nd.dronology.monitoring.simplechecker.checker;\n\nimport java.rmi.RemoteException;\n\nimport edu.nd.dronology.core.monitoring.ArtifactIdentifier;\nimport edu.nd.dronology.monitoring.service.IDroneMonitoringRemoteService;\nimport edu.nd.dronology.monitoring.simplechecker.BaseServiceProvider;\nimport edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic class SimpleChecker {\n\tprivate static volatile SimpleChecker INSTANCE = null;\n\tBaseServiceProvider provider = new BaseServiceProvider();\n\n\tprivate SimpleChecker() {\n\n\t}\n\n\tpublic static SimpleChecker getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (SimpleChecker.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new SimpleChecker();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\tpublic void init() {\n\n\t\ttry {\n\t\t\tSystem.setProperty(\"java.rmi.server.hostname\", \"localhost\");\n\n\t\t\tIDroneMonitoringRemoteService sevice = (IDroneMonitoringRemoteService) provider.getRemoteManager()\n\t\t\t\t\t.getService(IDroneMonitoringRemoteService.class);\n\n\t\t\t// ArtifactIdentifier id = new ArtifactIdentifier(ArtifactIdentifier.ROOT,\n\t\t\t// \"INTERNAL\");\n\t\t\tArtifactIdentifier id = new ArtifactIdentifier(ArtifactIdentifier.ROOT, \"INTERNAL\");\n\t\t\tArtifactIdentifier id2 = new ArtifactIdentifier(ArtifactIdentifier.ROOT, \"GCS-DEFAULT\");\n\n\t\t\tSimpleCheckerMessageHandler handler = new SimpleCheckerMessageHandler();\n\t\t\tsevice.registerMonitoringMessageHandler(handler, id);\n\t\t\tsevice.registerMonitoringMessageHandler(handler, id2);\n\t\t} catch (Throwable e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic void emergencyStop(String uavid) {\n\t\ttry {\n\t\t\tIFlightManagerRemoteService sevice = (IFlightManagerRemoteService) provider.getRemoteManager()\n\t\t\t\t\t.getService(IFlightManagerRemoteService.class);\n\t\t\tsevice.pauseFlight(uavid);\n\n\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n"}, {"id": "FakePythonGroundstation.java", "body": "package edu.nd.dronology.misc.gcs;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.text.DateFormat;\nimport java.util.Random;\n\nimport org.apache.commons.io.FileUtils;\n\nimport com.google.gson.FieldNamingPolicy;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.gstation.connector.messages.UAVHandshakeMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;\n\npublic class FakePythonGroundstation {\n\n\tprivate static Socket socket;\n\n\tfinal static Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()\n\t\t\t.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)\n\t\t\t.setVersion(1.0).serializeSpecialFloatingPointValues().create();\n\n\tprivate static String STATUS_MESSAGE;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tint port = 1234;\n\t\t\tServerSocket serverSocket = new ServerSocket(port);\n\t\t\t// Server is running always. This is done using this while(true) loop\n\n\t\t\tFile mfile = new File(\"sac\" + File.separator + \"message.txt\");\n\t\t\tSystem.out.println(mfile.getAbsolutePath());\n\t\t\tSTATUS_MESSAGE = FileUtils.readFileToString(mfile);\n\n\t\t\tsocket = serverSocket.accept();\n\t\t\tSystem.out.println(\"Client has connected!\");\n\t\t\tInputStream is = socket.getInputStream();\n\t\t\tInputStreamReader isr = new InputStreamReader(is);\n\t\t\tBufferedReader br = new BufferedReader(isr);\n\n\t\t\tLlaCoordinate cord1 = new LlaCoordinate(41.519200, -86.239127, 0);\n\t\t\tLlaCoordinate cord2 = new LlaCoordinate(41.519400, -86.239527, 0);\n\t\t\tLlaCoordinate cord3 = new LlaCoordinate(41.519600, -86.239927, 0);\n\n\t\t\tUAVHandshakeMessage handshake = new UAVHandshakeMessage(\"FAKE\", \"Drone1\");\n\t\t\thandshake.setHome(cord1);\n\t\t\thandshake.setType(UAVHandshakeMessage.MESSAGE_TYPE);\n\t\t\tFile file = new File(\"sac\" + File.separator + \"sacjson.txt\");\n\t\t\tSystem.out.println(file.getAbsolutePath());\n\t\t\tString sac = FileUtils.readFileToString(file);\n\t\t\thandshake.addPropery(\"safetycase\", sac);\n\n\t\t\tUAVHandshakeMessage handshake2 = new UAVHandshakeMessage(\"FAKE\",  \"Drone2\");\n\t\t\thandshake2.setHome(cord2);\n\t\t\thandshake2.setType(UAVHandshakeMessage.MESSAGE_TYPE);\n\t\t\thandshake2.addPropery(\"safetycase\", sac);\n\n\t\t\tUAVHandshakeMessage handshake3 = new UAVHandshakeMessage(\"FAKE\",  \"Drone3\");\n\t\t\thandshake3.setHome(cord3);\n\t\t\thandshake3.setType(UAVHandshakeMessage.MESSAGE_TYPE);\n\t\t\thandshake3.addPropery(\"safetycase\", sac);\n\n\t\t\tString handshakeString = GSON.toJson(handshake);\n\t\t\tString handshakeString2 = GSON.toJson(handshake2);\n\t\t\tString handshakeString3 = GSON.toJson(handshake3);\n\t\t\tThread.sleep(3000);\n\t\t\tOutputStream os = socket.getOutputStream();\n\t\t\tOutputStreamWriter osw = new OutputStreamWriter(os);\n\t\t\tBufferedWriter bw = new BufferedWriter(osw);\n\t\t\tbw.write(handshakeString);\n\t\t\tbw.write(\"\\n\");\n\t\t\tSystem.out.println(\"Message sent to the client is \" + handshakeString);\n\t\t\tbw.flush();\n\n\t\t\tThread.sleep(1000);\n\t\t\tbw.write(handshakeString2);\n\t\t\tbw.write(\"\\n\");\n\t\t\tSystem.out.println(\"Message sent to the client is \" + handshakeString2);\n\t\t\tbw.flush();\n\n\t\t\tThread.sleep(1000);\n\t\t\tbw.write(handshakeString3);\n\t\t\tbw.write(\"\\n\");\n\t\t\tSystem.out.println(\"Message sent to the client is \" + handshakeString3);\n\t\t\tbw.flush();\n\n\t\t\t// br.readLine();\n\t\t\t// bw.write(\"\\n\");\n\t\t\t// bw.flush();\n\n\t\t\tThread.sleep(500);\n\t\t\tint run = 0;\n\t\t\twhile (true) {\n\t\t\t\tString toSend;\n\t\t\t\tif (run % 5 == 0) {\n\t\t\t\t\ttoSend = sendMonitoringMessage();\n\t\t\t\t} else {\n\t\t\t\t\t// toSend = sendStatusMessage();\n\t\t\t\t\ttoSend = sendMonitoringMessage();\n\t\t\t\t}\n\n\t\t\t\t// if flying mission mlevel > 20%\n\t\t\t\t// if retunr home blvel > 10;\n\n\t\t\t\t// Reading the message from the client\n\n\t\t\t\t// String number = br.readLine();\n\t\t\t\t// System.out.println(\"Message received from client is \" + number);\n\n\t\t\t\t// Multiplying the number by 2 and forming the return message\n\t\t\t\t// String returnMessage;\n\t\t\t\t// try {\n\t\t\t\t// int numberInIntFormat = Integer.parseInt(number);\n\t\t\t\t// int returnValue = numberInIntFormat * 2;\n\t\t\t\t// returnMessage = String.valueOf(returnValue) + \"\\n\";\n\t\t\t\t// } catch (NumberFormatException e) {\n\t\t\t\t// // Input was not a number. Sending proper message back to client.\n\t\t\t\t// returnMessage = \"Please send a proper number\\n\";\n\t\t\t\t// }\n\n\t\t\t\t// Sending the response back to the client.\n\t\t\t\t// OutputStream os = socket.getOutputStream();\n\t\t\t\t// OutputStreamWriter osw = new OutputStreamWriter(os);\n\t\t\t\t// BufferedWriter bw = new BufferedWriter(osw);\n\t\t\t\tbw.write(toSend);\n\t\t\t\tbw.write(\"\\n\");\n\t\t\t\tSystem.out.println(\"Message sent to the client is \" + toSend);\n\t\t\t\tbw.flush();\n\t\t\t\trun++;\n\t\t\t\tThread.sleep(1000);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tprivate static String sendStatusMessage() {\n\n\t\treturn STATUS_MESSAGE;\n\t}\n\n\tprivate static String sendMonitoringMessage() {\n\t\tUAVMonitoringMessage mm = new UAVMonitoringMessage(\"Drone1\",\"FAKE\",  \"Drone1\");\n\t\tRandom rand = new Random();\n\t\tmm.setType(UAVMonitoringMessage.MESSAGE_TYPE);\n\t\t// mm.setuavid(\"DRONE1\");\n\n\t\tmm.addPropery(\"longitude\", \"23\");\n\t\tmm.addPropery(\"velocity\", \"80\");\n\t\tmm.addPropery(\"altitude\", \"50\");\n\t\tmm.addPropery(\"battery_remaining_percentage\", rand.nextInt(10) + 1);\n\t\tmm.addPropery(\"gps_bias\", \"1\");\n\t\t// mm.addPropery(\"max_velocity\", \"60\");\n\t\tString toSend = GSON.toJson(mm);\n\t\treturn toSend;\n\t}\n\n}"}, {"id": "IPersistableItem.java", "body": "package edu.nd.dronology.services.core.items;\n\npublic interface IPersistableItem {\n\n\tString getId();\n\n\tString getName();\n\n\tvoid setName(String string);\n\t\n}\n"}, {"id": "UAVRegistrationInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\npublic class UAVRegistrationInfo extends RemoteInfoObject {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 2844123024068335148L;\n\tprivate String type = \"Default\";\n\n\tpublic UAVRegistrationInfo(String name, String id) {\n\t\tsuper(name, id);\n\t}\n\n\tpublic String getType() {\n\t\treturn type;\n\t}\n\n\tpublic void setType(String type) {\n\t\tthis.type = type;\n\n\t}\n\n}\n"}, {"id": "GroundstationConnector.java", "body": "package edu.nd.dronology.gstation.connector;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.net.Socket;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport edu.nd.dronology.core.IUAVPropertyUpdateNotifier;\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.fleet.RuntimeDroneTypes;\nimport edu.nd.dronology.core.monitoring.DronologyMonitoringManager;\nimport edu.nd.dronology.core.monitoring.MessageMarshaller;\nimport edu.nd.dronology.core.status.DronologyListenerManager;\nimport edu.nd.dronology.core.vehicle.IDroneCommandHandler;\nimport edu.nd.dronology.core.vehicle.commands.ConnectionResponseCommand;\nimport edu.nd.dronology.core.vehicle.commands.IDroneCommand;\nimport edu.nd.dronology.gstation.connector.connect.IncommingGroundstationConnectionServer;\nimport edu.nd.dronology.gstation.connector.dispatch.DispatchQueueManager;\nimport edu.nd.dronology.gstation.connector.dispatch.ReadDispatcher;\nimport edu.nd.dronology.gstation.connector.dispatch.WriteDispatcher;\nimport edu.nd.dronology.gstation.connector.messages.AbstractUAVMessage;\nimport edu.nd.dronology.gstation.connector.messages.ConnectionRequestMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVMessageFactory;\nimport edu.nd.dronology.gstation.connector.service.connector.DroneConnectorService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.util.NamedThreadFactory;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Establishes new, and handles established connections between Dronology and\n * multiple GCS.<br>\n * Creates new {@link ReadDispatcher} and {@link WriteDispatcher} threads when a\n * connection to a new GCS is established.\n * \n * @author Michael Vierhauser\n *\n */\npublic class GroundstationConnector implements IDroneCommandHandler, Runnable {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(GroundstationConnector.class);\n\n\tprotected static final ExecutorService EXECUTOR = Executors.newFixedThreadPool(10,\n\t\t\tnew NamedThreadFactory(\"Groundstation-Threads\"));\n\n\t// socket for communication with python ground station\n\tprivate Socket socket;\n\tprivate final Map<String, IUAVPropertyUpdateNotifier> registeredListeners = new ConcurrentHashMap<>();\n\tprivate ReadDispatcher readDispatcher;\n\tprivate WriteDispatcher writeDispatcher;\n\tprivate String groundstationid;\n\tprivate DispatchQueueManager dispatchQueueManager;\n\tprivate boolean connected;\n\tprivate IncommingGroundstationConnectionServer server;\n\n\tpublic GroundstationConnector(IncommingGroundstationConnectionServer server, Socket socket) {\n\n\t\tthis.connected = false;\n\t\tthis.server = server;\n\t\tthis.socket = socket;\n\t}\n\n\t@Override\n\tpublic void sendCommand(IDroneCommand cmd) throws DroneException {\n\t\tLOGGER.trace(groundstationid + \" Sending Command to UAV \" + cmd.toString());\n\t\tdispatchQueueManager.send(cmd);\n\t\tDronologyMonitoringManager.getInstance().publish(MessageMarshaller.createMessage(cmd));\n\t}\n\n\t@Override\n\tpublic void setStatusCallbackNotifier(String id, IUAVPropertyUpdateNotifier listener) throws DroneException {\n\t\tif (registeredListeners.containsKey(id)) {\n\t\t\tthrow new DroneException(\"An listener with '\" + id + \"' is already registered\");\n\t\t}\n\t\tregisteredListeners.put(id, listener);\n\t\tdispatchQueueManager.createDispatchThread(id, listener);\n\t}\n\n\tpublic void tearDown() {\n\t\ttry {\n\t\t\treadDispatcher.tearDown();\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t\ttry {\n\t\t\twriteDispatcher.tearDown();\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t\ttry {\n\t\t\tdispatchQueueManager.tearDown();\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\n\t\tDronologyListenerManager.getInstance().notifyGCSShutdown(groundstationid);\n\n\t}\n\n\t@Override\n\tpublic String getHandlerId() {\n\t\treturn groundstationid;\n\t}\n\n\tpublic void registerSafetyValidator(IUAVSafetyValidator validator) {\n\t\tdispatchQueueManager.registerSafetyValidator(validator);\n\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tLOGGER.info(\"GroundstationConnector started\");\n\t\tBufferedReader reader;\n\t\ttry {\n\t\t\treader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n\t\t\tString line = reader.readLine();\n\t\t\tAbstractUAVMessage msg = UAVMessageFactory.create(line);\n\t\t\tif (!(msg instanceof ConnectionRequestMessage)) {\n\t\t\t\tLOGGER.hwFatal(\"Invalid Connection Request from groundstation! \" + line);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tboolean connectionSuccess = false;\n\t\t\ttry {\n\t\t\t\tDroneConnectorService.getInstance().registerConnection(this, (ConnectionRequestMessage) msg);\n\t\t\t\tthis.groundstationid = msg.getGCSId();\n\t\t\t\tsetupConnection();\n\t\t\t\tconnectionSuccess = true;\n\t\t\t} catch (GroundStationException ex) {\n\t\t\t\tLOGGER.hwFatal(ex.getMessage());\n\t\t\t}\n\t\t\tBufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n\t\t\tConnectionResponseCommand ackCommand = new ConnectionResponseCommand(groundstationid, connectionSuccess);\n\t\t\twriter.write(ackCommand.toJsonString());\n\t\t\twriter.write(System.lineSeparator());\n\t\t\twriter.flush();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tLOGGER.hwFatal(\"Error when establishing connection to groundstation \" + e.getMessage());\n\t\t}\n\n\t}\n\n\tprivate void setupConnection() {\n\t\ttry {\n\t\t\tdispatchQueueManager = new DispatchQueueManager(groundstationid);\n\n\t\t\treadDispatcher = new ReadDispatcher(socket, dispatchQueueManager);\n\t\t\twriteDispatcher = new WriteDispatcher(socket, dispatchQueueManager.getOutgoingCommandQueue());\n\t\t\tEXECUTOR.submit(readDispatcher);\n\t\t\tEXECUTOR.submit(writeDispatcher);\n\t\t\tRuntimeDroneTypes.getInstance().registerCommandHandler(this);\n\t\t\tconnected = true;\n\t\t} catch (Throwable e) {\n\t\t\tLOGGER.hwFatal(\"Can't connect to Python Groundstation \" + e.getMessage());\n\t\t}\n\t}\n\n\tprivate void scheduleReconnect() {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"}, {"id": "IFileChangeNotifyable.java", "body": "package edu.nd.dronology.services.core.api;\n\nimport java.util.Set;\n\n/**\n * Interface for being notified on changing objects on the server.\n * @author Michael Vierhauser\n *\n */\npublic interface IFileChangeNotifyable {\n\n/**\n * \n * @param changed The set of changed item names.\n */\n\tvoid notifyFileChange(Set<String> changed);\n\n}\n"}, {"id": "IExecuteableMissionPlan.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.plan;\n\nimport edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;\n\npublic interface IExecuteableMissionPlan {\n\n\tboolean isMissionActive();\n\n\tvoid checkAndActivateTask() throws MissionExecutionException;\n\n\tvoid cancelMission();\n\n}\n"}, {"id": "InfoNotification.java", "body": "package edu.nd.dronology.services.core.message;\n\npublic class InfoNotification {\n\n\t\n\t//message\n\t//severity warning/info/error\n\t//type \"battery\"\n\t// infrastrucuture... \n}\n"}, {"id": "IAreaMappingRemoteService.java", "body": "package edu.nd.dronology.services.core.remote;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.areamapping.GeneratedMappedArea;\nimport edu.nd.dronology.services.core.info.AreaMappingCategoryInfo;\nimport edu.nd.dronology.services.core.info.AreaMappingInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n/**\n * \n * @author Michael Vierhauser\n * \n */\npublic interface IAreaMappingRemoteService extends IRemoteableService, IFileTransmitRemoteService<AreaMappingInfo> {\n\n\tCollection<AreaMappingCategoryInfo> getMappingPathCategories() throws RemoteException;\n\n\tGeneratedMappedArea generateAreaMapping(AreaMappingInfo info) throws DronologyServiceException, RemoteException;\n\n\tvoid executeAreaMapping(GeneratedMappedArea info) throws DronologyServiceException, RemoteException;\n\n\tGeneratedMappedArea generateAreaMapping(AreaMappingInfo info, Collection<IUAVProxy> selectedUAVs)\n\t\t\tthrows DronologyServiceException, RemoteException;\n\n}\n"}, {"id": "AFMapDrones.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport com.vaadin.ui.Button;\nimport com.vaadin.ui.ComboBox;\nimport com.vaadin.ui.HorizontalLayout;\nimport com.vaadin.ui.Notification;\nimport com.vaadin.ui.Notification.Type;\nimport com.vaadin.ui.UI;\nimport com.vaadin.ui.VerticalLayout;\nimport com.vaadin.ui.Window;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.info.MissionInfo;\nimport edu.nd.dronology.services.core.info.UAVMappingInfo;\nimport edu.nd.dronology.services.core.items.IUAVMissionDescription;\nimport edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;\nimport edu.nd.dronology.services.core.remote.IMissionPlanningRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;\nimport edu.nd.dronology.ui.vaadin.start.MyUI;\n\n/*\n * This class produces a window that is used to map the drones in a mission to the drones available in active flights\n * \n * @author Jack Hill\n */\npublic class AFMapDrones extends Window {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -8656528814008366370L;\n\t\n\tprivate Map<String, String> droneMapping = new HashMap<String, String>();\n\tprivate VerticalLayout totalLayout = new VerticalLayout();\n\tprivate VerticalLayout leftMappingLayout = new VerticalLayout();\n\tprivate VerticalLayout rightMappingLayout = new VerticalLayout();\n\tprivate HorizontalLayout mappingLayout = new HorizontalLayout();\n\tprivate Collection<IUAVProxy> drones;\n\tprivate IDroneSetupRemoteService service;\n\tprivate BaseServiceProvider provider = MyUI.getProvider();\n\tprivate ArrayList<String> droneList = new ArrayList<>();\n\tprivate ArrayList<String> comboList = new ArrayList<>();\n\tprivate ArrayList<ComboBox<String>> allBoxes = new ArrayList<>();\n\tprivate UAVMappingInfo mappingInfo = new UAVMappingInfo();\n\n\tpublic AFMapDrones(List<IUAVMissionDescription> mission, MissionInfo missionInfo) {\n\t\t// pulls all of the active drones from dronology\n\t\ttry {\n\t\t\tservice = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);\n\t\t\tCollection<IUAVProxy> activeDrones = service.getActiveUAVs();\n\t\t\tdrones = new ArrayList<>(activeDrones);\n\t\t} catch (DronologyServiceException | RemoteException e1) {\n\t\t\tMyUI.setConnected(false);\n\t\t}\n\t\t\n\t\t// create two lists of all the drone name, one that will stay full and one that will be used in the combo boxes and decremented\n\t\t// whenever an active UAV is assigned to a mission UAV\n\t\tfor (IUAVProxy drone : drones) {\n\t\t\tcomboList.add(drone.getID());\n\t\t\tdroneList.add(drone.getID());\n\t\t}\n\t\tCollections.sort(comboList);\n\t\tCollections.sort(droneList);\n\t\t\n\t\t// create a combo box for each UAV in the mission\n\t\tint numDrones = mission.size();\n\t\tint index = 0;\n\t\tfor (IUAVMissionDescription uav : mission) {\n\t\t\tComboBox<String> uavMap = new ComboBox<>(uav.getName());\n\t\t\tuavMap.setItems(comboList);\n\t\t\t// add the pair to a mapping once an active UAV is assigned to a mission UAV\n\t\t\tuavMap.addValueChangeListener(e -> {\n\t\t\t\tdroneMapping.put(uavMap.getCaption(), uavMap.getValue());\n\t\t\t\tuavMap.setId(uavMap.getValue());\n\t\t\t\trefreshBoxes();\n\t\t\t});\n\t\t\t\n\t\t\tallBoxes.add(uavMap);\n\t\t\tif (numDrones > 5) {\n\t\t\t\t//Notification.show(\"HERE0\", Type.ERROR_MESSAGE);\n\t\t\t\t//Notification.show(\"index: \" + index, Type.ERROR_MESSAGE);\n\t\t\t\tif (index < (numDrones + 1)/2) {\n\t\t\t\t\tleftMappingLayout.addComponent(uavMap);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trightMappingLayout.addComponent(uavMap);\n\t\t\t\t\t//Notification.show(\"HERE1\", Type.ERROR_MESSAGE);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleftMappingLayout.addComponent(uavMap);\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\t\n\t\t// make a list with all the names of the active uavs\n\t\tArrayList<String> activeDroneNames = new ArrayList<>();\n\t\tfor (IUAVProxy drone : drones) {\n\t\t\tactiveDroneNames.add(drone.getID());\n\t\t}\n\t\t\n\t\t// match any uav that has the same name in the mission plan and active uav panel\n\t\tfor (IUAVMissionDescription uav : mission) {\n\t\t\tif (activeDroneNames.contains(uav.getName())) {\n\t\t\t\tdroneMapping.put(uav.getName(), uav.getName());\n\t\t\t\tactiveDroneNames.remove(uav.getName());\n\t\t\t\tfor (ComboBox<String> comboBox : allBoxes) {\n\t\t\t\t\tif (comboBox.getCaption().equals(uav.getName())) {\n\t\t\t\t\t\tcomboBox.setValue(uav.getName());\n\t\t\t\t\t\tcomboBox.setId(uav.getName());\n\t\t\t\t\t\trefreshBoxes();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tButton execute = new Button(\"Execute\");\n\t\texecute.addStyleName(\"btn-okay\");\n\t\tButton cancel = new Button(\"Cancel\");\n\t\tHorizontalLayout buttons = new HorizontalLayout();\n\t\tbuttons.addComponents(cancel, execute);\n\t\t\n\t\t// execute the mission with the current mapping\n\t\texecute.addClickListener(e -> {\n\t\t\t// canClose will be set to false if the user has not assigned every UAV in the mission to an active UAV\n\t\t\tboolean canClose = true;\n\t\t\tfor (ComboBox<String> box : allBoxes) {\n\t\t\t\tif (box.getId() == null) {\n\t\t\t\t\tcanClose = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (canClose) {\n\t\t\t\t// create the map object that will be used to execute the mission\n\t\t\t\tfor (Map.Entry<String, String> entry : droneMapping.entrySet()) {\n\t\t\t\t    String key = entry.getKey();\n\t\t\t\t    String value = entry.getValue();\n\t\t\t\t    mappingInfo.addAttribute(key, value);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// use service to execute the mission with the mapping\n\t\t\t\tIMissionPlanningRemoteService service = null;\n\t\t\t\ttry {\n\t\t\t\t\tservice = (IMissionPlanningRemoteService) provider.getRemoteManager().getService(IMissionPlanningRemoteService.class);\n\t\t\t\t}\n\t\t\t\tcatch (DronologyServiceException | RemoteException e1) {\n\t\t\t\t\te1.printStackTrace();\n\t\t\t\t\tMyUI.setConnected(false);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tservice.executeMissionPlan(missionInfo, mappingInfo);\n\t\t\t\t} catch (RemoteException | DronologyServiceException e1) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te1.printStackTrace();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tUI.getCurrent().removeWindow(this);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tNotification.show(\"You must assign an active UAV for each drone in the mission.\", Type.ERROR_MESSAGE);\n\t\t\t}\n\t\t});\n\t\t\n\t\t// cancel and return to the active flights tab\n\t\tcancel.addClickListener(e -> {\n\t\t\tUI.getCurrent().removeWindow(this);\n\t\t});\n\t\t\n\t\tmappingLayout.addComponent(leftMappingLayout);\n\t\tif (numDrones > 5) {\n\t\t\tmappingLayout.addComponent(rightMappingLayout);\n\t\t}\n\t\ttotalLayout.addComponents(mappingLayout, buttons);\n\t\t\n\t\tthis.setContent(totalLayout);\n\t\tthis.setResizable(false);\n\t\tthis.setClosable(false);\n\t\tthis.setModal(true);\n\t\tthis.center();\n\t}\n\t\n\t// only show the remaining active UAVs in the combo boxes so that a user does not try and assign one active UAV to multiple UAVs in the mission\n\tpublic void refreshBoxes() {\n\t\tfor (String name : droneList) {\n\t\t\tif (!comboList.contains(name)) {\n\t\t\t\tcomboList.add(name);\n\t\t\t}\n\t\t}\n\t\tCollections.sort(comboList);\n\t\tfor (ComboBox<String> box : allBoxes) {\n\t\t\tif (box.getId() != null) {\n\t\t\t\tcomboList.remove(box.getId());\n\t\t\t}\n\t\t\tbox.setItems(comboList);\n\t\t}\n\t}\n}\n"}, {"id": "IAreaMappingServiceInstance.java", "body": "package edu.nd.dronology.services.extensions.areamapping.instances;\n\nimport java.util.Collection;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.areamapping.GeneratedMappedArea;\nimport edu.nd.dronology.services.core.info.AreaMappingCategoryInfo;\nimport edu.nd.dronology.services.core.info.AreaMappingInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic interface IAreaMappingServiceInstance extends IFileTransmitServiceInstance<AreaMappingInfo> {\n\n\tCollection<AreaMappingCategoryInfo> getMappingPathCategories();\n\n\tAreaMappingInfo getMappingByName(String mappingName) throws DronologyServiceException;\n\n\tGeneratedMappedArea generateAreaMapping(AreaMappingInfo info) throws DronologyServiceException;\n\n\tvoid executeAreaMapping(GeneratedMappedArea area) throws DronologyServiceException;\n\n\tGeneratedMappedArea generateAreaMapping(AreaMappingInfo info, Collection<IUAVProxy> selectedUAVs)\n\t\t\tthrows DronologyServiceException;\n\n}\n"}, {"id": "AFControlsComponent.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.VerticalLayout;\n\n/**\n * This is the control panel framework for the Activated Flights UI\n * \n * @author Jinghui Cheng\n */\npublic class AFControlsComponent extends CustomComponent {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate AFInfoPanel info = new AFInfoPanel();\n\tpublic AFControlsComponent() {\n\t\tthis.setWidth(\"100%\");\n\t\taddStyleName(\"controls_component\");\n\t\t\n\t\tVerticalLayout content = new VerticalLayout();\n\n\t\tcontent.addComponent(info);\n\t\tsetCompositionRoot(content);\n\t}\n\t\n\tpublic AFInfoPanel getPanel(){\n\t\treturn info;\n\t}\n\t\n}\n"}, {"id": "DronologyPersistenceUtil.java", "body": "package edu.nd.dronology.services.core.persistence;\n\nimport com.thoughtworks.xstream.XStream;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.services.core.items.UAVRegistration;\nimport edu.nd.dronology.services.core.items.FlightRoute;\n\npublic class DronologyPersistenceUtil {\n\n\tprivate static final String ROUTE_ALIAS = \"FlightRoute\";\n\tprivate static final String COORDINATE_ALIAS = \"Coordinate\";\n\tprivate static final String SPEC_ALIAS = \"UAVSpecification\";\n\tprivate static final String WAYPOINT_ALIAS = \"Waypoint\";\n\t\n\tpublic static void preprocessStream(XStream xstream) {\n\n\t\txstream.alias(ROUTE_ALIAS, FlightRoute.class);\n\t\txstream.alias(COORDINATE_ALIAS, LlaCoordinate.class);\n\t\txstream.alias(WAYPOINT_ALIAS, Waypoint.class);\n\t\t\n\t\txstream.alias(SPEC_ALIAS, UAVRegistration.class);\n\n\t}\n\n}\n"}, {"id": "FollowTheLeaderWaypoint.java", "body": "package edu.nd.dronology.core.collisionavoidance.strategy;\n\nimport java.util.ArrayList;\n\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\nimport edu.nd.dronology.core.collisionavoidance.CollisionAvoider;\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.goal.WaypointGoalSnapshot;\n\npublic class FollowTheLeaderWaypoint implements CollisionAvoider {\n\n    private final Vector3D nedOffset;\n    private final double defaultSpeed = 5.0;\n\n    public FollowTheLeaderWaypoint(Vector3D nedOffset) {\n        this.nedOffset = nedOffset;\n    }\n\n    public FollowTheLeaderWaypoint(double north, double east, double down) {\n        this(new Vector3D(north, east, down));\n    }\n\n\t@Override\n\tpublic void avoid(ArrayList<DroneSnapshot> drones) {\n        DroneSnapshot leader = FollowTheLeaderNed.findLeader(drones);\n        DroneSnapshot follower = FollowTheLeaderNed.findFollower(drones);\n\n        if (leader != null) {\n            double followSpeed = defaultSpeed;\n            WaypointGoalSnapshot wp = StopEveryone.findActiveWaypointGoal(leader.getGoals());\n            if (wp != null) {\n                StopEveryone.flyToGoalIfNotAlready(leader, wp);\n                followSpeed = wp.getSpeed();\n            }\n\n            if (follower != null) {\n                LlaCoordinate followerWaypoint = leader.getPosition().findLla(this.nedOffset);\n                follower.getCommands().clear();\n                follower.getCommands().add(new WaypointCommand(followerWaypoint, followSpeed));\n            }\n        } else if (follower != null) {\n            WaypointGoalSnapshot wp = StopEveryone.findActiveWaypointGoal(follower.getGoals());\n            if (wp != null) {\n                StopEveryone.flyToGoalIfNotAlready(follower, wp);\n            }   \n        }\n\t}\n\n}"}, {"id": "RemoteInfoObject.java", "body": "package edu.nd.dronology.services.core.info;\n\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport edu.nd.dronology.services.core.api.IRemoteInfoObject;\n\nimport java.util.Set;\nimport java.util.TreeMap;\n\n/**\n * \n * Abstract base class for all info objects.\n * \n * @author Michael Vierhauser\n * \n */\npublic abstract class RemoteInfoObject implements IRemoteInfoObject {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -1610958467030762516L;\n\tprivate String name;\n\tprivate String id;\n\tprivate Map<String, String> attributes = new TreeMap<>();\n\n\t/**\n\t * @param name\n\t *          The name of the object; must not be null.\n\t * @param id\n\t *          The unique id of the object; must not be null.\n\t */\n\tpublic RemoteInfoObject(String name, String id) {\n\t\tif (name == null || id == null) {\n\t\t\tthrow new IllegalArgumentException(\"Parameter must not be null!\");\n\t\t}\n\t\tthis.name = name;\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic Set<Entry<String, String>> getAttributes() {\n\t\treturn attributes.entrySet();\n\t}\n\n\t@Override\n\tpublic void addAttribute(String key, String value) {\n\t\tif (key == null || value == null) {\n\t\t\tthrow new IllegalArgumentException(\"Parameter must not be null!\");\n\t\t}\n\t\tattributes.put(key, value);\n\t}\n\n\t@Override\n\tpublic String getAttribute(String key) {\n\t\tif (key == null) {\n\t\t\tthrow new IllegalArgumentException(\"Parameter must not be null!\");\n\t\t}\n\t\tif (attributes.containsKey(key)) {\n\t\t\treturn attributes.get(key);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((id == null) ? 0 : id.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tRemoteInfoObject other = (RemoteInfoObject) obj;\n\t\tif (id == null) {\n\t\t\tif (other.id != null)\n\t\t\t\treturn false;\n\t\t} else if (!id.equals(other.id))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t\n\t\n\t@Override\n\tpublic int compareTo(IRemoteInfoObject o) {\n\t\treturn this.id.compareTo(o.getId());\n\t}\n\n}\n"}, {"id": "FlightInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class FlightInfo extends RemoteInfoObject {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 256865471183839829L;\n\tprivate FlightPlanInfo currentFlight = null;\n\tprivate List<FlightPlanInfo> pending = Collections.emptyList();\n\tprivate List<FlightPlanInfo> completed = Collections.emptyList();\n\n\tpublic FlightInfo(String name, String id) {\n\t\tsuper(name, id);\n\t\tpending = new ArrayList<>();\n\t\tcompleted = new ArrayList<>();\n\t}\n\n\tpublic void setCurrentFlight(FlightPlanInfo currentFlight) {\n\t\tthis.currentFlight = currentFlight;\n\t}\n\n\tpublic FlightPlanInfo getCurrentFlights() {\n\t\treturn currentFlight;\n\t}\n\n\tpublic List<FlightPlanInfo> getPendingFlights() {\n\t\treturn pending;\n\t}\n\n\tpublic List<FlightPlanInfo> getCompletedFlights() {\n\t\treturn completed;\n\t}\n\n\tpublic void addPending(FlightPlanInfo planInfo) {\n\t\tpending.add(planInfo);\n\n\t}\n\n\tpublic void addCompleted(FlightPlanInfo planInfo) {\n\t\tcompleted.add(planInfo);\n\n\t}\n\n\n}\n"}, {"id": "PhysicalDroneUpdateMessage.java", "body": "package edu.nd.dronology.core.collisionavoidance.backendmessage;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\npublic class PhysicalDroneUpdateMessage extends AbstractMessage {\n    public String name;\n    public final LlaCoordinate position;\n    public final Vector3D velocity;\n    public final Vector3D attitude;\n    public PhysicalDroneUpdateMessage(String name, LlaCoordinate position, Vector3D velocity, Vector3D attitude) {\n        this.name = name;\n        this.position = position;\n        this.velocity = velocity;\n        this.attitude = attitude;\n    }\n}\n"}, {"id": "RuntimeDroneTypes.java", "body": "package edu.nd.dronology.core.fleet;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.exceptions.FlightZoneException;\nimport edu.nd.dronology.core.vehicle.IDroneCommandHandler;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * This is a SINGLETON class. To get an instance call getInstance() Sets the runtime mode of FlightZone either as SIMULATION or PHYSICAL The mode may only be set one time during execution. Simulation\n * uses soft drone objects. Physical uses real drones controlled using Dronekit API.\n * \n * @author Jane Cleland-Huang \n *\n */\npublic class RuntimeDroneTypes {\n\tprivate enum Mode {\n\t\tSIMULATION, PHYSICAL\n\t}\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(RuntimeDroneTypes.class);\n\n\tprivate Mode currentMode;\n\n\tMap<String, IDroneCommandHandler> commandHandlers = new ConcurrentHashMap<>();\n\tprivate static volatile RuntimeDroneTypes INSTANCE = null;\n\n\tprotected RuntimeDroneTypes() {\n\t}\n\n\tpublic static RuntimeDroneTypes getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (RuntimeDroneTypes.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new RuntimeDroneTypes();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t/**\n\t * Sets flightmode to SIMULATION. Does not allow the flight mode to be reset after it is initially set.\n\t * \n\t * @throws FlightZoneException\n\t */\n\tpublic void setVirtualEnvironment() throws FlightZoneException {\n\t\tif (currentMode == null) {\n\t\t\tcurrentMode = Mode.SIMULATION;\n\t\t} else if (currentMode == Mode.PHYSICAL) {\n\t\t\t// Do nothing\n\t\t} else\n\t\t\tthrow new FlightZoneException(\n\t\t\t\t\t\"Flight mode has already been set to PHYSICAL.  You may not reset to SIMULATION runtime.\");\n\t}\n\n\t/**\n\t * Sets flightmode to PHYSICAL Does not allow the flight mode to be reset after it is initially set.\n\t * \n\t * @throws FlightZoneException\n\t */\n\tpublic void setPhysicalEnvironment() throws FlightZoneException {\n\t\tif (currentMode == null) {\n\t\t\tcurrentMode = Mode.PHYSICAL;\n\t\t} else if (currentMode == Mode.SIMULATION) {\n\t\t\t// Do nothing\n\t\t} else\n\t\t\tthrow new FlightZoneException(\n\t\t\t\t\t\"Flight mode has already been set to SIMULATION.  You may not reset to PHYSICAL runtime.\");\n\t}\n\n\t/**\n\t * \n\t * @return true if in SIMULATION mode. False otherwise.\n\t */\n\tpublic boolean isSimulation() {\n\t\treturn currentMode == Mode.SIMULATION;\n\t}\n\n\t/**\n\t * \n\t * @return true if in PHYSICAL mode. False otherwise.\n\t */\n\tpublic boolean isPhysical() {\n\t\treturn currentMode == Mode.PHYSICAL;\n\t}\n\n\tpublic void registerCommandHandler(IDroneCommandHandler commandHandler) throws DroneException {\n\t\tString handlerId = commandHandler.getHandlerId();\n\t\tLOGGER.info(\"Drone command handler added '\" + handlerId + \"' - \" + commandHandler.getClass());\n\t\tif (commandHandlers.containsKey(handlerId)) {\n\t\t\tthrow new DroneException(\"CommandHandler with id '\" + handlerId + \"' already registered\");\n\t\t}\n\t\tcommandHandlers.put(handlerId, commandHandler);\n\t}\n\n\tpublic IDroneCommandHandler getCommandHandler(String handlerId) throws DroneException {\n\t\tif (!commandHandlers.containsKey(handlerId)) {\n\t\t\tthrow new DroneException(\"CommandHandler with id '\" + handlerId + \"' not registered\");\n\t\t}\n\t\treturn commandHandlers.get(handlerId);\n\t}\n\n\tpublic void unregisterCommandHandler(String handlerId) throws DroneException {\n\t\t// String handlerId = commandHandler.getHandlerId();\n\t\t// LOGGER.info(\"Drone command handler added '\" + handlerId + \"' - \" + commandHandler.getClass());\n\t\tif (!commandHandlers.containsKey(handlerId)) {\n\t\t\tthrow new DroneException(\"CommandHandler with id '\" + handlerId + \"' not registered\");\n\t\t}\n\t\tcommandHandlers.remove(handlerId);\n\t\tLOGGER.info(\"Drone command handler removed '\" + handlerId);\n\t}\n}\n"}, {"id": "ISimulatorScenario.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.util.List;\n\npublic interface ISimulatorScenario extends IPersistableItem {\n\t\n\tString getDescription();\n\n\tvoid setDescription(String description);\n\n\tString getCategory();\n\n\tvoid setCategory(String category);\n\t\n\t\n\tList<AssignedDrone> getAssignedDrones();\n\tList<String> getAssignedFlightPaths();\n\n\tboolean removeAssignedDrone(String droneId);\n\n\tboolean removeAssignedPath(String pathId);\n\n\tboolean addAssignedPath(String pathId);\n\n\tboolean addAssignedDrone(String droneId);\n\t\n}\n"}, {"id": "PVector.java", "body": "package edu.nd.dronology.core.coordinate;\n\n/**\n * A position on Earth, represented as an X, Y and Z coordinate in an\n * Earth centered Earth fixed reference frame.\n *\n * The origin of this frame is at the center of mass of the Earth. The X-axis\n * points towards where the equator meets the prime meridean (latitude 0,\n * longitude 0). The Z-axis points towards the geographic north pole (latitude\n * 90, longitude undefined). The Y-axis can be derived using right hand rule and\n * points towards latitude 0, longitude 90. All units are in meters.\n * \n * @author Michael Murphy \n * \n */ \npublic class PVector  extends AbstractPosition {\n\tprivate double x;\n\tprivate double y;\n\tprivate double z;\n\n\t/**\n\t * @param x\n\t *            the distance in meters along the axis that points from the\n\t *            center of mass of the Earth towards where the equator meets\n\t *            the prime meridean (latitude 0, longitude 0)\n\t * @param y\n\t *            the distance in meters along the axis that points from the\n\t *            center of mass of the Earth towards latitude 0, longitude 90\n\t * @param z\n\t *            the distance in meters along the axis that points from the\n\t *            center of mass of the Earth towards the geographic north pole\n\t *            (latitude 90, longitude undefined)\n\t */\n\tpublic PVector(double x, double y, double z) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t}\n\n\t/**\n\t * @return the x\n\t */\n\tpublic double getX() {\n\t\treturn x;\n\t}\n\n\t/**\n\t * @return the y\n\t */\n\tpublic double getY() {\n\t\treturn y;\n\t}\n\n\t/**\n\t * @return the z\n\t */\n\tpublic double getZ() {\n\t\treturn z;\n\t}\n\n\t/**\n\t * @return the n-vector plus altitude for this position\n\t */\n\t@Override\n\tpublic NVector toNVector() {\n\t\t/*\n\t\t * The formula this code is based on can be found in a journal article\n\t\t * called: \"A Non-singular Horizontal Position Representation\" by\n\t\t * Kenneth Gade. You can find it at https://goo.gl/iCqdCn (see equation\n\t\t * 23 in Appendix B.2.)\n\t\t * \n\t\t * Note: equation 23 is unconventional as it swaps the z component with\n\t\t * x component. This code follows the more common convention and returns\n\t\t * z and x to their proper place\n\t\t */\n\t\tdouble a = NVector.SEMI_MAJOR;\n\t\tdouble b = NVector.SEMI_MINOR;\n\t\tdouble e = Math.sqrt(1 - (b * b) / (a * a));\n\t\tdouble q = (1.0 - e * e) / (a * a) * this.z * this.z;\n\t\tdouble p = (this.y * this.y + this.x * this.x) / (a * a);\n\t\tdouble r = (p + q - Math.pow(e, 4.0)) / 6.0;\n\t\tdouble s = (Math.pow(e, 4) * p * q) / (4 * Math.pow(r, 3));\n\t\tdouble t = Math.pow((1.0 + s + Math.sqrt(s * (2.0 + s))), 1.0 / 3.0);\n\t\tdouble u = r * (1.0 + t + 1.0 / t);\n\t\tdouble v = Math.sqrt(u * u + Math.pow(e, 4.0) * q);\n\t\tdouble w = e * e * (u + v - q) / (2 * v);\n\t\tdouble k = Math.sqrt(u + v + w * w) - w;\n\t\tdouble d = (k * Math.sqrt(this.y * this.y + this.x * this.x)) / (k + e * e);\n\t\tdouble f = 1.0 / (Math.sqrt(d * d + this.z * this.z));\n\t\tdouble f2 = k / (k + e * e);\n\t\tdouble x = f * f2 * this.x;\n\t\tdouble y = f * f2 * this.y;\n\t\tdouble z = f * this.z;\n\t\tdouble alt = (k + e * e - 1) / k * Math.sqrt(d * d + this.z * this.z);\n\n\t\treturn new NVector(x, y, z, alt);\n\t}\n\n\t/**\n\t * @return the latitude, longitude, and altitude for this position\n\t */\n\t@Override\n\tpublic LlaCoordinate toLlaCoordinate() {\n\t\treturn toNVector().toLlaCoordinate();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tlong temp;\n\t\ttemp = Double.doubleToLongBits(x);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\ttemp = Double.doubleToLongBits(y);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\ttemp = Double.doubleToLongBits(z);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn String.format(\"PVector(%f, %f, %f)\", this.x, this.y, this.z);\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (!(obj instanceof PVector))\n\t\t\treturn false;\n\t\tPVector other = (PVector) obj;\n\t\tif (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))\n\t\t\treturn false;\n\t\tif (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))\n\t\t\treturn false;\n\t\tif (Double.doubleToLongBits(z) != Double.doubleToLongBits(other.z))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic PVector toPVector() {\n\t\treturn this;\n\t}\n}\n"}, {"id": "FlightRouteInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport edu.nd.dronology.core.util.Waypoint;\n\npublic class FlightRouteInfo extends RemoteInfoObject {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -7327376857430499641L;\n\tprivate String category;\n\tprivate List<Waypoint> waypoints = new ArrayList<>();\n\tprivate long dateCreated;\n\tprivate long dateModified;\n\tprivate double length;\n\tprivate String description;\n\n\tpublic FlightRouteInfo(String name, String id) {\n\t\tsuper(name, id);\n\t}\n\n\tpublic String getCategory() {\n\t\treturn category;\n\t}\n\n\tpublic void setCategory(String category) {\n\t\tthis.category = category;\n\n\t}\n\n\tpublic List<Waypoint> getWaypoints() {\n\t\treturn Collections.unmodifiableList(waypoints);\n\t}\n\n\tpublic void setDateModified(long dateModified) {\n\t\tthis.dateModified = dateModified;\n\t}\n\n\tpublic void setDateCreated(long dateCreated) {\n\t\tthis.dateCreated = dateCreated;\n\t}\n\n\tpublic void addWaypoint(Waypoint waypoint) {\n\t\twaypoints.add(waypoint);\n\t}\n\n\tpublic void removeWaypoint(Waypoint waypoint) {\n\t\twaypoints.remove(waypoint);\n\t}\n\n\tpublic double getRouteLength() {\n\t\treturn length;\n\t}\n\n\tpublic long getDateCreated() {\n\t\treturn dateCreated;\n\t}\n\n\tpublic long getDateModified() {\n\t\treturn dateModified;\n\t}\n\n\tpublic void setRouteLength(double length) {\n\t\tthis.length = length;\n\n\t}\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n}\n"}, {"id": "SimulatorScenarioXStreamPersistor.java", "body": "package edu.nd.dronology.services.core.persistence.internal;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.nio.charset.Charset;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport com.thoughtworks.xstream.XStream;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\n\nimport edu.nd.dronology.services.core.items.ISimulatorScenario;\nimport edu.nd.dronology.services.core.persistence.DronologyPersistenceUtil;\nimport edu.nd.dronology.services.core.persistence.IPersistenceManager;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class SimulatorScenarioXStreamPersistor implements IPersistenceManager<ISimulatorScenario> {\n\n\tprivate static final XStream xstream = new XStream(new XppDriver());\n\tprivate static ILogger LOGGER = LoggerProvider.getLogger(SimulatorScenarioXStreamPersistor.class);\n\n\tstatic final boolean useCompression = false;\n\n\t@Override\n\tpublic ISimulatorScenario open(InputStream fin) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t//\t xstream.setMode(XStream.);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\t\t\n\t\tif (useCompression) {\n\t\t\treturn loadedCompressedStream(fin);\n\t\t} else {\n\t\t\treturn loadUncompressedStream(fin);\n\t\t}\n\t}\n\n\tprivate ISimulatorScenario loadUncompressedStream(InputStream fin) throws PersistenceException {\n\t\ttry {\n\t\t\tInputStreamReader reader = new InputStreamReader(new BufferedInputStream(fin), Charset.forName(\"UTF-8\"));\n\t\t\tObject model = xstream.fromXML(reader);\n\t\t\treturn (ISimulatorScenario) model;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (fin != null) {\n\t\t\t\t\tfin.close();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate ISimulatorScenario loadedCompressedStream(InputStream fin) throws PersistenceException {\n\t\tInputStream zIn = null;\n\t\ttry {\n\t\t\tzIn = new GZIPInputStream(fin);\n\t\t\tObject model = xstream.fromXML(new BufferedReader(new InputStreamReader(zIn, \"UTF-8\")));\n\n\t\t\treturn (ISimulatorScenario) model;\n\t\t} catch (IOException e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (zIn != null) {\n\t\t\t\t\tzIn.close();\n\t\t\t\t}\n\t\t\t\tif (fin != null) {\n\t\t\t\t\tfin.close();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\n\t\t}\n\t}\n \n\t@Override\n\tpublic boolean save(ISimulatorScenario o, OutputStream fout) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t\t// xstream.setMode(XStream.ID_REFERENCES);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\t\t// xstream.addImplicitMap(ImplMEEvent.class, \"relatedEvents\", ImplMEEvent.class, \"relatedEvents\");\n\n\t\tif (useCompression) {\n\t\t\treturn saveCompressedStream(o, fout);\n\t\t} else {\n\t\t\treturn saveUncompressedStream(o, fout);\n\t\t}\n\n\t}\n\n\tprivate boolean saveUncompressedStream(ISimulatorScenario o, OutputStream fout) throws PersistenceException {\n\t\tOutputStreamWriter writer = null;\n\t\ttry {\n\t\t\twriter = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(\"UTF-8\"));\n\t\t\txstream.toXML(o, writer);\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (writer != null) {\n\t\t\t\t\twriter.close();\n\t\t\t\t}\n\t\t\t\tif (fout != null) {\n\t\t\t\t\tfout.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean saveCompressedStream(ISimulatorScenario o, OutputStream fout) throws PersistenceException {\n\t\ttry {\n\t\t\tGZIPOutputStream zOut = new GZIPOutputStream(fout);\n\t\t\txstream.toXML(o, new BufferedWriter(new OutputStreamWriter(zOut, \"UTF-8\")));\n\n\t\t\tzOut.close();\n\t\t\tfout.close();\n\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t}\n\t}\n\n}\n"}, {"id": "AreaMappingXStreamPersistor.java", "body": "package edu.nd.dronology.services.core.persistence.internal;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.nio.charset.Charset;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport com.thoughtworks.xstream.XStream;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\n\nimport edu.nd.dronology.services.core.items.IAreaMapping;\nimport edu.nd.dronology.services.core.persistence.DronologyPersistenceUtil;\nimport edu.nd.dronology.services.core.persistence.IPersistenceManager;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class AreaMappingXStreamPersistor implements IPersistenceManager<IAreaMapping> {\n\n\tprivate static final XStream xstream = new XStream(new XppDriver());\n\tprivate static ILogger LOGGER = LoggerProvider.getLogger(AreaMappingXStreamPersistor.class);\n\n\tstatic final boolean useCompression = false;\n\n\t@Override\n\tpublic IAreaMapping open(InputStream fin) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t//\t xstream.setMode(XStream.);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\t\t\n\t\tif (useCompression) {\n\t\t\treturn loadedCompressedStream(fin);\n\t\t} else {\n\t\t\treturn loadUncompressedStream(fin);\n\t\t}\n\t}\n\n\tprivate IAreaMapping loadUncompressedStream(InputStream fin) throws PersistenceException {\n\t\ttry {\n\t\t\tInputStreamReader reader = new InputStreamReader(new BufferedInputStream(fin), Charset.forName(\"UTF-8\"));\n\t\t\tObject model = xstream.fromXML(reader);\n\t\t\treturn (IAreaMapping) model;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (fin != null) {\n\t\t\t\t\tfin.close();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate IAreaMapping loadedCompressedStream(InputStream fin) throws PersistenceException {\n\t\tInputStream zIn = null;\n\t\ttry {\n\t\t\tzIn = new GZIPInputStream(fin);\n\t\t\tObject model = xstream.fromXML(new BufferedReader(new InputStreamReader(zIn, \"UTF-8\")));\n\n\t\t\treturn (IAreaMapping) model;\n\t\t} catch (IOException e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (zIn != null) {\n\t\t\t\t\tzIn.close();\n\t\t\t\t}\n\t\t\t\tif (fin != null) {\n\t\t\t\t\tfin.close();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\n\t\t}\n\t}\n \n\t@Override\n\tpublic boolean save(IAreaMapping o, OutputStream fout) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t\t// xstream.setMode(XStream.ID_REFERENCES);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\t\t// xstream.addImplicitMap(ImplMEEvent.class, \"relatedEvents\", ImplMEEvent.class, \"relatedEvents\");\n\n\t\tif (useCompression) {\n\t\t\treturn saveCompressedStream(o, fout);\n\t\t} else {\n\t\t\treturn saveUncompressedStream(o, fout);\n\t\t}\n\n\t}\n\n\tprivate boolean saveUncompressedStream(IAreaMapping o, OutputStream fout) throws PersistenceException {\n\t\tOutputStreamWriter writer = null;\n\t\ttry {\n\t\t\twriter = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(\"UTF-8\"));\n\t\t\txstream.toXML(o, writer);\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (writer != null) {\n\t\t\t\t\twriter.close();\n\t\t\t\t}\n\t\t\t\tif (fout != null) {\n\t\t\t\t\tfout.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean saveCompressedStream(IAreaMapping o, OutputStream fout) throws PersistenceException {\n\t\ttry {\n\t\t\tGZIPOutputStream zOut = new GZIPOutputStream(fout);\n\t\t\txstream.toXML(o, new BufferedWriter(new OutputStreamWriter(zOut, \"UTF-8\")));\n\n\t\t\tzOut.close();\n\t\t\tfout.close();\n\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t}\n\t}\n\n}\n"}, {"id": "AbstractMessage.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal.message;\n\npublic abstract class AbstractMessage {\n}\n"}, {"id": "UAVMappingInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\npublic class UAVMappingInfo extends RemoteInfoObject {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -2373680748153869356L;\n\n\tpublic UAVMappingInfo() {\n\t\tsuper(\"\", \"\");\n\t}\n\n}\n"}, {"id": "WriteDispatcher.java", "body": "package edu.nd.dronology.gstation.connector.dispatch;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.Socket;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport edu.nd.dronology.core.vehicle.commands.IDroneCommand;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * Writer Thread takes items from the outbound queue and writes it to the\n * socket.\n * \n * @author Michael Vierhauser\n *\n */\npublic class WriteDispatcher implements Runnable {\n\n\tprivate OutputStream outputStream;\n\tprivate AtomicBoolean cont = new AtomicBoolean(true);\n\tprivate BlockingQueue<IDroneCommand> outputQueue;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(WriteDispatcher.class);\n\n\tpublic WriteDispatcher(Socket pythonSocket, BlockingQueue<IDroneCommand> outputQueue) {\n\t\ttry {\n\t\t\toutputStream = pythonSocket.getOutputStream();\n\t\t\tthis.outputQueue = outputQueue;\n\t\t\tcont.set(true);\n\t\t} catch (IOException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tLOGGER.info(\"Write-Dispatcher started\");\n\t\ttry {\n\t\t\twhile (cont.get()) {\n\t\t\t\ttry {\n\t\t\t\t\tIDroneCommand toSend = outputQueue.take();\n\t\t\t\t\tif (toSend instanceof MarkerObject) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tLOGGER.hwInfo(\"Sending Command to UAV -\" + toSend.toString());\n\t\t\t\t\ttoSend.timestamp();\n\t\t\t\t\toutputStream.write(toSend.toJsonString().getBytes());\n\t\t\t\t\toutputStream.write(System.getProperty(\"line.separator\").getBytes());\n\t\t\t\t\toutputStream.flush();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLOGGER.error(e); \n\n\t\t\t\t}\n\t\t\t}\n\t\t\tLOGGER.info(\"Writer Thread shutdown\");\n\t\t\ttry {\n\t\t\t\toutputStream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t}\n\t}\n\n\tpublic void tearDown() {\n\t\tcont.set(false);\n\t\ttry {\n\t\t\toutputQueue.put(new MarkerObject());\n\t\t} catch (InterruptedException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\n\tpublic class MarkerObject implements IDroneCommand {\n\n\t\t/**\n\t\t * \n\t\t */\n\t\tprivate static final long serialVersionUID = 7890483609236721982L;\n\n\t\t@Override\n\t\tpublic String toJsonString() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void timestamp() {\n\t\t\t// TODO Auto-generated method stub\n\n\t\t}\n\n\t\t@Override\n\t\tpublic String getUAVId() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n}\n"}, {"id": "KMLMapCreator.java", "body": "package edu.nd.dronology.misc.kml;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport edu.nd.dronology.gstation.connector.messages.UAVMessageFactory;\nimport edu.nd.dronology.gstation.connector.messages.UAVStateMessage;\n\npublic class KMLMapCreator {\n\n\tprivate static final String UAVID = \"IRIS2\";\n\tprivate String name = \"result\";\n\tprivate String datapath = \"d:\\\\kmlexport\";\n\n\tpublic static void main(String[] args) {\n\n\t\tnew KMLMapCreator().createKMLFile(\"d:\\\\log.log\");\n\n\t}\n\n\tpublic void createKMLFile(String logfile) {\n\n\t\tList<UAVStateMessage> messages = readMessages(logfile);\n\n\t\tString kmlString = createKMLBody(messages);\n\n\t\twriteToFile(kmlString);\n\t}\n\n\tprivate List<UAVStateMessage> readMessages(String logfile) {\n\t\tList<UAVStateMessage> messageList = new ArrayList<>();\n\t\ttry {\n\n\t\t\tList<String> lines = Files.readAllLines(Paths.get(logfile));\n\n\t\t\tlines.forEach(l -> messageList.add(parseLine(l)));\n\t\t\treturn messageList;\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn messageList;\n\t}\n\n\tprivate UAVStateMessage parseLine(String l) {\n\t\tint start = l.indexOf(\"{\");\n\t\tString msgText = l.substring(start);\n\n\t\tUAVStateMessage msg;\n\t\ttry {\n\t\t\tmsg = (UAVStateMessage) UAVMessageFactory.create(msgText);\n\t\t\treturn msg;\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\n\t}\n\n\tprivate void writeToFile(String kmlString) {\n\t\tFile testexists = new File(datapath + \"/\" + name + \".kml\");\n\t\tWriter fwriter;\n\n\t\tif (!testexists.exists()) {\n\t\t\ttry {\n\n\t\t\t\tfwriter = new FileWriter(datapath + \"/\" + name + \".kml\");\n\t\t\t\tfwriter.write(kmlString);\n\t\t\t\tfwriter.flush();\n\t\t\t\tfwriter.close();\n\t\t\t} catch (IOException e1) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te1.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\telse {\n\n\t\t\t// schleifenvariable\n\t\t\tString filecontent = \"\";\n\n\t\t\tArrayList<String> newoutput = new ArrayList<String>();\n\t\t\t;\n\n\t\t\ttry {\n\t\t\t\tBufferedReader in = new BufferedReader(new FileReader(testexists));\n\t\t\t\twhile ((filecontent = in.readLine()) != null)\n\n\t\t\t\t\tnewoutput.add(filecontent);\n\n\t\t\t} catch (FileNotFoundException e1) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te1.printStackTrace();\n\t\t\t} catch (IOException e1) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te1.printStackTrace();\n\t\t\t}\n\n\t\t\t// newoutput.add(2, kmlelement);\n\n\t\t\tString rewrite = \"\";\n\t\t\tfor (String s : newoutput) {\n\t\t\t\trewrite += s;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfwriter = new FileWriter(datapath + \"/\" + name + \".kml\");\n\t\t\t\tfwriter.write(rewrite);\n\t\t\t\tfwriter.flush();\n\t\t\t\tfwriter.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tprivate final String kmlstart = \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\"\n\t\t\t+ \"<kml xmlns=\\\"http://www.opengis.net/kml/2.2\\\">\\n\";\n\n\t// private final String kmlelement = \"\\t<Placemark>\\n\" + \"\\t<name>WP%num</name>\\n\" + \"\\t<description>\" + name\n\t// + \"</description>\\n\" + \"\\t<Point>\\n\" + \"\\t\\t<coordinates>%lon,%lat,%alt</coordinates>\\n\" + \"\"\n\t// + \"\\t<gx:TimeSpan>\\n\"\n\t// + \"\\t<begin>%time</begin>\\n\"\n\t// + \"\\t</gx:TimeSpan>\\n\"\n\t// + \"\\t</Point>\\n\"\n\t// + \"\\t</Placemark>\\n\";\n\t//\n\n\tprivate final String kmlelement = \"\\t<Placemark>\\n\" + \"\\t<name>WP%num</name>\\n\" + \"\\t<description> %desc\"\n\t\t\t+ \"</description>\\n\" + \"\\t<LineString>\\n\" + \"<extrude>1</extrude>\" + \"<tessellate>1</tessellate>\"\n\t\t\t+ \"<altitudeMode>absolute</altitudeMode>\" + \"\\t\\t<coordinates>%coords</coordinates>\\n\" + \"</LineString>\"\n\t\t\t+ \"\\t</Placemark>\\n\";\n\n\tprivate String createKMLBody(List<UAVStateMessage> messages) {\n\n\t\tString kmlend = \"</kml>\";\n\n\t\tArrayList<String> content = new ArrayList<String>();\n\t\tcontent.add(kmlstart);\n\n\t\tStringBuilder cordBuilder = new StringBuilder();\n\t\tfor (UAVStateMessage m : messages) {\n\t\t\tString res = createKMLElement(m);\n\t\t\tif (res != null) {\n\t\t\t\tcordBuilder.append(res);\n\t\t\t}\n\t\t}\n\n\t\tString kmElement = kmlelement.replace(\"%coords\", cordBuilder.toString());\n\t\tkmElement = kmElement.replace(\"%desc\", UAVID);\n\t\tcontent.add(kmElement);\n\t\tcontent.add(kmlend);\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tcontent.forEach(str -> {\n\t\t\tsb.append(str);\n\t\t\tsb.append(\"\\n\");\n\t\t});\n\t\treturn sb.toString();\n\n\t}\n\n\tprivate String createKMLElement(UAVStateMessage m) {\n\n\t\tif (!m.getUavid().equals(UAVID)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(m.getLocation().getLongitude());\n\t\tsb.append(\",\");\n\t\tsb.append(m.getLocation().getLatitude());\n\t\tsb.append(\",\");\n\t\tsb.append(m.getLocation().getAltitude());\n\t\tsb.append(\",\");\n\n\t\treturn sb.toString();\n\t}\n}\n"}, {"id": "IUAVEquipmentTypeRegistration.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.io.Serializable;\n\npublic interface IUAVEquipmentTypeRegistration  extends IPersistableItem {\n\n\tString getDescription();\n\n\tvoid setDescription(String description);\n\n\tSerializable getAttribute(String key);\n\n\tvoid addAttribute(String key, Serializable value);\n\n\t\n}\n"}, {"id": "PlanPool.java", "body": "package edu.nd.dronology.core.flight;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.exceptions.FlightZoneException;\nimport edu.nd.dronology.core.util.DummyLockObject;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * The {@link PlanPool} manages pending, executing, and completed plans for a single UAV.\n * \n * @author Michael Vierhauser\n *\n */\npublic class PlanPool {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(PlanPool.class);\n\n\tprivate DummyLockObject lockObject = new DummyLockObject();\n\tprivate final List<IFlightPlan> pendingPlans = Collections.synchronizedList(new ArrayList<>());\n\tprivate IFlightPlan currentPlan;\n\tprivate final List<IFlightPlan> completedPlans = Collections.synchronizedList(new ArrayList<>());\n\tprivate String id; \n\n\tpublic PlanPool(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic void setCurrentFlightCompleted() throws DroneException {\n\t\tsynchronized (lockObject) {\n\t\t\tif (currentPlan == null) {\n\t\t\t\tthrow new DroneException(\"No active Plan to complete!\");\n\t\t\t}\n\t\t\tcompletedPlans.add(currentPlan);\n\t\t\ttry {\n\t\t\t\tcurrentPlan.setStatusToCompleted();\n\t\t\t} catch (FlightZoneException e) {\n\t\t\t\tLOGGER.error(e); \n\t\t\t}\n\t\t\tLOGGER.trace(\"Plan '\" + currentPlan.getFlightID() + \"' completed\");\n\t\t\tcurrentPlan = null;\n\t\t}\n\n\t}\n\n\tpublic void setNextPlanToCurrent() throws DroneException {\n\t\tsynchronized (lockObject) { \n\t\t\tif (currentPlan != null) {\n\t\t\t\tthrow new DroneException(\"Current plan not completed!\");\n\t\t\t}\n\t\t\tif (pendingPlans.isEmpty()) {\n\t\t\t\tthrow new DroneException(\"No pending flights scheduled!\");\n\t\t\t}\n\t\t\tcurrentPlan = pendingPlans.remove(0);\n\n\t\t\tLOGGER.info(id + \" - Plan '\" + currentPlan.getFlightID() + \"' setActive\");\n\t\t}\n\n\t}\n\n\tpublic void addPlan(IFlightPlan plan) { \n\t\tLOGGER.info(\"New Flight Plan '\" + plan.getFlightID() + \"' scheduled for \" + id);\n\t\tpendingPlans.add(plan);\n\n\t}\n\n\tpublic boolean hasPendingPlans() {\n\t\treturn pendingPlans.size() > 0;\n\t}\n\n\tpublic IFlightPlan getCurrentPlan() {\n\t\treturn currentPlan;\n\t}\n\n\tpublic List<IFlightPlan> getPendingPlans() {\n\t\treturn Collections.unmodifiableList(new ArrayList<>(pendingPlans));\n\t}\n\n\tpublic List<IFlightPlan> getCompletedPlans() {\n\t\treturn Collections.unmodifiableList(new ArrayList<>(completedPlans));\n\t}\n \n\tpublic void overridePlan(IFlightPlan masterPlan) {\n\t\tsynchronized (this) {\n\t\t\tif (currentPlan != null) {\n\t\t\t\tLOGGER.info(\"Current flight plan '\" + currentPlan.getFlightID() + \"' cancelled\");\n\t\t\t\tLOGGER.missionError(\"Current flight plan '\" + currentPlan.getFlightID() + \"' \" + id + \" cancelled\");\n\t\t\t\tcurrentPlan = null;\n\t\t\t}\n\t\t\tif (pendingPlans.size() > 0) {\n\t\t\t\tLOGGER.info(pendingPlans.size() + \" Pending flight plans cancelled\");\n\t\t\t\tLOGGER.missionError(pendingPlans.size() + \" Pending flight plans for \" + id + \" cancelled\");\n\t\t\t\tpendingPlans.clear();\n\t\t\t}\n\t\t\tcurrentPlan = masterPlan;\n\t\t} \n\n\t}\n\n\tpublic void cancelPendingPlans() { \n\t\tif (pendingPlans.size() > 0) {\n\t\t\tLOGGER.info(pendingPlans.size() + \" Pending flight plans cancelled\");\n\t\t\tLOGGER.missionError(pendingPlans.size() + \" Pending flight plans for \" + id + \" cancelled\");\n\t\t\tpendingPlans.clear();\n\t\t}\n\t}\n}\n"}, {"id": "DronologyConstants.java", "body": "package edu.nd.dronology.services.core.util;\n\nimport java.io.File;\n\npublic class DronologyConstants {\n\tpublic static final String DEFAULT_ROOT_FOLDER = \"D:\" + File.pathSeparator + \"dronology-workspace\"\n\t\t\t+ File.pathSeparator;\n\n\tpublic static final String DRONOLOGY_ROOT_FOLDER = \"dronology-workspace\";\n\n\tpublic static final String EXTENSION_FLIGHTROUTE = \"froute\";\n\tpublic static final String EXTENSION_REGISTRATION = \"reg\";\n\tpublic static final String EXTENSION_TYPEREGISTRATION = \"type\";\n\tpublic static final String EXTENSION_EQUIPMENT_TYPEREGISTRATION = \"type\";\n\n\tpublic static final String FOLDER_FLIGHTROUTE = \"flightroute\";\n\tpublic static final String FOLDER_REGISTRATION = \"registration\";\n\n\tpublic static final String FOLDERN_SIM_SCENARIO = \"simscenario\";\n\tpublic static final String EXTENSION_SIM_SCENARIO = \"sim\";\n\n\tpublic static final String EXTENSION_MISSION = \"mission\";\n\tpublic static final String EXTENSION_AREA = \"area\";\n\n\tpublic static final String FOLDER_AREAMAPPING = \"areamapping\";\n\n\tpublic static final String FOLDER_MISSIONPLANNING = \"missionplanning\";\n}\n"}, {"id": "AbstractUAVMessage.java", "body": "package edu.nd.dronology.gstation.connector.messages;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport edu.nd.dronology.core.monitoring.ArtifactIdentifier;\nimport edu.nd.dronology.core.monitoring.IMonitorableMessage;\nimport edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;\nimport edu.nd.dronology.core.util.PreciseTimestamp;\n\npublic class AbstractUAVMessage<T> implements Serializable, IMonitorableMessage {\n\n\tprivate static final long serialVersionUID = 8470856533906132618L;\n\n\tprivate transient PreciseTimestamp receiveTimestamp;\n\tprivate long sendtimestamp;\n\n\tprotected String type;\n\tprotected final Map<String, T> data = new HashMap<>();\n\tprotected String uavid;\n\tprivate String groundstationid;\n\n\tpublic AbstractUAVMessage(String type, String groundstationid, String uavid) {\n\t\tthis.type = type;\n\t\tthis.uavid = uavid;\n\t\tthis.groundstationid = groundstationid;\n\t\tthis.receiveTimestamp = PreciseTimestamp.create();\n\t}\n\n\tpublic void timestamp() {\n\t\tthis.receiveTimestamp = PreciseTimestamp.create();\n\n\t}\n\n\t@Override\n\tpublic PreciseTimestamp getTimestamp() {\n\t\treturn receiveTimestamp;\n\t}\n\n\tpublic long getSendtimestamp() {\n\t\treturn sendtimestamp;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn UAVMessageFactory.GSON.toJson(this);\n\t}\n\n\t@Override\n\tpublic String getUavid() {\n\t\treturn uavid;\n\t}\n\n\tpublic void setUavid(String uavid) {\n\t\tthis.uavid = uavid;\n\t}\n\n\tpublic void addPropery(String key, T value) {\n\t\tdata.put(key, value);\n\n\t}\n\n\tpublic T getProperty(String key) {\n\t\treturn data.get(key);\n\n\t}\n\n\tpublic Set<Entry<String, T>> getProperties() {\n\t\treturn data.entrySet();\n\t}\n\n\tpublic void setType(String type) {\n\t\tthis.type = type;\n\n\t}\n\n\tpublic String getGCSId() {\n\t\treturn groundstationid;\n\t}\n\n\t@Override\n\tpublic ArtifactIdentifier<?> getIdentifier() {\n\t\treturn new ArtifactIdentifier(ArtifactIdentifier.ROOT, groundstationid, uavid, getClass().getSimpleName());\n\n\t}\n\n\t@Override\n\tpublic String getData() {\n\t\treturn this.toString();\n\t}\n\n\t@Override\n\tpublic MessageType getType() {\n\t\treturn MessageType.GCS_MONITORING;\n\t}\n\n}\n"}, {"id": "DelayTask.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.tasks;\n\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * Delay tasks specifying a delay after a route has been executed before commencing with the next round. \n * \n * @author Michael Vierhauser\n *\n */\npublic class DelayTask extends AbstractMissionTask {\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(DelayTask.class);\n\n\tprivate final double duration;\n\tprivate long startTime;\n\n\t/**\n\t * \n\t * @param uavID\n\t * @param taskName\n\t * @param duration\n\t *          in seconds\n\t */\n\tprotected DelayTask(String uavID, String taskName, double duration) {\n\t\tsuper(uavID, taskName);\n\t\tthis.duration = duration;\n\t}\n\n\tpublic double getDuration() {\n\t\treturn duration;\n\t}\n\n\tpublic void startDelayTask() {\n\t\tLOGGER.info(\"Delay started for UAV '\" + getUAVId() + \"' duration: \" + duration);\n\t\tstartTime = System.currentTimeMillis();\n\t}\n\n\tpublic boolean isFinished() {\n\t\tboolean finished = System.currentTimeMillis() - startTime > duration * 1000;\n\n\t\tif (finished) {\n\t\t\tLOGGER.info(\"Delay finished for UAV '\" + getUAVId() + \"'\");\n\t\t}\n\t\treturn finished;\n\n\t}\n\n}"}, {"id": "AFInfoBox.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport org.vaadin.teemu.switchui.Switch;\n\nimport com.vaadin.server.Resource;\nimport com.vaadin.ui.Alignment;\nimport com.vaadin.ui.Button;\nimport com.vaadin.ui.CheckBox;\nimport com.vaadin.ui.Component;\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.GridLayout;\nimport com.vaadin.ui.HorizontalLayout;\nimport com.vaadin.ui.Image;\nimport com.vaadin.ui.Label;\nimport com.vaadin.ui.Notification;\nimport com.vaadin.ui.UI;\nimport com.vaadin.ui.VerticalLayout;\nimport com.vaadin.ui.themes.ValoTheme;\n\nimport edu.nd.dronology.core.vehicle.DroneFlightStateManager.FlightMode;\nimport edu.nd.dronology.ui.vaadin.connector.DronologyActionExecutor;\nimport edu.nd.dronology.ui.vaadin.flightroutes.windows.TakeoffAltitudeWindow;\nimport edu.nd.dronology.ui.vaadin.utils.ImageProvider;\nimport edu.nd.dronology.ui.vaadin.utils.StyleConstants; \n\n/**\n * This is the box in the side panel that contains a UAV's information\n * \n * @author Patrick Falvey\n *\n */\n\npublic class AFInfoBox extends CustomComponent {\n\tprivate static final long serialVersionUID = -8541147696474050819L;\n\n\tprivate boolean visible = false;\n\tprivate boolean isChecked;\n\tprivate boolean hoverInPlace;\n\tprivate boolean checkClicked = false;\n\n\tprivate CheckBox check = new CheckBox();\n\tprivate Label statusInfo1 = new Label();\n\tprivate Label statusInfo2 = new Label();\n\tprivate Label statusInfo3 = new Label();\n\tprivate Label health = new Label();\n\tprivate Label locationInfo1 = new Label();\n\t// private Label locationInfo2 = new Label();\n\t// private Label locationInfo3 = new Label();\n\tprivate Label locationInfo4 = new Label();\n\tprivate Switch hoverSwitch = new Switch();\n\tprivate Button returnToHome = new Button(\"\");\n\tprivate Button takeoff = new Button(\"\");\n\n\tprivate Resource takeoffIcon = ImageProvider.getTaekoffResource();\n\tprivate Resource rtlIcon = ImageProvider.getRTLResource();\n\tprivate Resource assignRouteIcon = ImageProvider.getAssignRouteResource();\n\tprivate Resource resendIcon = ImageProvider.getResendCommandResource();\n\tprivate Resource okIcon = ImageProvider.getStatusOKResource();\n\tprivate Resource user_controlled = ImageProvider.getStatusUsercontrolledResource();\n\n\tprivate Button assignNewRoute = new Button(\"\");\n\tprivate Button resendCommand = new Button(\"\");\n\n\tprivate VerticalLayout mainContent = new VerticalLayout();\n\tprivate HorizontalLayout topContent = new HorizontalLayout();\n\tprivate VerticalLayout middleContent = new VerticalLayout();\n\tprivate HorizontalLayout bottomContent = new HorizontalLayout();\n\tprivate UAVStatusWrapper uavStatus;\n\n\tpublic AFInfoBox(boolean isChecked, UAVStatusWrapper uavStatus, boolean hoverInPlace) {\n\t\tthis.uavStatus = uavStatus;\n\t\tthis.isChecked = isChecked;\n\t\tthis.hoverInPlace = hoverInPlace;\n\t}\n\n\tpublic void createContents() {\n\t\tthis.addStyleName(StyleConstants.INFO_BOX);\n\t\tthis.addStyleName(StyleConstants.AF_INFO_BOX);\n\n\t\ttopContent.addStyleName(StyleConstants.AF_BOX_INFO_TOP_CONTENT);\n\t\tmiddleContent.addStyleName(StyleConstants.AF_BOX_INFO_DETAIL_CONTENT);\n\t\tbottomContent.addStyleName(StyleConstants.AF_BOX_INFO_BOTTOM_CONTENT);\n\n\t\tcreateTopComponent();\n\n\t\tmiddleContent.addComponents(locationInfo1, locationInfo4);\n\n\t\tcreateBottomComponent();\n\n\t\tmainContent.addComponents(topContent, middleContent, bottomContent);\n\t\tmainContent.setSizeUndefined();\n\t\tmainContent.setSpacing(false);\n\n\t\tmiddleContent.setVisible(visible);\n\t\tbottomContent.setVisible(visible);\n\n\t\tsetCompositionRoot(mainContent);\n\n\t\treturnToHome.setHeight(\"30px\");\n\t\tassignNewRoute.setHeight(\"30px\");\n\t\ttakeoff.setHeight(\"30px\");\n\t\tresendCommand.setHeight(\"30px\");\n\n\t\ttakeoff.setWidth(\"55px\"); \n\t\treturnToHome.setWidth(\"55px\");\n\t\tassignNewRoute.setWidth(\"55px\");\n\t\tresendCommand.setWidth(\"55px\");\n\n\t\ttakeoff.setDescription(\"Take-off to target altitude\");\n\t\tresendCommand.setDescription(\"Resend previous command\");\n\t\treturnToHome.setDescription(\"Cancel all routes and return to home imediatelly\");\n\t\tassignNewRoute.setDescription(\"Assign a new flight route\");\n\n\t\ttakeoff.setStyleName(ValoTheme.BUTTON_ICON_ONLY);\n\t\t\n\t\ttakeoff.setIcon(takeoffIcon);\n\t\treturnToHome.setIcon(rtlIcon);\n\t\tassignNewRoute.setIcon(assignRouteIcon);\n\t\tresendCommand.setIcon(resendIcon);\n\t\taddListener();\n\t\tupdate(uavStatus);\n\t}\n\n\tprivate void createBottomComponent() {\n\t\tGridLayout bottomButtons = new GridLayout(2, 2);\n\t\tbottomButtons.setWidth(\"150px\");\n\t\tbottomButtons.setHeight(\"70px\");\n\t\tVerticalLayout bottomSwitch = new VerticalLayout();\n\n\t\thoverSwitch.setValue(this.hoverInPlace);\n\n\t\tLabel caption = new Label(\"Hover in Place\");\n\t\tbottomSwitch.addComponents(caption, hoverSwitch);\n\n\t\tbottomButtons.addComponents(takeoff, returnToHome, assignNewRoute, resendCommand);\n\t\tbottomContent.addComponents(bottomSwitch, bottomButtons);\n\n\t}\n\n\tprivate void createTopComponent() {\n\t\tVerticalLayout statusContent = new VerticalLayout();\n\t\tcheck.setValue(this.isChecked);\n\t\tImage droneImage = ImageProvider.getDefaultUAVImage();\n\n\t\tstatusInfo1.addStyleName(\"info_box_name\");\n\t\tstatusInfo1.addStyleName(ValoTheme.LABEL_BOLD);\n\n\t\tstatusContent.addComponents(statusInfo1, statusInfo2, statusInfo3);\n\t\tstatusContent.setSpacing(false);\n\t\t// health.setCaptionAsHtml(true);\n\t\thealth.setIcon(okIcon);\n\n\t\ttopContent.addComponents(check, droneImage, statusContent, health);\n\t\ttopContent.setSpacing(false);\n\t\ttopContent.setComponentAlignment(check, Alignment.TOP_LEFT);\n\t\ttopContent.setComponentAlignment(droneImage, Alignment.TOP_LEFT);\n\t\ttopContent.setComponentAlignment(statusContent, Alignment.TOP_LEFT);\n\t\ttopContent.setComponentAlignment(health, Alignment.TOP_RIGHT);\n\n\t}\n\n\tprivate void addListener() {\n\t\treturnToHome.addClickListener(e -> {\n\t\t\tDronologyActionExecutor.returnHome(null, uavStatus);\n\t\t});\n\n\t\ttakeoff.addClickListener(e -> {\n\t\t\tthis.takeOff();\n\t\t});\n\n\t\tassignNewRoute.addClickListener(assignEvent -> { // this opens the assign routes UI\n\t\t\tDronologyActionExecutor.assignRouteToUAV(uavStatus);\n\t\t});\n\t\t\n\t\tresendCommand.addClickListener(assignEvent -> { // this opens the assign routes UI\n\t\t\tDronologyActionExecutor.resendCommand(uavStatus);\n\t\t});\n\n\t\thoverSwitch.addValueChangeListener(e -> {\n\t\t\tthis.setHoverInPlace(this.hoverSwitch.getValue());\n\t\t});\n\n\t\t// this listener assists with whether a box is focused or only checked\n\t\ttopContent.addLayoutClickListener(e -> {\n\t\t\tComponent child = e.getChildComponent();\n\t\t\tif (child != null && child.getClass() == CheckBox.class) {\n\t\t\t\tcheckClicked = true;\n\t\t\t} else {\n\t\t\t\tcheckClicked = false;\n\t\t\t}\n\t\t});\n\n\t\ttopContent.addLayoutClickListener(e -> {\n\t\t\tComponent child = e.getChildComponent();\n\t\t\tif (child == null || !child.getClass().getCanonicalName().equals(\"com.vaadin.ui.CheckBox\")) {\n\t\t\t\tsetBoxVisible(visible);\n\t\t\t}\n\t\t});\n\n\t}\n\n\tprivate void takeOff() {\n\t\tif (!this.uavStatus.getStatus().equals(\"ON_GROUND\")) {\n\t\t\tNotification.show(uavStatus.getName() + \" is already in the air.\");\n\t\t\treturn;\n\t\t}\n\t\tTakeoffAltitudeWindow takeoffAltitudeWindow = new TakeoffAltitudeWindow(uavStatus.getName());\n\n\t\tUI.getCurrent().addWindow(takeoffAltitudeWindow);\n\t}\n\n\t/**\n\t * default constructor\n\t */\n\tpublic AFInfoBox() {\n\t\t// this(false, \"NAME/ID of UAV\", \"Status\", 0, \"green\", 0, 0, 0, 0, false);\n\t}\n\n\tpublic void setIsChecked(boolean isChecked) {\n\t\tthis.isChecked = isChecked;\n\t\tcheck.setValue(this.isChecked);\n\t}\n\n\tpublic boolean getIsChecked() {\n\t\tthis.isChecked = check.getValue();\n\t\treturn this.isChecked;\n\t}\n\n\tpublic CheckBox getCheckBox() {\n\t\treturn this.check;\n\t}\n\n\tpublic void setHoverInPlace(boolean hoverInPlace) {\n\t\tthis.hoverInPlace = hoverInPlace;\n\t\thoverSwitch.setValue(this.hoverInPlace);\n\t\t// if (this.hoverInPlace) {\n\t\t// this.status = \"Hovering\";\n\t\t// statusInfo2.setValue(\"Status: \");\n\t\t// } else {\n\t\t// this.status = \"\";\n\t\t// statusInfo2.setValue(\"Status: \");\n\t\t// }\n\t}\n\n\tpublic boolean getHoverInPlace() {\n\t\treturn this.hoverInPlace;\n\t}\n\n\tpublic Switch getHoverSwitch() {\n\t\treturn this.hoverSwitch;\n\t}\n\n\t/**\n\t * Expands and collapses the box\n\t * \n\t * @param visible\n\t */\n\tpublic void setBoxVisible(boolean visible) {\n\t\tif (visible) {\n\t\t\tthis.visible = false;\n\t\t\tmiddleContent.setVisible(this.visible);\n\t\t\tbottomContent.setVisible(this.visible);\n\t\t} else {\n\t\t\tthis.visible = true;\n\t\t\tmiddleContent.setVisible(this.visible);\n\t\t\tbottomContent.setVisible(this.visible);\n\t\t}\n\t}\n\n\tpublic boolean getBoxVisible() {\n\t\treturn this.visible;\n\t}\n\n\tpublic Button getHomeButton() {\n\t\treturn this.returnToHome;\n\t}\n\n\tpublic Button getRouteButton() {\n\t\treturn this.assignNewRoute;\n\t}\n\n\tpublic boolean getCheckClick() {\n\t\treturn checkClicked;\n\t}\n\n\tpublic void setCheckClick(boolean checkClicked) {\n\t\tthis.checkClicked = checkClicked;\n\t}\n\n\tpublic void update(UAVStatusWrapper uavStatus) {\n\t\tthis.uavStatus = uavStatus;\n\t\tstatusInfo1.setValue(uavStatus.getName());\n\t\tstatusInfo2.setValue(\"Status: \" + uavStatus.getStatus());\n\t\tstatusInfo3.setValue(\"Battery Life: \" + uavStatus.getBatteryLife() + \" %\");\n\n\t\tString locString = String.format(\"Lat: %s | Long: %s | Alt: %s\", uavStatus.getLatitude(),\n\t\t\t\tuavStatus.getLongitude(), uavStatus.getAltitude());\n\n\t\tlocationInfo1.setValue(locString);\n\t\t// locationInfo2.setValue(\"Longitude:\\t\" + uavStatus.getLongitude());\n\t\t// locationInfo3.setValue(\"Altitude:\\t\" + uavStatus.getAltitude() + \" meters\");\n\t\tlocationInfo4.setValue(\"Ground Speed:\\t\" + uavStatus.getSpeed() + \" m/s\");\n\n\t\t// health.setCaption(\"<span style=\\'color: \" + uavStatus.getHealthColor() + \"\n\t\t// !important;\\'> \"\n\t\t// + VaadinIcons.CIRCLE.getHtml() + \"</span>\");\n\t\t// if (uavStatus.getHealthColor().equals(\"green\"))\n\t\t// health.setDescription(\"Normally Functionable\");\n\t\t// else if (uavStatus.getHealthColor().equals(\"yellow\"))\n\t\t// health.setDescription(\"Needs Attention\");\n\t\t// else if (uavStatus.getHealthColor().equals(\"red\"))\n\t\t// health.setDescription(\"Needs Immediate Attention\");\n\n\t\tif (uavStatus.getStatus().equals(FlightMode.USER_CONTROLLED.toString())) {\n\t\t\thealth.setIcon(user_controlled);\n\t\t\tthis.setEnabled(false);\n\t\t\tsetBoxVisible(true);\n\t\t} else {\n\t\t\thealth.setIcon(okIcon);\n\t\t\tthis.setEnabled(true);\n\t\t}\n\n\t}\n\n\tpublic String getName() {\n\t\treturn uavStatus.getName();\n\t}\n\n\tpublic String getStatus() {\n\t\treturn uavStatus.getStatus();\n\t}\n\n\tpublic String getHealthColor() {\n\t\treturn uavStatus.getHealthColor();\n\t}\n}\n"}, {"id": "IdentifierCreator.java", "body": "package edu.nd.dronology.monitoring.tree;\n\n/**\n * \n * Factory Class for Artifact Identifier for creating Artifact Identifier for\n * the VarModel <br>\n * <br>\n * <b> Only use the factory methods for creating Artifact Identifier! </b>\n * <p/>\n * \n * @author Michael Vierhauser\n * \n */\npublic class IdentifierCreator {\n\n\t\n\n\t// public static ArtifactIdentifier createIdentifier(String gid, UAVStateMessage\n\t// message) {\n\t// String uavid = message.getUavid();\n\t// return new ArtifactIdentifier(ArtifactIdentifier.ROOT, gid, uavid,\n\t// UAVStateMessage.class.getSimpleName());\n\t//\n\t// }\n\t//\n\t// public static ArtifactIdentifier createIdentifier(String gid,\n\t// UAVMonitoringMessage message) {\n\t// String uavid = message.getUavid();\n\t// return new ArtifactIdentifier(ArtifactIdentifier.ROOT, gid, uavid,\n\t// UAVMonitoringMessage.class.getSimpleName());\n\t//\n\t// }\n\n\t// public static ArtifactIdentifier createIdentifier(String gid,\n\t// IMonitorableMessage message) {\n\t// if (message instanceof UAVStateMessage) {\n\t// return createIdentifier(gid, (UAVStateMessage) message);\n\t// }\n\t// if (message instanceof UAVMonitoringMessage) {\n\t// return createIdentifier(gid, (UAVMonitoringMessage) message);\n\t// }\n\t// return null;\n\t// }\n\n}\n"}, {"id": "IMappedItem.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.util.List;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\npublic interface IMappedItem {\n\n\tString getId();\n\n\tString getDescription();\n\n\tvoid setDescription(String description);\n\n\tvoid setId(String id);\n\n\tString getType();\n\n\tvoid setType(String type);\n\t\n\tvoid setImportance(Integer importance);\n\t\n\tInteger getImportance();\n\n\tvoid addCoordinate(LlaCoordinate coord);\n\t\n\tvoid setCoordinates(List<LlaCoordinate> coords);\n\n\tvoid removeCoodinate(LlaCoordinate coord);\n\n\tList<LlaCoordinate> getCoordinates();\n\n}\n"}, {"id": "SynchronizationPoint.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.sync;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * \n * Synchronization Point for routes assigned to UAVs. <br>\n * Once a {@link SynchronizationPoint} is {@link SynchronizationState#ACTIVE} by one UAV, all collaborators (i.e., registered UAV) have to reach the sync point in order to proceed.\n * \n * @author Jane Cleland-Huang\n *\n */\npublic class SynchronizationPoint {\n\tprivate String synchName;\n\tprivate Set<String> collaborators;\n\tprivate SynchronizationState synchronizationState;\n\n\tpublic SynchronizationPoint(String name) { \n\t\tsynchName = name;\n\t\tcollaborators = new HashSet<>();\n\t\tsynchronizationState = SynchronizationState.NOTACTIVATED;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn synchName + \" Members: \" + collaborators.size();\n\t}\n\n\tpublic void registerCollaborator(String UAV) {\n\t\tcollaborators.add(UAV);\n\t}\n\n\tpublic void activateSynchronizationPoint() {\n\t\tsynchronizationState = SynchronizationState.ACTIVE;\n\t}\n\n\tpublic void removeCollaborator(String uavid) {\n\t\tif (collaborators.contains(uavid)) { //It may already have been removed. Do nothing if its already removed\n\t\t\tcollaborators.remove(uavid);\n\t\t}\n\n\t\tif (collaborators.isEmpty() && synchronizationState.equals(SynchronizationState.ACTIVE))\n\t\t\tsynchronizationState = SynchronizationState.SYNCHED; // Assumes all collaborators are added before it\n\t\t// becomes active.\n\t}\n\n\tpublic int countUnsynched() {\n\t\treturn collaborators.size();\n\t}\n\n\tpublic boolean isSynched() {\n\t\treturn synchronizationState == SynchronizationState.SYNCHED;\n\t}\n}"}, {"id": "IDroneAttribute.java", "body": "package edu.nd.dronology.core.vehicle;\n\npublic interface IDroneAttribute<T> {\n\t\n\t\n\tpublic final String ATTRIBUTE_BATTERY_VOLTAGE = \"batteryVoltage\";\n\t\n\tpublic final String ATTRIBUTE_LOCATION = \"location\";\n\n\tString getKey();\n\n\tT getValue();\n\n}\n"}, {"id": "WaypointTask.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.tasks;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\npublic class WaypointTask extends AbstractMissionTask {\n\n\tprivate final LlaCoordinate coordinate;\n\n\tprotected WaypointTask(String uavID, LlaCoordinate coordinate) {\n\t\tsuper(uavID, coordinate.toString());\n\t\tthis.coordinate = coordinate;\n\t}\n\n\t@Override\n\tpublic LlaCoordinate getWaypoint() {\n\t\treturn coordinate;\n\t}\n}"}, {"id": "ModeChangeMessageTypeAdapter.java", "body": "package edu.nd.dronology.gstation.connector.messages;\n\nimport java.lang.reflect.Type;\n\nimport com.google.gson.JsonDeserializationContext;\nimport com.google.gson.JsonDeserializer;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParseException;\n\nimport edu.nd.dronology.core.vehicle.DroneFlightStateManager.FlightMode;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class ModeChangeMessageTypeAdapter implements JsonDeserializer<UAVModeChangeMessage> {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(ModeChangeMessageTypeAdapter.class);\n\n\t@Override\n\tpublic UAVModeChangeMessage deserialize(JsonElement element, Type mapType, JsonDeserializationContext arg2)\n\t\t\tthrows JsonParseException {\n\t\tJsonObject mapObject = element.getAsJsonObject();\n\t\tString uavid = mapObject.get(UAVModeChangeMessage.UAV_ID).getAsString();\n\t\tString gsid = mapObject.get(UAVModeChangeMessage.GS_ID).getAsString();\n\t\tJsonObject data = mapObject.getAsJsonObject(\"data\");\n\n\t\tString mode = data.get(UAVModeChangeMessage.MODE).getAsString();\n\n\t\tString dMode = FlightMode.USER_CONTROLLED.toString();\n\n\t\tif (\"LOITER\".equals(mode)) {\n\t\t\tdMode = FlightMode.USER_CONTROLLED.toString();\n\t\t} else if (\"STABILIZE\".equals(mode)) {\n\t\t\tdMode = FlightMode.IN_AIR.toString();\n\t\t} else if (\"GUIDED\".equals(mode)) {\n\t\t\tdMode = FlightMode.IN_AIR.toString();\n\t\t} else if (\"LAND\".equals(mode)) {\n\t\t\tdMode = FlightMode.IN_AIR.toString();\n\t\t} else {\n\t\t\tLOGGER.hwFatal(\"Mode '\" + mode + \"' not recognized!\");\n\t\t}\n\n\t\tUAVModeChangeMessage message = new UAVModeChangeMessage(gsid, uavid, dMode);\n\n\t\treturn message;\n\t}\n\n}\n"}, {"id": "LandTask.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.tasks;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\npublic class LandTask extends AbstractMissionTask {\n\n\tprivate final LlaCoordinate coordinate;\n\n\tprotected LandTask(String uavID, LlaCoordinate coordinate) {\n\t\tsuper(uavID, coordinate.toString());\n\t\tthis.coordinate = coordinate;\n\n\t}\n\n\t@Override\n\tpublic LlaCoordinate getWaypoint() {\n\t\treturn coordinate;\n\t}\n\n}"}, {"id": "IBatterySimulator.java", "body": "package edu.nd.dronology.core.simulator;\n\nimport edu.nd.dronology.core.vehicle.internal.VirtualDrone;\n\n/**\n * \n * The battery simulator simulates the battery usage / voltage drain while a {@link VirtualDrone} is in flight.\n * \n * @author Michael Vierhauser\n *\n */\npublic interface IBatterySimulator {\n\n\tvoid startBatteryDrain();\n\n\tvoid stopBatteryDrain();\n\n\tdouble getVoltage();\n\n}\n"}, {"id": "ExportRoutePrimitive.java", "body": "package edu.nd.dronology.services.core.unused;\n//package edu.nd.dronology.services.core.areamapping;\n//\n//import java.io.Serializable;\n//import java.util.Collections;\n//import java.util.List;\n//import java.util.Vector;\n//\n//import edu.nd.dronology.core.coordinate.LlaCoordinate;\n//\n//public class ExportRoutePrimitive implements Serializable{\n//\t/**\n//\t * \n//\t */\n//\tprivate static final long serialVersionUID = -7238362877727584258L;\n//\tprivate List<LlaCoordinate> routePrimitive;\n//\tprivate boolean downstreamDirection;\n//\t\n//\tpublic ExportRoutePrimitive() {\n//\t\troutePrimitive = new Vector<LlaCoordinate>();\n//\t\tdownstreamDirection = true;\n//\t}\n//\t\n//\tpublic void addRouteWaypoint(LlaCoordinate routeWaypoint) {\n//\t\troutePrimitive.add(routeWaypoint);\n//\t}\n//\t\n//\tpublic void reverseRoute() {\n//\t\tCollections.reverse(routePrimitive);\n//\t\tif(downstreamDirection) {\n//\t\t\tdownstreamDirection = false;\n//\t\t} else {\n//\t\t\tdownstreamDirection = true;\n//\t\t}\n//\t}\n//\t\n//\tpublic boolean getDownstreamDirection() {\n//\t\treturn downstreamDirection;\n//\t}\n//\t\n//\tpublic List<LlaCoordinate> getRoute(){\n//\t\treturn Collections.unmodifiableList(routePrimitive);\n//\t}\n//\t\n//\tpublic LlaCoordinate getRouteStartPoint(){\n//\t\treturn routePrimitive.get(0);\n//\t}\n//\t\n//\tpublic LlaCoordinate getRouteEndPoint(){\n//\t\treturn routePrimitive.get(size()-1);\n//\t}\n//\t\n//\tpublic LlaCoordinate getRouteWaypoint(int entry){\n//\t\treturn routePrimitive.get(entry);\n//\t}\n//\t\n//\tpublic void insertRouteWaypoint(int index, LlaCoordinate waypoint) {\n//\t\troutePrimitive.add(index, waypoint);\n//\t}\n//\t\n//\tpublic void setRouteWaypoint(int index, LlaCoordinate entry) {\n//\t\troutePrimitive.set(index, entry);\n//\t}\n//\t\n//\tpublic void setDownstreamDirection(boolean downstream) {\n//\t\tdownstreamDirection = downstream;\n//\t}\n//\t\n//\tpublic int size() {\n//\t\treturn routePrimitive.size();\n//\t}\n//}\n"}, {"id": "FlightRouteplanningServiceInstance.java", "body": "package edu.nd.dronology.services.instances.flightroute;\n\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.services.core.api.IFileChangeNotifyable;\nimport edu.nd.dronology.services.core.api.ServiceInfo;\nimport edu.nd.dronology.services.core.base.AbstractFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.info.FlightRouteCategoryInfo;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.items.FlightRoute;\nimport edu.nd.dronology.services.core.items.IFlightRoute;\nimport edu.nd.dronology.services.core.persistence.FlightRoutePersistenceProvider;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport edu.nd.dronology.services.core.util.DronologyConstants;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.core.util.ServiceIds;\nimport edu.nd.dronology.services.instances.DronologyElementFactory;\nimport edu.nd.dronology.services.supervisor.SupervisorService;\nimport edu.nd.dronology.util.FileUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * The {@link FlightRouteplanningServiceInstance} provides capabilities for retrieving {@link FlightRoute} from the file system.<br>\n * When a new {@link FlightRoute} is detected in the file system it gets automatically loaded.<br>\n * Routes are provided via {@link FlightRouteInfo} proxies containing, basic info on the flight route.\n * \n *   \n * \n * @author Michael Vierhauser\n * \n *\n */\npublic class FlightRouteplanningServiceInstance extends AbstractFileTransmitServiceInstance<FlightRouteInfo>\n\t\timplements IFileChangeNotifyable, IFlightRouteplanningServiceInstance {\n \n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(FlightRouteplanningServiceInstance.class);\n\n\tprivate static final int ORDER = 2;\n\n\tpublic static final String EXTENSION = DronologyConstants.EXTENSION_FLIGHTROUTE;\n\n\tprivate Map<String, FlightRouteInfo> flightPaths = new Hashtable<>();\n\n\tprivate Collection<FlightRouteCategoryInfo> categories = new ArrayList<>();\n\n\tpublic FlightRouteplanningServiceInstance() {\n\t\tsuper(ServiceIds.SERVICE_FLIGHROUTE, \"Routeplanning Management\", EXTENSION);\n\n\t\tcategories.add(new FlightRouteCategoryInfo(\"South-Bend Area\", \"sba\"));\n\t\tcategories.add(new FlightRouteCategoryInfo(\"River\", \"river\"));\n\t\tcategories.add(new FlightRouteCategoryInfo(\"Default\", \"Default\"));\n\t}\n\n\t@Override\n\tprotected Class<?> getServiceClass() {\n\t\treturn FlightRouteplanningService.class;\n\t}\n\n\t@Override\n\tprotected int getOrder() {\n\t\treturn ORDER;\n\t}\n\n\t@Override\n\tprotected String getPropertyPath() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void doStartService() throws Exception {\n\t\treloadItems();\n\t}\n\n\t@Override\n\tprotected void doStopService() throws Exception {\n\t\tfileManager.tearDown();\n\t}\n\n\t@Override\n\tpublic ServiceInfo getServiceInfo() {\n\t\tServiceInfo sInfo = super.getServiceInfo();\n\t\tsInfo.addAttribute(ServiceInfo.ATTRIBUTE_TYPE, ServiceInfo.ATTRIBUTE_FILE);\n\t\treturn sInfo;\n\t}\n\n\t@Override\n\tpublic FlightRouteInfo createItem() throws DronologyServiceException {\n\t\tFlightRoutePersistenceProvider persistor = FlightRoutePersistenceProvider.getInstance();\n\t\tIFlightRoute flightRoute = DronologyElementFactory.createNewFlightPath();\n\t\tflightRoute.setName(\"New-FlightRoute\");\n\t\tString savePath = FileUtil.concat(storagePath, flightRoute.getId(), EXTENSION);\n\n\t\ttry {\n\t\t\tpersistor.saveItem(flightRoute, savePath);\n\t\t} catch (PersistenceException e) {\n\t\t\tthrow new DronologyServiceException(\"Error when creating flight route: \" + e.getMessage());\n\t\t}\n\t\treturn new FlightRouteInfo(flightRoute.getName(), flightRoute.getId());\n\t}\n\n\t@Override\n\tprotected String getPath() {\n\t\tString path = SupervisorService.getInstance().getFlightPathLocation();\n\t\treturn path;\n\t}\n\n\t@Override\n\tprotected FlightRouteInfo fromFile(String id, File file) throws Throwable {\n\t\tIFlightRoute atm = FlightRoutePersistenceProvider.getInstance().loadItem(file.toURI().toURL());\n\t\tFlightRouteInfo info = new FlightRouteInfo(atm.getName(), id);\n\t\tinfo.setCategory(atm.getCategory());\n\t\tfor (Waypoint waypoint : atm.getWaypoints()) {\n\t\t\tinfo.addWaypoint(waypoint);\n\t\t}\n\n\t\tBasicFileAttributes attr = Files.readAttributes(Paths.get(file.toURI()), BasicFileAttributes.class);\n\t\tif (atm.getWaypoints().size() > 1) {\n\t\t\tdouble distance = calculateDistance(atm.getWaypoints());\n\t\t\tinfo.setRouteLength(distance);\n\t\t} else {\n\t\t\tinfo.setRouteLength(0);\n\t\t}\n\t\tinfo.setDateCreated(attr.creationTime().toMillis());\n\t\tinfo.setDateModified(attr.lastModifiedTime().toMillis());\n\t\tinfo.setDescription(atm.getDescription());\n\t\treturn info;\n\t} \n\n\tprivate double calculateDistance(List<Waypoint> waypoints) {\n\t\tLinkedList<Waypoint> ll = new LinkedList<>(waypoints);\n\t\tWaypoint current = ll.remove(0);\n\t\tdouble distance = 0;\n\t\twhile (!ll.isEmpty()) {\n\t\t\tWaypoint next = ll.remove(0);\n\t\t\tdistance += Math.abs(current.getCoordinate().distance(next.getCoordinate()));\n\t\t\tcurrent = next;\n\t\t}\n\t\treturn distance;\n\t}\n\n\t@Override\n\tprotected boolean hasProperties() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void notifyFileChange(Set<String> changed) {\n\t\tsuper.notifyFileChange(changed);\n\t\tfor (String s : changed) {\n\t\t\tString id = s.replace(\".\" + extension, \"\");\n\t\t\tif (!itemmap.containsKey(id)) {\n\t\t\t\tHashSet<Entry<String, FlightRouteInfo>> allEntries = new HashSet(flightPaths.entrySet());\n\t\t\t\tfor (Entry<String, FlightRouteInfo> e : allEntries) {\n\t\t\t\t\tif (e.getValue().getId().equals(changed)) {\n\t\t\t\t\t\tflightPaths.remove(e.getKey());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic Collection<FlightRouteCategoryInfo> getFlightPathCategories() {\n\t\treturn Collections.unmodifiableCollection(categories);\n\t}\n\n\t@Override\n\tpublic FlightRouteInfo getItem(String name) throws DronologyServiceException {\n\t\tfor (FlightRouteInfo item : itemmap.values()) {\n\t\t\tif (item.getId().equals(name)) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\t\tthrow new DronologyServiceException(\"Flighroute '\" + name + \"' not found\");\n\t}\n\n\t@Override\n\tpublic FlightRouteInfo getRouteByName(String routeName) throws DronologyServiceException {\n\t\tfor (FlightRouteInfo item : itemmap.values()) {\n\t\t\tif (item.getName().equals(routeName)) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\t\tthrow new DronologyServiceException(\"Flighroute '\" + routeName + \"' not found\");\n\t}\n}\n"}, {"id": "NVector.java", "body": "package edu.nd.dronology.core.coordinate;\n\nimport edu.nd.dronology.core.simulator.nvecsimulator.NvecInterpolator;\n\n/**\n * A terrestrial position defined by a normal vector (N-vector) and an altitude.\n * \n * An N-vector is a normal Vector that points out from the surface of the WGS-84\n * reference ellipsoid. The normal vector is combined with an altitude which\n * represents the distance above (or below) the reference ellipsoid (note this\n * is the distance above sea level as sea level is defined as the surface of the\n * ellipsoid in WGS-84). The n-vector and altitude together precisely define a\n * position on Earth. The n-vector should be a unit vector (i.e. a vector with a\n * magnitude = 1). The altitude should be in meters.\n *  \n * @author Michael Murphy \n *  \n */ \npublic class NVector extends AbstractPosition {\n\n\tpublic static final double SEMI_MAJOR = 6378137.0;\n\tpublic static final double SEMI_MINOR = 6356752.31;// 4245;\n\n\tprivate double x;\n\n\tprivate double y;\n\n\tprivate double z;\n\n\tprivate double altitude;\n\n\t/**\n\t * \n\t * @param x\n\t *            the x component of the normal vector\n\t * @param y\n\t *            the y component of the normal vector\n\t * @param z\n\t *            the z component of the normal vector\n\t * @param altitude\n\t *            the distance above the reference ellipsoid (negative altitudes\n\t *            represent altitude below this ellipsoid).\n\t */\n\tpublic NVector(double x, double y, double z, double altitude) {\n\t\tdouble m = Math.sqrt(x * x + y * y + z * z);\n\t\tthis.x = x / m;\n\t\tthis.y = y / m;\n\t\tthis.z = z / m;\n\t\tthis.altitude = altitude;\n\t}\n\n\t@Override\n\tpublic NVector toNVector() {\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tlong temp;\n\t\ttemp = Double.doubleToLongBits(x);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\ttemp = Double.doubleToLongBits(y);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\ttemp = Double.doubleToLongBits(z);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\ttemp = Double.doubleToLongBits(altitude);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (!(obj instanceof NVector))\n\t\t\treturn false;\n\t\tNVector other = (NVector) obj;\n\t\tif (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))\n\t\t\treturn false;\n\t\tif (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))\n\t\t\treturn false;\n\t\tif (Double.doubleToLongBits(z) != Double.doubleToLongBits(other.z))\n\t\t\treturn false;\n\t\tif (Double.doubleToLongBits(altitude) != Double.doubleToLongBits(other.altitude))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn String.format(\"NVector(%f, %f, %f, altitude=%f)\", x, y, z, altitude);\n\t}\n\n\t/**\n\t * @return the distance above sea level in meters\n\t */\n\tpublic double getAltitude() {\n\t\treturn altitude;\n\t}\n\n\t/**\n\t * @return the x component of the n-vector\n\t */\n\tpublic double getX() {\n\t\treturn x;\n\t}\n\n\t/**\n\t * @return the y component of the n-vector\n\t */\n\tpublic double getY() {\n\t\treturn y;\n\t}\n\n\t/**\n\t * @return the z component of the n-vector\n\t */\n\tpublic double getZ() {\n\t\treturn z;\n\t}\n\n\t/**\n\t * Finds the distance in meters from this NVector to another.\n\t * \n\t * This is the distance that a laser would travel.\n\t * \n\t * @param other\n\t *            the other position to find the position to.\n\t * @return The distance from this position to the other in meters\n\t */\n\tpublic double distance(NVector other) {\n\t\tPVector pSelf = toPVector();\n\t\tPVector pOther = other.toPVector();\n\t\tdouble dx = pSelf.getX() - pOther.getX();\n\t\tdouble dy = pSelf.getY() - pOther.getY();\n\t\tdouble dz = pSelf.getZ() - pOther.getZ();\n\t\treturn Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n\t}\n\n\t/**\n\t * @return a terrestrial position defined by an x, y, and z coordinate in an\n\t *         Earth centered Earth fixed reference frame.\n\t */\n\t@Override\n\tpublic PVector toPVector() {\n\t\t/*\n\t\t * The formula this code is based on can be found in a journal article\n\t\t * called: \"A Non-singular Horizontal Position Representation\" by\n\t\t * Kenneth Gade. You can find it at https://goo.gl/iCqdCn (see equation\n\t\t * 22 in appendix B)\n\t\t * \n\t\t * Note: equation 22 is unconventional as it swaps the z component with\n\t\t * x component. This code follows the more common convention and returns\n\t\t * z and x to their proper place\n\t\t */\n\t\tdouble a = SEMI_MAJOR;\n\t\tdouble b = SEMI_MINOR;\n\t\tdouble ab2 = (a * a) / (b * b);\n\t\tdouble f = b / Math.sqrt(z * z + ab2 * y * y + ab2 * x * x);\n\t\tdouble pz = f * z + altitude * z;\n\t\tdouble py = f * ab2 * y + altitude * y;\n\t\tdouble px = f * ab2 * x + altitude * x;\n\t\treturn new PVector(px, py, pz);\n\t}\n\n\t/**\n\t * @return a terrestrial position defined by a latitude, longitude, and\n\t *         altitude.\n\t */\n\t@Override\n\tpublic LlaCoordinate toLlaCoordinate() {\n\t\tdouble lat = Math.atan2(this.getZ(), Math.sqrt(this.getX() * this.getX() + this.getY() * this.getY()));\n\t\tdouble lon = Math.atan2(this.getY(), this.getX());\n\t\treturn new LlaCoordinate(Math.toDegrees(lat), Math.toDegrees(lon), this.getAltitude());\n\t}\n\t\n\tpublic static double laserDistance(NVector a, NVector b) {\n\t\tPVector pa = a.toPVector();\n\t\tPVector pb = b.toPVector();\n\t\tdouble dx = pa.getX() - pb.getX();\n\t\tdouble dy = pa.getY() - pb.getY();\n\t\tdouble dz = pa.getZ() - pb.getZ();\n\t\treturn Math.sqrt(dx * dx + dy * dy + dz * dz);\n\t}\n\t\n\tpublic static double travelDistance(NVector a, NVector b, double stepDistance) {\n\t\tdouble dist = 0.0;\n\t\tNVector current = a;\n\t\twhile (current.distance(b) > stepDistance) {\n\t\t\tcurrent = NvecInterpolator.move(current, b, 1.0);\n\t\t\tdist += stepDistance;\n\t\t}\n\t\tdist += current.distance(b);\n\t\treturn dist;\n\t}\n\t\n\tpublic static double travelDistance(NVector a, NVector b) {\n\t\treturn travelDistance(a, b, 1.0);\n\t}\n\n}\n"}, {"id": "DistanceUtil.java", "body": "package edu.nd.dronology.core.util;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.util.NullUtil;\n\npublic class DistanceUtil {\n\n\t/**\n\t * Calculate distance between two points in latitude and longitude taking into account height difference. If you are not interested in height difference pass 0.0. Uses Haversine method as its base.\n\t * \n\t * lat1, lon1 Start point lat2, lon2 End point el1 Start altitude in meters el2 End altitude in meters\n\t * \n\t * @returns Distance in Meters\n\t */\n\tpublic static double distance(double lat1, double lat2, double lon1, double lon2, double el1, double el2) {\n\n\t\t// lat1 = lat1/1000000;\n\t\t// lat2 = lat2/1000000;\n\t\t// lon1 = lon1/1000000;\n\t\t// lon2 = lon2/1000000;\n\t\tfinal int R = 6371; // Radius of the earth\n\n\t\tdouble latDistance = Math.toRadians(lat2 - lat1);\n\t\tdouble lonDistance = Math.toRadians(lon2 - lon1);\n\t\tdouble a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2) + Math.cos(Math.toRadians(lat1))\n\t\t\t\t* Math.cos(Math.toRadians(lat2)) * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);\n\t\tdouble c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\t\tdouble distance = R * c * 1000; // convert to meters\n\n\t\tdouble height = el1 - el2;\n\n\t\tdistance = Math.pow(distance, 2) + Math.pow(height, 2);\n\n\t\treturn Math.sqrt(distance);\n\t}\n\n\tpublic static double distance(LlaCoordinate currentPosition, LlaCoordinate targetPosition) {\n\t\treturn distance(currentPosition.getLatitude(), targetPosition.getLatitude(), currentPosition.getLongitude(),\n\t\t\t\ttargetPosition.getLongitude(), 0, 0);\n\t}\n\n\tpublic static double calculateTotalDistance(LlaCoordinate... coordinates) {\n\t\tNullUtil.checkArrayNull(coordinates);\n\t\tif (coordinates.length < 2) {\n\t\t\tthrow new IllegalArgumentException(\"At least 2 coordinates are required to calculate the distance between them!\");\n\t\t}\n\t\tdouble totaldistance = 0;\n\t\tfor (int i = 0; i < coordinates.length; i++) {\n\t\t\tLlaCoordinate current = coordinates[i];\n\t\t\tif (coordinates.length < (i + 2)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tLlaCoordinate next = coordinates[i + 1];\n\t\t\ttotaldistance = distance(current, next);\n\t\t}\n\t\treturn totaldistance;\n\t}\n\n}\n"}, {"id": "UAVProxy.java", "body": "package edu.nd.dronology.core.vehicle.proxy;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\n\n/**\n * \n * Proxy class for Manged Drones. <br>\n * This datastructure is intended to be passed to external clients and contains\n * necessary information regarding the actual UAV managed by Dronology\n *\n */\npublic class UAVProxy implements Serializable, IUAVProxy {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -3319827887969940655L;\n\tprivate volatile double latitude;\n\tprivate volatile double longitude;\n\tprivate volatile double altitude;\n\tprivate final String ID;\n\tprivate volatile double batteryLevel;\n\tprivate volatile double velocity;\n\tprivate Map<String, String> info;\n\tprivate String status;\n\tprivate String groundstationId;\n\tprivate LlaCoordinate home;\n\n\tpublic UAVProxy(String ID, long latitude, long longitude, int altitude, double batteryLevel, double velocity) {\n\t\tthis.ID = ID;\n\t\tthis.latitude = latitude;\n\t\tthis.longitude = longitude;\n\t\tthis.altitude = altitude;\n\t\tthis.batteryLevel = batteryLevel;\n\t\tthis.velocity = velocity;\n\t\tinfo = new HashMap<>();\n\t\tstatus = \"UNKNOWN\";\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getID()\n\t */\n\t@Override\n\tpublic String getID() {\n\t\treturn ID;\n\t}\n\n\t@Override\n\tpublic String getGroundstationId() {\n\t\treturn groundstationId;\n\t}\n\n\tpublic void setStatus(String status) {\n\t\tthis.status = status;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getStatus()\n\t */\n\t@Override\n\tpublic String getStatus() {\n\t\treturn status;\n\t}\n\n\tpublic void updateCoordinates(double latitude, double longitude, double altitude) {\n\t\tthis.latitude = latitude;\n\t\tthis.longitude = longitude;\n\t\tthis.altitude = altitude;\n\t}\n\n\tpublic void updateBatteryLevel(double batteryLevel) {\n\t\tthis.batteryLevel = batteryLevel;\n\t}\n\n\tpublic void updateVelocity(double velocity) {\n\t\tthis.velocity = velocity;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"ID: \" + ID + \" Pos: (\" + latitude + \",\" + longitude + \",\" + altitude + \") \" + \" Vel: \" + velocity\n\t\t\t\t+ \" Bat: \" + batteryLevel + \" --- \" + this.status;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn 17 + ID.hashCode();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getLongitude()\n\t */\n\t@Override\n\tpublic double getLongitude() {\n\t\treturn longitude;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getLatitude()\n\t */\n\t@Override\n\tpublic double getLatitude() {\n\t\treturn latitude;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getAltitude()\n\t */\n\t@Override\n\tpublic double getAltitude() {\n\t\treturn altitude;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getBatteryLevel()\n\t */\n\t@Override\n\tpublic double getBatteryLevel() {\n\t\treturn batteryLevel;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getVelocity()\n\t */\n\t@Override\n\tpublic double getVelocity() {\n\t\treturn velocity;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getInfo()\n\t */\n\t@Override\n\tpublic Map<String, String> getInfo() {\n\t\treturn info;\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getCoordinates()\n\t */\n\t@Override\n\tpublic LlaCoordinate getCoordinates() {\n\t\treturn new LlaCoordinate(latitude, longitude, altitude);\n\t}\n\n\tpublic void setVelocity(double velocity) {\n\t\tthis.velocity = velocity;\n\n\t}\n\n\tpublic void setGroundstationId(String groundstationId) {\n\t\tthis.groundstationId = groundstationId;\n\n\t}\n\n\t@Override\n\tpublic LlaCoordinate getHomeLocation() {\n\t\treturn home;\n\t}\n\n\tpublic void setHomeLocation(LlaCoordinate home) {\n\t\tthis.home = home;\n\n\t}\n\n}\n"}, {"id": "RemoteConnectionServiceInstance.java", "body": "package edu.nd.dronology.services.instances.remote;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Timer;\n\nimport edu.nd.dronology.services.core.api.ServiceInfo;\nimport edu.nd.dronology.services.core.base.AbstractRegisterableUnit;\nimport edu.nd.dronology.services.core.base.AbstractServiceInstance;\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\nimport edu.nd.dronology.services.core.remote.RemoteInfo;\nimport edu.nd.dronology.services.core.util.ServiceIds;\nimport edu.nd.dronology.services.remote.RemoteService;\nimport edu.nd.dronology.services.remote.rmi.RemoteManagerFactory;\nimport edu.nd.dronology.util.Immutables;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class RemoteConnectionServiceInstance extends AbstractServiceInstance implements\n\t\tIRemoteConnectionServiceInstance {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -8000279798861818920L;\n\tboolean started = false;\n\t// private AbstractRMIRemoteObject remoteObject;\n//\tprivate RemoteLogger remoteLogger;\n\t//private RemoteConnectionServiceInstance.CheckConnectionTask connectionTask;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(RemoteConnectionServiceInstance.class);\n\n\tList<IRemoteManager> remoteManager = new ArrayList<>();\n\n\tprivate static final Map<String, RemoteInfo> clients = new Hashtable<>();\n\tprivate Timer timer;\n\n\tpublic RemoteConnectionServiceInstance() {\n\t\tsuper(ServiceIds.SERVICE_REMOTE, \"Managing remote connections\");\n\t\ttimer = new Timer();\n\t}\n\n\t@Override\n\tprotected void doStartService() throws Exception {\n\t\tProperties prp = getConfigurationProperties();\n\t\tList<IRemoteManager> rmiObjects;\n\t\tif (prp.get(PORT_PROPERTY) != null) {\n\t\t\t// remoteObject = RemoteRMIRemoteObject.getInstance(Integer.parseInt((String) prp.get(PORT_PROPERTY)));\n\t\t\trmiObjects = RemoteManagerFactory.createRMIObjects(Integer.parseInt((String) prp.get(PORT_PROPERTY)));\n\n\t\t} else {\n\t\t\t// remoteObject = RemoteRMIRemoteObject.getInstance(null);\n\t\t\trmiObjects = RemoteManagerFactory.createRMIObjects(null);\n\t\t}\n\t\tremoteManager.addAll(rmiObjects);\n\n\t\tstarted = true;\n//\t\tremoteLogger = new RemoteLogger();\n//\t\tremoteLogger.start();\n\n\t\tfor (IRemoteManager mng : remoteManager) {\n\t\t\tmng.initialize();\n\t\t}\n\n//\t\tconnectionTask = new CheckConnectionTask();\n//\t\ttimer.scheduleAtFixedRate(connectionTask, 10000, 60000);\n\t}\n\n\t@Override\n\tprotected void doStopService() throws Exception {\n\t\tstarted = false;\n\n\t\tfor (IRemoteManager mng : remoteManager) {\n\t\t\tmng.tearDown();\n\t\t}\n\n\n\t}\n\n\t@Override\n\tprotected String getPropertyPath() {\n\t\treturn \"config/remoteServer.properties\";\n\t}\n\n\t@Override\n\tpublic void register(RemoteInfo rInfo) {\n\t\tlong timeStamp = System.currentTimeMillis();\n\t\trInfo.addAttribute(AbstractRegisterableUnit.TIMESTAMP, Long.toString(timeStamp));\n\t\tif (clients.containsKey(rInfo.getID())) {\n\t\t\tLOGGER.info(\"Keep alive received: \" + rInfo.toString());\n\t\t} else {\n\t\t\tLOGGER.info(\"Remote client registered: \" + rInfo.toString());\n\t\t}\n\t\tclients.put(rInfo.getID(), rInfo);\n\t}\n\n\t@Override\n\tpublic void unregister(RemoteInfo rInfo) {\n\t\tclients.remove(rInfo);\n\t}\n\n\t@Override\n\tpublic Collection<RemoteInfo> getRegisteredRemoteClients() {\n\t\tsynchronized (clients) {\n\t\t\treturn Immutables.linkedListCopy(clients.values());\n\t\t}\n\t}\n\n\t@Override\n\tprotected Class<?> getServiceClass() {\n\t\treturn RemoteService.class;\n\t}\n\n//\t@Override\n//\tpublic void logExternal(LogEventAdapter event) {\n//\t\tremoteLogger.logExternal(event);\n//\t}\n\n\t@Override\n\tprotected int getOrder() {\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic ServiceInfo getServiceInfo() {\n\t\tServiceInfo sInfo = super.getServiceInfo();\n\t\tsInfo.addAttribute(ServiceInfo.ATTRIBUTE_TYPE, ServiceInfo.ATTRIBUTE_REMOTE);\n\t\treturn sInfo;\n\t}\n\n//\tprivate class CheckConnectionTask extends TimerTask {\n//\n//\t\t@Override\n//\t\tpublic void run() {\n//\t\t\tfor (RemoteInfo info : getRegisteredRemoteClients()) {\n//\t\t\t\tif (!UnitUtil.isAlive(info)) {\n//\t\t\t\t\tunregister(info);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t}\n\n\t@Override\n\tpublic void addRemoteManager(IRemoteManager manager) {\n\t\tremoteManager.add(manager);\n\t\t\n\t}\n}\n"}, {"id": "MissionPlanningServiceRemoteFacade.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.service;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\n\nimport edu.nd.dronology.services.core.info.MissionInfo;\nimport edu.nd.dronology.services.core.info.UAVMappingInfo;\nimport edu.nd.dronology.services.core.listener.IItemChangeListener;\nimport edu.nd.dronology.services.core.remote.IMissionPlanningRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.extensions.missionplanning.service.internal.MissionPlanningService;\nimport edu.nd.dronology.services.instances.flightmanager.FlightManagerService;\nimport edu.nd.dronology.services.remote.AbstractRemoteFacade;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Remote facade for handling MissionPlanning<br>\n * Initial implementation of mission planning capabilities. <br>\n * Allows retrieving sending a mission plan as JSON String to Dronology.\n * \n * \n * @author Michael Vierhauser\n *\n */\npublic class MissionPlanningServiceRemoteFacade extends AbstractRemoteFacade implements IMissionPlanningRemoteService {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -4580658378477037955L;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(MissionPlanningServiceRemoteFacade.class);\n\tprivate static volatile MissionPlanningServiceRemoteFacade INSTANCE;\n\n\tprotected MissionPlanningServiceRemoteFacade() throws RemoteException {\n\t\tsuper(FlightManagerService.getInstance());\n\t}\n\n\tpublic static IMissionPlanningRemoteService getInstance() throws RemoteException {\n\t\tif (INSTANCE == null) {\n\t\t\ttry {\n\t\t\t\tsynchronized (MissionPlanningServiceRemoteFacade.class) {\n\t\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\t\tINSTANCE = new MissionPlanningServiceRemoteFacade();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} catch (RemoteException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tpublic void executeMissionPlan(String mission) throws RemoteException, DronologyServiceException {\n\t\tMissionPlanningService.getInstance().executeMissionPlan(mission);\n\n\t}\n\n\t@Override\n\tpublic void executeMissionPlan(MissionInfo info) throws RemoteException, DronologyServiceException {\n\t\tMissionPlanningService.getInstance().executeMissionPlan(info);\n\n\t}\n\n\t@Override\n\tpublic void cancelMission() throws RemoteException, DronologyServiceException {\n\t\tMissionPlanningService.getInstance().cancelMission();\n\n\t}\n\n\t@Override\n\tpublic byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException {\n\t\treturn MissionPlanningService.getInstance().requestFromServer(id);\n\t}\n\n\t@Override\n\tpublic void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException {\n\t\tMissionPlanningService.getInstance().transmitToServer(id, content);\n\t}\n\n\t@Override\n\tpublic boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException {\n\t\treturn MissionPlanningService.getInstance().addItemChangeListener(listener);\n\t}\n\n\t@Override\n\tpublic boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException {\n\t\treturn MissionPlanningService.getInstance().removeItemChangeListener(listener);\n\n\t}\n\n\t@Override\n\tpublic Collection<MissionInfo> getItems() throws RemoteException {\n\t\treturn MissionPlanningService.getInstance().getItems();\n\n\t}\n\n\t@Override\n\tpublic MissionInfo createItem() throws RemoteException, DronologyServiceException {\n\t\treturn MissionPlanningService.getInstance().createItem();\n\n\t}\n\n\t@Override\n\tpublic void deleteItem(String itemid) throws RemoteException, DronologyServiceException {\n\t\tMissionPlanningService.getInstance().deleteItem(itemid);\n\n\t}\n\n\t@Override\n\tpublic void executeMissionPlan(MissionInfo mission, UAVMappingInfo mapping)\n\t\t\tthrows RemoteException, DronologyServiceException {\n\t\tMissionPlanningService.getInstance().executeMissionPlan(mission, mapping);\n\n\t}\n\n}"}, {"id": "IDroneSetupRemoteService.java", "body": "package edu.nd.dronology.services.core.remote;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo;\nimport edu.nd.dronology.services.core.listener.IDroneStatusChangeListener;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n/**\n * \n * Remote Interface for handling UAVs.<br>\n * Allows initializing new UAVs. <br>\n * Allows retrieving active UAVs which returns a proxy ({@link IUAVProxy}) of the actual physical or virtual uav.\n * \n * \n * @author Michael Vierhauser\n *\n */\npublic interface IDroneSetupRemoteService extends IRemoteableService {\n\n\tCollection<IUAVProxy> getActiveUAVs() throws RemoteException;\n\n\tvoid initializeDrones(DroneInitializationInfo... info) throws RemoteException, DronologyServiceException;\n\n\tvoid addDroneStatusChangeListener(IDroneStatusChangeListener listener)\n\t\t\tthrows RemoteException, DronologyServiceException;\n\n\tvoid removeDroneStatusChangeListener(IDroneStatusChangeListener listener)\n\t\t\tthrows RemoteException, DronologyServiceException;\n\n\tvoid resendCommand(String uavid) throws RemoteException, DronologyServiceException;\n\n}\n"}, {"id": "StopExecutorViaReverse.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal;\n\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.vehicle.IDrone;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\n\npublic class StopExecutorViaReverse implements CommandExecutor {\n\n    enum StopExecutionState {\n        RADIOING_REVERSE,\n        WAITING_TO_REVERSE,\n        RADIOING_STOP,\n        WATCHING_THE_CLOCK,\n        WAITING_FOREVER,\n        FINISHED;\n    }\n\n    // seconds to wait after sending reverse NED command before sending NED(0,0,0) command\n    private static final double REVERSAL_WAIT_TIME = 2.0;\n\n    // how fast should the UAV reverse to stop\n    private static final double REVERSAL_SPEED = 7.0;\n\n    private IDrone drone;\n    StopExecutionState state = StopExecutionState.RADIOING_REVERSE;\n    StopCommand data;\n    long reverseRadioTime;\n    long startTime;\n\n    public StopExecutorViaReverse(IDrone drone, StopCommand data) {\n        this.drone = drone;\n        this.data = data;\n    }\n\n    @Override\n    public void process() {\n        switch (state) {\n            case RADIOING_REVERSE:\n                radioReverse();\n                break;\n            case WAITING_TO_REVERSE:\n                waitForReversal();\n                break;\n            case RADIOING_STOP:\n                radioStop();\n                break;\n            case WATCHING_THE_CLOCK:\n                checkClock();\n                break;\n\n            case WAITING_FOREVER:\n            case FINISHED:\n            default:\n                // Do nothing.\n                break;\n        }\n    }\n\n    private void radioReverse() {\n        //should this flatten? what if the UAV is going up?\n        Vector3D reverseNED = drone.getLatestDroneSnapshot().getVelocity().scalarMultiply(-1.0).normalize().scalarMultiply(REVERSAL_SPEED);\n        drone.setVelocity(reverseNED.getX(), reverseNED.getY(), reverseNED.getZ());\n        reverseRadioTime = System.nanoTime();\n        state = StopExecutionState.WAITING_TO_REVERSE;\n    }\n\n    private void waitForReversal() {\n        double reversalWaitTimer = (System.nanoTime() - reverseRadioTime) * 1.0e-9;\n        if (REVERSAL_WAIT_TIME < reversalWaitTimer) {\n            state = StopExecutionState.RADIOING_STOP;\n        }\n    }\n\n    private void radioStop() {\n        drone.setVelocity(0.0, 0.0, 0.0);\n\n        double waitDuration = data.getTime();\n        if (waitDuration > 0.0) {\n            startTime = System.nanoTime();\n            state = StopExecutionState.WATCHING_THE_CLOCK;\n        }\n        else {\n            state = StopExecutionState.WAITING_FOREVER;\n        }\n    }\n\n    private void checkClock() {\n        double waitDuration = data.getTime();\n        long deltaNano = System.nanoTime()- startTime;\n        double deltaT = deltaNano * 1.0e-9;\n        if (deltaT > waitDuration) {\n            state = StopExecutionState.FINISHED;\n        }\n    }\n\n    @Override\n    public boolean isFinished() {\n        return state == StopExecutionState.FINISHED;\n    }\n\n}\n"}, {"id": "FlightRouteplanningServiceRemoteFacade.java", "body": "package edu.nd.dronology.services.facades;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\n\nimport edu.nd.dronology.services.core.info.FlightRouteCategoryInfo;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.listener.IItemChangeListener;\nimport edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.instances.flightroute.FlightRouteplanningService;\nimport edu.nd.dronology.services.remote.AbstractRemoteFacade;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Remote facade for handling UAV routes<br>\n * Allows creating and modifying routes.\n * \n * \n * @author Michael Vierhauser\n * \n */\npublic class FlightRouteplanningServiceRemoteFacade extends AbstractRemoteFacade\n\t\timplements IFlightRouteplanningRemoteService {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -4580658378477037955L;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(FlightRouteplanningServiceRemoteFacade.class);\n\tprivate static volatile FlightRouteplanningServiceRemoteFacade INSTANCE;\n\n\tprotected FlightRouteplanningServiceRemoteFacade() throws RemoteException {\n\t\tsuper(FlightRouteplanningService.getInstance());\n\t}\n\n\tpublic static IFlightRouteplanningRemoteService getInstance() throws RemoteException {\n\t\tif (INSTANCE == null) {\n\t\t\ttry {\n\t\t\t\tsynchronized (FlightRouteplanningServiceRemoteFacade.class) {\n\t\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\t\tINSTANCE = new FlightRouteplanningServiceRemoteFacade();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (RemoteException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tpublic byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException {\n\t\treturn FlightRouteplanningService.getInstance().requestFromServer(id);\n\t}\n\n\t@Override\n\tpublic void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException {\n\t\tFlightRouteplanningService.getInstance().transmitToServer(id, content);\n\n\t}\n\n\t@Override\n\tpublic boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException {\n\t\treturn FlightRouteplanningService.getInstance().addItemChangeListener(listener);\n\t}\n\n\t@Override\n\tpublic boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException {\n\t\treturn FlightRouteplanningService.getInstance().removeItemChangeListener(listener);\n\t}\n\n\t@Override\n\tpublic Collection<FlightRouteInfo> getItems() throws RemoteException {\n\t\treturn FlightRouteplanningService.getInstance().getItems();\n\t}\n\n\t@Override\n\tpublic FlightRouteInfo createItem() throws RemoteException, DronologyServiceException {\n\t\treturn FlightRouteplanningService.getInstance().createItem();\n\t}\n\n\t@Override\n\tpublic void deleteItem(String itemid) throws RemoteException, DronologyServiceException {\n\t\tFlightRouteplanningService.getInstance().deleteItem(itemid);\n\n\t}\n\n\t@Override\n\tpublic Collection<FlightRouteCategoryInfo> getFlightPathCategories() {\n\t\treturn FlightRouteplanningService.getInstance().getFlightPathCategories();\n\t}\n\n}"}, {"id": "PhysicalDroneFleetFactory.java", "body": "package edu.nd.dronology.core.fleet;\n\nimport edu.nd.dronology.core.Discuss;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.monitoring.DronologyMonitoringManager;\nimport edu.nd.dronology.core.monitoring.MessageMarshaller;\nimport edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;\nimport edu.nd.dronology.core.vehicle.IDrone;\nimport edu.nd.dronology.core.vehicle.IDroneCommandHandler;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\nimport edu.nd.dronology.core.vehicle.internal.PhysicalDrone;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * Factory class for initializing a new {@link PhysicalDrone} instance.\n *  \n * @author Jane Cleland-Huang\n *  \n */\npublic class PhysicalDroneFleetFactory extends AbstractDroneFleetFactory {\n \n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(PhysicalDroneFleetFactory.class);\n\n\tprivate static volatile PhysicalDroneFleetFactory INSTANCE = null;\n\tprivate IDroneCommandHandler commandHandler;\n\n\tprotected PhysicalDroneFleetFactory() {\n\t}\n\n\tpublic void setCommandHandler(IDroneCommandHandler commandHandler) {\n\t\tthis.commandHandler = commandHandler;\n\t}\n\n\tpublic static PhysicalDroneFleetFactory getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (PhysicalDroneFleetFactory.class) {\n\t\t\t\tif (INSTANCE == null) { \n\t\t\t\t\tINSTANCE = new PhysicalDroneFleetFactory();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\t@Discuss(discuss = \"todo: fligh to altitude 10... workaround just for testing purposes... needs to be fixed..\")\n\tpublic ManagedDrone initializeDrone(String droneID, String droneType, double latitude, double longitude,\n\t\t\tdouble altitude) throws DroneException {\n\n\t\tString[] ids = droneID.split(\":\"); \n\t\tif (ids.length != 2) {\n\t\t\tthrow new DroneException(\"Invalid drone id '\" + droneID + \"' --> - droneid:groundstationid\");\n\t\t}\n\t\tString drnId = ids[0];\n\t\tString groundstationid = ids[1];\n\n\t\tIDrone drone = new PhysicalDrone(createDroneID(drnId),\n\t\t\t\tRuntimeDroneTypes.getInstance().getCommandHandler(groundstationid));\n\t\tManagedDrone managedDrone = new ManagedDrone(drone);\n\t\tdrone.setManagedDrone(managedDrone);\n\n\t\tLlaCoordinate currentPosition = new LlaCoordinate(latitude, longitude, 10);\n\t\tLOGGER.info(\"Drone initialized at: \" + currentPosition.toString());\n\t\tDronologyMonitoringManager.getInstance().publish(MessageMarshaller\n\t\t\t\t.createMessage(MessageType.PHYSICAL_UAV_ACTIVATED, drone.getDroneName(), currentPosition));\n\n\t\tdrone.setBaseCoordinates(currentPosition);\n\t\tdrone.setCoordinates(currentPosition.getLatitude(), currentPosition.getLongitude(), currentPosition.getAltitude());\n\t\tmanagedDrone.start();\n\t\tDroneFleetManager.getInstance().addDrone(managedDrone);\n\t\treturn managedDrone;\n\t}\n}"}, {"id": "RRDemoScript.java", "body": "package edu.nd.dronology.misc.scripts;\n\nimport java.net.MalformedURLException;\nimport java.rmi.Naming;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;\nimport edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic class RRDemoScript {\n\n\tprivate static final String ADDRESS_SCHEME = \"rmi://%s:%s/Remote\";\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\n\t\t\tIRemoteManager manager = (IRemoteManager) Naming.lookup(String.format(ADDRESS_SCHEME, \"127.0.0.1\", 9779));\n\n\t\t\t// IDroneSetupRemoteService service = (IDroneSetupRemoteService)\n\t\t\t// manager.getService(IDroneSetupRemoteService.class);\n\t\t\t//\n\t\t\tIFlightManagerRemoteService managerService = (IFlightManagerRemoteService) manager\n\t\t\t\t\t.getService(IFlightManagerRemoteService.class);\n\n\t\t\tIFlightRouteplanningRemoteService planningService = (IFlightRouteplanningRemoteService) manager\n\t\t\t\t\t.getService(IFlightRouteplanningRemoteService.class);\n\t\t\t//\n\n\t\t\tList<FlightRouteInfo> allRoutes = new ArrayList<>(planningService.getItems());\n\n\t\t\tfor (FlightRouteInfo r : allRoutes) {\n\t\t\t\tSystem.out.println(r.getName());\n\n\t\t\t}\n\n\t\t\tFlightRouteInfo r1 = getRouteByName(\"RR2_SouthArea\", allRoutes);\n\t\t\tFlightRouteInfo r2 = getRouteByName(\"RR3A_RiverBank\", allRoutes);\n\t\t\tFlightRouteInfo r3 = getRouteByName(\"RR3B_RiverBank\", allRoutes);\n\t\t\tFlightRouteInfo r4 = getRouteByName(\"RR4A_RiverBank2\", allRoutes);\n\t\t\tFlightRouteInfo r5 = getRouteByName(\"RR4B_RiverBank2\", allRoutes);\n\n\t\t\tif (r1 == null) {\n\t\t\t\tSystem.out.println(\"RR2_SouthArea not found!!!\");\n\t\t\t}\n\t\t\tif (r2 == null) {\n\t\t\t\tSystem.out.println(\"RR3A_RiverBank not found!!!\");\n\t\t\t}\n\t\t\tif (r3 == null) {\n\t\t\t\tSystem.out.println(\"RR3B_RiverBank not found!!!\");\n\t\t\t}\n\t\t\tif (r4 == null) {\n\t\t\t\tSystem.out.println(\"RR4A_RiverBank2 not found!!!\");\n\t\t\t}\n\t\t\tif (r5 == null) {\n\t\t\t\tSystem.out.println(\"RR4B_RiverBank2 not found!!!\");\n\t\t\t}\n\n\t\t\tmanagerService.planFlight(\"SBFD-2\", \"RR2_SouthArea\", r1.getWaypoints());\n\t\t\tmanagerService.planFlight(\"SBFD-3\", \"RR3A_RiverBank\", r2.getWaypoints());\n\t\t\tmanagerService.planFlight(\"SBFD-3\", \"RR3B_RiverBank\", r3.getWaypoints());\n\t\t\tmanagerService.planFlight(\"SBFD-4\", \"RR4A_RiverBank2\", r4.getWaypoints());\n\t\t\tmanagerService.planFlight(\"SBFD-4\", \"RR4B_RiverBank2\", r5.getWaypoints());\n\t\t\tThread.sleep(2000);\n\n\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedURLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (NotBoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tprivate static FlightRouteInfo getRouteByName(String name, List<FlightRouteInfo> allRoutes) {\n\t\tfor (FlightRouteInfo r : allRoutes) {\n\t\t\tif (r.getName().equals(name)) {\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic Random rand = new Random();\n\n}\n"}, {"id": "JsonTester2.java", "body": "package edu.nd.dronology.misc.gcs;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.util.Map;\n\nimport org.apache.commons.io.FileUtils;\n\nimport com.google.gson.FieldNamingPolicy;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\nimport edu.nd.dronology.gstation.connector.messages.StateMessageTypeAdapter;\nimport edu.nd.dronology.gstation.connector.messages.UAVStateMessage;\n\npublic class JsonTester2 {\n\n\tstatic final Gson GSON = new GsonBuilder().serializeNulls()\n\t\t\t.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)\n\t\t\t.setVersion(1.0).serializeSpecialFloatingPointValues().registerTypeAdapter(Map.class, new StateMessageTypeAdapter()).create();\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString string = FileUtils.readFileToString(new File(\"D:\\\\state.txt\"));\n\n\t\t\tUAVStateMessage message = GSON.fromJson(string, UAVStateMessage.class);\n\t\t\n\t\t\t\n\t\t\tSystem.out.println(message.getLocation());\n\t\t\tSystem.out.println(message.getGroundspeed());\n\t\t\tSystem.out.println(message.getUavid());\n\t\t\tSystem.out.println(message.getAttitude());\n\t\t\tSystem.out.println(message.getBatterystatus());\n\t\t\tSystem.out.println(message.getMode());\n\t\t\tSystem.out.println(message.getStatus());\n\t\t\tSystem.out.println(message.getVelocity());\n\t\t\tSystem.out.println(message.getLocation());\n\t\t\tSystem.out.println(message.getLocation());\n\t\t\tSystem.out.println(message.getLocation());\n\t\t\t\n\t\t\t\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n}\n"}, {"id": "DroneCollectionStatus.java", "body": "package edu.nd.dronology.core.status;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.core.vehicle.proxy.UAVProxy;\nimport edu.nd.dronology.util.Immutables;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n// Singleton class\npublic class DroneCollectionStatus {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(DroneCollectionStatus.class);\n\n\tprivate Map<String, UAVProxy> drones;\n\tprivate static volatile DroneCollectionStatus INSTANCE = null;\n\n\tprotected DroneCollectionStatus() {\n\t\tdrones = new HashMap<>();\n\t}\n\n\tpublic static DroneCollectionStatus getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (DroneCollectionStatus.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new DroneCollectionStatus();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\tpublic void testStatus() {\n\t\tLOGGER.info(\"Print current drone dump\");\n\t\tfor (UAVProxy droneStatus : drones.values()) {\n\t\t\tLOGGER.info(droneStatus.toString());\n\t\t}\n\t}\n\n\tpublic Map<String, UAVProxy> getDrones() {\n\t\treturn Immutables.hashMapCopy(drones);\n\t}\n\n\tpublic void addDrone(UAVProxy drone) {\n\t\tdrones.put(drone.getID(), drone);\n\t}\n\n\tpublic void removeDrone(String droneID) {\n\t\tif (drones.containsKey(droneID)) {\n\t\t\tdrones.remove(droneID);\n\t\t}\n\t}\n\n\tpublic void removeDrone(IUAVProxy drone) {\n\t\tif (drones.containsKey(drone.getID())) {\n\t\t\tdrones.remove(drone.getID());\n\t\t}\n\t}\n\n\tpublic UAVProxy getDrone(String droneID) {\n\t\tif (drones.containsKey(droneID)) {\n\t\t\treturn drones.get(droneID);\n\t\t}\n\t\treturn null;\n\t}\n}\n"}, {"id": "UAVRegistrationServiceRemoteFacade.java", "body": "package edu.nd.dronology.services.facades;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\n\nimport org.apache.commons.lang.NotImplementedException;\n\nimport edu.nd.dronology.services.core.info.UAVRegistrationInfo;\nimport edu.nd.dronology.services.core.info.TypeRegistrationInfo;\nimport edu.nd.dronology.services.core.listener.IItemChangeListener;\nimport edu.nd.dronology.services.core.remote.IUAVRegistrationRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.instances.registration.uavs.UAVRegistrationService;\nimport edu.nd.dronology.services.remote.AbstractRemoteFacade;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class UAVRegistrationServiceRemoteFacade extends AbstractRemoteFacade implements IUAVRegistrationRemoteService {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -4580658378477037955L;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(UAVRegistrationServiceRemoteFacade.class);\n\tprivate static volatile UAVRegistrationServiceRemoteFacade INSTANCE;\n\n\tprotected UAVRegistrationServiceRemoteFacade() throws RemoteException {\n\t\tsuper(UAVRegistrationService.getInstance());\n\t}\n\n\tpublic static IUAVRegistrationRemoteService getInstance() throws RemoteException {\n\t\tif (INSTANCE == null) {\n\t\t\ttry {\n\t\t\t\tsynchronized (UAVRegistrationServiceRemoteFacade.class) {\n\t\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\t\tINSTANCE = new UAVRegistrationServiceRemoteFacade();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (RemoteException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tpublic byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException {\n\t\treturn UAVRegistrationService.getInstance().requestFromServer(id);\n\t}\n\n\t@Override\n\tpublic void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException {\n\t\tUAVRegistrationService.getInstance().transmitToServer(id, content);\n\n\t}\n\n\t@Override\n\tpublic boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException {\n\t\tthrow new NotImplementedException();\n\t}\n\n\t@Override\n\tpublic boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException {\n\t\tthrow new NotImplementedException();\n\t}\n\n\t@Override\n\tpublic Collection<UAVRegistrationInfo> getItems() throws RemoteException {\n\t\treturn UAVRegistrationService.getInstance().getItems();\n\t}\n\n\t@Override\n\tpublic UAVRegistrationInfo createItem() throws RemoteException, DronologyServiceException {\n\t\treturn UAVRegistrationService.getInstance().createItem();\n\t}\n\n\t@Override\n\tpublic void deleteItem(String itemid) throws RemoteException, DronologyServiceException {\n\t\t// TODO Auto-generated method stub\n\t\tthrow new NotImplementedException();\n\t}\n\n\n\n}"}, {"id": "Utilities.java", "body": "package edu.nd.dronology.services.extensions.areamapping.util;\n\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Path2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Vector;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.services.core.areamapping.EdgeLla;\nimport edu.nd.dronology.services.core.items.FlightRoute;\nimport edu.nd.dronology.services.core.items.IFlightRoute;\nimport edu.nd.dronology.services.core.items.IMappedItem;\nimport edu.nd.dronology.services.extensions.areamapping.internal.Geometry;\nimport edu.nd.dronology.services.extensions.areamapping.internal.ImageWaypoint;\nimport edu.nd.dronology.services.extensions.areamapping.internal.ImageWaypoints;\nimport edu.nd.dronology.services.extensions.areamapping.internal.MapNode;\nimport edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;\nimport edu.nd.dronology.services.extensions.areamapping.internal.RiverList;\nimport edu.nd.dronology.services.extensions.areamapping.internal.SourcePoints;\nimport edu.nd.dronology.services.extensions.areamapping.model.RiverSubsegment;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive.RouteType;\n\n\npublic class Utilities {\n\n    /**\n     * This function calculates the average latitude.\n     * @return average latitude\n     */\n    public static double getAvgLatitude(double minLatitude, double maxLatitude){\n        return (minLatitude + maxLatitude)/2;\n    }\n    \n    public static RiverBank edgeLlaToRiverBank(List<EdgeLla> input){\n    \tRiverBank newBank = new RiverBank();\n    \tfor(EdgeLla entry : input) {\n    \t\tnewBank.add(new Point2D.Double(entry.getLatitude(), entry.getLongitude()));\n    \t}\n    \treturn newBank;\n    }\n    \n    public static List<RiverBank> processDronologyInput(RiverBank bank1, RiverBank bank2, Vector<Double> latitudeBounds){\n    \tList<RiverBank> bankList = new ArrayList<>();\n\t    double minLatitude = 1000;\n\t    double maxLatitude = -1000;\n\t    double latitude;\n\t    for(Point2D.Double node : bank1.get()){\n\t        latitude = node.getX();\n\t        if(latitude < minLatitude){\n\t            minLatitude = latitude;\n\t        }\n\t        if(maxLatitude < latitude){\n\t            maxLatitude = latitude;\n\t        }\n\t    }\n\t    for(Point2D.Double node : bank2.get()){\n\t        latitude = node.getX();\n\t        if(latitude < minLatitude){\n\t            minLatitude = latitude;\n\t        }\n\t        if(maxLatitude < latitude){\n\t            maxLatitude = latitude;\n\t        }\n\t    }\n\t    double avgLatitude = getAvgLatitude(minLatitude, maxLatitude);\n\t    latitudeBounds.add(minLatitude);\n\t    latitudeBounds.add(maxLatitude);\n\t    bank1 = gpsRiverBankToCartesianRiverBank(avgLatitude, bank1);\n\t    bank2 = gpsRiverBankToCartesianRiverBank(avgLatitude, bank2);\n\t    bankList.add(bank1);\n\t    bankList.add(bank2);\n\t    return bankList;\n    \t\n    }\n\n    /**\n     * This splits the nodes from the JSON input into vectors for each bank of the river and puts these vectors\n     * into a list.\n     * @param riverList\n     * @return a list of Vectors of Point2D.Double representing the banks of the river\n     */\n    \n    public static List<RiverBank> makeBankVectors(RiverList riverList, Vector<Double> latitudeBounds){\n        List<RiverBank> bankList = new ArrayList<>();\n        RiverBank bank1 = new RiverBank();\n        RiverBank bank2 = new RiverBank();\n        double minLatitude = 1000;\n        double maxLatitude = -1000;\n        double latitude;\n        for(MapNode node : riverList.getNodes()){\n            latitude = node.getLatitude();\n            if(latitude < minLatitude){\n                minLatitude = latitude;\n            }\n            if(maxLatitude < latitude){\n                maxLatitude = latitude;\n            }\n            if(node.get_riverSide() == 1) {\n                bank1.add(new Point2D.Double(node.getLatitude(),node.getLongitude()));\n            } else {\n                bank2.add(new Point2D.Double(node.getLatitude(),node.getLongitude()));\n            }\n        }\n        double avgLatitude = getAvgLatitude(minLatitude, maxLatitude);\n        latitudeBounds.add(minLatitude);\n        latitudeBounds.add(maxLatitude);\n        bank1 = gpsRiverBankToCartesianRiverBank(avgLatitude, bank1);\n        bank2 = gpsRiverBankToCartesianRiverBank(avgLatitude, bank2);\n        bankList.add(bank1);\n        bankList.add(bank2);\n        return bankList;\n    }\n    \n    /**\n     * This function converts the river bank vectors containing gps coordinates into vectors of cartesian\n     * coordinates for all the calculations during the dynamic route generation algorithm.\n     * @param avgLatitude\n     * @param gpsBank\n     * @return RiverBank in cartesian coordinates\n     */\n    private static RiverBank gpsRiverBankToCartesianRiverBank(double avgLatitude, RiverBank gpsBank) {\n        RiverBank riverBank = new RiverBank();\n        for(Point2D.Double entry : gpsBank.get()){\n            riverBank.add(Geometry.gpsToCartesian(entry,avgLatitude));\n        }\n        return riverBank;\n    }\n    \n    \n    /**\n     * This function converts the riverbank nodes from cartesian coordinates to gps coordinates.\n     * @param avgLatitude\n     * @param cartesianBank\n     * @return RiverBank in gps coordinates\n     */\n    public static RiverBank cartesianRiverBankToGpsRiverBank(double avgLatitude, RiverBank cartesianBank) {\n    \tRiverBank riverBank = new RiverBank();\n    \tfor(Point2D.Double entry : cartesianBank.get()){\n            riverBank.add(Geometry.cartesianToGPS(entry,avgLatitude));\n        }\n        return riverBank;\n    }\n    \n    \n    /**\n     * This function converts the route primitive to cartesian coordinates from gps coordinates.\n     * @param l\n     * @param avgLatitude\n     * @return RoutePrimitive in cartesian coordinates\n     */\n    public static RoutePrimitive gpsRouteToCartesianRoute(RoutePrimitive l, double avgLatitude) {\n    \tfor(int i = 0; i < l.size(); i++) {\n    \t\tl.setRouteWaypoint(i,Geometry.gpsToCartesian(l.getRouteWaypoint(i),avgLatitude));\n    \t}\n    \treturn l;\n    }\n\n    /**\n     * This function convertes the route primitive to gps coordinates from cartesian coordinates.\n     * @param l\n     * @return RoutePrimitive in gps coordinates\n     */\n    public static RoutePrimitive cartesianRouteToGpsRoute(RoutePrimitive l, double avgLatitude){\n        for(int i = 0; i < l.size(); i++){\n            l.setRouteWaypoint(i,Geometry.cartesianToGPS(l.getRouteWaypoint(i),avgLatitude));\n        }\n        return l;\n    }\n\n    /**\n     * This function verifies the input order of the nodes from the JSON file to ensure that they are in the expected\n     * order. It transforms them to the expected form if necessary.\n     */\n    \n    /**\n     * This function takes the RiverBanks created from the JSON file to make sure that they are in the necessary order.\n     * @param gpsBank1\n     * @param gpsBank2\n     */\n    public static void verifyInputOrder(RiverBank gpsBank1, RiverBank gpsBank2){\n        Point2D.Double start1 = gpsBank1.get(0);\n        Point2D.Double end1 = gpsBank1.get(gpsBank1.size()-1);\n        Point2D.Double start2 = gpsBank2.get(0);\n        Point2D.Double end2 = gpsBank2.get(gpsBank2.size()-1);\n        boolean intersect = Line2D.linesIntersect(start1.getX(),start1.getY(),start2.getX(), start2.getY(),end1.getX(),end1.getY(),end2.getX(),end2.getY());\n        if(intersect){\n        \tSystem.out.println(\"bank2 reversed\");\n            gpsBank2.reverse();\n        }\n    }\n\n    /**\n     * This function splits up the riverbank nodes into sections for each drone to search and returns a vector of lists\n     * of vectors. Each list corresponds to the segment one drone will search, and each vector in the list\n     * corresonds to a bank of the river.\n     * @return a vector of lists corresponding to the section each drone will search\n     */\n    \n    //note: don't really need this function anymore\n    public static Vector<RiverSubsegment> makeRiverVectors(List<RiverBank> bankList, int drones, int bank1SegmentSize, int bank2SegmentSize){\n        RiverBank riverBank1 = bankList.get(0);\n        RiverBank riverBank2 = bankList.get(1);\n        Vector<RiverSubsegment> riverVectors = new Vector<RiverSubsegment>();\n\n        int counter1 = 0;\n        int counter2 = 0;\n        for(int i = 0; i < drones-1; i++){\n            RiverSubsegment riverSegment = new RiverSubsegment();\n            RiverBank bank1 = new RiverBank();\n\n\n            makeVector1(counter1,bank1,riverBank1,bank1SegmentSize);\n            riverSegment.add(bank1);\n            counter1 += bank1SegmentSize-1;\n\n            RiverBank bank2 = new RiverBank();\n            makeVector2(counter2,bank2,riverBank2,bank2SegmentSize);\n            riverSegment.add(bank2);\n            counter2 += bank2SegmentSize -1;\n\n            riverVectors.add(riverSegment);\n        }\n        RiverSubsegment riverSegment = new RiverSubsegment();\n        RiverBank bank1 = new RiverBank();\n        RiverBank bank2 = new RiverBank();\n        makeFinalVectors(counter1,riverSegment,bank1,riverBank1);\n        makeFinalVectors(counter2,riverSegment,bank2,riverBank2);\n        riverVectors.add(riverSegment);\n        return riverVectors;\n    }\n\n    /**\n     * This function is a helper function for makeRiverVectors(). It forms the vectors of nodes for one bank\n     * of the river except for the very last vector on that side.\n     * @param counter1\n     * @param bank1\n     */\n    private static void makeVector1(int counter1,  RiverBank bank1, RiverBank riverBank1, int bank1SegmentSize){\n        for(int j = counter1; j < counter1 + bank1SegmentSize; j++){\n            bank1.add(riverBank1.get(j));\n        }\n    }\n\n    /**\n     * This function is a helper function for makeRiverVectors(). It forms the vectors of nodes for the other bank\n     * of the river except for the last vector on this side.\n     * @param counter2\n     * @param bank2\n     */\n    private static void makeVector2(int counter2, RiverBank bank2, RiverBank riverBank2, int bank2SegmentSize){\n        for(int j = counter2; j < counter2 + bank2SegmentSize; j++){\n            bank2.add(riverBank2.get(j));\n        }\n    }\n\n    /**\n     * This function is a helper function for makeRiverVectors(). It makes the last vector of nodes for each bank\n     * of the river.\n     * @param counter1\n     * @param counter2\n     * @param riverSegment\n     * @param bank1\n     * @param bank2\n     */\n    private static void makeFinalVectors(int counter, RiverSubsegment riverSegment, RiverBank bank, RiverBank riverBank){\n        for(int j = counter; j < riverBank.size(); j++) {\n            bank.add(riverBank.get(j));\n        }\n        riverSegment.add(bank);\n    }\n    \n    \n    /**\n     * This function makes a polygon of the entire river segment. This allows checking for points contained within the \n     * river segment.\n     * @param bankList\n     * @return Path2D.Double polygon of the river segment\n     */\n    public static Path2D.Double makeTotalRiverSegment(List<RiverBank> bankList){\n    \tPath2D.Double totalSegment = new Path2D.Double();\n    \tRiverBank bank1 = bankList.get(0);\n    \tRiverBank bank2 = bankList.get(1);\n    \ttotalSegment.moveTo(bank1.get(0).getX(), bank1.get(0).getY());\n    \tfor(int i = 1; i < bank1.size(); i++) {\n    \t\ttotalSegment.lineTo(bank1.get(i).getX(), bank1.get(i).getY());\n    \t}\n    \tfor(int i = bank2.size()-1; i >= 0; i--) {\n    \t\ttotalSegment.lineTo(bank2.get(i).getX(), bank2.get(i).getY());\n    \t}\n    \treturn totalSegment;\n    }\n\n    /**\n     * This function creates Path2D.Double shapes to represent each subsegment of the riversegment. This is used for\n     * checking if a point is inside the shape, which is done to determine the stopping point for each search route.\n     * @return vector of Path2D.Double shapes representing subsegments of the riversegment\n     */\n    //Assumes riverVectors has been called beforehand so that riverBanks are in cartesian coordinates\n    public static Vector<Path2D.Double> makeRiverSegments(List<RiverBank> bankList, int drones, int bank1SegmentSize, int bank2SegmentSize){\n    \t\tVector<Path2D.Double> riverSegments = new Vector<Path2D.Double>();\n            RiverBank riverBank1 = bankList.get(0);\n            RiverBank riverBank2 = bankList.get(1);\n            int counter1 = 0;\n            int counter2 = 0;\n            for(int i = 0; i < drones-1; i++){\n                Path2D.Double riverSegment = new Path2D.Double();\n                Point2D.Double node0 = riverBank1.get(counter1);\n                riverSegment.moveTo(node0.getX(),node0.getY());\n\n                makeRiverbank1(counter1,riverSegment,riverBank1,bank1SegmentSize);\n                counter1 += bank1SegmentSize-1;\n\n                makeRiverbank2(counter2,riverSegment,riverBank2,bank2SegmentSize);\n                counter2 += bank2SegmentSize -1;\n\n                riverSegment.closePath();\n                riverSegments.add(riverSegment);\n            }\n            Path2D.Double riverSegment = new Path2D.Double();\n            Point2D.Double node0 = riverBank1.get(counter1);\n            riverSegment.moveTo(node0.getX(),node0.getY());\n            makeFinalSegment(counter1,counter2,riverSegment,riverBank1,riverBank2);\n            riverSegment.closePath();\n            riverSegments.add(riverSegment);\n            return riverSegments;\n    }\n\n    /**\n     * This function is a helper function for makeRiverSegments(). It adds the nodes from the first bank of the river\n     * to the shape.\n     * @param counter1\n     * @param riverSegment\n     */\n    private static void makeRiverbank1(int counter1, Path2D.Double riverSegment, RiverBank riverBank1, int bank1SegmentSize){\n        for(int j = counter1 + 1; j < counter1 + bank1SegmentSize; j++){\n            Point2D.Double node = riverBank1.get(j);\n            riverSegment.lineTo(node.getX(),node.getY());\n        }\n    }\n\n    /**\n     * This function is a helper function for makeRiverSegments(). It adds the nodes from the second bank of the river\n     * to the shape.\n     * @param counter2\n     * @param riverSegment\n     */\n    private static void makeRiverbank2(int counter2, Path2D.Double riverSegment, RiverBank riverBank2, int bank2SegmentSize){\n        for(int j = counter2 + bank2SegmentSize - 1; j >= counter2; j--){\n            Point2D.Double node = riverBank2.get(j);\n            riverSegment.lineTo(node.getX(),node.getY());\n        }\n    }\n\n    /**\n     * This function is a helper function for makeRiverSegments(). It adds the remaining nodes from each side of the\n     * river to make the last subsegment of the riversegment.\n     * @param counter1\n     * @param counter2\n     * @param riverSegment\n     */\n    private static void makeFinalSegment(int counter1,int counter2,Path2D.Double riverSegment, RiverBank riverBank1, RiverBank riverBank2) {\n        for (int j = counter1 + 1; j < riverBank1.size(); j++) {\n            Point2D.Double node = riverBank1.get(j);\n            riverSegment.lineTo(node.getX(), node.getY());\n        }\n        for (int j = riverBank2.size() - 1; j >= counter2; j--) {\n            Point2D.Double node = riverBank2.get(j);\n            riverSegment.lineTo(node.getX(), node.getY());\n        }\n    }\n    \n    \n    /**\n     * This function generates image waypoints at a specified distance along a RoutePrimitive\n     * @param route\n     * @param APERATURE_HEIGHT\n     * @param OVERLAP_FACTOR\n     */\n    public static void generateImageWaypoints(RoutePrimitive route, double APERATURE_HEIGHT, double OVERLAP_FACTOR) {\n\t\tPoint2D.Double newPoint = new Point2D.Double();\n\t\tImageWaypoint imagePoint = new ImageWaypoint();\n\t\tPoint2D.Double point1;\n\t\tPoint2D.Double point2;\n\t\tImageWaypoints imagePoints = route.getIWP();\n\t\tdouble routeSegmentDistance;\n\t\tdouble traverseDistance = APERATURE_HEIGHT*OVERLAP_FACTOR;;\n\t\tdouble distanceRatio;\n\t\tdouble theta = Geometry.getAngle(route.getRouteWaypoint(0), route.getRouteWaypoint(1));\n\t\timagePoints.add(new ImageWaypoint(route.getRouteWaypoint(0),theta));\n\t\tfor(int i = 0; i < route.size()-1; i++) {\n\t\t\tpoint1 = route.getRouteWaypoint(i);\n\t\t\tpoint2 = route.getRouteWaypoint(i+1);\n\t\t\ttheta = Geometry.getAngle(point1, point2);\n\t\t\tif(Geometry.findCartesianDistance(point1, imagePoints.get(imagePoints.size()-1).getWaypoint()) > 2.0) {\n\t\t\t\timagePoints.add(new ImageWaypoint(point1,theta));\n\t\t\t}\n\t\t\t//imagePoints.add(point1);\n\t\t\trouteSegmentDistance = Geometry.findCartesianDistance(point1, point2);\n\t\t\twhile(traverseDistance <= routeSegmentDistance) {\n\t\t\t\t\tdistanceRatio = traverseDistance / routeSegmentDistance;\n\t\t\t\t\tnewPoint = Geometry.findOffsetPoint(point1, point2, distanceRatio);\n\t\t\t\t\timagePoints.add(new ImageWaypoint(newPoint,theta));\n\t\t\t\t\trouteSegmentDistance = routeSegmentDistance - traverseDistance;\n\t\t\t\t\tpoint1 = newPoint;\n\t\t\t} \n\t\t}\n\t\timagePoints.add(new ImageWaypoint(route.getRouteWaypoint(route.size()-1),theta));\n    }\n    \n    private static int determineRouteSplit(RoutePrimitive route) {\n    \tint splitNumber = 1;\n    \tif(route.getRouteType() == RoutePrimitive.RouteType.CRISSCROSS || route.getRouteType() == RoutePrimitive.RouteType.INNER_CRISSCROSS) {\n    \t\tsplitNumber = 4;\n    \t}\n    \telse if(route.getRouteType() == RoutePrimitive.RouteType.RIVERBANK) {\n    \t\tsplitNumber = 2;\n    \t}\n    \treturn splitNumber;\n    }\n  \n    public static List<RoutePrimitive> splitRoutePrimitives(List<RoutePrimitive> currentRoutes, double APERATURE_HEIGHT, double OVERLAP_FACTOR){\n    \tList<RoutePrimitive> newRoutes = new ArrayList<>();\n    \tfor(RoutePrimitive route : currentRoutes) {\n    \t\tint splitNumber = determineRouteSplit(route);\n    \t\tint nodesNumber = route.size() / splitNumber + 1;\n    \t\tint counter = 0;\n    \t\tboolean lastSplit = false;\n    \t\tfor(int i = 0; i < splitNumber - 1; i++) {\n    \t\t\tnewRoutes.add(smallerRoutePrimitive(route, nodesNumber, counter, lastSplit, APERATURE_HEIGHT, OVERLAP_FACTOR));\n    \t\t\tcounter += nodesNumber - 1;\n    \t\t}\n    \t\tlastSplit = true;\n    \t\tnewRoutes.add(smallerRoutePrimitive(route, nodesNumber, counter, lastSplit, APERATURE_HEIGHT, OVERLAP_FACTOR));\n    \t}\n    \treturn newRoutes;\n    }\n    \n    private static RoutePrimitive smallerRoutePrimitive(RoutePrimitive route, int nodesNumber, int startPoint, boolean lastSplit, double APERATURE_HEIGHT, double OVERLAP_FACTOR){\n    \tRoutePrimitive newRoute = new RoutePrimitive(route.getRouteType(),route.getRouteWeight());\n    \tif(lastSplit) {\n    \t\tnodesNumber  = route.size() - startPoint;\n    \t}\n    \tfor(int i = startPoint; i < startPoint + nodesNumber; i++) {\n    \t\tnewRoute.addRouteWaypoint(route.getRouteWaypoint(i));\n    \t}\n    \tgenerateImageWaypoints(newRoute, APERATURE_HEIGHT, OVERLAP_FACTOR);\n    \treturn newRoute;\n    }\n//    // NOTE: change all of these to expect IFlightRoute instead of ExportRoutePrimitive\n//    public static ExportAllocationInformation makeExportAllocationInformation(AllocationInformation allocationInformation) {\n//    \tExportAllocationInformation newAllocationInformation = new ExportAllocationInformation();\n//    \tdouble altitude = 15;\n//    \tfor(Drone drone : allocationInformation.getDroneAllocations()) {\n//    \t\tnewAllocationInformation.addDroneAllocation(makeExportDrone(drone, altitude));\n//    \t\taltitude += 5;\n//    \t}\n//    \tnewAllocationInformation.setMetricsStatistics(allocationInformation.getMetricStatistics());\n//    \treturn newAllocationInformation;\n//    }\n    \n//    public static ExportDrone makeExportDrone(Drone drone, double altitude) {\n//    \tExportDrone newDrone = new ExportDrone();\n//    \tnewDrone.setDroneStartPoint(new LlaCoordinate(drone.getDroneStartPoint().getX(), drone.getDroneStartPoint().getY(), altitude));\n//    \tnewDrone.setDroneHomeLocation(new LlaCoordinate(drone.getDroneHomeLocation().getX(), drone.getDroneHomeLocation().getY(), altitude));\n//    \tnewDrone.setUAVId(drone.getUAVId());\n//    \tnewDrone.setDroneRouteAssignment(makeExportDroneRouteAssignment(drone.getDroneRouteAssignment(), altitude));\n//    \treturn newDrone;\n//    }\n//    \t\n//    private static ExportDroneRouteAssignment makeExportDroneRouteAssignment(DroneRouteAssignment routeAssignment, double altitude) {\n//    \tExportDroneRouteAssignment newRouteAssignment = new ExportDroneRouteAssignment();\n//    \tHashMap<RouteType, Integer> routePrimitiveCounters = new HashMap<>();\n//    \troutePrimitiveCounters.put(RouteType.CRISSCROSS, 0);\n//    \troutePrimitiveCounters.put(RouteType.RIVERBANK, 0);\n//    \troutePrimitiveCounters.put(RouteType.PRIORITYAREA, 0);\n//    \tfor(RoutePrimitive routePrimitive : routeAssignment.get()) {\n//    \t\tnewRouteAssignment.add(makeFlightRoute(routePrimitive, altitude, routePrimitiveCounters));\n//    \t}\n//    \treturn newRouteAssignment;\n//    }\n    \n    private static String assignFlightRouteName(RoutePrimitive route, HashMap<RoutePrimitive.RouteType, Integer> counters) {\n    \tRouteType routeType = route.getRouteType();\n    \tString name;\n    \tif(routeType == RouteType.CRISSCROSS) {\n    \t\tname = \"CrissCross Route \" + counters.get(RouteType.CRISSCROSS);\n    \t\tcounters.put(RouteType.CRISSCROSS, counters.get(RouteType.CRISSCROSS) + 1);\n    \t}\n    \telse if(routeType == RouteType.RIVERBANK) {\n    \t\tname = \"RiverBank Route \" + counters.get(RouteType.RIVERBANK);\n    \t\tcounters.put(RouteType.RIVERBANK, counters.get(RouteType.RIVERBANK) + 1);\n    \t} else {\n    \t\tname = \"PriorityArea Route \" + counters.get(RouteType.PRIORITYAREA);\n    \t\tcounters.put(RouteType.PRIORITYAREA, counters.get(RouteType.PRIORITYAREA) + 1);\n    \t}\n    \treturn name;\n    }\n    \n    //edit to return IFlightRoute with name as something with type of route\n    public static IFlightRoute makeFlightRoute(RoutePrimitive route, double altitude, HashMap<RoutePrimitive.RouteType, Integer> counters) {\n    \tIFlightRoute newRoute = new FlightRoute();\n    \tfor(Point2D.Double entry : route.getRoute()) {\n    \t\tnewRoute.addWaypoint(new Waypoint(new LlaCoordinate(entry.getX(), entry.getY(), altitude)));\n    \t}\n    \tnewRoute.setName(assignFlightRouteName(route, counters));\n    \treturn newRoute;\n    }\n    \n    public static SourcePoints transformPriorityArea(IMappedItem area, double centralLatitude){\n    \tSourcePoints newArea = new SourcePoints(area.getImportance());\n    \tfor(LlaCoordinate entry : area.getCoordinates()) {\n    \t\tPoint2D.Double newPoint = new Point2D.Double(entry.getLatitude(), entry.getLongitude());\n    \t\tnewArea.addSourcePoint(Geometry.gpsToCartesian(newPoint, centralLatitude));\n    \t}\n    \treturn newArea;\n    }\n    \n    public static void printRiverSegment(Vector<RiverSubsegment> riverVectors) {\n    \tSystem.out.println(\"riverVectors: \");\n\t\t//printout for graph visualization\n\t\tSystem.out.printf(\"[\");\n\t\tfor(RiverSubsegment l : riverVectors){\n\t\t\tSystem.out.printf(\"[\");\n\t\t\tfor(RiverBank v : l.get()){\n\t\t\t\tSystem.out.printf(\"[\");\n\t\t\t\tfor(Point2D.Double entry : v.get()){\n\t\t\t\t\tSystem.out.printf(\"[\"+entry.getX()+\",\"+entry.getY()+\"],\");\n\t\t\t\t}\n\t\t\t\tSystem.out.printf(\"],\");\n\t\t\t}\n\t\t\tSystem.out.printf(\"],\");\n\t\t}\n\t\tSystem.out.println(\"]\");\n    }\n    \n    public static void printRoutePrimitives(List<RoutePrimitive> routes) {\n    \tSystem.out.println(\"routePrimitives: \");\n\t\tSystem.out.printf(\"[\");\n\t\tfor(RoutePrimitive rList : routes){\n\t\t\tSystem.out.printf(\"[\");\n\t\t\tfor(Point2D.Double entry: rList.getRoute()){\n\t\t\t\tSystem.out.printf(\"[\"+entry.getX()+\", \"+entry.getY()+\"],\");\n\t\t\t}\n\t\t\tSystem.out.printf(\"],\");\n\t\t}\n\t\tSystem.out.println(\"]\");\n    }\n    \n    public static void printImageWaypoints(List<RoutePrimitive> routes) {\n    \tSystem.out.println(\"image Waypoints: \");\n\t\tSystem.out.printf(\"[\");\n\t\tfor(RoutePrimitive rList : routes){\n\t\t\tImageWaypoints imagePoints = rList.getIWP();\n\t\t\tSystem.out.printf(\"[\");\n\t\t\tfor(ImageWaypoint entry: imagePoints.get()){\n\t\t\t\tSystem.out.printf(\"[\"+entry.getWaypoint().getX()+\", \"+entry.getWaypoint().getY()+\"],\");\n\t\t\t}\n\t\t\tSystem.out.printf(\"],\");\n\t\t}\n\t\tSystem.out.println(\"]\");\n    }\n    \n    public static void printSourcePoints(List<SourcePoints> sourcePoints) {\n    \tSystem.out.println(\"sourcePoints: \");\n\t\tSystem.out.printf(\"[\");\n\t\tfor(SourcePoints points : sourcePoints){\n\t\t\tSystem.out.printf(\"[\");\n\t\t\tfor(Point2D.Double entry: points.getSourcePoints()){\n\t\t\t\tSystem.out.printf(\"[\"+entry.getX()+\", \"+entry.getY()+\"],\");\n\t\t\t}\n\t\t\tSystem.out.printf(\"],\");\n\t\t}\n\t\tSystem.out.println(\"]\");\n    }\n    \n    /**\n     * This function prints out the information for python visualization \n     * @param riverVectors\n     * @param routes\n     */\n    public static void debugPrintOut(Vector<RiverSubsegment> riverVectors,List<RoutePrimitive> routes){\n    \tprintRiverSegment(riverVectors);\n    \tprintRoutePrimitives(routes);\n    \tprintImageWaypoints(routes);\n\t}\n}\n\n\n"}, {"id": "IMovementSimulator.java", "body": "package edu.nd.dronology.core.simulator;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.vehicle.internal.VirtualDrone;\n\n/**\n * \n * The movement simulator simulates the movement of a {@link VirtualDrone} to reach its assigned waypoints.\n * \n * @author Michael Vierhauser\n *\n */\npublic interface IMovementSimulator {\n\n\tboolean move(double i);\n\n\tvoid setFlightPath(LlaCoordinate currentPosition, LlaCoordinate targetCoordinates);\n\n\tvoid checkPoint();\n\n\tboolean isDestinationReached(double distanceMovedPerTimeStep);\n\n}\n"}, {"id": "StopCommand.java", "body": "package edu.nd.dronology.core.collisionavoidance.guidancecommands;\n\n/**\n * A command that tells the UAV to hover in place.\n */\npublic class StopCommand extends Command {\n\n    private final double time;\n\n    /**\n     * <p>\n     * Creates a stop command. This command tells the UAV to hover in place for the specified number of seconds. If\n     * given a negative or zero time parameter, then this command will remain in effect indefinitely.\n     * </p>\n     * <p>\n     * <p>\n     * For example, to create a stop command that lasts for 10 seconds\n     * <pre>\n     *         {@code\n     *         StopCommand stop = new StopCommand(10.0);\n     *         }\n     *     </pre>\n     * </p>\n     * <p>\n     * <p>\n     * To create a stop command that lasts until someone or something intervenes\n     * <pre>\n     *         {@code\n     *         StopCommand stopForever = new StopCommand(0);\n     *         }\n     *     </pre>\n     * </p>\n     *\n     * @param time in seconds that this stop command is to remain in effect. A value less than or equal to 0 indicates\n     *             that this command should remain in effect indefinitely or until someone or something intervenes.\n     */\n    public StopCommand(double time) {\n        this.time = time;\n    }\n\n    /**\n     * Return the amount of time this command should remain in effect. A value less than or equal to 0 indicates that\n     * this command should remain in effect indefinitely.\n     *\n     * @return time this stop command is to remain in effect. A value less than or equal to 0 indicates that this\n     * command should remain in effect indefinitely.\n     */\n    public double getTime() {\n        return time;\n    }\n\n    @Override\n    public String toString() {\n        return \"StopCommand(\" + time + \" seconds)\";\n    }\n}\n"}, {"id": "IUAVTypeRegistration.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.io.Serializable;\n\npublic interface IUAVTypeRegistration extends IPersistableItem {\n\n\tString getDescription();\n\n\tvoid setDescription(String description);\n\n\tSerializable getAttribute(String key);\n\n\tvoid addAttribute(String key, Serializable value);\n\n\tvoid setUAVImage(byte[] image);\n\n\tbyte[] getImage();\n\n}\n"}, {"id": "StatusDispatchThread.java", "body": "package edu.nd.dronology.gstation.connector.dispatch;\n\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\n\nimport edu.nd.dronology.core.IUAVPropertyUpdateNotifier;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.status.DronologyListenerManager;\nimport edu.nd.dronology.core.vehicle.DroneFlightStateManager.FlightMode;\nimport edu.nd.dronology.gstation.connector.messages.AbstractUAVMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVModeChangeMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVStateMessage;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class StatusDispatchThread extends AbstractStatusDispatchThread<AbstractUAVMessage> implements Callable {\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(StatusDispatchThread.class);\n\n\tprivate IUAVPropertyUpdateNotifier listener;\n\n\tpublic StatusDispatchThread(final BlockingQueue<AbstractUAVMessage> queue, IUAVPropertyUpdateNotifier listener) {\n\t\tsuper(queue);\n\t\tthis.listener = listener;\n\t}\n\n\tprotected void notifyListener() throws Exception {\n\n\t}\n\n\t@Override\n\tpublic Object call() {\n\t\twhile (cont.get()) {\n\n\t\t\ttry {\n\t\t\t\tAbstractUAVMessage state = queue.take();\n\t\t\t\tif (state instanceof UAVStateMessage) {\n\t\t\t\t\tUAVStateMessage sm = (UAVStateMessage) state;\n\t\t\t\t\tLlaCoordinate location = sm.getLocation();\n\t\t\t\t\tdouble level = sm.getBatterystatus().getBatteryLevel();\n\t\t\t\t\tdouble speed = sm.getGroundspeed();\n\t\t\t\t\tlistener.update(location, level, speed, sm.getVelocity(), sm.getAttitude());\n\t\t\t\t} else if (state instanceof UAVModeChangeMessage) {\n\t\t\t\t\tUAVModeChangeMessage mcm = (UAVModeChangeMessage) state;\n\t\t\t\t\t\n\t\t\t\t\tlistener.updateMode(mcm.getMode());\n\n\t\t\t\t\t// If the new mode is LOITER, we should remove this drone from its mission plan\n\t\t\t\t\t// (if it has one).\n\t\t\t\t\t// TODO: determine if this is actually the right place to do this.\n\t\t\t\t\t// TODO: potentially create an enum for mode names.\n\t\t\t\t\tif (mcm.getMode().equals(FlightMode.USER_CONTROLLED.toString())) {\n\t\t\t\t\t\tDronologyListenerManager.getInstance().notifyUAVRemoved(mcm.getUavid());\n\t\t\t\t\t\t// notify flight plan pool... remove active plans..\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tLOGGER.error(\"Unhandled message type detected \" + state.getClass());\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLOGGER.warn(\"Status Dispatch Thread terminated\");\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\n\t\t}\n\t\tLOGGER.info(\"Dispatcher shutdown!\");\n\t\treturn null;\n\t}\n\n}\n"}, {"id": "ExportDroneRouteAssignment.java", "body": "package edu.nd.dronology.services.core.unused;\n//package edu.nd.dronology.services.core.areamapping;\n//\n//import java.io.Serializable;\n//import java.util.ArrayList;\n//import java.util.Collections;\n//import java.util.List;\n//\n//import edu.nd.dronology.services.core.items.FlightRoute;\n//import edu.nd.dronology.services.core.items.IFlightRoute;\n//\n//public class ExportDroneRouteAssignment implements Serializable {\n//\t/**\n//\t * \n//\t */\n//\tprivate static final long serialVersionUID = -942703933531286156L;\n//\tList<IFlightRoute> droneRoute;\n//\t\n//\tpublic ExportDroneRouteAssignment() {\n//\t\tdroneRoute = new ArrayList<>();\n//\t}\n//\t\n//\tpublic void add(IFlightRoute flightRoute) {\n//\t\tdroneRoute.add(flightRoute);\n//\t}\n//\t\n//\tpublic List<IFlightRoute> get(){\n//\t\treturn Collections.unmodifiableList(droneRoute);\n//\t}\n//\t\n//\tpublic IFlightRoute get(int entry) {\n//\t\treturn droneRoute.get(entry);\n//\t}\n//\t\n//\tpublic void set(int index, FlightRoute entry) {\n//\t\tdroneRoute.set(index, entry);\n//\t}\n//\t\n//\tpublic void setDroneRouteAssignment(List<IFlightRoute> assignment) {\n//\t\tdroneRoute = assignment;\n//\t}\n//}\n"}, {"id": "AMInfoPanel.java", "body": "package edu.nd.dronology.ui.vaadin.areamapping;\n\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nimport com.vaadin.ui.Button;\nimport com.vaadin.ui.ComboBox;\nimport com.vaadin.ui.Component;\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.Panel;\nimport com.vaadin.ui.VerticalLayout;\n\nimport edu.nd.dronology.services.core.info.AreaMappingInfo;\nimport edu.nd.dronology.services.core.remote.IAreaMappingRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.ui.vaadin.areamapping.windows.AMUnsavedChangesConfirmation.ChangeType;\nimport edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;\nimport edu.nd.dronology.ui.vaadin.start.MyUI;\n\n/**\n * This is the side panel that shows the list of existing mappings.\n * \n * @author Andrew Slavin\n *\n */\n\npublic class AMInfoPanel extends CustomComponent{\n\t\n\tprivate static final long serialVersionUID = 3661239148456256352L;\n\n\tprivate VerticalLayout mappingListLayout = new VerticalLayout(); // contains list of mappings\n\tprivate MapCreationComponent mapCreation; // contains new mapping and sub-map buttons\n\tprivate VerticalLayout inPanelLayout = new VerticalLayout(); // contains mapCreation and mappingListLayout\n\tprivate AMControlsComponent controlComponent;\n\tprivate Panel panel = new Panel();\n\tprivate List<String> mappingList = new ArrayList<>();\n\tComboBox<String> comboBox = new ComboBox<>(); // search bar for existing mappings\n\t\n\tpublic AMInfoPanel(AMControlsComponent controls) {\n\t\tcontrolComponent = controls;\n\t\tmapCreation = new MapCreationComponent(this, controls);\n\t\tinPanelLayout.addComponents(mapCreation, comboBox, mappingListLayout);\n\t\tpanel.setContent(inPanelLayout);\n\t\tpanel.addStyleName(\"am_info_panel\");\n\t\tpanel.addStyleName(\"control_panel\");\n\n\t\tsetCompositionRoot(panel);\n\t\t\n        BaseServiceProvider provider=MyUI.getProvider();\n\t\t\n\t\trefreshMappings();\n\t\trefreshSearchBar();\n\t\tcomboBox.setItems(mappingList);\n\t\tcomboBox.setSizeFull();\n\t\t\n\t    //highlight the route chosen on the map \n\t\tcomboBox.addValueChangeListener(event -> {\n        \t\n        \tString name=comboBox.getValue();\n        \t\n        \tIAreaMappingRemoteService service;\n        \t try {\n             \tservice=(IAreaMappingRemoteService) provider.getRemoteManager().getService(IAreaMappingRemoteService.class);\n             \tList<AreaMappingInfo> allMappings = new ArrayList<>(service.getItems());\n             \tCollections.sort(allMappings, new AreaMappingIntoNameComparator());\n             \t\n             \t//puts the routes into the list that gets loaded onto the search bar \n             \tfor(AreaMappingInfo mapping : allMappings ) {\n             \t\tif (name.equals(mapping.getName())) {\n             \t\t\tcontrols.getInfoPanel().unhighlightAllInfoBoxes();\n            \t\t\tcontrols.getInfoPanel().highlightInfoBox(controls.getInfoPanel().getMappingIndex(mapping));\n\n                \t\t// Displays the mapping on map also.\n            \t\t\tcontrolComponent.getMainLayout().setMapComponent(controls.getMainLayout().getMapComponent());\n            \t\t\tcontrolComponent.getMainLayout().getMapComponent().getMetaInfo().showInfoForSelectedMapping(mapping);\n            \t\t\tcontrolComponent.getMainLayout().getMapComponent().displayAreaMapping(mapping);\n            \t\t\tcontrolComponent.getMainLayout().getMapComponent().setMappingCenter();\n                \t\tbreak;\n             \t\t}\n        \t \t}\n             \t\n             } catch(RemoteException | DronologyServiceException e) {\n             \tMyUI.setConnected(false);\n             \te.printStackTrace();\n             }\n        \t // reset search bar\n        \t comboBox.setValue(\"\");\n        });\n\t\t\n\t\t// click listener for when another mapping is selected\n\t\tmappingListLayout.addLayoutClickListener(e -> {\n\t\t\t// if editing, bring up unsaved changes box\n\t\t\tif (controls.getMainLayout().getMapComponent().getMapUtilities().getSidesAreEditable() || controls.getMainLayout().getMapComponent().getMapUtilities().getPrioritiesAreEditable()) {\n\t\t\t\tcontrols.getMainLayout().getUnsavedChangesConfirmation()\n\t\t\t\t\t\t.showWindow(this.getHighlightedAMInfoBox().getAreaMappingInfo().getName(), ChangeType.SWITCH_MAPPING, e);\n\t\t\t} else {\n\t\t\t\t// If map is not in edit mode, then just switch to the other mapping.\n\t\t\t\tComponent childComponent = e.getChildComponent();\n\t\t\t\tif (childComponent != null && childComponent.getClass().equals(AMInfoBox.class)) {\n\t\t\t\t\tcontrols.getMainLayout().switchMapping((AMInfoBox) childComponent);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t}\n\t\n\t\n\n\t// Ensures mappings are updated by removing and re-adding mappings.\n\tpublic void refreshMappings() {\n\t\tAMInfoBox highlightedBox = this.getHighlightedAMInfoBox();\n\t\tString highlightedId = highlightedBox == null ? \"\" : highlightedBox.getId();\n\n\t\tmappingListLayout.removeAllComponents();\n\t\tCollection<AreaMappingInfo> allMappings = getMappingsFromDronology();\n\t\tpanel.setCaption(allMappings.size() + \" Mappings\");\n\n\t\t// Iterates through the mappings, gets the fields of each, and creates an infobox.\n\t\tfor (AreaMappingInfo info : allMappings) {\n\t\t\tAMInfoBox mappingBox = addMapping(info);\n\t\t\t// To preserve previous route selection\n\t\t\tif (highlightedId.equals(mappingBox.getId())) {\n\t\t\t\tthis.getControls().getMainLayout().switchMapping(mappingBox);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//ensures that the routes in the search bar are updated by removing and re-adding them\n\tpublic void refreshSearchBar() {\n\t\t\n\t\t//puts the routes into the list that gets loaded onto the search bar\n\t\tmappingList.clear();\n\t\t\n\t\tCollection<AreaMappingInfo> allMappings = getMappingsFromDronology();\n\t\tfor(AreaMappingInfo mapping : allMappings )\n    \t{\n    \t\tmappingList.add(mapping.getName());\n    \t}\n\t\tcomboBox.setItems(mappingList);\n\t}\n\t\n\t// fetch mappings information from dronology\n\tpublic Collection<AreaMappingInfo> getMappingsFromDronology() {\n\t\tIAreaMappingRemoteService service;\n\t\tBaseServiceProvider provider = MyUI.getProvider();\n\t\ttry {\n\t\t\tservice = (IAreaMappingRemoteService) provider.getRemoteManager()\n\t\t\t\t\t.getService(IAreaMappingRemoteService.class);\n\t\t\tList<AreaMappingInfo> allMappings = new ArrayList<>(service.getItems());\n\t\t\tCollections.sort(allMappings, new AreaMappingIntoNameComparator());\n\n\t\t\treturn allMappings;\n\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\tMyUI.setConnected(false);\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t// Gets AreaMappingInfo based on mapping index.\n\tpublic AreaMappingInfo getAreaMappingInfo(int index) {\n\t\treturn ((AMInfoBox) mappingListLayout.getComponent(index)).getAreaMappingInfo();\n\t}\n\n\t// Gets the mapping index based on the AreaMappingInfo.\n\tpublic int getMappingIndex(AreaMappingInfo info) {\n\t\tfor (int i = 0; i < mappingListLayout.getComponentCount(); i++) {\n\t\t\tif (info.equals(((AMInfoBox) mappingListLayout.getComponent(i)).getAreaMappingInfo()))\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t// Gets the mapping info box based on the AreaMappingInfo.\n\tpublic AMInfoBox getMappingInfoBox(AreaMappingInfo info) {\n\t\tfor (int i = 0; i < mappingListLayout.getComponentCount(); i++) {\n\t\t\tif (info.equals(((AMInfoBox) mappingListLayout.getComponent(i)).getAreaMappingInfo()))\n\t\t\t\treturn (AMInfoBox) mappingListLayout.getComponent(i);\n\t\t}\n\t\treturn null;\n\t}\n\n\t// Gets the mapping info box based on the AreaMappingInfo id.\n\tpublic AMInfoBox getMappingInfoBox(String id) {\n\t\tfor (int i = 0; i < mappingListLayout.getComponentCount(); i++) {\n\t\t\tif (id.equals(((AMInfoBox) mappingListLayout.getComponent(i)).getAreaMappingInfo().getId()))\n\t\t\t\treturn (AMInfoBox) mappingListLayout.getComponent(i);\n\t\t}\n\t\treturn null;\n\t}\n\n\t// Adds a mapping to the infobox based on parameters.\n\tpublic AMInfoBox addMapping(AreaMappingInfo areaMappingInfo) {\n\t\tAMInfoBox mappingBox = new AMInfoBox(this, areaMappingInfo);\n\t\tmappingListLayout.addComponent(mappingBox);\n\t\treturn mappingBox;\n\t}\n\n\tpublic void unhighlightAllInfoBoxes() {\n\t\tfor (int i = 0; i < mappingListLayout.getComponentCount(); i++) {\n\t\t\tmappingListLayout.getComponent(i).removeStyleName(\"info_box_focus\");\n\t\t}\n\t}\n\n\tpublic void highlightInfoBox(int index) {\n\t\tmappingListLayout.getComponent(index).addStyleName(\"info_box_focus\");\n\t}\n\n\tpublic AMInfoBox getHighlightedAMInfoBox() {\n\t\tfor (int i = 0; i < mappingListLayout.getComponentCount(); i++) {\n\t\t\tif (mappingListLayout.getComponent(i).getStyleName().contains(\"info_box_focus\"))\n\t\t\t\treturn (AMInfoBox) mappingListLayout.getComponent(i);\n\t\t}\n\t\treturn null;\n\t}\n\n\t// Gets the mapping layout.\n\tpublic VerticalLayout getMappings() {\n\t\treturn mappingListLayout;\n\t}\n\n\t// Gets the controls component that was passed in through the constructor.\n\tpublic AMControlsComponent getControls() {\n\t\treturn controlComponent;\n\t}\n\n\t// Gets the button used to display the mapping creation window.\n\tpublic Button getNewMappingButtonFromCreationComponent() {\n\t\treturn mapCreation.getNewMappingButton();\n\t}\n\n\t// Removes the current window (used to remove mapping creation window).\n\tpublic void removeNewMappingWindow() {\n\t\tmapCreation.removeNewMappingWindow();\n\t}\t\n}\n"}, {"id": "UAVHandshakeMessage.java", "body": "package edu.nd.dronology.gstation.connector.messages;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\npublic class UAVHandshakeMessage extends AbstractUAVMessage<Object> implements Serializable {\n\n\tprivate static final long serialVersionUID = 1502042637906425729L;\n\tpublic static final String MESSAGE_TYPE = \"handshake\";\n\tpublic static final String HOME = \"home\";\n\tpublic static final String SAFETY_CASE = \"safetycase\";\n\n\tpublic UAVHandshakeMessage(String groundstationid, String uavid) {\n\t\tsuper(MESSAGE_TYPE, groundstationid, uavid); \n\t}\n\n\tpublic LlaCoordinate getHome() {\n\t\tif (data.get(HOME) instanceof LlaCoordinate) {\n\t\t\treturn (LlaCoordinate) data.get(HOME);\n\t\t}\n\t\tMap<String, Double> homeMap = (Map<String, Double>) data.get(HOME);\n\t\tdata.put(HOME, new LlaCoordinate(homeMap.get(\"x\"), homeMap.get(\"y\"), homeMap.get(\"z\")));\n\t\treturn (LlaCoordinate) data.get(HOME);\n\t}\n\n\tpublic String getSafetyCase() {\n\t\treturn data.get(SAFETY_CASE) != null ? data.get(SAFETY_CASE).toString() : null;\n\t}\n\n\tpublic void setHome(LlaCoordinate coordinate) {\n\t\tdata.put(HOME, coordinate);\n\n\t}\n\n}\n"}, {"id": "FullMissionPlan2.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.plan;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport edu.nd.dronology.core.DronologyConstants;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.info.UAVMappingInfo;\nimport edu.nd.dronology.services.core.items.IMissionPlan;\nimport edu.nd.dronology.services.core.items.IUAVMissionDescription;\nimport edu.nd.dronology.services.core.items.IUAVMissionTask;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;\nimport edu.nd.dronology.services.extensions.missionplanning.sync.SynchronizationManager;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.TaskFactory;\nimport edu.nd.dronology.services.instances.dronesetup.DroneSetupService;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Manages a mission plan. Each Mission plan has one\n * <code>FullMissionPlan</code> instance, and one <code>UAVMissionPlan</code>\n * instance for each UAV in the Mission plan. <br>\n * Each of the UAV's individual mission plans are composed of MissionTasks. <br>\n * Once the entire mission plan is loaded, a thread is created which checks each\n * of the individual UAVMissionPlans to determine if they can start the next\n * task.\n * \n * @author Jane Cleland-Huang\n */\npublic class FullMissionPlan2 implements IExecuteableMissionPlan {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(FullMissionPlan2.class);\n\n\tprivate Map<String, UAVMissionPlan> uavMissionPlans;\n\tprivate SynchronizationManager synchPointMgr;\n\n\tprivate IMissionPlan instructions;\n\n\tprivate UAVMappingInfo mapping;\n\n\t/**\n\t * Constructs the CoordinatedMission instance. A mission consists of one or more\n\t * UAVs, each of which has a set of assigned tasks and synchronization points.\n\t * \n\t * @param instructions\n\t * \n\t * @param mission\n\t */\n\tFullMissionPlan2(IMissionPlan instructions) {\n\t\tthis.instructions = instructions;\n\t\tuavMissionPlans = new HashMap<>();\n\t\tsynchPointMgr = SynchronizationManager.getInstance();\n\n\t}\n\n\t/**\n\t * Adds an additional UAV to the mission plan. Creates the\n\t * <code>UAVMissionTasks</code> instance and passes it a reference to the\n\t * <code>synchPointMgr</code>\n\t * \n\t * @param uavID\n\t *            the ID of the UAV\n\t * @return\n\t * @throws MissionExecutionException\n\t */\n\tpublic UAVMissionPlan addUAV(String uavID) throws MissionExecutionException {\n\t\tLOGGER.info(\"Adding UAV: \" + uavID);\n\t\tUAVMissionPlan plan = new UAVMissionPlan(uavID, synchPointMgr);\n\t\tif (uavMissionPlans.containsKey(uavID)) {\n\t\t\tthrow new MissionExecutionException(\"Mission Plan for UAV '\" + uavID + \"' already defined\");\n\t\t}\n\t\tuavMissionPlans.put(uavID, plan);\n\t\treturn plan;\n\t}\n\n\tpublic void removeUAV(String uavID) {\n\t\tuavMissionPlans.remove(uavID);\n\t}\n\n\t/**\n\t * Assigns a task to a specific UAV\n\t * \n\t * @param uavID\n\t *            UAV Identifier\n\t * @param task\n\t *            Task to perform (e.g., Route, Waypoint, Synchronize,\n\t *            FlightPattern)\n\t * @param taskID\n\t *            Task specifics (e.g., specific waypoint, route name etc)\n\t * @throws MissionExecutionException\n\t */\n\tpublic void addTask(String uavID, String task, String taskID, Map<String, Serializable> params)\n\t\t\tthrows MissionExecutionException {\n\t\tLOGGER.info(\"Adding Task to uav ':\" + uavID + \"' -- \" + task + \" -- \" + taskID);\n\t\tfor (UAVMissionPlan plan : uavMissionPlans.values()) {\n\t\t\tif (plan.getUavID().equals(uavID)) {\n\t\t\t\tplan.addTask(TaskFactory.getTask(task, uavID, taskID, params), synchPointMgr);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow new MissionExecutionException(\"UAVMissionPlan '\" + uavID + \"' not available!\");\n\t}\n\n\t@Override\n\tpublic boolean isMissionActive() {\n\t\tfor (UAVMissionPlan plan : uavMissionPlans.values()) {\n\t\t\tif (plan.hasTasks()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Build all synch points\n\t */\n\tprivate void buildAllSynchPoints() {\n\t\tuavMissionPlans.forEach((uavId, plan) -> {\n\t\t\tplan.buildSynchPoints();\n\t\t});\n\t}\n\n\t/**\n\t * Activates next task in each UAV mission, if there is no unfinished active\n\t * task\n\t * \n\t * @throws MissionExecutionException\n\t */\n\t@Override\n\tpublic void checkAndActivateTask() throws MissionExecutionException {\n\t\tfor (UAVMissionPlan plan : uavMissionPlans.values()) {\n\t\t\tif (!plan.hasActiveTask()) {\n\t\t\t\tplan.activateNextTask();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Expands flight pattern tasks (e.g., coordinatedTakeOff or coordinatedLanding)\n\t * \n\t * @throws MissionExecutionException\n\t * \n\t */\n\tprivate void expandAllTasks() throws MissionExecutionException {\n\t\tfor (UAVMissionPlan plan : uavMissionPlans.values()) {\n\t\t\tplan.expandTaskList();\n\t\t}\n\t}\n\n\tpublic void build(UAVMappingInfo mapping) throws MissionExecutionException {\n\t\ttry {\n\t\t\tthis.mapping = mapping;\n\t\t\taddUAVS();\n\t\t\texpandAllTasks();\n\t\t\tbuildAllSynchPoints();\n\t\t\tsynchPointMgr.activateAllSynchPoints();\n\t\t\trunPreChecks();\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t\tthrow t;\n\t\t}\n\n\t}\n\n\tprivate void addUAVS() throws MissionExecutionException {\n\t\tfor (IUAVMissionDescription desc : instructions.getMissionDescriptions()) {\n\t\t\tcreatePlan(desc);\n\t\t}\n\t}\n\n\tprivate void createPlan(IUAVMissionDescription desc) throws MissionExecutionException {\n\t\tString uavid = desc.getName();\n\t\tif (mapping.getAttribute(desc.getName()) != null) {\n\t\t\tuavid = mapping.getAttribute(desc.getName());\n\t\t}\n\n\t\tUAVMissionPlan plan = addUAV(uavid);\n\t\tfor (IUAVMissionTask t : desc.getTasks()) {\n\t\t\taddTask(plan.getUavID(), t.getType(), t.getId(), t.getParameters());\n\t\t}\n\n\t}\n\n\tprivate void runPreChecks() throws MissionExecutionException {\n\t\tfor (Entry<String, UAVMissionPlan> e : uavMissionPlans.entrySet()) {\n\t\t\tcheckDistance(e.getKey(), e.getValue());\n\t\t}\n\t}\n\n\tprivate void checkDistance(String uavid, UAVMissionPlan plan) throws MissionExecutionException {\n\t\tLlaCoordinate coordinate = plan.getStartingRouteWaypoint();\n\t\tIUAVProxy uav = null;\n\t\tif (coordinate == null) {\n\t\t\tthrow new MissionExecutionException(\"Error when retrieving first waypoint for uav '\" + uavid + \"'\");\n\t\t}\n\t\ttry {\n\t\t\tuav = DroneSetupService.getInstance().getActiveUAV(uavid);\n\t\t} catch (DronologyServiceException e) {\n\t\t\tthrow new MissionExecutionException(e.getMessage());\n\t\t}\n\t\tdouble distanceToFirstWaypoint = uav.getCoordinates().distance(coordinate);\n\t\tif (distanceToFirstWaypoint > DronologyConstants.MISSION_MAX_STARTING_DISTANCE) {\n\t\t\tthrow new MissionExecutionException(\n\t\t\t\t\t\"Distance to first waypoint exceeds maximum safety distance: \" + distanceToFirstWaypoint + \"m\");\n\t\t}\n\t\tLOGGER.info(\"Precheck passed -- Distance to first waypoint: \" + distanceToFirstWaypoint);\n\n\t}\n\n\t@Override\n\tpublic void cancelMission() {\n\t\tLOGGER.missionError(\"Mission cancelled!\");\n\t\tfor (UAVMissionPlan plan : uavMissionPlans.values()) {\n\t\t\tString uavid = plan.getUavID();\n\t\t\tMissionUtil.stopUAV(uavid);\n\t\t}\n\t}\n\n}\n"}, {"id": "MissionHandler.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport com.vaadin.ui.Upload.Receiver;\nimport com.vaadin.ui.Upload.SucceededEvent;\nimport com.vaadin.ui.Upload.SucceededListener;\n\nimport edu.nd.dronology.services.core.info.MissionInfo;\nimport edu.nd.dronology.services.core.remote.IMissionPlanningRemoteService;\nimport edu.nd.dronology.ui.vaadin.start.MyUI;\n\npublic class MissionHandler {\n\n\t//private MissionUploader receiver;\n\n\tpublic MissionHandler() {\n\t\t//receiver = new MissionUploader();\n\t}\n\n\tpublic void executeMission() {\n\t\t// System.out.println(\"UPLOAD!!\");\n\t\ttry {\n\t\t\t// Upload upload = new Upload(\"Upload Image Here\", receiver);\n\t\t\t// upload.setButtonCaption(\"Select\");\n\t\t\t//System.out.println(\"STRING:\" + missionContent);\n\t\t\tIMissionPlanningRemoteService missionService = (IMissionPlanningRemoteService) MyUI.getProvider()\n\t\t\t\t\t.getRemoteManager().getService(IMissionPlanningRemoteService.class);\n\n\t\t\tmissionService.executeMissionPlan(missionContent);\n\t\t} catch (Exception e) {\n\t\t\tMyUI.setConnected(false);\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n/*\n\tpublic MissionUploader getReceiver() {\n\t\treturn receiver;\n\t}\n*/\t\n\tpublic void setMissionContent(MissionInfo info) {\n\t\tmissionContent = info;\n\t}\n\t\n\n\t// Show uploaded file in this placeholder\n\tMissionInfo missionContent;\n\n\t// Implement both receiver that saves upload in a file and\n\t// listener for successful upload\n\t\n\t//class MissionUploader implements Receiver, SucceededListener {\n\t\t/**\n\t\t * \n\t\t */\n\t/*\n\t\tprivate static final long serialVersionUID = -533969977302422170L;\n\t\tpublic File file;\n\n\t\t@Override\n\t\tpublic OutputStream receiveUpload(String filename, String mimeType) {\n\t\t\tSystem.out.println(\"UPLOAD!!!!\");\n\t\t\tFileOutputStream fos = null; // Output stream to write to\n\t\t\ttry {\n\t\t\t\tSystem.out.println(filename);\n\n\t\t\t\t// file = new File(\"c:\\\\tmp\\\\uploads\\\\\" + filename);\n\t\t\t\tfile = File.createTempFile(\"abc\", \"tmp\");\n\t\t\t\tfile.createNewFile();\n\t\t\t\tfos = new FileOutputStream(file);\n\t\t\t} catch (Throwable e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// ...\n\t\t\treturn fos;\n\t\t}\n\n\t\t\n\t\t@Override\n\t\tpublic void uploadSucceeded(SucceededEvent event) {\n\t\t\ttry {\n\t\t\t\tmissionContent = readFile(file.getAbsolutePath());\n\t\t\t\texecuteMission();\n\t\t\t} catch (Throwable e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String readFile(String absolutePath) {\n\t\t\tStringBuilder contents = new StringBuilder();\n\t\t\tBufferedReader buf = getBufferedFileReader(absolutePath);\n\t\t\tString line;\n\t\t\ttry {\n\t\t\t\twhile (buf != null && (line = buf.readLine()) != null) {\n\t\t\t\t\tcontents.append(line + System.lineSeparator());\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn contents.toString();\n\t\t}\n\n\t\tpublic BufferedReader getBufferedFileReader(String absolutePath) {\n\t\t\tFileReader fr = null;\n\t\t\tBufferedReader buf = null;\n\t\t\ttry {\n\t\t\t\tString path = absolutePath;\n\t\t\t\tfr = new FileReader(path);\n\t\t\t\tbuf = new BufferedReader(fr);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// OGGER.Lwarn(\"Could not read file: \" + absolutePath);\n\t\t\t\te.printStackTrace();\n\n\t\t\t}\n\t\t\treturn buf;\n\t\t}\n\t\t\n\t};\n\t*/\n}\n\n"}, {"id": "UAVEquipmentTypeRegistrationPersistenceProvider.java", "body": "package edu.nd.dronology.services.core.persistence;\n\nimport edu.nd.dronology.services.core.items.IUAVEquipmentTypeRegistration;\nimport edu.nd.dronology.services.core.items.IUAVRegistration;\nimport edu.nd.dronology.services.core.persistence.internal.UAVEquipmentTypeRegistrationXStreamPersistor;\n\n\n/**\n * Provider implementation for {@link IUAVRegistration}.<br>\n * Details see {@link AbstractItemPersistenceProvider}\n * \n * @author Michael Vierhauser\n * \n */\npublic class UAVEquipmentTypeRegistrationPersistenceProvider extends AbstractItemPersistenceProvider<IUAVEquipmentTypeRegistration> {\n\n\tpublic UAVEquipmentTypeRegistrationPersistenceProvider() {\n\t\tsuper();\n\t}\n\n\t@Override\n\tprotected void initPersistor() {\n\t\tPERSISTOR = new UAVEquipmentTypeRegistrationXStreamPersistor();\n\n\t}\n\n\t@Override\n\tprotected void initPersistor(String type) {\n\t\tinitPersistor();\n\t}\n\n\tpublic static UAVEquipmentTypeRegistrationPersistenceProvider getInstance() {\n\t\treturn new UAVEquipmentTypeRegistrationPersistenceProvider();\n\t}\n\n}\n"}, {"id": "UAVMonitorableMessage.java", "body": "package edu.nd.dronology.core.monitoring.messages;\n\nimport java.io.Serializable;\nimport java.text.DateFormat;\n\nimport com.google.gson.FieldNamingPolicy;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\nimport edu.nd.dronology.core.monitoring.ArtifactIdentifier;\nimport edu.nd.dronology.core.monitoring.IMonitorableMessage;\nimport edu.nd.dronology.core.util.FormatUtil;\nimport edu.nd.dronology.core.util.PreciseTimestamp;\n\n/**\n * \n * Base class for all monitorable messages.\n * \n * @author Michael Vierhauser\n *\n */\npublic class UAVMonitorableMessage implements IMonitorableMessage {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -9170213896841874463L;\n\tstatic final transient Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()\n\t\t\t.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).setVersion(1.0)\n\t\t\t.serializeSpecialFloatingPointValues().create();\n\n\tpublic enum MessageType {\n\t\tCOMMAND, STATE_CHANGE, PLAN_ACTIVATED, GCS_MONITORING, WAYPOINT_REACHED, PLAN_COMPLETE, VIRTUAL_UAV_ACTIVATED, PHYSICAL_UAV_ACTIVATED, PHYSICAL_UAV_DEACTIVATED, FENCE_BREACH, FENCE_CHECK, MISSION_WAYPOINT, COLLISION\n\t}\n\n\tprivate final MessageType type;\n\tprivate final PreciseTimestamp timestamp;\n\tprivate final ArtifactIdentifier id;\n\tprivate String uavid;\n\tprivate String data;\n\tprivate String datatype;\n\n\tpublic UAVMonitorableMessage(MessageType type, String uavid) {\n\t\tthis(type, uavid, null);\n\t}\n\n\tpublic UAVMonitorableMessage(MessageType type, String uavid, Serializable data) {\n\t\ttimestamp = PreciseTimestamp.create();\n\t\tthis.type = type;\n\t\tthis.uavid = uavid;\n\t\tthis.id = new ArtifactIdentifier(ArtifactIdentifier.ROOT, \"INTERNAL\", type.toString(), uavid);\n\t\tif (data != null) {\n\t\t\tthis.data = GSON.toJson(data);\n\t\t\tthis.datatype = data.getClass().getSimpleName();\n\t\t}\n\t}\n\n\t@Override\n\tpublic MessageType getType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic PreciseTimestamp getTimestamp() {\n\t\treturn timestamp;\n\t}\n\n\t@Override\n\tpublic String getUavid() {\n\t\treturn uavid;\n\t}\n\n\t@Override\n\tpublic String getData() {\n\t\treturn data;\n\t}\n\n\t@Override\n\tpublic ArtifactIdentifier<?> getIdentifier() {\n\t\treturn id;\n\n\t}\n\n\tpublic String getDataType() {\n\t\treturn datatype;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn FormatUtil.formatTimestamp(timestamp) + \" [Message: \" + type + \" | uav:\" + uavid + \" | \" + data + \" ]\";\n\n\t}\n\n}\n"}, {"id": "IStartstrategy.java", "body": "package edu.nd.dronology.core.vehicle.uav;\n\npublic interface IStartstrategy {\n\n}\n"}, {"id": "AssignedDrone.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport edu.nd.dronology.core.CoordinateChange;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\npublic class AssignedDrone {\n\n\tpublic final String droneName;\n\tpublic LlaCoordinate startCoordinate = new LlaCoordinate(0, 0, 0);\n\n\tpublic AssignedDrone(String droneName) {\n\t\tsuper();\n\t\tthis.droneName = droneName;\n\t}\n\n\tpublic LlaCoordinate getStartCoordinate() {\n\t\treturn startCoordinate;\n\t}\n\n\t@CoordinateChange\n\tpublic void setStartCoordinate(double latitude, double longitude, double altitude) {\n\t\tstartCoordinate = new LlaCoordinate(latitude, longitude, altitude);\n\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((droneName == null) ? 0 : droneName.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tAssignedDrone other = (AssignedDrone) obj;\n\t\tif (droneName == null) {\n\t\t\tif (other.droneName != null)\n\t\t\t\treturn false;\n\t\t} else if (!droneName.equals(other.droneName))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic String getName() {\n\t\treturn droneName;\n\t}\n\n}\n"}, {"id": "MapNode.java", "body": "package edu.nd.dronology.services.extensions.areamapping.internal;\n\n\n\n//Class defining nodes along the riverbanks\npublic class MapNode {\n  double _latitude;\n  double _longitude;\n  int _riverSide;\n\n  public MapNode(double latitude, double longitude, int riverside){\n      _latitude = latitude;\n      _longitude = longitude;\n      _riverSide = riverside;\n  }\n\n  public double getLatitude() {\n      return _latitude;\n  }\n  public double getLongitude(){\n      return _longitude;\n  }\n  public int get_riverSide(){\n      return _riverSide;\n  }\n}\n\n"}, {"id": "TreeNode.java", "body": "package edu.nd.dronology.monitoring.tree;\n\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.WeakHashMap;\n\nimport edu.nd.dronology.core.monitoring.ArtifactIdentifier;\nimport edu.nd.dronology.util.Immutables;\nimport edu.nd.dronology.util.NullUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * A tree node which can hold elements at a node (a set of ArtifactIdentifier)\n * and<br/>\n * have some children identified by ArtifactIdentifier.\n * \n * \n */\n\npublic class TreeNode {\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(TreeNode.class);\n\n\tprivate final ArtifactIdentifier artifactIdentifier;\n\n\tprivate final Set<ArtifactIdentifier> elements = new HashSet<>();\n\n\tprivate final WeakHashMap<ArtifactIdentifier, TreeNode> children = new WeakHashMap<>();\n\n\tprivate TreeNode parent;\n\n\tpublic TreeNode(ArtifactIdentifier id) {\n\t\tNullUtil.checkNull(id);\n\t\tthis.artifactIdentifier = id;\n\t}\n\n\tpublic synchronized ArtifactIdentifier getArtifactIdentifier() {\n\t\treturn artifactIdentifier;\n\t}\n\n\t/**\n\t * Returns an existing child or creates a new one, if none present.\n\t * \n\t * @param id\n\t * @return The child with the given identifier.\n\t */\n\tpublic synchronized TreeNode getChild(final ArtifactIdentifier id) {\n\t\tif (id == null) {\n\t\t\tthrow new IllegalArgumentException(\"Parameter id can't be null!\");\n\t\t}\n\t\tif (children.containsKey(id)) {\n\t\t\treturn children.get(id);\n\t\t}\n\t\tTreeNode node = new TreeNode(id);\n\t\tchildren.put(id, node);\n\t\tnode.setParent(this);\n\t\treturn node;\n\t}\n\n\tprivate void setParent(TreeNode treeNode) {\n\t\tthis.parent = treeNode;\n\n\t}\n\n\tpublic synchronized boolean addElement(ArtifactIdentifier id) {\n\t\tif (elements.contains(id)) {\n\t\t\tfor (ArtifactIdentifier elem : elements) {\n\t\t\t\tif (elem.equals(id)) {\n\t\t\t\t\telem.attachItems(id.getAttachedItems());\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn elements.add(id);\n\t}\n\n\tpublic synchronized Set<ArtifactIdentifier> getElements() {\n\t\treturn Immutables.hashSetCopy(elements);\n\t}\n\n\tpublic synchronized Map<ArtifactIdentifier, TreeNode> getChildren() {\n\t\treturn Immutables.hashMapCopy(children);\n\t}\n\n\t/**\n\t * Remove all children and elements.\n\t */\n\tpublic synchronized void clear() {\n\t\tchildren.clear();\n\t\telements.clear();\n\t}\n\n\t@Override\n\tpublic synchronized int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = (prime * result) + ((artifactIdentifier == null) ? 0 : artifactIdentifier.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic synchronized boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (obj == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (getClass() != obj.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tTreeNode other = (TreeNode) obj;\n\t\tif (artifactIdentifier == null) {\n\t\t\tif (other.artifactIdentifier != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (!artifactIdentifier.equals(other.artifactIdentifier)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic synchronized String toString() {\n\t\treturn \"TreeNode [artifactIdentifier=\" + artifactIdentifier + \", children=\" + children + \", elems=\" + elements\n\t\t\t\t+ \"]\";\n\t}\n\n\t/**\n\t * Debug-only diagnostic output.\n\t */\n\tpublic synchronized void toLog() {\n\t\tLOGGER.debug(\"artifactIdentifier=\" + artifactIdentifier);\n\t\tLOGGER.debug(\"elems=\" + elements);\n\t\tfor (Map.Entry<ArtifactIdentifier, TreeNode> childEntries : children.entrySet()) {\n\t\t\tLOGGER.debug(\"---\");\n\t\t\tLOGGER.debug(\"child '\" + childEntries.getKey() + \"':\");\n\t\t\tLOGGER.debug(childEntries.getValue());\n\t\t}\n\n\t}\n\n\tpublic TreeNode getParent() {\n\t\treturn parent;\n\t}\n\n\tpublic void remove(TreeNode node) {\n\t\tchildren.remove(node.getArtifactIdentifier());\n\t}\n}\n"}, {"id": "SourcePoints.java", "body": "package edu.nd.dronology.services.extensions.areamapping.internal;\n\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class SourcePoints {\n\tprivate List<Point2D.Double> sourcePoints;\n\tprivate int weight;\n\t\n\tpublic SourcePoints() {\n\t\tthis(0);\n\t}\n\t\n\tpublic SourcePoints(int weight) {\n\t\tsourcePoints = new ArrayList<>();\n\t\tthis.weight = weight;\n\t}\n\t\n\tpublic List<Point2D.Double> getSourcePoints(){\n\t\treturn Collections.unmodifiableList(sourcePoints);\n\t}\n\t\n\tpublic Point2D.Double getSourcePoint(int index){\n\t\treturn sourcePoints.get(index);\n\t}\n\t\n\tpublic void setSourcePoints(List<Point2D.Double> points) {\n\t\tsourcePoints = points;\n\t}\n\t\n\tpublic void setSourcePoint(int index, Point2D.Double point) {\n\t\tsourcePoints.set(index, point);\n\t}\n\t\n\tpublic void addSourcePoint(Point2D.Double point) {\n\t\tsourcePoints.add(point);\n\t}\n\t\n\tpublic int size() {\n\t\treturn sourcePoints.size();\n\t}\n\t\n\tpublic int getWeight() {\n\t\treturn weight;\n\t}\n}\n"}, {"id": "CommandExecutor.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal;\n\npublic interface CommandExecutor {\n    void process();\n    boolean isFinished();\n}\n"}, {"id": "IRouteCreator.java", "body": "package edu.nd.dronology.services.extensions.areamapping.creation;\n\nimport java.awt.geom.Path2D.Double;\nimport java.util.List;\n\nimport edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\n\npublic interface IRouteCreator {\n\n\tList<RoutePrimitive> generateRoutePrimitives();\n\n\tList<RiverBank> getBankList();\n\n\tDouble getTotalRiverSegment();\n\n\tdouble getAverageLatitude();\n\n}\n"}, {"id": "IPlanStatusChangeListener.java", "body": "package edu.nd.dronology.core.flight;\n\npublic interface IPlanStatusChangeListener {\n\n\tvoid notifyPlanChange(IFlightPlan changedPlan);\n\n}\n"}, {"id": "UAVRegistration.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class UAVRegistration implements IUAVRegistration {\n\n\tprivate String id;\n\tprivate String name;\n\tprivate String description;\n\tprivate String type = \"Default\";\n\tprivate Map<String, Serializable> attributes;\n\tprivate byte[] image;\n\n\tpublic UAVRegistration() {\n\t\tid = UUID.randomUUID().toString();\n\t\tattributes = new HashMap<>();\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\t// TODO Auto-generated method stub\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\t@Override\n\tpublic void setType(String type) {\n\t\tthis.type = type;\n\n\t}\n\n\t@Override\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\n\t}\n\n\t@Override\n\tpublic String getType() {\n\t\treturn type;\n\t}\n\n\t@Override\n\tpublic Serializable getAttribute(String key) {\n\t\treturn attributes.get(key);\n\t}\n\n\t@Override\n\tpublic void addAttribute(String key, Serializable value) {\n\t\tattributes.put(key, value);\n\t}\n\n\t@Override\n\tpublic void setUAVImage(byte[] image) {\n\t\tthis.image = image;\n\t}\n\n\t@Override\n\tpublic byte[] getImage() {\n\t\treturn image;\n\t}\n}\n"}, {"id": "JsonTester.java", "body": "package edu.nd.dronology.misc.gcs;\n\nimport java.text.DateFormat;\n\nimport com.google.gson.FieldNamingPolicy;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\nimport edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;\n\npublic class JsonTester {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t//\n\t\t// System.out.println(new TakeoffCommand(\"1\", 20).toJsonString());\n\t\t// System.out.println(new SetModeCommand(\"1\", \"LAND\").toJsonString());\n\t\t// System.out.println(new GoToCommand(\"1\", new LlaCoordinate(41.732957,\n\t\t// -86.180883, 20)).toJsonString());\n\t\t// System.out.println(new TakeoffCommand(\"1\", 20).toJsonString());\n\n\t\tfinal Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()\n\t\t\t\t.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)\n\t\t\t\t.setVersion(1.0).serializeSpecialFloatingPointValues().create();\n\n\t\tUAVMonitoringMessage mm = new UAVMonitoringMessage(\"Drone1\", \"FAKE\", \"Drone1\");\n\n\t\tmm.setType(\"MonitoringMessage\");\n\t\t// mm.setuavid(\"DRONE1\");\n\t\tmm.addPropery(\"NR_SATELITES\", \"5\");\n\t\tmm.addPropery(\"GPS_BIAS\", \"3.125\");\n\t\tmm.addPropery(\"CURRENT_SPEED\", \"5.25\");\n\n\t\tSystem.out.println(GSON.toJson(mm));\n\n\t}\n\n}\n"}, {"id": "VirtualDroneFleetFactory.java", "body": "package edu.nd.dronology.core.fleet;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.monitoring.DronologyMonitoringManager;\nimport edu.nd.dronology.core.monitoring.MessageMarshaller;\nimport edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;\nimport edu.nd.dronology.core.vehicle.IDrone;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\nimport edu.nd.dronology.core.vehicle.internal.VirtualDrone;\n/**\n * Factory class for initializing a new {@link VirtualDrone} instance.\n * \n * @author Jane Cleland-Huang \n *\n */\npublic class VirtualDroneFleetFactory extends AbstractDroneFleetFactory {\n\n\tprotected VirtualDroneFleetFactory() {\n\n\t} \n\n\tprivate static volatile VirtualDroneFleetFactory INSTANCE = null;\n\n\tpublic static VirtualDroneFleetFactory getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (VirtualDroneFleetFactory.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new VirtualDroneFleetFactory();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE; \n\t}\n\n\t@Override\n\tpublic ManagedDrone initializeDrone(String droneID, String droneType, double latitude, double longitude,\n\t\t\tdouble altitude) throws DroneException {\n\t\tIDrone drone = new VirtualDrone(createDroneID(droneID));\n\t\tManagedDrone managedDrone = new ManagedDrone(drone);\n\n\t\tdrone.setManagedDrone(managedDrone);\n\t\tLlaCoordinate currentPosition = new LlaCoordinate(latitude, longitude, altitude);\n\t\tdrone.setBaseCoordinates(currentPosition);\n\t\tdrone.setCoordinates(currentPosition.getLatitude(), currentPosition.getLongitude(),\n\t\t\t\tcurrentPosition.getAltitude());\n\t\tmanagedDrone.start(); \n\t\tDroneFleetManager.getInstance().addDrone(managedDrone);\n\t\tDronologyMonitoringManager.getInstance().publish(MessageMarshaller\n\t\t\t\t.createMessage(MessageType.VIRTUAL_UAV_ACTIVATED, drone.getDroneName(), currentPosition));\n\n\t\treturn managedDrone;\n\t}\n\n}\n"}, {"id": "DefaultAction.java", "body": "package edu.nd.dronology.core.collisionavoidance.strategy.onionbackend;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\nimport edu.nd.dronology.core.collisionavoidance.strategy.StopEveryone;\nimport edu.nd.dronology.core.goal.WaypointGoalSnapshot;\n\npublic class DefaultAction implements IAction {\n\n\t@Override\n\tpublic void applyAction(DroneSnapshot snapshot) {\n        WaypointGoalSnapshot goal = StopEveryone.findActiveWaypointGoal(snapshot.getGoals());\n        if (goal != null) {\n            StopEveryone.flyToGoalIfNotAlready(snapshot, goal);\n        }\n\t}\n\n}"}, {"id": "DistanceChecker.java", "body": "package edu.nd.dronology.monitoring.simplechecker.checker;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.monitoring.DronologyMonitoringManager;\nimport edu.nd.dronology.core.monitoring.IMonitorableMessage;\nimport edu.nd.dronology.core.monitoring.MessageMarshaller;\nimport edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;\nimport edu.nd.dronology.core.util.ManagedHashTableList;\nimport edu.nd.dronology.gstation.connector.messages.UAVStateMessage;\nimport edu.nd.dronology.util.Pair;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class DistanceChecker {\n\tprivate static final transient ILogger LOGGER = LoggerProvider.getLogger(DistanceChecker.class);\n\n\tprivate static final double MIN_DIST = 5;\n\n\tpublic DistanceChecker() {\n\t\tTimer timer = new Timer();\n\t\ttimer.schedule(new CheckTask(), 0, 1500);\n\t}\n\n\tprivate static transient DistanceChecker INSTANCE;\n\n\tprivate BlockingQueue<UAVStateMessage> messageQueue = new ArrayBlockingQueue<>(100);\n\n\tprivate transient ManagedHashTableList<String, Pair> dataMap = new ManagedHashTableList<>();\n\n\tpublic static DistanceChecker getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (SimpleChecker.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new DistanceChecker();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\tpublic void notify(IMonitorableMessage message) {\n\t\tmessageQueue.offer((UAVStateMessage) message);\n\n\t}\n\n\tprivate class CheckTask extends TimerTask {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tList<UAVStateMessage> toCheck = new ArrayList<>();\n\t\t\tmessageQueue.drainTo(toCheck);\n\t\t\t// System.out.println(\"RUN DISTANCE CHECK!\" + dataMap.size());\n\t\t\tcalculateDistance(toCheck);\n\t\t\tcalculateDistance();\n\t\t}\n\n\t}\n\n\tpublic void processMessage(UAVStateMessage msg) {\n\t\ttry {\n\n\t\t\tdouble xVal = msg.getLocation().getLatitude();\n\t\t\tdouble yVal = msg.getLocation().getLongitude();\n\t\t\tdouble zVal = msg.getLocation().getAltitude();\n\n\t\t\tLlaCoordinate cord = new LlaCoordinate(xVal, yVal, zVal);\n\t\t\t// System.out.println(event.getSource()+\":::\"+cord);\n\n\t\t\tdataMap.add(msg.getUavid(), Pair.create(msg.getSendtimestamp(), cord));\n\n\t\t\t// setLastValidState(Boolean.parseBoolean(value.toString()));\n\t\t} catch (Throwable e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\n\tpublic void calculateDistance() {\n\t\ttry {\n\t\t\tManagedHashTableList<String, Pair> checkMap = new ManagedHashTableList<>();\n\t\t\tsynchronized (dataMap) {\n\t\t\t\tfor (Entry<String, List<Pair>> e : dataMap.entrySet()) {\n\t\t\t\t\tcheckMap.put(e.getKey(), e.getValue());\n\t\t\t\t}\n\t\t\t\tdataMap.clear();\n\t\t\t}\n\n\t\t\tfor (Entry<String, List<Pair>> e : checkMap.entrySet()) {\n\t\t\t\tString id = e.getKey();\n\t\t\t\tList<Pair> cords = e.getValue();\n\n\t\t\t\tfor (Pair corrd : cords) {\n\t\t\t\t\tfor (Entry<String, List<Pair>> f : checkMap.entrySet()) {\n\t\t\t\t\t\tString fid = f.getKey();\n\t\t\t\t\t\tif (id.equals(fid)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tList<Pair> fcords = f.getValue();\n\t\t\t\t\t\tfor (Pair fcoord : fcords) {\n\n\t\t\t\t\t\t\t// System.out.println(id + \"-\" + fid + \"DISTANCE:\" + corrd.distance(fcoord));\n\n\t\t\t\t\t\t\tLlaCoordinate c1 = (LlaCoordinate) Pair.cast(corrd).getSecond();\n\t\t\t\t\t\t\tLlaCoordinate c2 = (LlaCoordinate) Pair.cast(fcoord).getSecond();\n\n\t\t\t\t\t\t\tlong ts1 = (long) Pair.cast(corrd).getFirst();\n\t\t\t\t\t\t\tlong ts2 = (long) Pair.cast(fcoord).getFirst();\n\t\t\t\t\t\t\tlong dif = Math.abs(ts1 - ts2);\n\t\t\t\t\t\t\t// System.out.println(Math.abs(ts1.getTimestamp() - ts2.getTimestamp()));\n\t\t\t\t\t\t\tif (dif > 500) {\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdouble distance = (c1.distance(c2));\n\n\t\t\t\t\t\t\tif (distance < MIN_DIST) {\n\t\t\t\t\t\t\t\tLOGGER.error(\"COLLISION!!!\");\n\t\t\t\t\t\t\t\tDronologyMonitoringManager.getInstance().publish(MessageMarshaller.createMessage(\n\t\t\t\t\t\t\t\t\t\tMessageType.COLLISION, id, new CollisionInfo(id, fid, distance)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic void calculateDistance(List<UAVStateMessage> toCheck) {\n\t\ttoCheck.forEach(m -> {\n\t\t\tprocessMessage(m);\n\t\t});\n\n\t}\n\n}\n"}, {"id": "UAVMissionPlan.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.plan;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.services.core.info.FlightInfo;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;\nimport edu.nd.dronology.services.extensions.missionplanning.patterns.IFlightPattern;\nimport edu.nd.dronology.services.extensions.missionplanning.patterns.PatternFactory;\nimport edu.nd.dronology.services.extensions.missionplanning.patterns.PatternFactory.PatternType;\nimport edu.nd.dronology.services.extensions.missionplanning.patterns.TaskList;\nimport edu.nd.dronology.services.extensions.missionplanning.sync.SynchronizationManager;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.DelayTask;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.IMissionTask;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.LandTask;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.PatternTask;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.RouteTask;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.SyncTask;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.TakeoffTask;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.WaypointTask;\nimport edu.nd.dronology.services.instances.flightmanager.FlightManagerService;\nimport edu.nd.dronology.services.instances.flightroute.FlightRouteplanningService;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * Mission plan for an individual UAV. Part of an {@link IExecuteableMissionPlan}.\n * \n * @author Jane Cleland-Huang\n *\n */\npublic class UAVMissionPlan {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(UAVMissionPlan.class);\n \n\tprivate IMissionTask activeTask = null;\n\tprivate final String uavid;\n\tprivate List<IMissionTask> taskList;\n\tprivate LlaCoordinate homeLocation;\n\tprivate LlaCoordinate firstWaypointLocation;\n\n\tprivate int coordinationAltitude = 0;\n\tprivate final transient SynchronizationManager synchMgr;\n\n\tpublic UAVMissionPlan(String uavID, SynchronizationManager synchMgr) {\n\t\tthis.uavid = uavID;\n\t\ttaskList = new LinkedList<>();\n\t\tthis.synchMgr = synchMgr;\n\t}\n\n\t/**\n\t * Check if task if finished\n\t * \n\t * @return\n\t * @throws MissionExecutionException\n\t */\n\tprivate boolean isExecutingTask() throws MissionExecutionException {\n\t\tFlightInfo info;\n\t\ttry {\n\t\t\tinfo = FlightManagerService.getInstance().getFlightInfo(uavid);\n\t\t} catch (DronologyServiceException e) {\n\t\t\tLOGGER.error(e);\n\t\t\tthrow new MissionExecutionException(e.getMessage());\n\t\t}\n\t\treturn info.getCurrentFlights() != null;\n\n\t}\n\n\t/**\n\t * Needs to actually activate the flight route. NOTE: Needs to handle ROUTE, WAYPOINT, TAKEOFF, and LAND (Synch is done internally and shouldn't need any extra coordination).\n\t * \n\t * @throws Exception\n\t */\n\tpublic void activateNextTask() throws MissionExecutionException {\n\t\tactiveTask = null;\n\t\tif (!taskList.isEmpty()) {\n\t\t\tactiveTask = taskList.get(0);\n\t\t\ttaskList.remove(0);\n\n\t\t\t// Now execute the task. This will depend on whether it is a waypoint, entire\n\t\t\t// route, or synch point\n\t\t\tif (activeTask instanceof SyncTask) {\n\t\t\t\tLOGGER.missionInfo(\"UAV \" + uavid + \" waiting at SYNCH POINT: \" + activeTask.getTaskName());\n\t\t\t\tsynchMgr.uavVisitedSynchPoint(uavid, activeTask.getTaskName()); // Marks this uav as synched\n\n\t\t\t\tif (synchMgr.isFullySynched(activeTask.getTaskName())) {\n\t\t\t\t\tLOGGER.missionInfo(\"All UAVs released from \" + activeTask.getTaskName());\n\t\t\t\t\tactiveTask = null; // Free to move on.\n\t\t\t\t}\n\n\t\t\t} else if (activeTask instanceof RouteTask) {\n\t\t\t\tMissionUtil.activateRoute(activeTask);\n\t\t\t} else if (activeTask instanceof DelayTask) { \n\t\t\t\t((DelayTask) activeTask).startDelayTask();\n\t\t\t} else if (activeTask instanceof WaypointTask || activeTask instanceof TakeoffTask\n\t\t\t\t\t|| activeTask instanceof LandTask) {\n\t\t\t\tLOGGER.missionInfo(\"ACTIVATED FLIGHT TO WAYPOINT: \" + uavid + \" \" + activeTask.getTaskName());\n\t\t\t\tMissionUtil.activateWaypoint(activeTask);\n\t\t\t} else {\n\t\t\t\tthrow new UnsupportedOperationException(\"Task '\" + activeTask.getClass() + \"' not supported\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tpublic String getUavID() {\n\t\treturn uavid;\n\t}\n\n\tpublic void setCoordinationAltitude(int alt) {\n\t\tcoordinationAltitude = alt;\n\t}\n\n\tpublic int getCoordinationAltitude() {\n\t\treturn coordinationAltitude; // Add error if null.\n\t}\n\n\tpublic boolean hasActiveTask() throws MissionExecutionException {\n\t\tif (activeTask == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (activeTask instanceof SyncTask) {\n\t\t\tString synchName = activeTask.getTaskName();\n\t\t\tif (!synchMgr.synchPointExists(synchName)) {\n\t\t\t\tLOGGER.missionError(\"Missing synch point\");\n\t\t\t\treturn false;\n\t\t\t} else if (synchMgr.isFullySynched(synchName)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\n\t\t} else if (activeTask instanceof DelayTask) {\n\t\t\treturn !((DelayTask) activeTask).isFinished();\n\t\t} else {// Waypoint or Route\n\t\t\treturn isExecutingTask();\n\t\t}\n\t}\n\n\tpublic void addTask(IMissionTask task, SynchronizationManager synchMgr) throws MissionExecutionException { // Remove\n\t\t// SynchMgr\n\t\ttaskList.add(task);\n\t\tif (firstWaypointLocation == null && task instanceof RouteTask) {\n\t\t\tfirstWaypointLocation = MissionUtil.getFirstWayPoint(task.getTaskName());\n\t\t}\n\t}\n\n\tpublic void buildSynchPoints() {\n\t\ttaskList.forEach(task -> {\n\t\t\tif (task instanceof SyncTask) {\n\t\t\t\tsynchMgr.createSynchronizationPoint(task.getTaskName());\n\t\t\t\tsynchMgr.addSynchItem(task.getUAVId(), task.getTaskName());\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic boolean hasTasks() {\n\t\treturn activeTask != null || taskList.size() > 0;\n\n\t}\n\n\tpublic int taskCount() {\n\t\treturn taskList.size();\n\t}\n\n\t/**\n\t * Expand the task list with PATTERNS. Currently supports two different patterns \"SynchronizedTakeoff\" and \"SynchronizedLanding\" Assumptions: SynchronizedTakeoff has a ROUTE definied immediately\n\t * after. SynchronizedLanding has a ROUTE defined immediately prior.\n\t * \n\t * @throws MissionExecutionException\n\t */\n\tpublic void expandTaskList() throws MissionExecutionException {\n\t\tList<IMissionTask> allTasks = new ArrayList<>();\n\t\tfor (IMissionTask task : taskList) {\n\t\t\thomeLocation = MissionUtil.getHome(task.getUAVId());\n\t\t\tif (task instanceof PatternTask) {\n\t\t\t\tif (task.getTaskName().equals(\"SynchronizedTakeoff\")) {\n\t\t\t\t\tIFlightPattern pattern = PatternFactory.getPattern(PatternType.COORDINATED_TAKEOFF);\n\t\t\t\t\tpattern.initialize(synchMgr);\n\t\t\t\t\tif (firstWaypointLocation != null) // Currently it only expands IF we have at least one ROUTE. It\n\t\t\t\t\t\t// treats the first waypoint as the target waypoint.\n\t\t\t\t\t\tpattern.expandFlightPattern(this, homeLocation, firstWaypointLocation);\n\t\t\t\t\tTaskList list = pattern.getTaskList();\n\t\t\t\t\tallTasks.addAll(list.getTasks());\n\t\t\t\t} else if (task.getTaskName().equals(\"SynchronizedLanding\")) {\n\t\t\t\t\tIFlightPattern pattern = PatternFactory.getPattern(PatternType.COORDINATED_LANDING);\n\t\t\t\t\tpattern.initialize(synchMgr);\n\t\t\t\t\tLlaCoordinate currentFinalWaypoint;\n\t\t\t\t\tcurrentFinalWaypoint = MissionUtil.getFinalWaypoint(allTasks);\n\t\t\t\t\tpattern.expandFlightPattern(this, currentFinalWaypoint, homeLocation);\n\t\t\t\t\tTaskList list = pattern.getTaskList();\n\t\t\t\t\tallTasks.addAll(list.getTasks());\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tallTasks.add(task);\n\t\t\t}\n\t\t}\n\t\ttaskList = allTasks;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\t// self check\n\t\tif (this == o)\n\t\t\treturn true;\n\t\t// null check\n\t\tif (o == null)\n\t\t\treturn false;\n\t\t// type check and cast\n\t\tif (getClass() != o.getClass())\n\t\t\treturn false;\n\t\tUAVMissionPlan that = (UAVMissionPlan) o;\n\t\treturn this.uavid.equals(that.uavid);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tint prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((uavid == null) ? 0 : uavid.hashCode());\n\t\treturn result;\n\t}\n\n\tpublic LlaCoordinate getStartingRouteWaypoint() throws MissionExecutionException {\n\t\tfor (IMissionTask t : taskList) {\n\t\t\tif (t instanceof RouteTask) {\n\t\t\t\ttry {\n\t\t\t\t\tFlightRouteInfo route = FlightRouteplanningService.getInstance().getRouteByName(t.getTaskName());\n\t\t\t\t\tLlaCoordinate coord = route.getWaypoints().get(0).getCoordinate();\n\t\t\t\t\treturn coord;\n\t\t\t\t} catch (DronologyServiceException e) {\n\t\t\t\t\tthrow new MissionExecutionException(\"Error when getting initial waypoint for '\" + t.getTaskName() + \"'\");\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tLOGGER.error(\"No RouteTask found in Mission\");\n\t\treturn taskList.get(0).getWaypoint();\n\n\t}\n\n}"}, {"id": "CollisionAvoidanceUtil.java", "body": "package edu.nd.dronology.core.collisionavoidance;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.commons.math3.util.CombinatoricsUtils;\n\npublic class CollisionAvoidanceUtil {\n\n    private static class DronePairIterator implements Iterator<DronePair> {\n\n        Iterator<int[]> indices;\n        List<DroneSnapshot> snapshots;\n\n        DronePairIterator(List<DroneSnapshot> snapshots, Iterator<int[]> indices) {\n            this.snapshots = snapshots;\n            this.indices = indices;\n        }\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn indices.hasNext();\n\t\t}\n\n\t\t@Override\n\t\tpublic DronePair next() {\n            int[] nextIndices = indices.next();\n            int indexA = nextIndices[0];\n            int indexB = nextIndices[1];\n            return new DronePair(snapshots.get(indexA), snapshots.get(indexB));\n\t\t}\n\n    }\n\n    private static Iterator<DronePair> pairs(List<DroneSnapshot> snapshots) {\n        if (snapshots.size() >= 2) {\n            Iterator<int[]> indices = CombinatoricsUtils.combinationsIterator(snapshots.size(), 2);\n            return new DronePairIterator(snapshots, indices);\n        } else {\n            return Collections.emptyIterator();\n        }\n    }\n\n    public static Iterable<DronePair> findPairs(final List<DroneSnapshot> snapshots) {\n        return new Iterable<DronePair>(){\n        \n            @Override\n            public Iterator<DronePair> iterator() {\n                return pairs(snapshots);\n            }\n            \n        };\n    }\n\n}"}, {"id": "WaypointExecutor.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal;\n\nimport edu.nd.dronology.core.DronologyConstants;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand;\nimport edu.nd.dronology.core.vehicle.IDrone;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\n\npublic class WaypointExecutor implements CommandExecutor {\n\n    enum WaypointExecutionState {\n        RADIOING,\n        SENSING,\n        FINISHED;\n    }\n\n    private IDrone drone;\n    WaypointExecutionState state = WaypointExecutionState.RADIOING;\n    WaypointCommand data;\n\n    public WaypointExecutor(IDrone drone, WaypointCommand data) {\n        this.drone = drone;\n        this.data = data;\n    }\n\n    @Override\n    public void process() {\n        switch (this.state) {\n            case RADIOING:\n                radioDrone();\n                break;\n\n            case SENSING:\n                senseDrone();\n                break;\n\n            case FINISHED:\n            default:\n                // Do nothing.\n                break;\n        }\n    }\n\n    @Override\n    public boolean isFinished() {\n        return this.state == WaypointExecutionState.FINISHED;\n    }\n\n    private void radioDrone() {\n        drone.flyTo(this.data.getDestination(), this.data.getSpeed());\n        this.state = WaypointExecutionState.SENSING;\n    }\n\n    private void senseDrone() {\n        double targetDistance = drone.getCoordinates().distance(data.getDestination());\n        if (targetDistance < DronologyConstants.THRESHOLD_WAYPOINT_DISTANCE) {\n            this.state = WaypointExecutionState.FINISHED;\n        }\n    }\n}\n"}, {"id": "FlightManagerService.java", "body": "package edu.nd.dronology.services.instances.flightmanager;\n\nimport java.util.Collection;\nimport java.util.List;\n\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.services.core.base.AbstractServerService;\nimport edu.nd.dronology.services.core.info.FlightInfo;\nimport edu.nd.dronology.services.core.info.FlightPlanInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n/**\n * \n * Service for handling UAV flights<br>\n * Allows assigning flight plans to UAVs <br>\n * Allows sending flight related commands to UAVs (take-off, return to home...).\n * \n *  \n * @author Michael Vierhauser\n *\n */\npublic class FlightManagerService extends AbstractServerService<IFlightManagerServiceInstance> {\n\n\tprivate static volatile FlightManagerService INSTANCE;\n\n\tprotected FlightManagerService() {\n\t}\n\n\t/**\n\t * @return The singleton ConfigurationService instance\n\t */\n\tpublic static FlightManagerService getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (FlightManagerService.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new FlightManagerService();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tprotected IFlightManagerServiceInstance initServiceInstance() {\n\t\treturn new FlightManagerServiceInstance();\n\t}\n\n\tpublic FlightInfo getFlightInfo(String uavId) throws DronologyServiceException {\n\t\treturn serviceInstance.getFlightInfo(uavId);\n\n\t}\n\n\tpublic void planFlight(String uavid, String planName, List<Waypoint> waypoints) throws Exception {\n\t\tserviceInstance.planFlight(uavid, planName, waypoints);\n\n\t}\n\n\tpublic void planFlight(String planName, List<Waypoint> waypoints) throws Exception {\n\t\tserviceInstance.planFlight(planName, waypoints);\n\n\t}\n\n\tpublic void returnToHome(String uavid) throws Exception {\n\t\tserviceInstance.returnToHome(uavid);\n\n\t} \n\n\tpublic void pauseFlight(String uavid) throws Exception {\n\t\tserviceInstance.pauseFlight(uavid);\n\n\t}\n\n\tpublic Collection<FlightPlanInfo> getCurrentFlights() {\n\t\treturn serviceInstance.getCurrentFlights();\n\t}\n\n\tpublic void cancelPendingFlights(String uavid) throws Exception {\n\t\tserviceInstance.cancelPendingFlights(uavid);\n\t}\n\n\tpublic void takeoff(String uavid, double altitude) throws DronologyServiceException {\n\t\tserviceInstance.takeoff(uavid, altitude);\n\n\t}\n\n\tpublic void emergencyStop(String uavid) throws DronologyServiceException {\n\t\tserviceInstance.emergencyStop(uavid);\n\n\t}\n\n}\n"}, {"id": "IFlightPattern.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.patterns;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;\nimport edu.nd.dronology.services.extensions.missionplanning.plan.UAVMissionPlan;\nimport edu.nd.dronology.services.extensions.missionplanning.sync.SynchronizationManager;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.IMissionTask;\n\n/**\n * Interface for all flight pattern implementations that can be expanded into several different {@link IMissionTask}.\n * \n * @author Michael Vierhauser\n *\n */\npublic interface IFlightPattern {\n\n\tvoid initialize(SynchronizationManager synchMgr);\n\n\t/**\n\t * Coordinates the flight of multiple UAVs across a potentially overlapping space consisting of a currentLocation and a targetLocation for each UAV. FOR NOW: We assume that currentCoordinates and\n\t * targetWayPoints for all UAVs are unique and sufficiently separated from each other. Paths to move from current to target positions may overlap. We should add this check in later on.\n\t * \n\t * @param uavMission\n\t *          The mission plan the pattern belongs to.\n\t * @param currentLocation\n\t *          The current location from which the pattern starts.\n\t * @param targetLocation\n\t *          The target location when the pattern is completed.\n\t * @throws MissionExecutionException\n\t */\n\tpublic void expandFlightPattern(UAVMissionPlan uavMission, LlaCoordinate currentLocation,\n\t\t\tLlaCoordinate targetLocation) throws MissionExecutionException;\n\n\t/**\n\t * \n\t * @return A {@link TaskList } containing the tasks part of that pattern.\n\t */\n\tpublic TaskList getTaskList();\n\n}\n"}, {"id": "LogCleaner.java", "body": "package edu.nd.dronology.services.supervisor;\n\nimport java.io.File;\nimport java.util.Map;\n\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.core.Appender;\nimport org.apache.logging.log4j.core.LoggerContext;\nimport org.apache.logging.log4j.core.appender.RollingFileAppender;\n\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class LogCleaner {\n\n\t/**\n\t * 30 days = 720 hours\n\t */\n\tprivate static final int DELTE_TRESHOLD = 720;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(LogCleaner.class);\n\n\tpublic static void run() {\n\t\ttry {\n\n\t\t\tLoggerContext ctx = (LoggerContext) LogManager.getContext(false);\n\t\t\tSystem.out.println(\"Using logger config:\" + ctx.getConfiguration().getConfigurationSource().getLocation());\n\n\t\t\tMap<String, Appender> appenders = ctx.getRootLogger().getAppenders();\n\t\t\tfor (Appender app : appenders.values()) {\n\t\t\t\tif (app instanceof RollingFileAppender) {\n\t\t\t\t\tcheckPath(((RollingFileAppender) app).getFileName().substring(0,\n\t\t\t\t\t\t\t((RollingFileAppender) app).getFileName().lastIndexOf(\"/\")));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t}\n\t}\n\n\tprivate static void checkPath(String substring) {\n\t\t\n\t\tFile logFolder = new File(substring);\n\t\tFile[] logFiles = logFolder.listFiles();\n\t\tLOGGER.info(\"Cleaning up log file directory: '\" + logFolder.getAbsolutePath() + \"'\");\n\t\tfor (File f : logFiles) {\n\t\t\ttry {\n\t\t\t\tdouble lastModifified = (System.currentTimeMillis() - f.lastModified()) / 1000 / 60 / 60;\n\n\t\t\t\tif (lastModifified > DELTE_TRESHOLD && FilenameUtils.getExtension(f.getName()).equals(\"log\")) {\n\t\t\t\t\tf.delete();\n\t\t\t\t\tLOGGER.info(\"Deleting log file older than \" + (DELTE_TRESHOLD / 24) + \" days:\" + f.getAbsolutePath());\n\t\t\t\t}\n\t\t\t} catch (Throwable e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n"}, {"id": "UnassignFlightMessage.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal.message;\n\npublic class UnassignFlightMessage extends AbstractMessage {\n\n}\n"}, {"id": "DroneSnapshotOption.java", "body": "package edu.nd.dronology.core.collisionavoidance;\n\npublic class DroneSnapshotOption {\n    public final DroneSnapshot snapshot;\n    public final String droneName;\n    public DroneSnapshotOption(DroneSnapshot snapshot, String droneName) {\n        this.snapshot = snapshot;\n        this.droneName = droneName;\n    }\n}\n"}, {"id": "MappedItem.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.UUID;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\npublic abstract class MappedItem implements IMappedItem, Serializable {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -2076504393371550022L;\n\n\tpublic MappedItem(String id) {\n\t\tthis.id = id;\n\t}\n\n\tprivate String type;\n\tprivate String id;\n\tprivate String description;\n\tprivate Integer importance;\n\tprivate List<LlaCoordinate> coordinates = new ArrayList<>();\n\n\t\n\t@Override\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\t@Override\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic String getType() {\n\t\treturn type;\n\t}\n\t@Override\n\tpublic void setType(String type) {\n\t\tthis.type = type;\n\t}\n\t@Override\n\tpublic void setImportance(Integer importance) {\n\t\tthis.importance = importance;\n\t}\n\t@Override\n\tpublic Integer getImportance() {\n\t\treturn importance;\n\t} \n\t@Override\n\tpublic void addCoordinate(LlaCoordinate coord) {\n\t\tcoordinates.add(coord);\n\t}\n\t@Override\n\tpublic void setCoordinates(List<LlaCoordinate> coords) {\n\t\tcoordinates = coords;\n\t}\n\t@Override\n\tpublic void removeCoodinate(LlaCoordinate coord) {\n\t\tcoordinates.remove(coord);\n\t}\n\t@Override\n\tpublic List<LlaCoordinate> getCoordinates() {\n\t\treturn Collections.unmodifiableList(coordinates);\n\t}\n}\n"}, {"id": "RouteSelector.java", "body": "package edu.nd.dronology.services.extensions.areamapping.unused;\n//package edu.nd.dronology.services.extensions.areamapping;\n//\n//import java.awt.geom.Path2D;\n//import java.awt.geom.Point2D;\n//import java.util.ArrayList;\n//import java.util.Collection;\n//import java.util.Collections;\n//import java.util.HashSet;\n//import java.util.List;\n//import java.util.Set;\n//\n//import edu.nd.dronology.core.coordinate.LlaCoordinate;\n//import edu.nd.dronology.core.vehicle.IUAVProxy;\n//import edu.nd.dronology.services.core.areamapping.MetricsStatistics;\n//import edu.nd.dronology.services.extensions.areamapping.internal.Geometry;\n//import edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;\n//import edu.nd.dronology.services.extensions.areamapping.metrics.AllocationInformation;\n//import edu.nd.dronology.services.extensions.areamapping.metrics.Drone;\n//import edu.nd.dronology.services.extensions.areamapping.metrics.MetricsRunner;\n//import edu.nd.dronology.services.extensions.areamapping.metrics.MetricsUtilities;\n//import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\n//import edu.nd.dronology.services.extensions.areamapping.util.Utilities;\n//\n//public class RouteSelector  {\n//\n//\tprivate static final double APERATURE_WIDTH = 10;\n//\tprivate static final double APERATURE_HEIGHT= 0.8* APERATURE_WIDTH;\n//\tprivate static final double OVERLAP_FACTOR = 0.7;\n//\tprivate double avgLatitude;\n//\tprivate int availableDrones;\n//\tprivate List<RoutePrimitive> routePrimitives;\n//\tprivate MetricsRunner metricsRunner;\n//\tprivate List<IUAVProxy> uavs;\n//\n//\t\n//\tpublic void initialize(List<RoutePrimitive>routePrimitives, List<RiverBank> bankList, Path2D.Double totalRiverSegment, int availableDrones, double avgLatitude, Collection<IUAVProxy> uavs) {\n//\t\t// TODO Auto-generated method stub\n//\t\troutePrimitives = Utilities.splitRoutePrimitives(routePrimitives, 4, APERATURE_HEIGHT, OVERLAP_FACTOR);\n//\t\tthis.routePrimitives = routePrimitives;\n//\t\tthis.availableDrones = availableDrones;\n//\t\tthis.avgLatitude = avgLatitude;\n//\t\tthis.uavs = new ArrayList<>(uavs);\n//\t\tmetricsRunner = new MetricsRunner(routePrimitives, totalRiverSegment, bankList, APERATURE_WIDTH, APERATURE_HEIGHT, uavs.size());\n//\t}\n//\t\n//\t//GeneratedRouteAssignment....\n//\tprivate List<Drone> generateRandomAssingments(){\n//\t\tSet<Integer> assignedRoutes = new HashSet<>();\n//\t\tavailableDrones = uavs.size();\n//\t\tint droneNum;\n//\t\tint routeNum;\n//\t\n//\t\tint routeAssignmentNum = MetricsUtilities.generateRandomNumber(routePrimitives.size()-1, 1);\n//\t\tList<Drone> droneList = new ArrayList<>();\n//\t\tfor(int i = 0; i < availableDrones; i++) {\n//\t\t\tdroneList.add(new Drone());\n//\t\t\tLlaCoordinate home = uavs.get(i).getHomeLocation();\n//\t\t\tLlaCoordinate currentLocation = uavs.get(i).getCoordinates();\n//\t\t\tdroneList.get(i).setDroneHomeLocation(Geometry.gpsToCartesian(new Point2D.Double(home.getLatitude(),home.getLongitude()), avgLatitude));\n//\t\t\tdroneList.get(i).setDroneStartPoint(Geometry.gpsToCartesian(new Point2D.Double(currentLocation.getLatitude(),currentLocation.getLongitude()), avgLatitude));\n//\t\t\tdroneList.get(i).setUAVId(uavs.get(i).getID());\n//\t\t}\n//\t\twhile(assignedRoutes.size() < routeAssignmentNum) {\n//\t\t\t//assign drone routes in here\n//\t\t\tdroneNum = MetricsUtilities.generateRandomNumber(availableDrones-1,0);\n//\t\t\trouteNum = MetricsUtilities.generateRandomNumber(routeAssignmentNum, 0);\n//\t\t\twhile(assignedRoutes.contains(routeNum)) {\n//\t\t\t\trouteNum = MetricsUtilities.generateRandomNumber(routeAssignmentNum, 0);\n//\t\t\t}\n//\t\t\tdroneList.get(droneNum).getDroneRouteAssignment().add(routePrimitives.get(routeNum));\n//\t\t\tassignedRoutes.add(routeNum);\n//\t\t}\n//\t\treturn droneList;\n//\t}\n//\t\n//\tprivate MetricsStatistics generateMetricsStatistics(List<Drone> drones) {\n//\t\tmetricsRunner.setDroneAssignments(drones);\n//\t\treturn metricsRunner.runMetrics();\n//\t}\n//\t\n//\t//use a loop to pick best route\n//\t//return wrapper for list<drone> and metrics\n//\tpublic List<AllocationInformation> generateAssignments() {\n//\t\t// loop to create assignments and check for best assignment\n//\t\tList<AllocationInformation> allAllocations = new ArrayList<>();\n//\t\tAllocationInformation finalAllocation = new AllocationInformation();\n//\t\t/*List<Drone> assignment = generateRandomAssingments();\n//\t\tfinalAllocation.setDroneAllocations(assignment);\n//\t\tfinalAllocation.setMetricsStatistics(generateMetricsStatistics(assignment));\n//\t\tallAllocations.add(finalAllocation);*/\n//\t\tfor(int i = 0; i < 100; i++) {\n//\t\t\tList<Drone> assignments = generateRandomAssingments();\n//\t\t\tAllocationInformation currentAllocation = new AllocationInformation();\n//\t\t\tcurrentAllocation.setDroneAllocations(assignments);\n//\t\t\tcurrentAllocation.setMetricsStatistics(generateMetricsStatistics(assignments));\n//\t\t\tallAllocations.add(currentAllocation);\n//\t\t\t/*boolean added = false;\n//\t\t\tfor(int j = 0; j < top5Allocations.size(); j++) {\n//\t\t\t\t//allows 0 collisions\n//\t\t\t\tif(top5Allocations.get(j).getMetricStatistics().getAllocationScore() < currentAllocation.getMetricStatistics().getAllocationScore() && currentAllocation.getMetricStatistics().getCollisions() == 0) {\n//\t\t\t\t\ttop5Allocations.add(j, currentAllocation);\n//\t\t\t\t\tadded = true;\n//\t\t\t\t\tif(top5Allocations.size() > 5) {\n//\t\t\t\t\t\ttop5Allocations.remove(top5Allocations.size()-1);\n//\t\t\t\t\t}\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t//allows 0 collisions\n//\t\t\tif(top5Allocations.size() < 5 && !added && currentAllocation.getMetricStatistics().getCollisions() == 0) {\n//\t\t\t\ttop5Allocations.add(currentAllocation);\n//\t\t\t}*/\n//\t\t\t\n//\t\t}\n//\t\tCollections.sort(allAllocations);\n//\t/*\tfor(AllocationInformation entry : top5Allocations) {\n//\t\t\tList<Drone> routeAssignments = new ArrayList<>();\n//\t\t\trouteAssignments = entry.getDroneAllocations();\n//\t\t\tfor(Drone drone : routeAssignments) {\n//\t\t\t\tdrone.cartesianToGps(avgLatitude);\n//\t\t\t}\n//\t\t\tentry.setDroneAllocations(routeAssignments);\n//\t\t}*/\n//\t\tfor(RoutePrimitive route : routePrimitives) {\n//\t\t\troute = Utilities.cartesianRouteToGpsRoute(route, avgLatitude);\n//\t\t}\n//\t\t//are home and start locations converted back?\n//\t\treturn allAllocations;\n//\t}\n//\t\n//\n//}\n"}, {"id": "FlightPlanInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.util.Waypoint;\n\npublic class FlightPlanInfo extends RemoteInfoObject {\n\n\t\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 256865471183839829L;\n\tprivate String droneId;\n\tprivate List<Waypoint> waypoints = new ArrayList<>();\n\tprivate LlaCoordinate startLocation;\n\tprivate long startTime;\n\tprivate long endTime;\n\n\tpublic String getDroneId() {\n\t\treturn droneId;\n\t}\n\n\tpublic List<Waypoint> getWaypoints() {\n\t\treturn waypoints;\n\t}\n\n\tpublic LlaCoordinate getStartLocation() {\n\t\treturn startLocation;\n\t}\n\n\tpublic long getStartTime() {\n\t\treturn startTime;\n\t}\n\n\tpublic long getEndTime() {\n\t\treturn endTime;\n\t}\n\n\tpublic FlightPlanInfo(String name, String id) {\n\t\tsuper(name, id);\n\t}\n\n\tpublic void setDroneId(String droneId) {\n\t\tthis.droneId = droneId;\n\n\t}\n\n\tpublic void setWaypoints(List<Waypoint> waypoints) {\n\t\tthis.waypoints.clear();\n\t\tthis.waypoints.addAll(waypoints);\n\n\t}\n\n\tpublic void setStartLocation(LlaCoordinate startLocation) {\n\t\tthis.startLocation = startLocation;\n\n\t}\n\n\tpublic void setStartTime(long startTime) {\n\t\tthis.startTime = startTime;\n\n\t}\n\n\tpublic void setEndTime(long endTime) {\n\t\tthis.endTime = endTime;\n\n\t}\n\n\t\n}\n"}, {"id": "IUAVProxy.java", "body": "package edu.nd.dronology.core.vehicle;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\npublic interface IUAVProxy extends Serializable {\n\n\tString getID();\n\n\tString getStatus();\n\n\tdouble getLongitude();\n\n\tdouble getLatitude();\n\n\tdouble getAltitude();\n\n\tdouble getBatteryLevel();\n\n\tdouble getVelocity();\n\n\tMap<String, String> getInfo();\n\n\tLlaCoordinate getCoordinates();\n\n\tLlaCoordinate getHomeLocation();\n\n\tString getGroundstationId();\n\n}"}, {"id": "WaypointGoal.java", "body": "package edu.nd.dronology.core.goal;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\nimport edu.nd.dronology.core.coordinate.AbstractPosition;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.core.vehicle.internal.PhysicalDrone;\n\nimport java.util.Observable;\n\n\npublic class WaypointGoal extends AbstractGoal {\n\n    // The distance threshold (meters) for determining when a waypoint has been reached\n    private double dThresh = 2.0;\n\n    private final AbstractPosition position;\n    private final double speed;\n\n    public WaypointGoal(Waypoint waypoint) {\n        this.position = waypoint.getCoordinate();\n        this.speed = waypoint.getApproachingspeed();\n    }\n\n    public WaypointGoal(AbstractPosition position, double speed) {\n        this.position = position;\n        this.speed = speed;\n    }\n\n    public WaypointGoal(Waypoint waypoint, double dThresh) {\n        this.position = waypoint.getCoordinate();\n        this.speed = waypoint.getApproachingspeed();\n        this.dThresh = dThresh;\n    }\n\n\n    public AbstractPosition getPosition() {\n        return position;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n\n    @Override\n    public void update(Observable observable, Object o) {\n        GoalState curState = getState();\n\n        if (observable instanceof PhysicalDrone) {\n            if (curState == GoalState.ACTIVE) {\n                DroneSnapshot snapshot = ((PhysicalDrone) observable).getLatestDroneSnapshot();\n                double dist = position.distance(snapshot.getPosition());\n\n                if (dist <= dThresh) {\n                    setCompleted();\n                }\n            }\n        }\n        else if (observable instanceof AbstractGoal) {\n            if (curState == GoalState.PENDING) {\n                GoalState state = ((AbstractGoal) observable).getState();\n\n                if (state == GoalState.COMPLETE) {\n                    setActive();\n                }\n            }\n        }\n    }\n\n    @Override\n    public IGoalSnapshot buildSnapshot() {\n        return new WaypointGoalSnapshot(this.getPosition(), this.getSpeed(), this.getState());\n    }\n}\n"}, {"id": "IMonitorableMessage.java", "body": "package edu.nd.dronology.core.monitoring;\n\nimport java.io.Serializable;\n\nimport edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;\nimport edu.nd.dronology.core.util.PreciseTimestamp;\n\n/**\n *  Interface for all messages that shall be subscribeable via the monitoring API.\n * \n * \n * @author Michael Vierhauser\n *\n */\npublic interface IMonitorableMessage extends Serializable{\n\n\tArtifactIdentifier<?> getIdentifier();\n\n\tString getUavid();\n\n\tString getData();\n\n\tPreciseTimestamp getTimestamp();\n\n\tMessageType getType();\n\n}\n"}, {"id": "IFlightRoute.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.util.List;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.util.Waypoint;\n\npublic interface IFlightRoute extends IPersistableItem {\n\tString getDescription();\n\n\tvoid setDescription(String description);\n\n\tvoid setCategory(String category);\n\n\tString getCategory();\n\n\tList<Waypoint> getWaypoints();\n\n\tvoid addWaypoint(Waypoint waypoint);\n\n\tvoid setTakeoffAltitude(double altitude);\n\n\tvoid addWaypoint(Waypoint waypoint, int index);\n\n\tint removeWaypoint(Waypoint waypoint);\n\n\tWaypoint removeWaypoint(int index);\n\n}\n"}, {"id": "DroneRouteAssignment.java", "body": "package edu.nd.dronology.services.extensions.areamapping.metrics;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport javax.rmi.CORBA.Util;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\nimport edu.nd.dronology.services.extensions.areamapping.util.Utilities;\n\npublic class DroneRouteAssignment {\n\n\tList<RoutePrimitive> droneRoute;\n\t\n\tpublic DroneRouteAssignment() {\n\t\tdroneRoute = new ArrayList<>();\n\t}\n\t\n\tpublic void add(RoutePrimitive routePrimitive) {\n\t\tdroneRoute.add(routePrimitive);\n\t}\n\t\n\tpublic List<RoutePrimitive> get(){\n\t\treturn Collections.unmodifiableList(droneRoute);\n\t}\n\t\n\tpublic RoutePrimitive get(int entry) {\n\t\treturn droneRoute.get(entry);\n\t}\n\t\n\tpublic void set(int index, RoutePrimitive entry) {\n\t\tdroneRoute.set(index, entry);\n\t}\n\t\n\tpublic void setDroneRouteAssignment(List<RoutePrimitive> assignment) {\n\t\tdroneRoute = assignment;\n\t}\n}\n"}, {"id": "CoordinatedLandingPattern.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.patterns;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.monitoring.DronologyMonitoringManager;\nimport edu.nd.dronology.core.monitoring.MessageMarshaller;\nimport edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;\nimport edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;\nimport edu.nd.dronology.services.extensions.missionplanning.plan.UAVMissionPlan;\nimport edu.nd.dronology.services.extensions.missionplanning.sync.SyncConstants;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.PatternTask;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.TaskFactory;\nimport edu.nd.dronology.services.extensions.missionplanning.v1.FullMissionPlan;\n\n/**\n * \n * Predefined pattern for coordinated landing that is expanded as part of a {@link PatternTask} in a {@link FullMissionPlan}.<br>\n * \n * @author Michael Vierhauser\n *\n */\npublic class CoordinatedLandingPattern extends AbstractFlightPattern implements IFlightPattern {\n\tCoordinatedLandingPattern() {\n\n\t}\n\n\t@Override\n\tpublic void expandFlightPattern(UAVMissionPlan uavMission, LlaCoordinate currentLocation,\n\t\t\tLlaCoordinate targetLocation) throws MissionExecutionException {\n\n\t\tif (uavMission.getCoordinationAltitude() == 0) {\n\t\t\tuavMission.setCoordinationAltitude(synchPointMgr.getNextAltitude());\n\t\t}\n\n\t\tLlaCoordinate targetWaypoint1 = new LlaCoordinate(currentLocation.getLatitude(), currentLocation.getLongitude(),\n\t\t\t\tuavMission.getCoordinationAltitude());\n\t\tDronologyMonitoringManager.getInstance()\n\t\t\t\t.publish(MessageMarshaller.createMessage(MessageType.MISSION_WAYPOINT, uavMission.getUavID(), targetWaypoint1));\n\n\t\tLlaCoordinate targetWaypoint2 = new LlaCoordinate(targetLocation.getLatitude(), targetLocation.getLongitude(),\n\t\t\t\tuavMission.getCoordinationAltitude());\n\t\tDronologyMonitoringManager.getInstance()\n\t\t\t\t.publish(MessageMarshaller.createMessage(MessageType.MISSION_WAYPOINT, uavMission.getUavID(), targetWaypoint2));\n\n\t\tLlaCoordinate landWaypoint = new LlaCoordinate(targetLocation.getLatitude(), targetLocation.getLongitude(),\n\t\t\t\ttargetLocation.getAltitude());\n\t\tDronologyMonitoringManager.getInstance()\n\t\t\t\t.publish(MessageMarshaller.createMessage(MessageType.MISSION_WAYPOINT, uavMission.getUavID(), landWaypoint));\n\n\t\taddTask(TaskFactory.getTask(TaskFactory.WAYPOINT, uavMission.getUavID(), targetWaypoint1));\n\t\taddTask(TaskFactory.getTask(TaskFactory.SYNC, uavMission.getUavID(), SyncConstants.LANDING_ASC_REACHED));\n\n\t\taddTask(TaskFactory.getTask(TaskFactory.WAYPOINT, uavMission.getUavID(), targetWaypoint2));\n\t\taddTask(TaskFactory.getTask(TaskFactory.SYNC, uavMission.getUavID(), SyncConstants.LANDING_LONLAT_REACHED));\n\n\t\taddTask(TaskFactory.getTask(TaskFactory.LAND, uavMission.getUavID(), landWaypoint));\n\t\taddTask(TaskFactory.getTask(TaskFactory.SYNC, uavMission.getUavID(), SyncConstants.LANDING_HOME_REACHED));\n\n\t}\n\n\t@Override\n\tprotected void doCreateSyncPoints() {\n\t\taddSyncPoint(\"SP-TakeOff-AscentTargetReached\");\n\t\taddSyncPoint(\"SP-TakeOff-LonLatReached\");\n\t\taddSyncPoint(\"SP-TakeOff-FirstWayPointReached\");\n\n\t}\n\n}\n"}, {"id": "UAVRegistrationXStreamPersistor.java", "body": "package edu.nd.dronology.services.core.persistence.internal;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.nio.charset.Charset;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport com.thoughtworks.xstream.XStream;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\n\nimport edu.nd.dronology.services.core.items.IUAVRegistration;\nimport edu.nd.dronology.services.core.persistence.DronologyPersistenceUtil;\nimport edu.nd.dronology.services.core.persistence.IPersistenceManager;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class UAVRegistrationXStreamPersistor implements IPersistenceManager<IUAVRegistration> {\n\n\tprivate static final XStream xstream = new XStream(new XppDriver());\n\tprivate static ILogger LOGGER = LoggerProvider.getLogger(UAVRegistrationXStreamPersistor.class);\n\n\tstatic final boolean useCompression = false;\n\n\t@Override\n\tpublic IUAVRegistration open(InputStream fin) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t//\t xstream.setMode(XStream.);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\t\t\n\t\tif (useCompression) {\n\t\t\treturn loadedCompressedStream(fin);\n\t\t} else {\n\t\t\treturn loadUncompressedStream(fin);\n\t\t}\n\t}\n\n\tprivate IUAVRegistration loadUncompressedStream(InputStream fin) throws PersistenceException {\n\t\ttry {\n\t\t\tInputStreamReader reader = new InputStreamReader(new BufferedInputStream(fin), Charset.forName(\"UTF-8\"));\n\t\t\tObject model = xstream.fromXML(reader);\n\t\t\treturn (IUAVRegistration) model;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (fin != null) {\n\t\t\t\t\tfin.close();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate IUAVRegistration loadedCompressedStream(InputStream fin) throws PersistenceException {\n\t\tInputStream zIn = null;\n\t\ttry {\n\t\t\tzIn = new GZIPInputStream(fin);\n\t\t\tObject model = xstream.fromXML(new BufferedReader(new InputStreamReader(zIn, \"UTF-8\")));\n\n\t\t\treturn (IUAVRegistration) model;\n\t\t} catch (IOException e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (zIn != null) {\n\t\t\t\t\tzIn.close();\n\t\t\t\t}\n\t\t\t\tif (fin != null) {\n\t\t\t\t\tfin.close();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\n\t\t}\n\t}\n \n\t@Override\n\tpublic boolean save(IUAVRegistration o, OutputStream fout) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t\t// xstream.setMode(XStream.ID_REFERENCES);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\t\t// xstream.addImplicitMap(ImplMEEvent.class, \"relatedEvents\", ImplMEEvent.class, \"relatedEvents\");\n\n\t\tif (useCompression) {\n\t\t\treturn saveCompressedStream(o, fout);\n\t\t} else {\n\t\t\treturn saveUncompressedStream(o, fout);\n\t\t}\n\n\t}\n\n\tprivate boolean saveUncompressedStream(IUAVRegistration o, OutputStream fout) throws PersistenceException {\n\t\tOutputStreamWriter writer = null;\n\t\ttry {\n\t\t\twriter = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(\"UTF-8\"));\n\t\t\txstream.toXML(o, writer);\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (writer != null) {\n\t\t\t\t\twriter.close();\n\t\t\t\t}\n\t\t\t\tif (fout != null) {\n\t\t\t\t\tfout.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean saveCompressedStream(IUAVRegistration o, OutputStream fout) throws PersistenceException {\n\t\ttry {\n\t\t\tGZIPOutputStream zOut = new GZIPOutputStream(fout);\n\t\t\txstream.toXML(o, new BufferedWriter(new OutputStreamWriter(zOut, \"UTF-8\")));\n\n\t\t\tzOut.close();\n\t\t\tfout.close();\n\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t}\n\t}\n\n}\n"}, {"id": "AMMapComponent.java", "body": "package edu.nd.dronology.ui.vaadin.areamapping;\n\nimport java.io.ByteArrayInputStream;\nimport java.rmi.RemoteException;\nimport java.util.List;\nimport java.util.Vector;\n\nimport org.vaadin.addon.leaflet.LMap;\nimport org.vaadin.addon.leaflet.shared.Point;\n\nimport com.vaadin.ui.AbsoluteLayout;\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.VerticalLayout;\nimport com.vaadin.ui.AbsoluteLayout.ComponentPosition;\n\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.services.core.areamapping.EdgeLla;\nimport edu.nd.dronology.services.core.info.AreaMappingInfo;\nimport edu.nd.dronology.services.core.items.IAreaMapping;\nimport edu.nd.dronology.services.core.persistence.AreaMappingPersistenceProvider;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport edu.nd.dronology.services.core.remote.IAreaMappingRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.ui.vaadin.areamapping.windows.AMDeleteWayPointConfirmation;\nimport edu.nd.dronology.ui.vaadin.areamapping.windows.AMWayPointPopupView;\nimport edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;\nimport edu.nd.dronology.ui.vaadin.map.LeafletmapFactory;\nimport edu.nd.dronology.ui.vaadin.start.MyUI;\nimport edu.nd.dronology.ui.vaadin.utils.WaypointReplace;\n\n/**\n * This is the map component for area mapping. It holds most of the visual elements, and is largely controlled by AMMapMarkerUtilities\n * \n * @author Andrew Slavin\n */\n\npublic class AMMapComponent extends CustomComponent{\n\t\n\tprivate static final long serialVersionUID = 8009738721123823238L;\n\tprivate AMMainLayout mainLayout;\n\tprivate AMMapMarkerUtilities utilities;\n\t\n\tprivate AMWayPointPopupView waypointPopupView;\n\tprivate AMDeleteWayPointConfirmation deleteWayPointConfirmation = new AMDeleteWayPointConfirmation(this);\n\t\n\tprivate VerticalLayout content = new VerticalLayout();\n\tprivate AbsoluteLayout mapAndComponentsLayout = new AbsoluteLayout();\n\t\n\tprivate AMEditSidesController editSidesController = new AMEditSidesController(this);\n\tprivate AMEditPrioritiesController editPrioritiesController = new AMEditPrioritiesController(this);\n\tprivate AMSubMapController subMapController = new AMSubMapController(this);\n\tprivate AMMetaInfo metaInfo = new AMMetaInfo(this);\n\tprivate LMap leafletMap;\n\t\n\tpublic AMMapComponent(AMMainLayout mainLayout) {\n\t\tthis.mainLayout = mainLayout;\n\t\tthis.setWidth(\"100%\");\n\t\tleafletMap = LeafletmapFactory.generateMap();\n\t\t\n\t\t// create a popup when user mouses over waypoint via listener\n\t\twaypointPopupView = new AMWayPointPopupView(this);\n\t\t\n\t\tmapAndComponentsLayout.addComponents(waypointPopupView, leafletMap, subMapController, editSidesController, editPrioritiesController);\n\t\tcontent.addComponents(metaInfo, mapAndComponentsLayout);\n\t\tsetCompositionRoot(content);\t\t\n\t\t\n\t\tthis.addStyleName(\"map_component\");\n\t\tthis.addStyleName(\"am_map_component\"); \n\t\tmapAndComponentsLayout.addStyleName(\"am_mapabsolute_layout\");\n\t\tleafletMap.addStyleName(\"am_leaflet_map\");\n\t\tleafletMap.addStyleName(\"bring_back\");\n\t\t\n\t\teditSidesController.addStyleName(\"bring_front\");\n\t\teditSidesController.setVisible(false);\n\t\teditPrioritiesController.addStyleName(\"bring_front\");\n\t\teditPrioritiesController.setVisible(false);\n\t\tsubMapController.addStyleName(\"bring_front\");\n\t\tsubMapController.setVisible(false);\n\t\t\n\t\tutilities = new AMMapMarkerUtilities(this);\n\t}\n\t\n\t\t// Displays with the map. Called when a mapping is deleted so that\n\t\t// its waypoints are no longer displayed.\n\t\tpublic void displayNoMapping() {\n\t\t\tmetaInfo.showInfoWhenNoMappingIsSelected();\n\t\t\tutilities.removeAllPins();\n\t\t\tupdateLinesAndGrid();\n\t\t}\n\t\t\n\t\t@WaypointReplace\n\t\tpublic void displayAreaMapping(AreaMappingInfo info) {\n\t\t\tmetaInfo.showInfoForSelectedMapping(info);\n\n\t\t\t// Removes old pins and show the new pins\n\t\t\tutilities.removeAllPins();\n\t\t\tfor (EdgeLla coordinate : info.getCoordinates(0)) {\n\t\t\t\tWaypoint waypoint = new Waypoint(coordinate);\n\t\t\t\tUIEdgePoint way = new UIEdgePoint(waypoint, 0);\n\t\t\t\tutilities.addNewPin(way, -1);\n\t\t\t}\n\t\t\tfor (EdgeLla coordinate : info.getCoordinates(1)) {\n\t\t\t\tWaypoint waypoint = new Waypoint(coordinate);\n\t\t\t\tUIEdgePoint way = new UIEdgePoint(waypoint, 1);\n\t\t\t\tutilities.addNewPin(way, -1);\n\t\t\t}\n\n\t\t\t// redraw the lines and priorities to the map\n\t\t\tutilities.getAllPriorityLines().clear();\n\t\t\tutilities.getAllPrioritySides().clear();\n\t\t\tutilities.getNewPrioritySideLines().clear();\n\t\t\tupdateLinesAndGrid();\n\t\t\tutilities.drawPriorities();\n\t\t\tutilities.highlightUpstream();\n\t\t\tsetMappingCenter();\n\t\t}\n\t\n\t\t// Displays the waypoints in edit mode depending on whether or not the route is new.\n\t\tpublic void updateWayPointCount(AMMapMarkerUtilities mapUtilities) {\n\t\t\tmetaInfo.setNumWaypoints(mapUtilities.getOrderedWayPoints().get(0).size(), mapUtilities.getOrderedWayPoints().get(1).size());\n\t\t}\n\n\t\t// Gets the mapping description using the currently selected mapping stored by\n\t\t// \"selectedMapping\".\n\t\tpublic String getMappingDescription() {\n\t\t\tAreaMappingPersistenceProvider mappingPersistor = AreaMappingPersistenceProvider.getInstance();\n\t\t\tByteArrayInputStream inStream;\n\t\t\tIAreaMapping amapping;\n\n\t\t\tIAreaMappingRemoteService service;\n\t\t\tBaseServiceProvider provider = MyUI.getProvider();\n\n\t\t\tString description = null;\n\t\t\t// Sends the information to dronology to be saved.\n\t\t\ttry {\n\t\t\t\tservice = (IAreaMappingRemoteService) provider.getRemoteManager()\n\t\t\t\t\t\t.getService(IAreaMappingRemoteService.class);\n\n\t\t\t\tString id = this.getMainLayout().getControls().getInfoPanel().getHighlightedAMInfoBox().getId();\n\n\t\t\t\tbyte[] information = service.requestFromServer(id);\n\t\t\t\tinStream = new ByteArrayInputStream(information);\n\t\t\t\tamapping = mappingPersistor.loadItem(inStream);\n\n\t\t\t\tdescription = amapping.getDescription();\n\t\t\t\tif (description == null) {\n\t\t\t\t\tdescription = \"No Description\";\n\t\t\t\t}\n\t\t\t} catch (DronologyServiceException | RemoteException e1) {\n\t\t\t\tMyUI.setConnected(false);\n\t\t\t\te1.printStackTrace();\n\t\t\t} catch (PersistenceException e1) {\n\t\t\t\te1.printStackTrace();\n\t\t\t}\n\t\t\treturn description;\n\t\t}\n\n\t\t// Sets the center of the route based on the stored waypoints such that the map\n\t\t// is as visible as possible.\n\t\tpublic void setMappingCenter() {\n\t\t\tif (metaInfo.isAutoZoomingChecked()) {\n\t\t\t\t// Calculates the mean point and sets the route.\n\t\t\t\tdouble meanLat = 0;\n\t\t\t\tdouble meanLon = 0;\n\t\t\t\tint numberPoints;\n\t\t\t\tdouble farthestLat = 0;\n\t\t\t\tdouble farthestLon = 0;\n\t\t\t\tdouble zoom;\n\n\t\t\t\tVector<List<UIEdgePoint>> currentWayPoints = utilities.getOrderedWayPoints();\n\t\t\t\tnumberPoints = currentWayPoints.get(0).size() + currentWayPoints.get(1).size();\n\n\t\t\t\tfor (UIEdgePoint p : currentWayPoints.get(0)) {\n\t\t\t\t\tmeanLat += Double.valueOf(p.getLatitude());\n\t\t\t\t\tmeanLon += Double.valueOf(p.getLongitude());\n\t\t\t\t}\n\t\t\t\tfor (UIEdgePoint p : currentWayPoints.get(1)) {\n\t\t\t\t\tmeanLat += Double.valueOf(p.getLatitude());\n\t\t\t\t\tmeanLon += Double.valueOf(p.getLongitude());\n\t\t\t\t}\n\n\t\t\t\tmeanLat /= (numberPoints * 1.0);\n\t\t\t\tmeanLon /= (numberPoints * 1.0);\n\n\t\t\t\t// Finds farthest latitude and longitude from mean.\n\t\t\t\tfor (UIEdgePoint p : currentWayPoints.get(0)) {\n\t\t\t\t\tif ((Math.abs(Double.valueOf(p.getLatitude()) - meanLat) > farthestLat)) {\n\t\t\t\t\t\tfarthestLat = (Math.abs((Double.valueOf(p.getLatitude())) - meanLat));\n\t\t\t\t\t}\n\t\t\t\t\tif ((Math.abs(Double.valueOf(p.getLongitude()) - meanLon) > farthestLon)) {\n\t\t\t\t\t\tfarthestLon = (Math.abs((Double.valueOf(p.getLongitude()) - meanLon)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (UIEdgePoint p : currentWayPoints.get(1)) {\n\t\t\t\t\tif ((Math.abs(Double.valueOf(p.getLatitude()) - meanLat) > farthestLat)) {\n\t\t\t\t\t\tfarthestLat = (Math.abs((Double.valueOf(p.getLatitude())) - meanLat));\n\t\t\t\t\t}\n\t\t\t\t\tif ((Math.abs(Double.valueOf(p.getLongitude()) - meanLon) > farthestLon)) {\n\t\t\t\t\t\tfarthestLon = (Math.abs((Double.valueOf(p.getLongitude()) - meanLon)));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Used to calculate zoom level.\n\t\t\t\tPoint centerPoint = new Point(meanLat, meanLon);\n\t\t\t\tif (farthestLat == 0 && farthestLon == 0) {\n\t\t\t\t\tzoom = 17;\n\t\t\t\t} else {\n\t\t\t\t\tzoom = Math.floor(Math.log10(180.0 / Math.max(farthestLat, farthestLon)) / Math.log10(2));\n\t\t\t\t}\n\n\t\t\t\tleafletMap.setCenter(centerPoint, zoom + 1);\n\t\t\t}\n\t\t}\n\n\t\t// Refreshes the map and grid by removing lines, redrawing them, and then\n\t\t// setting the map again.\n\t\tpublic void updateLinesAndGrid() {\n\t\t\tutilities.redrawAllLines(false);\n\t\t\t// if deleting a polygon, don't try to redraw polygons\n\t\t\tif (this.getMainLayout().getDeletingMapping()) {\n\t\t\t\tutilities.removeAllPriorityAreas();\n\t\t\t\tthis.getMainLayout().setDeletingMapping(false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tpublic ComponentPosition getWaypointPopupViewPosition() {\n\t\t\treturn mapAndComponentsLayout.getPosition(waypointPopupView);\n\t\t}\n\n\t\tpublic void setWaypointPopupViewPosition(ComponentPosition position) {\n\t\t\tmapAndComponentsLayout.setPosition(waypointPopupView, position);\n\t\t}\n\n\t\t// Gets the class that represents the utilities.\n\t\tpublic AMMapMarkerUtilities getMapUtilities() {\n\t\t\treturn utilities;\n\t\t}\n\n\t\tpublic LMap getMap() {\n\t\t\treturn leafletMap;\n\t\t}\n\n\t\t// Gets the main layout (passed into constructor).\n\t\tpublic AMMainLayout getMainLayout() {\n\t\t\treturn mainLayout;\n\t\t}\n\n\t\t// Gets the route information bar above the map.\n\t\tpublic AMMetaInfo getMetaInfo() {\n\t\t\treturn metaInfo;\n\t\t}\n\t \n\t\tpublic AMEditSidesController getEditSidesController() {\n\t\t\treturn editSidesController;\n\t\t}\n\t\t\n\t\tpublic AMEditPrioritiesController getEditPrioritiesController() {\n\t\t\treturn editPrioritiesController;\n\t\t}\n\t\t\n\t\tpublic AMSubMapController getSubMapController() {\n\t\t\treturn subMapController;\n\t\t}\n\n\t\tpublic AMWayPointPopupView getWaypointPopupView() {\n\t\t\treturn waypointPopupView;\n\t\t}\n\n\t\tpublic AMDeleteWayPointConfirmation getDeleteWayPointConfirmation() {\n\t\t\treturn deleteWayPointConfirmation;\n\t\t}\n\t\t\n}\n"}, {"id": "Command.java", "body": "package edu.nd.dronology.core.collisionavoidance.guidancecommands;\n\npublic abstract class Command {\n}\n"}, {"id": "DroneSnapshotInternal.java", "body": "package edu.nd.dronology.core.collisionavoidance;\n\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.goal.AbstractGoal;\nimport edu.nd.dronology.core.goal.IGoalSnapshot;\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n *\n * \n */\npublic class DroneSnapshotInternal implements DroneSnapshot {\n\n    private String name;\n    private final LlaCoordinate position;\n    private final Vector3D velocity;\n    private final Vector3D attitude;\n    private String state;\n    private Set<IGoalSnapshot> goals;\n\n\n    private final ArrayList<Command> commands;\n\n    public DroneSnapshotInternal(String name, LlaCoordinate position, Vector3D velocity, Vector3D attitude) {\n        this.name = name;\n        this.position = position;\n        this.velocity = velocity;\n        this.attitude = attitude;\n        this.commands = new ArrayList<>();\n        this.goals = new HashSet<>();\n    }\n\n    @Override\n    public LlaCoordinate getPosition() {\n        return this.position;\n    }\n\n    @Override\n    public ArrayList<Command> getCommands() {\n        return commands;\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public Vector3D getVelocity() {\n        return velocity;\n    }\n\n    @Override\n    public Vector3D getAttitude() {\n        return attitude;\n    }\n\n    @Override\n    public String getState() {\n        return this.state;\n    }\n\n    @Override\n    public Set<IGoalSnapshot> getGoals() {\n        return goals;\n    }\n\n    public void setState(String state) {\n        this.state = state;\n    }\n\n    public void setGoals(Set<IGoalSnapshot> goals) {\n        this.goals = goals;\n    }\n}\n"}, {"id": "IMissionPlan.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.util.List;\n\npublic interface IMissionPlan extends IPersistableItem{\n\n\tString getDescription();\n\n\tvoid setDescription(String description);\n\n\tList<IUAVMissionDescription> getMissionDescriptions();\n\n\tvoid addMissionDescription(IUAVMissionDescription description);\n\n\n\n}\n"}, {"id": "DroneSafetyStateManager.java", "body": "package edu.nd.dronology.core.vehicle;\n\n/**\n * Associates a drone safety state object with a drone. ONLY set this in the drone constructor. NEVER interchange at runtime - otherwise drone state will be incorrectly changed.\n * \n * @author Jane Cleland-Huang\n * @version 0.01\n *\n */\npublic class DroneSafetyStateManager {\n\n\tprivate enum SafetyMode {\n\t\tDIVERTED, HALTED, NORMAL\n\t}\n\n\tprivate SafetyMode safetyMode;\n\n\t/**\n\t * Constructor States for both FlightMode and SafetyMode set to initial state\n\t */\n\tpublic DroneSafetyStateManager() {\n\t\tsafetyMode = SafetyMode.NORMAL;\n\t}\n\n\t// Setters\n\tpublic void setSafetyModeToNormal() {\n\t\tsafetyMode = SafetyMode.NORMAL;\n\t}\n\n\tpublic void setSafetyModeToDiverted() {\n\t\tsafetyMode = SafetyMode.DIVERTED;\n\t}\n\n\tpublic void setSafetyModeToHalted() {\n\t\tsafetyMode = SafetyMode.HALTED;\n\t}\n\n\tpublic boolean isSafetyModeNormal() {\n\t\treturn safetyMode == SafetyMode.NORMAL;\n\t}\n\n\tpublic boolean isSafetyModeDiverted() {\n\t\treturn safetyMode == SafetyMode.DIVERTED;\n\n\t}\n\n\tpublic boolean isSafetyModeHalted() {\n\t\treturn safetyMode == SafetyMode.HALTED;\n\n\t}\n\n\tpublic String getSafetyStatus() {\n\t\treturn safetyMode.toString();\n\t}\n\n}\n"}, {"id": "IDroneSimulatorServiceInstance.java", "body": "package edu.nd.dronology.services.instances.dronesimulator;\n\nimport java.util.Collection;\nimport java.util.List;\n\nimport edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.info.SimulatorScenarioCategoryInfo;\nimport edu.nd.dronology.services.core.info.SimulatorScenarioInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic interface IDroneSimulatorServiceInstance extends IFileTransmitServiceInstance<SimulatorScenarioInfo> {\n\n\tvoid activateScenario(SimulatorScenarioInfo scenario) throws DronologyServiceException;\n\n\tCollection<SimulatorScenarioCategoryInfo> getCategories();\n\n\n}\n"}, {"id": "AMEditSidesController.java", "body": "package edu.nd.dronology.ui.vaadin.areamapping;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.vaadin.ui.Button;\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.HorizontalLayout;\nimport com.vaadin.ui.Label;\nimport com.vaadin.ui.Notification;\nimport com.vaadin.ui.RadioButtonGroup;\nimport com.vaadin.ui.UI;\nimport com.vaadin.ui.themes.ValoTheme;\n\nimport edu.nd.dronology.ui.vaadin.areamapping.windows.AMSaveAreaWithoutFinishWindow;\n\n/**\n * This allows the user to create and edit mappings. However, it is primarily a shell with the necessary buttons.\n * The save button and cancel button functionality is primarily carried out by saveClick and cancelClick in the areas controller.\n * \n * @author Andrew Slavin\n *\n */\n\npublic class AMEditSidesController extends CustomComponent {\n\t/**\n\t *  \n\t */\n\tprivate static final long serialVersionUID = 212323831233690123L;\n\tprivate AMMapComponent mapComponent;\n\tprivate HorizontalLayout totalLayout = new HorizontalLayout();\n\tprivate Button cancelButton = new Button(\"Cancel\");\n\tprivate Button saveButton = new Button(\"Save\");\n\tprivate Button editPrioritiesButton = new Button(\"Priorities\");\n\tprivate Button editSidesButton = new Button(\"Sides\");\n\tprivate RadioButtonGroup<String> group = new RadioButtonGroup<>();\n\tprivate Label smallText = new Label(\"Left click to add a side coordinate. Drag waypoints to move.\");\n\t\n\tprivate List<UIEdgePoint> storedPoints0 = new ArrayList<>();\n\tprivate List<UIEdgePoint> storedPoints1 = new ArrayList<>();\n\tprivate Boolean sideA = false;\n\n\tpublic AMEditSidesController(AMMapComponent mapComponent) {\n\t\tthis.mapComponent = mapComponent;\n\n\t\tsetStyleName(\"am_edit_bar\");\n\t\tsmallText.setStyleName(\"small_text\");\n\n\t\tcancelButton.setHeight(\"25px\");\n\t\tsaveButton.setHeight(\"25px\");\n\t\teditPrioritiesButton.setHeight(\"35px\");\n\t\teditSidesButton.setHeight(\"30px\");\n\t\teditSidesButton.addStyleName(\"sides_button\");\n\t\teditSidesButton.setEnabled(false);\n\t\teditSidesButton.addStyleName(\"toggle_button\");\n\t\teditPrioritiesButton.addStyleName(\"toggle_button\");\n\t\tgroup.setHeight(\"10px\");\n\t\tgroup.setItems(\"Side A\", \"Side B\");\n\t\tgroup.addStyleName(ValoTheme.OPTIONGROUP_HORIZONTAL);\n\t\tgroup.setSelectedItem(\"Side A\");\n\t\ttotalLayout.addComponents(editSidesButton, editPrioritiesButton, smallText, group, cancelButton, saveButton);\n\t\tsetCompositionRoot(totalLayout);\n\n\t\t// Click listeners for the cancel and saves buttons on edit bar\n\t\tcancelButton.addClickListener(e -> {\n\t\t\texitEditMode();\n\t\t\tmapComponent.getEditPrioritiesController().cancelClick();\n\t\t});\n\t\tsaveButton.addClickListener(e -> {\n\t\t\t\n\t\t\t// if the user hasn't selected upstream yet, prompt them to do so\n\t\t\tif (mapComponent.getMapUtilities().getUpstream() == null) {\n\t\t\t\tNotification.show(\"Please select the most upstream side A coordinate.\", Notification.Type.ERROR_MESSAGE);\n\t\t\t\tmapComponent.getEditPrioritiesController().setSelectingUpstream(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t// reset buttons and check that area is correct number of sides\n\t\t\tmapComponent.getEditPrioritiesController().getDrawAreaButton().setEnabled(true);\n\t\t\tmapComponent.getEditPrioritiesController().getDrawSideButton().setEnabled(true);\n\t\t\tif (mapComponent.getEditPrioritiesController().getDrawingArea()) {\n\t\t\t\tif (mapComponent.getMapUtilities().getPolygonVertices().size() < 3) {\n\t\t\t\t\tNotification.show(\"Please finish your unfinished priority area.\", Notification.Type.ERROR_MESSAGE);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tUI.getCurrent().addWindow(new AMSaveAreaWithoutFinishWindow(mapComponent.getEditPrioritiesController()));\n\t\t\t}\n\t\t\telse if (mapComponent.getEditPrioritiesController().getDrawingSide()) {\n\t\t\t\tif (mapComponent.getMapUtilities().getNewPrioritySideLines().size() == 0) {\n\t\t\t\t\tNotification.show(\"Please finish your unfinished priority area.\", Notification.Type.ERROR_MESSAGE);\n\t\t\t\t}\n\t\t\t\tUI.getCurrent().addWindow(new AMSaveAreaWithoutFinishWindow(mapComponent.getEditPrioritiesController()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmapComponent.getEditPrioritiesController().saveClick();\n\t\t\t\texitEditMode();\n\t\t\t}\n\t\t});\n\t\t\n\t\t// if radio button is switched, change side of mapping\n\t\tgroup.addValueChangeListener(e -> {\n\t\t\tsideA = !sideA;\n\t\t});\n\t\t\n\t\teditPrioritiesButton.addClickListener(e -> {\n\t\t\texitEditMode();\n\t\t\tmapComponent.getEditPrioritiesController().enterEditMode();\n\t\t});\n\t\t\n\t}\n\n\n\t// Enables editing, adds the edit bar, and calls the enableMappingEditing function\n\t// from MapMarkerUtilities.\n\tpublic void enterEditMode() {\n\t\tstoredPoints0 = mapComponent.getMapUtilities().getOrderedWayPoints().get(0);\n\t\tstoredPoints1 = mapComponent.getMapUtilities().getOrderedWayPoints().get(1);\n\n\t\tmapComponent.getMapUtilities().setSidesAreEditable(true);\n\t\tmapComponent.getMapUtilities().setPrioritiesAreEditable(false);\n\n\t\tthis.setVisible(true);\n\n\t\tmapComponent.getMap().addStyleName(\"fr_leaflet_map_edit_mode\");\n\t}\n\n\t// Disables editing, removes the edit bar, and changes the component styles\n\t// accordingly.\n\tpublic void exitEditMode() {\n\t\tstoredPoints0.clear();\n\t\tstoredPoints1.clear();\n\n\t\tmapComponent.getMapUtilities().setSidesAreEditable(false);\n\t\tthis.setVisible(false);\n\n\t\tmapComponent.getMap().removeStyleName(\"fr_leaflet_map_edit_mode\");\n\t}\n\tpublic Boolean getSideA() {\n\t\treturn sideA;\n\t}\n\t\n\tpublic void setSideA() {\n\t\tgroup.setSelectedItem(\"Side A\");\n\t}\n\t\n\tpublic Button getSaveButton() {\n\t\treturn saveButton;\n\t}\n\t\n}\n"}, {"id": "FollowTheLeaderNed.java", "body": "package edu.nd.dronology.core.collisionavoidance.strategy;\n\nimport java.util.ArrayList;\n\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\nimport edu.nd.dronology.core.collisionavoidance.CollisionAvoider;\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.NedCommand;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.goal.WaypointGoalSnapshot;\n\npublic class FollowTheLeaderNed implements CollisionAvoider {\n\n    private static final double THRESHOLD_DISTANCE = 1.0;\n    private static final double FOLLOW_DISTANCE = 10.0;\n    private static final Vector3D NED_OFFSET = new Vector3D(0, 0, -FOLLOW_DISTANCE);\n\n\t@Override\n\tpublic void avoid(ArrayList<DroneSnapshot> drones) {\n        DroneSnapshot leader = findLeader(drones);\n        DroneSnapshot follower = findFollower(drones);\n\n        if (leader != null) {\n            WaypointGoalSnapshot wp = StopEveryone.findActiveWaypointGoal(leader.getGoals());\n            if (wp != null) {\n                StopEveryone.flyToGoalIfNotAlready(leader, wp);\n            }\n\n            if (follower != null) {\n                Vector3D ned = findFollowVelocity(leader.getPosition(), follower.getPosition());\n                follower.getCommands().clear();\n                follower.getCommands().add(new NedCommand(ned.getX(), ned.getY(), ned.getZ(), 2.0));\n            }\n        } else if (follower != null) {\n            WaypointGoalSnapshot wp = StopEveryone.findActiveWaypointGoal(follower.getGoals());\n            if (wp != null) {\n                StopEveryone.flyToGoalIfNotAlready(follower, wp);\n            }   \n        }\n    }\n\n    Vector3D findFollowVelocity(LlaCoordinate leader, LlaCoordinate follower) {\n        LlaCoordinate followPoint = leader.findLla(NED_OFFSET);\n        double distance = followPoint.distance(follower);\n        if (distance > THRESHOLD_DISTANCE) {    \n            double speed = Math.min(distance, 7.0);\n            Vector3D arrow = follower.findNed(followPoint);\n            return arrow.normalize().scalarMultiply(speed);\n        }\n        return Vector3D.ZERO;\n    }\n    \n    static DroneSnapshot findLeader(ArrayList<DroneSnapshot> drones) {\n        for (DroneSnapshot drone: drones) {\n            if (\"LEADER\".equals(drone.getName())) {\n                return drone;\n            }\n        }\n        return null;\n    }\n\n    static DroneSnapshot findFollower(ArrayList<DroneSnapshot> drones) {\n        for (DroneSnapshot drone: drones) {\n            if (!\"LEADER\".equals(drone.getName())) {\n                return drone;\n            }\n        }\n        return null;\n     }\n}"}, {"id": "DroneSimulatorServiceRemoteFacade.java", "body": "package edu.nd.dronology.services.facades;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\n\nimport edu.nd.dronology.services.core.info.SimulatorScenarioCategoryInfo;\nimport edu.nd.dronology.services.core.info.SimulatorScenarioInfo;\nimport edu.nd.dronology.services.core.listener.IItemChangeListener;\nimport edu.nd.dronology.services.core.remote.IDroneSimulatorRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.instances.dronesimulator.DroneSimulatorService;\nimport edu.nd.dronology.services.remote.AbstractRemoteFacade;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class DroneSimulatorServiceRemoteFacade extends AbstractRemoteFacade implements IDroneSimulatorRemoteService {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -4580658378477037955L;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(DroneSimulatorServiceRemoteFacade.class);\n\tprivate static volatile DroneSimulatorServiceRemoteFacade INSTANCE;\n\n\tprotected DroneSimulatorServiceRemoteFacade() throws RemoteException {\n\t\tsuper(DroneSimulatorService.getInstance());\n\t}\n\n\tpublic static IDroneSimulatorRemoteService getInstance() throws RemoteException {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (DroneSimulatorServiceRemoteFacade.class) {\n\t\t\t\ttry {\n\t\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\t\tINSTANCE = new DroneSimulatorServiceRemoteFacade();\n\t\t\t\t\t}\n\t\t\t\t} catch (RemoteException e) {\n\t\t\t\t\tLOGGER.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\n\t}\n\n\t@Override\n\tpublic byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException {\n\t\treturn DroneSimulatorService.getInstance().requestFromServer(id);\n\t}\n\n\t@Override\n\tpublic void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException {\n\t\tDroneSimulatorService.getInstance().transmitToServer(id, content);\n\n\t}\n\n\t@Override\n\tpublic boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException {\n\t\treturn DroneSimulatorService.getInstance().addItemChangeListener(listener);\n\t}\n\n\t@Override\n\tpublic boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException {\n\t\treturn DroneSimulatorService.getInstance().removeItemChangeListener(listener);\n\t}\n\n\t@Override\n\tpublic Collection<SimulatorScenarioInfo> getItems() throws RemoteException {\n\t\treturn DroneSimulatorService.getInstance().getItems();\n\t}\n\n\t@Override\n\tpublic SimulatorScenarioInfo createItem() throws RemoteException, DronologyServiceException {\n\t\treturn DroneSimulatorService.getInstance().createItem();\n\t}\n\n\t@Override\n\tpublic void deleteItem(String itemid) throws RemoteException, DronologyServiceException {\n\t\tDroneSimulatorService.getInstance().deleteItem(itemid);\n\n\t}\n\n\t@Override\n\tpublic void activateScenario(SimulatorScenarioInfo scenario) throws RemoteException, DronologyServiceException {\n\t\tDroneSimulatorService.getInstance().activateScenario(scenario);\n\t\t\n\t}\n\n\t@Override\n\tpublic Collection<SimulatorScenarioCategoryInfo> getCategories() throws RemoteException {\n\t\treturn DroneSimulatorService.getInstance().getCategories();\n\t\t\n\t}\n}"}, {"id": "RouteAssignmentDemoScript.java", "body": "package edu.nd.dronology.misc.scripts;\n\nimport java.rmi.Naming;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\n\npublic class RouteAssignmentDemoScript {\n\n\tprivate static final String ADDRESS_SCHEME = \"rmi://%s:%s/Remote\";\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\n\t\t\tIRemoteManager manager = (IRemoteManager) Naming.lookup(String.format(ADDRESS_SCHEME, \"127.0.0.1\", 9779));\n\n\t\t\tIFlightManagerRemoteService managerService = (IFlightManagerRemoteService) manager\n\t\t\t\t\t.getService(IFlightManagerRemoteService.class);\n\n\t\t\tList<Waypoint> route1 = new ArrayList<>();\n\t\t\tdouble lat = -43.123;\n\t\t\tdouble lon= 23.4123;\n\t\t\tdouble alt = 10;\n\t\t\troute1.add(new Waypoint(new LlaCoordinate(lat, lon, alt)));\n\n\t\t\tmanagerService.planFlight(\"UAV1\", \"TestRoute1\", route1);\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n}\n"}, {"id": "RiverList.java", "body": "package edu.nd.dronology.services.extensions.areamapping.internal;\n\n//Class used for automatic parsing of JSON file with GSON library\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class RiverList{\n  private List<MapNode> nodes;\n  public RiverList(){\n      nodes = new ArrayList<MapNode>();\n  }\n  public List<MapNode> getNodes(){\n      return nodes;\n  }\n}\n"}, {"id": "MetricsUtilities.java", "body": "package edu.nd.dronology.services.extensions.areamapping.metrics;\n\nimport java.awt.Point;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Path2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.Vector;\n\nimport edu.nd.dronology.services.extensions.areamapping.internal.Geometry;\nimport edu.nd.dronology.services.extensions.areamapping.internal.ImageWaypoint;\nimport edu.nd.dronology.services.extensions.areamapping.internal.ImageWaypoints;\nimport edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive.RouteType;\n\npublic class MetricsUtilities {\n\t/**\n\t * This function generates circular ellipses for each image waypoint.\n\t * \n\t * @param route\n\t * @param APERATURE_WIDTH\n\t * @return vector of circular Ellipse2D.Double\n\t */\n\tpublic static Vector<Ellipse2D.Double> generateIWPCircles(RoutePrimitive route, double APERATURE_WIDTH) {\n\t\tVector<Ellipse2D.Double> circles = new Vector<>();\n\t\tImageWaypoints imageWaypoints = route.getIWP();\n\t\tfor (ImageWaypoint entry : imageWaypoints.get()) {\n\t\t\tEllipse2D.Double newCircle = new Ellipse2D.Double(entry.getWaypoint().getX() - APERATURE_WIDTH / 2,\n\t\t\t\t\tentry.getWaypoint().getY() - APERATURE_WIDTH / 2, APERATURE_WIDTH, APERATURE_WIDTH);\n\t\t\tcircles.add(newCircle);\n\t\t}\n\t\treturn circles;\n\t}\n\n\tpublic static Vector<Path2D.Double> generateIWPRectangles(RoutePrimitive route, double APERATURE_WIDTH,\n\t\t\tdouble APERATURE_HEIGHT) {\n\t\tVector<Path2D.Double> coverageRectangles = new Vector<>();\n\t\tfor (ImageWaypoint entry : route.getIWP().get()) {\n\t\t\tcoverageRectangles.add(generateIWPRectangle(entry, APERATURE_WIDTH, APERATURE_HEIGHT));\n\t\t}\n\t\treturn coverageRectangles;\n\t}\n\n\tprivate static Path2D.Double generateIWPRectangle(ImageWaypoint imagePoint, double APERATURE_WIDTH,\n\t\t\tdouble APERATURE_HEIGHT) {\n\t\tPath2D.Double coverageRectangle = new Path2D.Double();\n\t\tPoint2D.Double midpoint1 = new Point2D.Double();\n\t\tPoint2D.Double midpoint2 = new Point2D.Double();\n\t\tPoint2D.Double corner1 = new Point2D.Double();\n\t\tPoint2D.Double corner2 = new Point2D.Double();\n\t\tPoint2D.Double corner3 = new Point2D.Double();\n\t\tPoint2D.Double corner4 = new Point2D.Double();\n\t\tdouble dxHeight = APERATURE_HEIGHT / 2 * Math.cos(imagePoint.getOrientationAngle());\n\t\tdouble dyHeight = APERATURE_HEIGHT / 2 * Math.sin(imagePoint.getOrientationAngle());\n\t\tdouble dxWidth = APERATURE_WIDTH / 2 * Math.cos(imagePoint.getOrientationAngle() + Math.PI / 2);\n\t\tdouble dyWidth = APERATURE_WIDTH / 2 * Math.sin(imagePoint.getOrientationAngle() + Math.PI / 2);\n\t\tmidpoint1.setLocation(imagePoint.getWaypoint().getX() + dxHeight, imagePoint.getWaypoint().getY() + dyHeight);\n\t\tmidpoint2.setLocation(imagePoint.getWaypoint().getX() - dxHeight, imagePoint.getWaypoint().getY() - dyHeight);\n\t\tcorner1.setLocation(midpoint1.getX() + dxWidth, midpoint1.getY() + dyWidth);\n\t\tcorner2.setLocation(midpoint1.getX() - dxWidth, midpoint1.getY() - dyWidth);\n\t\tcorner3.setLocation(midpoint2.getX() - dxWidth, midpoint2.getY() - dyWidth);\n\t\tcorner4.setLocation(midpoint2.getX() + dxWidth, midpoint2.getY() + dyWidth);\n\t\tcoverageRectangle.moveTo(corner1.getX(), corner1.getY());\n\t\tcoverageRectangle.lineTo(corner2.getX(), corner2.getY());\n\t\tcoverageRectangle.lineTo(corner3.getX(), corner3.getY());\n\t\tcoverageRectangle.lineTo(corner4.getX(), corner4.getY());\n\t\tcoverageRectangle.closePath();\n\t\treturn coverageRectangle;\n\t}\n\n\tstatic Random random = new Random();\n\n\tpublic static int generateRandomNumber(int max, int min) {\n\n\t\treturn random.nextInt((max - min) + 1) + min;\n\t}\n\n\t/**\n\t * This function generates a pseudorandom point.\n\t * \n\t * @param minPoint\n\t * @param maxPoint\n\t * @return Point2D.Double pseudorandom point\n\t */\n\tpublic static Point2D.Double generateRandomPoint(Point2D.Double minPoint, Point2D.Double maxPoint) {\n\t\tPoint2D.Double newPoint = new Point2D.Double();\n\t\tdouble minLat = minPoint.getX();\n\t\tdouble maxLat = maxPoint.getX();\n\t\tdouble minLong = minPoint.getY();\n\t\tdouble maxLong = maxPoint.getY();\n\t\tRandom random = new Random();\n\t\tdouble newX = (random.nextDouble() * (maxLat + 1 - minLat)) + minLat;\n\t\tdouble newY = (random.nextDouble() * (maxLong + 1 - minLong)) + minLong;\n\t\tnewPoint.setLocation(newX, newY);\n\t\treturn newPoint;\n\t}\n\n\t// assumes drone startPoint and home location are stored in cartesian coordinates\n\tpublic static double totalDroneDistance(Drone drone) {\n\t\tdouble totalDistance = 0;\n\t\tDroneRouteAssignment routeAssignment = drone.getDroneRouteAssignment();\n\t\tPoint2D.Double startPoint = drone.getDroneStartPoint();\n\t\tfor (RoutePrimitive route : routeAssignment.get()) {\n\t\t\ttotalDistance += Geometry.findCartesianDistance(startPoint, route.getRouteStartPoint());\n\t\t\ttotalDistance += route.getRouteDistance();\n\t\t\tstartPoint = route.getRouteEndPoint();\n\t\t}\n\t\ttotalDistance += Geometry.findCartesianDistance(startPoint, drone.getDroneHomeLocation());\n\t\treturn totalDistance;\n\t}\n\t\n\tpublic static double totalBatteryDistance(Drone drone) {\n\t\tdouble totalDistance = 0;\n\t\tDroneRouteAssignment routeAssignment = drone.getDroneRouteAssignment();\n\t\tPoint2D.Double startPoint = drone.getDroneStartPoint();\n\t\tfor (RoutePrimitive route : routeAssignment.get()) {\n\t\t\tif(route.getRouteType() == RouteType.HOME) {\n\t\t\t\ttotalDistance += route.getRouteDistance();\n\t\t\t\tif(totalDistance / 1000 > 10) {\n\t\t\t\t\treturn totalDistance;\n\t\t\t\t}\n\t\t\t\ttotalDistance = 0;\n\t\t\t} else {\n\t\t\t\ttotalDistance += Geometry.findCartesianDistance(startPoint, route.getRouteStartPoint());\n\t\t\t\ttotalDistance += route.getRouteDistance();\n\t\t\t\tstartPoint = route.getRouteEndPoint();\n\t\t\t}\n\t\t}\n\t\ttotalDistance += Geometry.findCartesianDistance(startPoint, drone.getDroneHomeLocation());\n\t\treturn totalDistance;\n\t}\n\t\n\tpublic static double totalAllocationDistance(List<Drone> drones) {\n\t\tdouble totalDistance = 0;\n\t\tfor(Drone drone : drones) {\n\t\t\ttotalDistance += totalDroneDistance(drone);\n\t\t}\n\t\treturn totalDistance;\n\t}\n\t\n\tpublic static List<Double> calculateDroneDistances(List<Drone> drones){\n\t\tList<Double> droneDistances = new ArrayList<>();\n\t\tfor(Drone drone : drones) {\n\t\t\tdroneDistances.add(totalDroneDistance(drone));\n\t\t}\n\t\treturn droneDistances;\n\t}\n\n\tpublic static double equalityOfTasks(List<Drone> drones) {\n\t\tdouble maxDistance = -Double.MAX_VALUE;\n\t\tdouble minDistance = Double.MAX_VALUE;\n\t\tdouble distance;\n\t\tfor (Drone drone : drones) {\n\t\t\tdistance = totalDroneDistance(drone);\n\t\t\tif (distance < minDistance) {\n\t\t\t\tminDistance = distance;\n\t\t\t}\n\t\t\tif (maxDistance < distance) {\n\t\t\t\tmaxDistance = distance;\n\t\t\t}\n\t\t}\n\t\treturn minDistance / maxDistance;\n\t}\n\t\n\tprivate static List<Point2D.Double> generateRandomRiverCoveragePoints(List<RiverBank> bankList, Path2D.Double totalRiverSegment) {\n\t\tPoint2D.Double minBound = new Point2D.Double();\n\t\tPoint2D.Double maxBound = new Point2D.Double();\n\t\tVector<Point2D.Double> bounds = Geometry.simpleRiverBoundingRectangle(bankList);\n\t\tList<Point2D.Double> coveragePoints = new ArrayList<>();\n\t\tminBound = bounds.get(0);\n\t\tmaxBound = bounds.get(1);\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tPoint2D.Double newPoint = MetricsUtilities.generateRandomPoint(minBound, maxBound);\n\t\t\twhile (!totalRiverSegment.contains(newPoint)) {\n\t\t\t\tnewPoint = MetricsUtilities.generateRandomPoint(minBound, maxBound);\n\t\t\t}\n\t\t\tcoveragePoints.add(newPoint);\n\t\t}\n\t\treturn coveragePoints;\n\t}\n\n\t/**\n\t * This function calculates coverage statistics for the chosen RoutePrimitive objects.\n\t * \n\t * @param routes\n\t * @param coveragePoints\n\t * @param APERATURE_WIDTH\n\t * @return CoverageStatistics\n\t */\n\tpublic static double calculateRouteCoverage(List<Drone> drones, Path2D.Double totalRiverSegment,\n\t\t\tList<RiverBank> bankList, double APERATURE_WIDTH, double APERATURE_HEIGHT) {\n\t\tList<Point2D.Double> coveragePoints = generateRandomRiverCoveragePoints(bankList, totalRiverSegment);\n\t\tdouble coverageFraction;\n\t\tdouble missedPoints = 0;\n\t\tboolean covered = false;\n\t\tList<RoutePrimitive> routes = new ArrayList<>();\n\t\tfor (Drone drone : drones) {\n\t\t\troutes.addAll(drone.getDroneRouteAssignment().get());\n\t\t}\n\t\tVector<Path2D.Double> imageWaypointRectangles = new Vector<>();\n\t\tfor (RoutePrimitive route : routes) {\n\t\t\tif(route.getRouteType() != RoutePrimitive.RouteType.HOME) {\n\t\t\t\timageWaypointRectangles.addAll(generateIWPRectangles(route, APERATURE_WIDTH, APERATURE_HEIGHT));\n\t\t\t}\n\t\t}\n\t\tfor (Point2D.Double coveragePoint : coveragePoints) {\n\t\t\tfor (Path2D.Double rectangle : imageWaypointRectangles) {\n\t\t\t\tif (rectangle.contains(coveragePoint)) {\n\t\t\t\t\tcovered = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!covered) {\n\t\t\t\tmissedPoints += 1;\n\t\t\t}\n\t\t\tcovered = false;\n\t\t}\n\t\tcoverageFraction = 1 - missedPoints / coveragePoints.size();\n\t\treturn coverageFraction;\n\t}\n\n\tpublic static double calculateDownstreamRatio(List<Drone> drones) {\n\t\tdouble downstreamRoutes = 0;\n\t\tdouble upstreamRoutes = 0;\n\t\tDroneRouteAssignment droneRoute;\n\t\tfor (Drone drone : drones) {\n\t\t\tdroneRoute = drone.getDroneRouteAssignment();\n\t\t\tfor (RoutePrimitive route : droneRoute.get()) {\n\t\t\t\tif (route.getDownstreamDirection()) {\n\t\t\t\t\tdownstreamRoutes += 1;\n\t\t\t\t} else {\n\t\t\t\t\tupstreamRoutes += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn downstreamRoutes / (downstreamRoutes + upstreamRoutes);\n\t}\n\t\n\tprivate static double calculateDronePriorityCoverage(Drone drone) {\n\t\tdouble coverage = 0;\n\t\tdouble primitivePosition = 1;\n\t\tfor(RoutePrimitive routePrimitive : drone.getDroneRouteAssignment().get()) {\n\t\t\tcoverage += routePrimitive.getRouteWeight() * (1 / primitivePosition);\n\t\t\tprimitivePosition++;\n\t\t}\n\t\treturn coverage;\n\t}\n\t\n\tpublic static double calculateAllocationPriorityCoverage(List<Drone> drones) {\n\t\tdouble allocationCoverage = 0;\n\t\tfor(Drone drone : drones) {\n\t\t\tallocationCoverage += calculateDronePriorityCoverage(drone);\n\t\t}\n\t\treturn allocationCoverage;\n\t}\n\n\tpublic static boolean batteryFailure(Drone drone) {\n\t\tif (totalBatteryDistance(drone) / 1000 > 10) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic static int collisionCheck(List<Drone> drones) {\n\t\tint collisions = 0;\n\t\tfor (int i = 0; i < drones.size() - 1; i++) {\n\t\t\tList<Point2D.Double> currRoute = drones.get(i).getDroneFullRoute();\n\t\t\tfor (int d = i + 1; d < drones.size(); d++) {\n\t\t\t\tList<Point2D.Double> otherRoute = drones.get(d).getDroneFullRoute();\n\t\t\t\tdouble currDistance = 0;\n\t\t\t\tfor (int r = 0; r < currRoute.size() - 1; r++) {\n\t\t\t\t\tLine2D.Double currLineSeg = new Line2D.Double(currRoute.get(r), currRoute.get(r + 1));\n\t\t\t\t\tdouble otherDistance = 0;\n\t\t\t\t\tfor (int r2 = 0; r2 < otherRoute.size() - 1; r2++) {\n\t\t\t\t\t\tLine2D.Double otherLineSeg = new Line2D.Double(otherRoute.get(r2), otherRoute.get(r2 + 1));\n\t\t\t\t\t\tif (currLineSeg.intersectsLine(otherLineSeg)) {\n\t\t\t\t\t\t\tPoint2D.Double intersectionPoint = Geometry.findLineIntersection(currLineSeg, otherLineSeg);\n\t\t\t\t\t\t\tif (Math.abs((currDistance + Geometry.findCartesianDistance(\n\t\t\t\t\t\t\t\t\tnew Point2D.Double(currLineSeg.getX1(), currLineSeg.getY1()), intersectionPoint))\n\t\t\t\t\t\t\t\t\t- (otherDistance + Geometry.findCartesianDistance(\n\t\t\t\t\t\t\t\t\t\t\tnew Point2D.Double(otherLineSeg.getX1(), otherLineSeg.getY1()), intersectionPoint))) < 10) {\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * System.out.println(Geometry.findLineIntersection(currLineSeg, otherLineSeg)); System.out.println(\"currLineSeg: \" + \"[\" + currLineSeg.getX1() + \", \" + currLineSeg.getX2() + \"] [\" +\n\t\t\t\t\t\t\t\t * currLineSeg.getY1() + \", \" + currLineSeg.getY2() +\"]\"); System.out.println(\"otherLineSeg: \" + \"[\" + otherLineSeg.getX1() + \", \" + otherLineSeg.getX2() + \"] [\" + otherLineSeg.getY1()\n\t\t\t\t\t\t\t\t * + \", \" + otherLineSeg.getY2() +\"]\"); System.out.println(\"currDistance: \" + currDistance); System.out.println(\"otherDistance: \" + otherDistance);\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tcollisions += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\totherDistance += Geometry.findCartesianDistance(otherRoute.get(r2), otherRoute.get(r2 + 1));\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrDistance += Geometry.findCartesianDistance(currRoute.get(r), currRoute.get(r + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn collisions;\n\t}\n\n\tpublic static boolean routeAssignmentOutsideRiver(DroneRouteAssignment assignment, Path2D.Double riverSegment,\n\t\t\tdouble APERATURE_HEIGHT) {\n\t\tboolean outsideRiver = false;\n\t\tfor (int i = 0; i < assignment.get().size() - 1; i++) {\n\t\t\tPoint2D.Double startPoint = assignment.get(i).getRouteEndPoint();\n\t\t\tPoint2D.Double endPoint = assignment.get(i + 1).getRouteStartPoint();\n\t\t\toutsideRiver = transitionOutsideRiver(startPoint, endPoint, riverSegment, APERATURE_HEIGHT);\n\t\t\tif (outsideRiver) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn outsideRiver;\n\t}\n\n\t// assumes it will never be going outside the river if the transition is less than an APERATURE_HEIGHT in length\n\n\tprivate static boolean transitionOutsideRiver(Point2D.Double startPoint, Point2D.Double endPoint,\n\t\t\tPath2D.Double riverSegment, double APERATURE_HEIGHT) {\n\t\tboolean outsideRiver = false;\n\t\tdouble totalDistance = Geometry.findCartesianDistance(startPoint, endPoint);\n\t\tdouble distanceRatio = APERATURE_HEIGHT / totalDistance;\n\t\tif (totalDistance < APERATURE_HEIGHT) {\n\t\t\treturn outsideRiver;\n\t\t}\n\t\twhile (APERATURE_HEIGHT < totalDistance) {\n\t\t\tPoint2D.Double newPoint = Geometry.findOffsetPoint(startPoint, endPoint, distanceRatio);\n\t\t\tif (!riverSegment.contains(newPoint)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tstartPoint = newPoint;\n\t\t\ttotalDistance = totalDistance - APERATURE_HEIGHT;\n\t\t}\n\t\treturn outsideRiver;\n\t}\n}\n"}, {"id": "IFlightRouteplanningServiceInstance.java", "body": "package edu.nd.dronology.services.instances.flightroute;\n\nimport java.util.Collection;\n\nimport edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.info.FlightRouteCategoryInfo;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic interface IFlightRouteplanningServiceInstance extends IFileTransmitServiceInstance<FlightRouteInfo> {\n\n\tCollection<FlightRouteCategoryInfo> getFlightPathCategories();\n\n\tFlightRouteInfo getRouteByName(String routeName) throws DronologyServiceException;\n\n}\n"}, {"id": "IFileTransmitServiceInstance.java", "body": "package edu.nd.dronology.services.core.api;\n\nimport java.util.Collection;\n\nimport edu.nd.dronology.services.core.listener.IItemChangeListener;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic interface IFileTransmitServiceInstance<ITEM_TYPE> extends IServiceInstance{\n\n\tbyte[] requestFromServer(String id) throws DronologyServiceException;\n\n\tvoid transmitToServer(String id, byte[] content) throws DronologyServiceException;\n\n\tpublic boolean addItemChangeListener(IItemChangeListener listener);\n\t\n\tpublic boolean removeItemChangeListener(IItemChangeListener listener);\n\t\n\tCollection <ITEM_TYPE> getItems();\n\t\n\tITEM_TYPE getItem(String id) throws DronologyServiceException;\n\t\n\tITEM_TYPE createItem() throws  DronologyServiceException;\n\n\tvoid deleteItem(String itemid) throws  DronologyServiceException;\n\t\n\t\n}\n"}, {"id": "CollisionAvoidanceBackend.java", "body": "package edu.nd.dronology.core.collisionavoidance;\n\nimport edu.nd.dronology.core.collisionavoidance.backendmessage.*;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\nimport java.util.*;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\n/**\n * <p>\n * The CollisionAvoidanceBackend is responsible for running the CollisionAvoider. Observes are registered in\n * ManagedDrone(s) and PhysicalDrone(s). These Observes pass along state. In the case of ManagedDrone, that state is the\n * set of active goals and the commandQueue. For PhysicalDrone, it's the drone's sensed state (its position, velocity\n * etc.). The data from both is combined to create DroneSnapshot(s) so that CollisionAvoider.avoid() can be called.\n * </p>\n *\n * <h2>implementation details (subject to change)</h2>\n * <p>\n * The idea behind CollisionAvoidanceBackend is to create an actor inspired object that only does work in response to\n * messages coming into its mailbox. CollisionAvoidanceBackend can do four things:\n * <ul>\n *     <li>Run CollisionAvoider.avoid() and disperse guidance to the managed drones. This class expects a stand-alone\n *     timer task to send this message periodically.</li>\n *\n *     <li>Receive an update message from a managed drone. This message includes a snapshot of the active goals as well\n *     as the queue of commands currently being executed. Messages of this type come in when the set of active goals\n *     changes or when the queue of commands changes. This happens when a goal or command is completed, for example.\n *     </li>\n *\n *     <li>Receive an update message from a physical drone. This message contains data sensed by a drones (its position,\n *     velocity, etc.). Messages of this type come in when new data is received from the drone.</li>\n *\n *     <li>Receive a stop command. This message should come in when the program is shutting down. This message causes\n *     the thread to gracefully stop.</li>\n * </ul>\n * </p>\n *\n *  <p>\n *     The {@link CollisionAvoidanceMessenger} object returned by {@link #getMessenger()} takes care of\n *     converting method calls into messages and delivering them to CollisionAvoidanceBackend's mailbox. All the\n *     functionality offered by this class is made accessible by the CollisionAvoidanceMessenger.\n * </p>\n * @see CollisionAvoidanceMessenger\n */\npublic class CollisionAvoidanceBackend implements Runnable {\n    private static final ILogger LOGGER = LoggerProvider.getLogger(CollisionAvoidanceBackend.class);\n    private static final boolean FIFO_MAILBOX = true;\n    // TODO get this value, MAX_UAVS, from a configuration file\n    private static final int MAX_UAVS = 10;\n    // TODO get this value, UAV_REPORTS_PER_SECOND, from a configuration file\n    private static final int UAV_REPORTS_PER_SECOND = 1;\n    private static final int MAILBOX_BUFFER_FACTOR = 2;\n    private static final int MAILBOX_CAPACITY = MAX_UAVS * UAV_REPORTS_PER_SECOND * MAILBOX_BUFFER_FACTOR;\n\n    private final ArrayBlockingQueue<AbstractMessage> mailbox = new ArrayBlockingQueue<>(MAILBOX_CAPACITY, FIFO_MAILBOX);\n    private final CollisionAvoider avoiderStrategy;\n    private final CollisionAvoidanceMessenger messenger;\n    private final Map<String, PhysicalDroneUpdateMessage> droneStates = new HashMap<>();\n    private final Map<String, ManagedDroneUpdateMessage> droneControls = new HashMap<>();\n\n    private boolean running = true;\n\n    public CollisionAvoidanceBackend(CollisionAvoider avoiderStrategy) {\n        this.avoiderStrategy = avoiderStrategy;\n        this.messenger = new CollisionAvoidanceMessenger(this.mailbox);\n    }\n\n    public CollisionAvoidanceMessenger getMessenger() {\n        return this.messenger;\n    }\n\n    private void stop() {\n        running = false;\n    }\n\n    public void run() {\n        int timeoutCount = 0;\n        while(running) {\n            try {\n                AbstractMessage message = mailbox.poll(1000, TimeUnit.MILLISECONDS);\n\n                if (message == null) {\n                    timeoutCount = timeoutCount + 1;\n                    if (timeoutCount > 2) {\n                        LOGGER.warn(\"has not received any messages for \" + timeoutCount + \" seconds\");\n                    }\n                } else {\n                    timeoutCount = 0;\n                    if (message instanceof  PhysicalDroneUpdateMessage) {\n                        updatePhysicalDrone((PhysicalDroneUpdateMessage) message);\n                    } else if (message instanceof  ManagedDroneUpdateMessage) {\n                        updateManagedDrone((ManagedDroneUpdateMessage) message);\n                    } else if (message instanceof CheckerTaskMessage) {\n                        runAvoid();\n                    } else if (message instanceof StopMessage) {\n                        stop();\n                    } else {\n                        LOGGER.warn(\"UNKNOWN MESSAGE TYPE \" + message);\n                    }\n                }\n            } catch (InterruptedException e) {\n                LOGGER.warn(\"CollisionAvoidanceBackend interrupted\");\n                LOGGER.trace(e);\n            }\n        }\n    }\n\n    private void updatePhysicalDrone(PhysicalDroneUpdateMessage msg) {\n        droneStates.put(msg.name, msg);\n    }\n\n    private void updateManagedDrone(ManagedDroneUpdateMessage msg) {\n        droneControls.put(msg.name, msg);\n\n    }\n\n    private void runAvoid() {\n        ArrayList<DroneSnapshot> droneSnapshots = makeDroneSnapshots();\n        avoiderStrategy.avoid(droneSnapshots);\n        updateManagedDroneGuidance(droneSnapshots);\n    }\n\n    private ArrayList<DroneSnapshot> makeDroneSnapshots() {\n        ArrayList<DroneSnapshot> snapshots = new ArrayList<>(droneStates.size());\n        List<String> droneNames = droneStates.keySet().stream()\n                .filter(droneName -> droneStates.containsKey(droneName) && droneControls.containsKey(droneName))\n                .collect(Collectors.toList());\n        for(String droneName : droneNames) {\n            PhysicalDroneUpdateMessage droneState = droneStates.get(droneName);\n            ManagedDroneUpdateMessage droneControl = droneControls.get(droneName);\n            DroneSnapshotInternal snapshot = new DroneSnapshotInternal(droneName,\n                    droneState.position, droneState.velocity, droneState.attitude);\n            snapshot.getCommands().addAll(droneControl.commandQueue);\n            snapshot.setState(droneControl.state);\n            snapshot.setGoals(droneControl.goals);\n            snapshots.add(snapshot);\n        }\n        return snapshots;\n    }\n\n    private void updateManagedDroneGuidance(ArrayList<DroneSnapshot> snapshots) {\n        for (DroneSnapshot snapshot : snapshots) {\n            droneControls.get(snapshot.getName()).managedDrone.getMessenger().updateGuidance(snapshot.getCommands());\n        }\n    }\n}\n"}, {"id": "MissionPlanningXStreamPersistor.java", "body": "package edu.nd.dronology.services.core.persistence.internal;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.nio.charset.Charset;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport com.thoughtworks.xstream.XStream;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\n\nimport edu.nd.dronology.services.core.items.IMissionPlan;\nimport edu.nd.dronology.services.core.persistence.DronologyPersistenceUtil;\nimport edu.nd.dronology.services.core.persistence.IPersistenceManager;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class MissionPlanningXStreamPersistor implements IPersistenceManager<IMissionPlan> {\n\n\tprivate static final XStream xstream = new XStream(new XppDriver());\n\tprivate static ILogger LOGGER = LoggerProvider.getLogger(MissionPlanningXStreamPersistor.class);\n\n\tstatic final boolean useCompression = false;\n\n\t@Override\n\tpublic IMissionPlan open(InputStream fin) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t//\t xstream.setMode(XStream.);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\t\t\n\t\tif (useCompression) {\n\t\t\treturn loadedCompressedStream(fin);\n\t\t} else {\n\t\t\treturn loadUncompressedStream(fin);\n\t\t}\n\t}\n\n\tprivate IMissionPlan loadUncompressedStream(InputStream fin) throws PersistenceException {\n\t\ttry {\n\t\t\tInputStreamReader reader = new InputStreamReader(new BufferedInputStream(fin), Charset.forName(\"UTF-8\"));\n\t\t\tObject model = xstream.fromXML(reader);\n\t\t\treturn (IMissionPlan) model;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (fin != null) {\n\t\t\t\t\tfin.close();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate IMissionPlan loadedCompressedStream(InputStream fin) throws PersistenceException {\n\t\tInputStream zIn = null;\n\t\ttry {\n\t\t\tzIn = new GZIPInputStream(fin);\n\t\t\tObject model = xstream.fromXML(new BufferedReader(new InputStreamReader(zIn, \"UTF-8\")));\n\n\t\t\treturn (IMissionPlan) model;\n\t\t} catch (IOException e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (zIn != null) {\n\t\t\t\t\tzIn.close();\n\t\t\t\t}\n\t\t\t\tif (fin != null) {\n\t\t\t\t\tfin.close();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\n\t\t}\n\t}\n \n\t@Override\n\tpublic boolean save(IMissionPlan o, OutputStream fout) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t\t// xstream.setMode(XStream.ID_REFERENCES);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\t\t// xstream.addImplicitMap(ImplMEEvent.class, \"relatedEvents\", ImplMEEvent.class, \"relatedEvents\");\n\n\t\tif (useCompression) {\n\t\t\treturn saveCompressedStream(o, fout);\n\t\t} else {\n\t\t\treturn saveUncompressedStream(o, fout);\n\t\t}\n\n\t}\n\n\tprivate boolean saveUncompressedStream(IMissionPlan o, OutputStream fout) throws PersistenceException {\n\t\tOutputStreamWriter writer = null;\n\t\ttry {\n\t\t\twriter = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(\"UTF-8\"));\n\t\t\txstream.toXML(o, writer);\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (writer != null) {\n\t\t\t\t\twriter.close();\n\t\t\t\t}\n\t\t\t\tif (fout != null) {\n\t\t\t\t\tfout.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean saveCompressedStream(IMissionPlan o, OutputStream fout) throws PersistenceException {\n\t\ttry {\n\t\t\tGZIPOutputStream zOut = new GZIPOutputStream(fout);\n\t\t\txstream.toXML(o, new BufferedWriter(new OutputStreamWriter(zOut, \"UTF-8\")));\n\n\t\t\tzOut.close();\n\t\t\tfout.close();\n\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t}\n\t}\n\n}\n"}, {"id": "FlightSimulator.java", "body": "package edu.nd.dronology.core.simulator.simplesimulator;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.util.DistanceUtil;\nimport edu.nd.dronology.core.vehicle.internal.VirtualDrone;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * Computes the current position of a virtual drone as it moves during flight. Serves as a lightweight SITL for a drone.\n * \n * @author Jane Cleland-Huang\n */\npublic class FlightSimulator {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(FlightSimulator.class);\n\n\tprivate LlaCoordinate currentPosition;\n\tprivate LlaCoordinate targetPosition;\n\tprivate Long previousDistance = 0L;\n\n\tprivate boolean reached = false;\n\n\tprivate VirtualDrone drone;\n\n\t/**\n\t * Creates a flight simulator object for a single virtual drone\n\t * \n\t * @param drone\n\t */\n\tprotected FlightSimulator(VirtualDrone drone) {\n\t\tthis.drone = drone;\n\t}\n\n\t/**\n\t * Sets current flight path from current position to a targeted position\n\t * \n\t * @param currentPos\n\t *          Coordinates of current position\n\t * @param targetPos\n\t *          Coordinates of target position\n\t */\n\tpublic void setFlightPath(LlaCoordinate currentPos, LlaCoordinate targetPos) {\n\t\tif (currentPosition == null || reached) {\n\n\t\t\tthis.currentPosition = currentPos;\n\t\t\treached = false;\n\t\t} \n\n\t\tthis.targetPosition = targetPos;\n\t\tpreviousDistance = getRemainingDistance();\n\t}\n\n\t/**\n\t * Computes the distance between current position and target position\n\t * \n\t * @return distance remaining in degree points.\n\t */\n\tpublic long getRemainingDistance() {\n\t\treturn (long) Math.sqrt((Math.pow(computeLongitudeDelta(), 2)) + Math.pow(computeLatitudeDelta(), 2));\n\t}\n\n\t/**\n\t * Computes the delta between the drones current latitude and its target latitude.\n\t * \n\t * @return\n\t */\n\tprivate double computeLatitudeDelta() {\n\t\treturn (currentPosition.getLatitude() - targetPosition.getLatitude()) * 1000000;\n\t}\n\n\t/**\n\t * Computes the delta between the drones current longitude and its target longitude\n\t * \n\t * @return\n\t */\n\tprivate double computeLongitudeDelta() {\n\t\treturn (currentPosition.getLongitude() - targetPosition.getLongitude()) * 1000000;\n\t}\n\n\t/**\n\t * Computes the angle at which a drone is flying with respect to the vertical\n\t * \n\t * @return\n\t */\n\tprivate double computeAngle() {\n\t\tdouble height = computeLatitudeDelta(); // opposite\n\t\t// double width = (computeLongitudeDelta());\n\t\tdouble hypotenuse = getRemainingDistance();\n\t\tdouble sinTheta = height / hypotenuse;\n\t\tdouble angle = Math.asin(sinTheta) * 180 / Math.PI;\n\t\treturn Double.isNaN(angle) ? 1 : angle;\n\t}\n\n\t/**\n\t * Computes the position of the drone following one step. Checks if destination has been reached.\n\t * \n\t * @param step\n\t *          : Distance in degree points to move per iteration\n\t * @return isStillMoving?\n\t */\n\tpublic boolean move(double step) {\n\t\ttry {\n\t\t\t// First determine which relative quadrant the target is in -- in relation to current position at the origin of X,Y axes\n\n\t\t\tdouble theta = computeAngle();\n\t\t\tdouble heightIncrement = Math.abs((long) (Math.sin(theta) * step));\n\t\t\tdouble widthIncrement = Math.abs((long) (Math.cos(theta) * step));\n\n\t\t\tdouble scaleFactor = 0.1;\n\n\t\t\twidthIncrement *= scaleFactor;\n\t\t\theightIncrement *= scaleFactor;\n\t\t\tdouble newLongit = 0;\n\t\t\tdouble newLatid = 0;\n\n\t\t\t// Latitude delta\n\t\t\tif (currentPosition.getLatitude() < targetPosition.getLatitude()) {\n\t\t\t\t// currentPosition.setLatitude(currentPosition.getLatitude() + heightIncrement); // Drone is south of Target\n\t\t\t\tnewLatid = (currentPosition.getLatitude() * 1000000) + heightIncrement;\n\t\t\t} else {\n\t\t\t\t// currentPosition.setLatitude(currentPosition.getLatitude() - heightIncrement); // Drone is North (or same) as target\n\t\t\t\tnewLatid = (currentPosition.getLatitude() * 1000000) - heightIncrement;\n\t\t\t}\n\t\t\t// Longitude delta\n\t\t\tif (currentPosition.getLongitude() < targetPosition.getLongitude()) {\n\t\t\t\t// currentPosition.setLongitude(currentPosition.getLongitude() + widthIncrement); // Drone is to the left/west of target\n\t\t\t\tnewLongit = (currentPosition.getLongitude() * 1000000) + widthIncrement;\n\t\t\t} else {\n\t\t\t\t// currentPosition.setLongitude(currentPosition.getLongitude() - widthIncrement); // Drone is to the right/east of target\n\t\t\t\tnewLongit = (currentPosition.getLongitude() * 1000000) - widthIncrement;\n\t\t\t}\n\t\t\t// double distanceMoved = Math.sqrt(Math.pow(heightIncrement,2)+Math.pow(widthIncrement,2));\n\n\t\t\tnewLatid = newLatid / 1000000;\n\t\t\tnewLongit = newLongit / 1000000;\n\n\t\t\tcurrentPosition = new LlaCoordinate(newLatid, newLongit, currentPosition.getAltitude());\n\t\t\tLOGGER.trace(\"Remaining Dinstance: \" + DistanceUtil.distance(currentPosition, targetPosition));\n\t\t\t// if (previousDistance <= getRemainingDistance() && getRemainingDistance() < 200) {\n\t\t\tdrone.setCoordinates(currentPosition);\n\t\t\tif (DistanceUtil.distance(currentPosition, targetPosition) < 2) {\n\t\t\t\tpreviousDistance = getRemainingDistance();\n\t\t\t\t// LOGGER.info(drone.getDroneName() + \" ==> Waypoint reached\");\n\t\t\t\treached = true;\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tpreviousDistance = getRemainingDistance();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * Checks if a drone has reached its target destination.\n\t * \n\t * @param distanceMovedPerTimeStep\n\t *          Checks location with respect to target position.\n\t * @return true if target position is reached.\n\t */\n\tpublic boolean isDestinationReached(double distanceMovedPerTimeStep) {\n\t\tdouble latDistance = Math.abs(currentPosition.getLatitude() - targetPosition.getLatitude());\n\t\tdouble lonDistance = Math.abs(currentPosition.getLongitude() - targetPosition.getLongitude());\n\t\treturn lonDistance <= distanceMovedPerTimeStep && latDistance <= distanceMovedPerTimeStep;\n\t}\n\n}\n"}, {"id": "IDronologyChangeListener.java", "body": "package edu.nd.dronology.core.status;\n\npublic interface IDronologyChangeListener {\n\n\tvoid notifyUAVRemoved(String uavid);\n\n\tvoid notifyGCSShutdown(String groundstationid);\n\n}\n"}, {"id": "Discuss.java", "body": "package edu.nd.dronology.core;\n/**\n * Marker annotation for things we need to talk about!\n * @author Michael\n *\n */\n\npublic @interface Discuss {\n\t\n\t   String discuss();\n\t \n\n}\n"}, {"id": "IUAVTypeRegistrationRemoteService.java", "body": "package edu.nd.dronology.services.core.remote;\n\nimport edu.nd.dronology.services.core.info.UAVTypeRegistrationInfo;\n\npublic interface IUAVTypeRegistrationRemoteService extends IRemoteableService, IFileTransmitRemoteService<UAVTypeRegistrationInfo> {\n\n\t\n\t\n}\n"}, {"id": "DroneMonitoringService.java", "body": "package edu.nd.dronology.monitoring.service;\n\nimport java.util.Set;\n\nimport edu.nd.dronology.core.monitoring.ArtifactIdentifier;\nimport edu.nd.dronology.monitoring.IRemoteMonitoringMessageHandler;\nimport edu.nd.dronology.services.core.base.AbstractServerService;\n\n\n\n/**\n * \n * Service for UAV monitoring messages<br>\n * Allows registering {@link IRemoteMonitoringMessageHandler} to subscribe to certain message types or topics<br>\n * \n *  \n * @author Michael Vierhauser\n *\n */ \npublic class DroneMonitoringService extends AbstractServerService<IDroneMonitoringServiceInstance> {\n\n\tprivate static volatile DroneMonitoringService INSTANCE;\n\n\tprotected DroneMonitoringService() {\n\t}\n\n\t/**\n\t * @return The singleton DroneMonitoringService instance\n\t */\n\tpublic static DroneMonitoringService getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (DroneMonitoringService.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new DroneMonitoringService();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tprotected IDroneMonitoringServiceInstance initServiceInstance() {\n\t\treturn new DroneMonitoringServiceInstance();\n\t}\n\n\tpublic void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler) {\n\t\tserviceInstance.registerMonitoringMessageHandler(handler);\n\t}\n\n\tpublic void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler,\n\t\t\tArtifactIdentifier identifier) {\n\t\tserviceInstance.registerMonitoringMessageHandler(handler, identifier);\n\t}\n\n\tprotected void setMonitoringFrequency(String uavid, Double frequency) {\n\n\t}\n\n\tpublic Set<IRemoteMonitoringMessageHandler> getSubscribedHandler(ArtifactIdentifier identifier) {\n\t\treturn serviceInstance.getSubscribedHandler(identifier);\n\n\t}\n\n\tpublic void unsubscribeHandler(IRemoteMonitoringMessageHandler handler) {\n\t\tserviceInstance.unsubscribeHandler(handler);\n\t}\n\n}\n"}, {"id": "IDroneSimulatorRemoteService.java", "body": "package edu.nd.dronology.services.core.remote;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\n\nimport edu.nd.dronology.services.core.info.SimulatorScenarioCategoryInfo;\nimport edu.nd.dronology.services.core.info.SimulatorScenarioInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n/**\n * Meta-Model Service Interface: Handling artifact  models.<br>\n * Extends {@link IFileTransmitRemoteService} and provides methods for retrieving and saving models from the server.\n * \n * @author Michael Vierhauser\n * \n */\npublic interface IDroneSimulatorRemoteService extends IRemoteableService, IFileTransmitRemoteService<SimulatorScenarioInfo> {\n\n\t\n\tpublic void activateScenario(SimulatorScenarioInfo scenario) throws RemoteException, DronologyServiceException;\n\t\n\tpublic Collection<SimulatorScenarioCategoryInfo> getCategories() throws RemoteException;\n\t\n}\n"}, {"id": "StateMessageTypeAdapter.java", "body": "package edu.nd.dronology.gstation.connector.messages;\n\nimport java.lang.reflect.Type;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.google.gson.JsonDeserializationContext;\nimport com.google.gson.JsonDeserializer;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.google.gson.JsonParseException;\nimport com.google.gson.JsonPrimitive;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.gstation.connector.messages.UAVStateMessage.BatteryStatus;\nimport edu.nd.dronology.gstation.connector.messages.UAVStateMessage.DroneMode;\nimport edu.nd.dronology.gstation.connector.messages.UAVStateMessage.DroneStatus;\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class StateMessageTypeAdapter implements JsonDeserializer<Map> {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(StateMessageTypeAdapter.class);\n\n\t@Override\n\tpublic Map deserialize(JsonElement element, Type mapType, JsonDeserializationContext arg2)\n\t\t\tthrows JsonParseException {\n\t\tMap<String, Object> dataMap = new HashMap<>();\n\t\tJsonObject mapObject = element.getAsJsonObject();\n\n\t\tLlaCoordinate location = deserializeLLACoordinate(mapObject, UAVStateMessage.LOCATION);\n\t\tdataMap.put(UAVStateMessage.LOCATION, location);\n\n\t\tVector3D attitude = deserializeVector3D(mapObject, UAVStateMessage.ATTITUDE);\n\t\tdataMap.put(UAVStateMessage.ATTITUDE, attitude);\n\n\t\tVector3D velocity = deserializeVector3D(mapObject, UAVStateMessage.VELOCITY);\n\t\tdataMap.put(UAVStateMessage.VELOCITY, velocity);\n\n\t\tString statusString = mapObject.get(UAVStateMessage.STATUS).getAsString();\n\t\tString modeString = mapObject.get(UAVStateMessage.MODE).getAsString();\n\n\t\tdataMap.put(UAVStateMessage.STATUS, DroneStatus.valueOf(statusString));\n\t\tdataMap.put(UAVStateMessage.MODE, DroneMode.valueOf(modeString));\n\n\t\tboolean armedValue = mapObject.get(UAVStateMessage.ARMED).getAsBoolean();\n\t\tdataMap.put(UAVStateMessage.ARMED, Boolean.valueOf(armedValue));\n\n\t\tboolean armableValue = mapObject.get(UAVStateMessage.ARMABLE).getAsBoolean();\n\t\tdataMap.put(UAVStateMessage.ARMABLE, Boolean.valueOf(armableValue));\n\n\t\tdouble groundspeed = mapObject.get(UAVStateMessage.GROUNDSPEED).getAsDouble();\n\t\tdataMap.put(UAVStateMessage.GROUNDSPEED, Double.valueOf(groundspeed));\n\n\t\tBatteryStatus batteryStatus = deserializeBatteryStatus(mapObject, UAVStateMessage.BATTERYSTATUS);\n\t\tdataMap.put(UAVStateMessage.BATTERYSTATUS, batteryStatus);\n\n\t\t// TODO Auto-generated method stub\n\t\treturn dataMap;\n\t}\n\n\tprivate BatteryStatus deserializeBatteryStatus(JsonObject mapObject, String itemname) {\n\t\tJsonElement locationElem = mapObject.get(itemname);\n\t\tJsonObject locObject = locationElem.getAsJsonObject();\n\n\t\tdouble bcurrent = -1;\n\t\tif (locObject.has(\"current\")) {\n\t\t\ttry {\n\t\t\t\tJsonPrimitive level = locObject.getAsJsonPrimitive(\"current\");\n\t\t\t\tbcurrent = level.getAsDouble();\n\t\t\t} catch (ClassCastException e) {\n\t\t\t\tLOGGER.error(\"Current not a value\");\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\n\t\tdouble blevel = -1;\n\t\tif (locObject.has(\"level\")) {\n\t\t\ttry {\n\t\t\t\tJsonPrimitive level = locObject.getAsJsonPrimitive(\"level\");\n\t\t\t\tblevel = level.getAsDouble();\n\t\t\t} catch (ClassCastException e) {\n\t\t\t\tLOGGER.error(\"Level not a value\");\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\n\t\t}\n\n\t\tdouble bvoltage = -1;\n\t\tif (locObject.has(\"voltage\")) {\n\t\t\ttry {\n\t\t\t\tJsonPrimitive volt = locObject.getAsJsonPrimitive(\"voltage\");\n\t\t\t\tbvoltage = volt.getAsDouble();\n\t\t\t} catch (ClassCastException e) {\n\t\t\t\tLOGGER.error(\"Voltage not a value\");\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t\treturn new BatteryStatus(bcurrent, bvoltage, blevel);\n\t}\n\n\tprivate LlaCoordinate deserializeLLACoordinate(JsonObject mapObject, String itemname) {\n\t\tJsonElement locationElem = mapObject.get(itemname);\n\t\tJsonObject locObject = locationElem.getAsJsonObject();\n\n\t\tJsonPrimitive latitude = locObject.getAsJsonPrimitive(\"x\");\n\t\tJsonPrimitive longitude = locObject.getAsJsonPrimitive(\"y\");\n\t\tJsonPrimitive altitude = locObject.getAsJsonPrimitive(\"z\");\n\n\t\treturn new LlaCoordinate(latitude.getAsDouble(), longitude.getAsDouble(), altitude.getAsDouble());\n\n\t}\n\n\tprivate Vector3D deserializeVector3D(JsonObject mapObject, String itemname) {\n\t\tJsonElement locationElem = mapObject.get(itemname);\n\t\tJsonObject locObject = locationElem.getAsJsonObject();\n\n\t\tJsonPrimitive x = locObject.getAsJsonPrimitive(\"x\");\n\t\tJsonPrimitive y = locObject.getAsJsonPrimitive(\"y\");\n\t\tJsonPrimitive z = locObject.getAsJsonPrimitive(\"z\");\n\n\t\treturn new Vector3D(x.getAsDouble(), y.getAsDouble(), z.getAsDouble());\n\t}\n\n}\n"}, {"id": "AbstractFileTransmitServerService.java", "body": "package edu.nd.dronology.services.core.base;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\n\nimport edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.listener.IItemChangeListener;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Abstract base class for all services that can handle files.\n * \n * @author Michael Vierhauser \n *\n * @param <S>\n *          The service instance.\n * @param <T>\n *          The type of file that is supported.\n */\npublic abstract class AbstractFileTransmitServerService<S extends IFileTransmitServiceInstance<T>, T>\n\t\textends AbstractServerService<S> {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(AbstractFileTransmitServerService.class);\n\n\tpublic AbstractFileTransmitServerService() {\n\t\tsuper();\n\t}\n\n\tpublic byte[] requestFromServer(String id) throws DronologyServiceException {\n\t\treturn serviceInstance.requestFromServer(id);\n\t}\n\n\tpublic void transmitToServer(String id, byte[] content) throws DronologyServiceException {\n\t\tserviceInstance.transmitToServer(id, content);\n\t}\n\n\tpublic boolean addItemChangeListener(IItemChangeListener listener) {\n\t\treturn serviceInstance.addItemChangeListener(listener);\n\t}\n\n\tpublic boolean removeItemChangeListener(IItemChangeListener listener) {\n\t\treturn serviceInstance.removeItemChangeListener(listener);\n\t}\n\n\tpublic Collection<T> getItems() throws RemoteException {\n\t\treturn serviceInstance.getItems();\n\t}\n\t\n\tpublic T getItems(String id) throws RemoteException, DronologyServiceException {\n\t\treturn serviceInstance.getItem(id);\n\t}\n\n\tpublic T createItem() throws RemoteException, DronologyServiceException {\n\t\treturn serviceInstance.createItem();\n\t}\n\n\tpublic void deleteItem(String itemid) throws DronologyServiceException {\n\t\tserviceInstance.deleteItem(itemid);\n\n\t}\n\n}\n"}, {"id": "NVECSimulator.java", "body": "package edu.nd.dronology.core.simulator.nvecsimulator;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.coordinate.NVector;\nimport edu.nd.dronology.core.simulator.IFlightSimulator;\nimport edu.nd.dronology.core.simulator.simplesimulator.DroneVoltageSimulator;\nimport edu.nd.dronology.core.simulator.simplesimulator.FlightSimulator;\nimport edu.nd.dronology.core.vehicle.internal.VirtualDrone;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class NVECSimulator implements IFlightSimulator {\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(FlightSimulator.class);\n\tprivate VirtualDrone drone;\n\tprivate NVector currentPosition;\n\tprivate NVector targetPosition;\n\tprivate DroneVoltageSimulator voltageSimulator;\n\n\tpublic NVECSimulator(VirtualDrone drone) {\n\t\tthis.drone = drone;\n\t\tvoltageSimulator = new DroneVoltageSimulator();\n\t}\n\n\t@Override\n\tpublic boolean isDestinationReached(double distanceMovedPerTimeStep) {\n\t\treturn NvecInterpolator.move(currentPosition, targetPosition, distanceMovedPerTimeStep).equals(targetPosition);\n\t}\n\n\t@Override\n\tpublic boolean move(double i) {\n\t\tcurrentPosition = NvecInterpolator.move(currentPosition, targetPosition, i);\n\t\tdrone.setCoordinates(currentPosition.toLlaCoordinate());\n\t\tLOGGER.trace(\"Remaining Dinstance: \" + NVector.travelDistance(currentPosition, targetPosition));\n\t\treturn !currentPosition.equals(targetPosition);\n\t}\n\n\t@Override\n\tpublic void setFlightPath(LlaCoordinate currentPosition, LlaCoordinate targetCoordinates) {\n\t\tthis.currentPosition = currentPosition.toNVector();\n\t\tthis.targetPosition = targetCoordinates.toNVector();\n\n\t}\n\n\t@Override\n\tpublic void startBatteryDrain() {\n\t\tvoltageSimulator.startBatteryDrain();\n\t}\n\n\t@Override\n\tpublic void stopBatteryDrain() {\n\t\tvoltageSimulator.startBatteryDrain();\n\n\t}\n\n\t@Override\n\tpublic double getVoltage() {\n\t\treturn voltageSimulator.getVoltage();\n\t}\n\n\t@Override\n\tpublic void checkPoint() {\n\t\tvoltageSimulator.checkPoint();\n\n\t}\n\n}\n"}, {"id": "RiverSubsegment.java", "body": "package edu.nd.dronology.services.extensions.areamapping.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;\n\npublic class RiverSubsegment {\n\tprivate List<RiverBank> riverSubsegment;\n\t\n\tpublic RiverSubsegment() {\n\t\triverSubsegment = new ArrayList<>();\n\t}\n\t\n\tpublic RiverSubsegment(RiverBank bank1, RiverBank bank2) {\n\t\triverSubsegment = new ArrayList<>();\n\t\triverSubsegment.add(bank1);\n\t\triverSubsegment.add(bank2);\n\t}\n\t\n\tpublic void add(RiverBank riverBank) {\n\t\triverSubsegment.add(riverBank);\n\t}\n\t\n\tpublic List<RiverBank> get(){\n\t\treturn Collections.unmodifiableList(riverSubsegment);\n\t}\n\t\n\tpublic RiverBank get(int entry) {\n\t\treturn riverSubsegment.get(entry);\n\t}\n\t\n\tpublic void set(int index, RiverBank entry) {\n\t\triverSubsegment.set(index, entry);\n\t}\n\t\n\t\n}\n"}, {"id": "AMMetaInfo.java", "body": "package edu.nd.dronology.ui.vaadin.areamapping;\n\nimport java.io.File;\n\nimport com.vaadin.event.LayoutEvents.LayoutClickEvent;\nimport com.vaadin.event.LayoutEvents.LayoutClickListener;\nimport com.vaadin.server.FileResource;\nimport com.vaadin.server.VaadinService;\nimport com.vaadin.ui.Button;\nimport com.vaadin.ui.CheckBox;\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.HorizontalLayout;\nimport com.vaadin.ui.Label;\nimport com.vaadin.ui.TextField;\nimport com.vaadin.ui.UI;\nimport com.vaadin.ui.VerticalLayout;\nimport com.vaadin.ui.themes.ValoTheme;\n\nimport edu.nd.dronology.services.core.info.AreaMappingInfo;\nimport edu.nd.dronology.ui.vaadin.areamapping.windows.AMGenerateRouteDroneWindow;\nimport edu.nd.dronology.ui.vaadin.areamapping.windows.AMUnsavedChangesConfirmation.ChangeType;\n\n/**\n * Implements the top panel, which displays information about the name of the mapping and the number of coordinates on each side.\n * \n * @author Andrew Slavin\n *\n */\n\n\npublic class AMMetaInfo extends CustomComponent {\n\t/** \n\t * \n\t */\n\tprivate static final long serialVersionUID = -1112368712373412381L;\n\tprivate Label nameLabel;\n\tprivate Label sideANumLabel;\n\tprivate Label sideBNumLabel;\n\tprivate Label descriptionLabel;\n\tprivate Button generateRouteButton;\n\tprivate AreaMappingInfo mappingInfo;\n\tprivate int num0;\n\tprivate int num1;\n\t\n\tprivate HorizontalLayout allContent;\n\tprivate VerticalLayout leftSide;\n\tprivate VerticalLayout rightSide;\n\tprivate CheckBox autoZoomingCheckBox;\n\t\n\tprivate AMGenerateRouteDroneWindow generateRouteDroneWindow;\n\n\tpublic AMMetaInfo(AMMapComponent map) {\n\t\t\n\t\tsideANumLabel = new Label(\"\");\n\t\tsideBNumLabel = new Label(\"\");\n\t\tnameLabel = new Label(\"No Mapping Selected\");\n\n\t\t// The two labels are initialized separately so that they can be changed\n\t\t// independently later.\n\t\tHorizontalLayout labels = new HorizontalLayout();\n\t\tlabels.addComponents(nameLabel, sideANumLabel, sideBNumLabel);\n\n\t\tautoZoomingCheckBox = new CheckBox(\"Zoom to Route\");\n\t\tautoZoomingCheckBox.setValue(true);\n\n\t\tString basepath = VaadinService.getCurrent().getBaseDirectory().getAbsolutePath();\n\n\t\tFileResource editIcon = new FileResource(new File(basepath + \"/VAADIN/img/editButtonFull.png\"));\n\t\tButton editButton = new Button(\"Edit\");\n\t\teditButton.setIcon(editIcon);\n\t\teditButton.addStyleName(ValoTheme.BUTTON_ICON_ONLY);\n\n\t\tFileResource deleteIcon = new FileResource(new File(basepath + \"/VAADIN/img/deleteButtonFull.png\"));\n\t\tButton deleteButton = new Button(\"Delete\");\n\t\tdeleteButton.setIcon(deleteIcon);\n\t\tdeleteButton.addStyleName(ValoTheme.BUTTON_ICON_ONLY);\n\t\t\n\t\tgenerateRouteButton = new Button(\"Generate Route\");\n\t\tgenerateRouteButton.setWidth(\"150px\");\n\n\t\t// A layout is used to hold the description label so that a LayoutClickListener\n\t\t// can be added later.\n\t\tHorizontalLayout descriptionHolder = new HorizontalLayout();\n\t\tdescriptionLabel = new Label(\"\");\n\t\tdescriptionHolder.addComponent(descriptionLabel);\n\n\t\tHorizontalLayout buttons = new HorizontalLayout();\n\t\tbuttons.addComponents(generateRouteButton, editButton, deleteButton);\n\n\t\tHorizontalLayout checkboxes = new HorizontalLayout();\n\t\tcheckboxes.addComponents(autoZoomingCheckBox);\n\n\t\tleftSide = new VerticalLayout();\n\t\tleftSide.addComponents(labels, descriptionHolder);\n\n\t\trightSide = new VerticalLayout();\n\t\trightSide.addComponents(buttons, checkboxes);\n\n\t\t// \"leftSide\" includes the labels and description, while \"rightSide\" includes\n\t\t// the buttons and checkboxes.\n\t\tallContent = new HorizontalLayout();\n\t\tallContent.setStyleName(\"fr_route_meta_info\");\n\t\tallContent.addStyleName(\"has_route\");\n\t\t\n\t\t// only add left side when initialized, right side is added when a route is\n\t\t// selected\n\t\tallContent.addComponent(leftSide);\n\n\t\trightSide.addStyleName(\"route_meta_controls\");\n\t\tleftSide.addStyleName(\"route_meta_label_description\");\n\n\t\tTextField nameEditField = new TextField();\n\t\tTextField descriptionEditField = new TextField();\n\n\t\tnameEditField.setStyleName(\"name_edit_field\");\n\t\tdescriptionEditField.setStyleName(\"description_edit_field\");\n\t\tnameLabel.setStyleName(\"name_lable\");\n\t\tsideANumLabel.setStyleName(\"waypoint_num_lable\");\n\t\tsideBNumLabel.setStyleName(\"waypoint_num_lable\");\n\t\tdescriptionLabel.setStyleName(\"description_lable\");\n\n\t\t// Click listeners for the edit and delete buttons.\n\t\teditButton.addClickListener(e -> {\n\t\t\tmap.getEditSidesController().enterEditMode();\n\t\t});\n\t\t\n\t\t// prompt user to confirm that they want to delete the mapping\n\t\tdeleteButton.addClickListener(e -> {\n\t\t\tif (map.getMapUtilities().getSidesAreEditable() || map.getMapUtilities().getPrioritiesAreEditable()) {\n\t\t\t\tmap.getMainLayout().getUnsavedChangesConfirmation().showWindow(map.getMainLayout().getControls()\n\t\t\t\t\t\t.getInfoPanel().getHighlightedAMInfoBox().getAreaMappingInfo().getName(),\n\t\t\t\t\t\tChangeType.DELETE_MAPPING, e);\n\t\t\t} else {\n\t\t\t\tmap.getMainLayout().getDeleteMappingConfirmation().showWindow(\n\t\t\t\t\t\tmap.getMainLayout().getControls().getInfoPanel().getHighlightedAMInfoBox().getAreaMappingInfo(),\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t});\n\t\t\n\t\t// click listener for the generate route button\n\t\t// brings up a window to select drones\n\t\tgenerateRouteButton.addClickListener(e -> {\n\t\t\tgenerateRouteDroneWindow = new AMGenerateRouteDroneWindow(map);\n\t\t\tUI.getCurrent().addWindow(generateRouteDroneWindow);\n\t\t\tgenerateRouteDroneWindow.closeIfNoDrones();\n\t\t});\n\n\t\t// Double click allows user to edit label by turning it into a textbox.\n\t\tlabels.addLayoutClickListener(new LayoutClickListener() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void layoutClick(LayoutClickEvent event) {\n\t\t\t\tif (!map.getMapUtilities().getSidesAreEditable() && !map.getMapUtilities().getPrioritiesAreEditable())\n\t\t\t\t\treturn;\n\t\t\t\tif (event.getClickedComponent() == nameLabel) {\n\t\t\t\t\tif (event.isDoubleClick()) {\n\t\t\t\t\t\t// Change layout to accommodate for the textfield.\n\t\t\t\t\t\tallContent.removeAllComponents();\n\n\t\t\t\t\t\tHorizontalLayout nameArea = new HorizontalLayout();\n\t\t\t\t\t\tnameEditField.setValue(nameLabel.getValue());\n\t\t\t\t\t\tnameArea.addComponents(nameEditField, sideANumLabel, sideANumLabel);\n\n\t\t\t\t\t\tVerticalLayout textLayout = new VerticalLayout();\n\t\t\t\t\t\ttextLayout.addComponents(nameArea, descriptionHolder);\n\t\t\t\t\t\ttextLayout.addStyleName(\"mapping_meta_label_description\");\n\n\t\t\t\t\t\tallContent.addComponents(textLayout, rightSide);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t// Double click allows user to edit description by turning it into a textbox.\n\t\tdescriptionHolder.addLayoutClickListener(new LayoutClickListener() {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void layoutClick(LayoutClickEvent event) {\n\t\t\t\tif (!map.getMapUtilities().getSidesAreEditable() && !map.getMapUtilities().getPrioritiesAreEditable())\n\t\t\t\t\treturn;\n\t\t\t\tif (event.getClickedComponent() == descriptionLabel) {\n\t\t\t\t\tif (event.isDoubleClick()) {\n\t\t\t\t\t\t// Change layout to accommodate for the textfield.\n\t\t\t\t\t\tallContent.removeAllComponents();\n\t\t\t\t\t\tlabels.removeAllComponents();\n\n\t\t\t\t\t\tVerticalLayout textLayout = new VerticalLayout();\n\t\t\t\t\t\ttextLayout.addStyleName(\"mapping_meta_label_description\");\n\t\t\t\t\t\tlabels.addComponents(nameLabel, sideANumLabel, sideBNumLabel);\n\n\t\t\t\t\t\tdescriptionEditField.setValue(descriptionLabel.getValue());\n\t\t\t\t\t\ttextLayout.addComponents(labels, descriptionEditField);\n\t\t\t\t\t\tallContent.addComponents(textLayout, rightSide);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t// Textfield turns back into the correct label once the user clicks away.\n\t\tnameEditField.addBlurListener(e -> {\n\t\t\tnameLabel.setValue(nameEditField.getValue());\n\n\t\t\tlabels.removeAllComponents();\n\t\t\tlabels.addComponents(nameLabel, sideANumLabel, sideBNumLabel);\n\n\t\t\tleftSide.removeAllComponents();\n\t\t\tleftSide.addComponents(labels, descriptionHolder);\n\n\t\t\tallContent.removeAllComponents();\n\t\t\tallContent.addComponents(leftSide, rightSide);\n\n\t\t\trightSide.addStyleName(\"route_meta_controls\");\n\t\t});\n\t\t// Once the user clicks away from the description field, the correct label is\n\t\t// shown.\n\t\tdescriptionEditField.addBlurListener(e -> {\n\t\t\tdescriptionLabel.setValue(descriptionEditField.getValue());\n\n\t\t\tlabels.removeAllComponents();\n\t\t\tlabels.addComponents(nameLabel, sideANumLabel, sideBNumLabel);\n\n\t\t\tleftSide.removeAllComponents();\n\t\t\tleftSide.addComponents(labels, descriptionHolder);\n\n\t\t\tallContent.removeAllComponents();\n\t\t\tallContent.addComponents(leftSide, rightSide);\n\n\t\t\trightSide.addStyleName(\"route_meta_controls\");\n\t\t});\n\n\t\tsetCompositionRoot(allContent);\n\t}\n\n\tpublic String getMappingName() {\n\t\treturn nameLabel.getValue();\n\t}\n\n\tpublic void setMappingName(String name) {\n\t\tnameLabel.setValue(name);\n\t}\n\n\tpublic String getMappingDescription() {\n\t\treturn descriptionLabel.getValue();\n\t}\n\n\tpublic void setMappingDescription(String description) {\n\t\tdescriptionLabel.setValue(description);\n\t}\n\n\tpublic void showInfoForSelectedMapping(AreaMappingInfo info) {\n\t\tmappingInfo = info;\n\t\tnameLabel.setValue(info.getName());\n\t\tdescriptionLabel.setValue(info.getDescription());\n\t\tsetNumWaypoints(info.getCoordinates(0).size(), info.getCoordinates(1).size());\n\n\t\tallContent.addComponent(rightSide);\n\t}\n\n\tpublic void showInfoWhenNoMappingIsSelected() {\n\t\tnameLabel.setValue(\"No Mapping Selected\");\n\t\tdescriptionLabel.setValue(\"\");\n\t\tsideANumLabel.setValue(\"\");\n\t\tsideBNumLabel.setValue(\"\");\n\t\tallContent.removeComponent(rightSide);\n\t}\n\n\t// Ensures that the correct description of coordinates is shown.\n\tpublic void setNumWaypoints(int num0, int num1) {\n\t\tif (num0 == 1) {\n\t\t\tsideANumLabel.setValue(\"(\" + num0 + \" Side A coordinate)\");\n\t\t\tthis.num0 = num0;\n\t\t} else {\n\t\t\tsideANumLabel.setValue(\"(\" + num0 + \" Side A coordinates)\");\n\t\t\tthis.num0 = num0;\n\t\t}\n\t\tif (num1 == 1) {\n\t\t\tsideBNumLabel.setValue(\"(\" + num1 + \" Side B coordinate)\");\n\t\t\tthis.num1 = num1;\n\t\t} else {\n\t\t\tsideBNumLabel.setValue(\"(\" + num1 + \" Side B coordinates)\");\n\t\t\tthis.num1 = num1;\n\t\t}\n\t}\n\n\n\tpublic boolean isAutoZoomingChecked() {\n\t\treturn autoZoomingCheckBox.getValue() == true;\n\t}\n\t\n\tpublic AreaMappingInfo getMappingInfo() {\n\t\treturn mappingInfo;\n\t}\n\t\n\tpublic int getNum0() {\n\t\treturn num0;\n\t}\n\t\n\tpublic int getNum1() {\n\t\treturn num1;\n\t}\n\t\n}"}, {"id": "UAVStateMessage.java", "body": "package edu.nd.dronology.gstation.connector.messages;\n\nimport java.io.Serializable;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\n/**\n * State message received from the GCS for a specific UAV.\n * \n * @author Michael Vierhauser\n *\n */\npublic class UAVStateMessage extends AbstractUAVMessage<Object> implements Serializable {\n\n\tprivate static final long serialVersionUID = -5703232763831907307L;\n\tpublic static final String MESSAGE_TYPE = \"state\";\n\n\tpublic static final transient String LOCATION = \"location\";\n\tpublic static final transient String ATTITUDE = \"attitude\";\n\tpublic static final transient String VELOCITY = \"velocity\";\n\n\tpublic static final transient String MODE = \"mode\";\n\tpublic static final transient String STATUS = \"status\";\n\n\tpublic static final transient String ARMED = \"armed\";\n\tpublic static final transient String ARMABLE = \"armable\";\n\n\tpublic static final transient String GROUNDSPEED = \"groundspeed\";\n\tpublic static final transient String BATTERYSTATUS = \"batterystatus\";\n\n\tpublic enum DroneMode {\n\t\tGUIDED, INIT, LAND, RTL, POSHOLD, OF_LOITER, STABILIZE, AUTO, THROW, DRIFT, FLIP, AUTOTUNE, ALT_HOLD, BRAKE, LOITER, AVOID_ADSB, POSITION, CIRCLE, SPORT, ACRO;\n\t}\n\n\tpublic enum DroneStatus {\n\t\tSTANDBY, UNINIT, BOOT, CALIBRATING, ACTIVE, CRITICAL, EMERGENCY, POWEROFF, INIT;\n\t}\n\n\tpublic UAVStateMessage(String message, String groundstationid, String uavid) {\n\t\tsuper(message, groundstationid, uavid);\n\t}\n\n\tpublic LlaCoordinate getLocation() {\n\t\treturn (LlaCoordinate) data.get(LOCATION);\n\t}\n\n\tpublic Vector3D getAttitude() {\n\t\treturn (Vector3D) data.get(ATTITUDE);\n\t}\n\n\tpublic Vector3D getVelocity() {\n\t\treturn (Vector3D) data.get(VELOCITY);\n\t}\n\n\tpublic boolean isArmable() {\n\t\treturn (Boolean) data.get(ARMABLE);\n\t}\n\n\tpublic double getGroundspeed() {\n\t\treturn (Double) data.get(GROUNDSPEED);\n\t}\n\n\tpublic DroneStatus getStatus() {\n\t\treturn (DroneStatus) data.get(STATUS);\n\t}\n\n\tpublic boolean isArmed() {\n\t\treturn (Boolean) data.get(ARMED);\n\t}\n\n\tpublic DroneMode getMode() {\n\t\treturn (DroneMode) data.get(MODE);\n\t}\n\n\tpublic BatteryStatus getBatterystatus() {\n\t\treturn (BatteryStatus) data.get(BATTERYSTATUS);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"armed=\" + isArmed() + \"| mode \" + getMode() + \" | Coordinate[\"\n\t\t\t\t+ Double.toString(getLocation().getLatitude()) + \",\" + Double.toString(getLocation().getLongitude()) + \",\"\n\t\t\t\t+ Double.toString(getLocation().getAltitude()) + \"]\";\n\t}\n\n\tpublic static class BatteryStatus implements Serializable{\n\t\t/**\n\t\t * \n\t\t */\n\t\tprivate static final long serialVersionUID = -7752170927927875169L;\n\t\tprivate double current;\n\t\tprivate double voltage;\n\t\tprivate double level;\n\n\t\tpublic BatteryStatus(double current, double voltage, double level) {\n\t\t\tthis.current = current;\n\t\t\tthis.voltage = voltage;\n\t\t\tthis.level = level;\n\t\t}\n\n\t\tpublic double getBatteryLevel() {\n\t\t\treturn level;\n\t\t}\n\n\t\tpublic double getBatteryCurrent() {\n\t\t\treturn current;\n\t\t}\n\n\t\tpublic double getBatteryVoltage() {\n\t\t\treturn voltage;\n\t\t}\n\t}\n}\n"}, {"id": "Runner.java", "body": "package edu.nd.dronology.misc.scripts;\n\nimport java.net.MalformedURLException;\nimport java.rmi.Naming;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;\nimport edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;\nimport edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic class Runner {\n\n\tprivate static final String ADDRESS_SCHEME = \"rmi://%s:%s/Remote\";\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\n\t\t\tIRemoteManager manager = (IRemoteManager) Naming.lookup(String.format(ADDRESS_SCHEME, \"localhost\", 9898));\n\n\t\t\tIDroneSetupRemoteService service = (IDroneSetupRemoteService) manager.getService(IDroneSetupRemoteService.class);\n\n\t\t\tIFlightManagerRemoteService managerService = (IFlightManagerRemoteService) manager\n\t\t\t\t\t.getService(IFlightManagerRemoteService.class);\n\n\t\t\tIFlightRouteplanningRemoteService planningService = (IFlightRouteplanningRemoteService) manager\n\t\t\t\t\t.getService(IFlightRouteplanningRemoteService.class);\n\n\t\t\tList<FlightRouteInfo> allRoutes = new ArrayList<>(planningService.getItems());\n\t\t\t// int NUM_DRONES = 0;\n\t\t\t// for (int i = 0; i < NUM_DRONES; i++) {\n\t\t\t// double coordofset = (double) i / 10000;\n\t\t\t// LlaCoordinate coord = new LlaCoordinate((41.519400 + coordofset), -86.239927, 0);\n\t\t\t// DroneInitializationInfo dr = new DroneInitializationInfo(\"Sim-Drone\" + i, DroneMode.MODE_VIRTUAL,\n\t\t\t// \"IRIS+\", coord);\n\t\t\t//\n\t\t\t// service.initializeDrones(dr);\n\t\t\t// }\n\n\t\t\t// for (DroneStatus dr : service.getDrones().values()) {\n\t\t\t// FlightRouteInfo inf = getRandomRoute(allRoutes);\n\t\t\t//\n\t\t\t// managerService.planFlight(dr.getID(), \"randplan\", inf.getWaypoints());\n\t\t\t//\n\t\t\t// }\n\t\t\tFlightRouteInfo inf = allRoutes.remove(0);\n\t\t\tfor (IUAVProxy dr : service.getActiveUAVs()) {\n\n\t\t\t\tmanagerService.planFlight(dr.getID(), \"randplan\", inf.getWaypoints());\n\n\t\t\t}\n\n\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedURLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (NotBoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tstatic Random rand = new Random();\n\n\tprivate static FlightRouteInfo getRandomRoute(List<FlightRouteInfo> allRoutes) {\n\t\tint routeSize = allRoutes.size();\n\n\t\tint randomNumber = rand.nextInt(routeSize);\n\n\t\treturn allRoutes.get(randomNumber);\n\n\t}\n\n}\n"}, {"id": "AbstractDrone.java", "body": "package edu.nd.dronology.core.vehicle;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.exceptions.FlightZoneException;\nimport edu.nd.dronology.core.vehicle.proxy.UAVProxy;\nimport edu.nd.dronology.core.vehicle.proxy.UAVProxyManager;\nimport edu.nd.dronology.util.NullUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\nimport java.util.Observable;\n\n/**\n * Abstract Base class for both virtual and physical drones\n * \n * \n * @author Michael\n *\n */\npublic abstract class AbstractDrone extends Observable implements IDrone {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(AbstractDrone.class);\n\n\tprivate LlaCoordinate basePosition; // In current version drones always return to base at the end of their flights.\n\tprotected volatile LlaCoordinate currentPosition;\n\tprotected final String droneName;\n\tprotected UAVProxy droneStatus; // PHY\n\n\tprivate ManagedDrone mgdDrone;\n\n\tprotected AbstractDrone(String drnName) {\n\t\tNullUtil.checkNull(drnName);\n\t\tthis.droneName = drnName;\n\t\tcurrentPosition = null;\n\t\tdroneStatus = new UAVProxy(drnName, 0, 0, 0, 0.0, 0.0); // Not initialized yet //PHYS\n\t\tUAVProxyManager.getInstance().addDrone(droneStatus); // PHYS\n\t}\n\n\t@Override\n\tpublic void setCoordinates(double lat, double lon, double alt) { // For physical drone this must be set by reading position\n\t\tcurrentPosition = new LlaCoordinate(lat, lon, alt);\n\t\tdroneStatus.updateCoordinates(lat, lon, alt);\n\t}\n\n\t@Override\n\tpublic void setCoordinates(LlaCoordinate coordinate) { // For physical drone this must be set by reading position\n\t\tcurrentPosition = coordinate;\n\t\tdroneStatus.updateCoordinates(currentPosition.getLatitude(), currentPosition.getLongitude(),\n\t\t\t\tcurrentPosition.getAltitude());\n\t}\n\n\t@Override\n\tpublic double getLatitude() {\n\t\treturn currentPosition.getLatitude();\n\t}\n\n\t@Override\n\tpublic double getLongitude() {\n\t\treturn currentPosition.getLongitude();\n\t}\n\n\t@Override\n\tpublic double getAltitude() {\n\t\treturn currentPosition.getAltitude();\n\t}\n\n\t@Override\n\tpublic LlaCoordinate getCoordinates() {\n\t\treturn currentPosition;\n\t}\n\n\t@Override\n\tpublic String getDroneName() {\n\t\treturn droneName;\n\t}\n\n\t@Override\n\tpublic UAVProxy getDroneStatus() {\n\t\treturn droneStatus;\n\t}\n\n\t/**\n\t * Set base coordinates for the drone\n\t * \n\t * @param basePosition\n\t */\n\t@Override\n\tpublic void setBaseCoordinates(LlaCoordinate basePosition) {\n\n\t\tthis.basePosition = new LlaCoordinate(basePosition.getLatitude(), basePosition.getLongitude(),\n\t\t\t\tbasePosition.getAltitude());\n\t\tdroneStatus.setHomeLocation(basePosition);\n\t\tLOGGER.info(\"Base Coordinate of Drone '\" + droneName + \" set to '\" + basePosition.toString());\n\t}\n\n\t/**\n\t * Get unique base coordinates for the drone\n\t * \n\t * @return base coordinates\n\t */\n\t@Override\n\tpublic LlaCoordinate getBaseCoordinates() {\n\t\treturn basePosition;\n\t}\n\n\tpublic void setVelocity(double velocity) {\n\t\tdroneStatus.updateVelocity(velocity);\n\n\t}\n\n\tpublic void updateBatteryLevel(double batteryLevel) {\n\t\tdroneStatus.updateBatteryLevel(batteryLevel);\n\n\t}\n\n\tpublic void setUserControlled() {\n\t\ttry {\n\t\t\tmgdDrone.getFlightModeState().setModeToUserControlled();\n\t\t} catch (FlightZoneException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void setManagedDrone(ManagedDrone mgdDrone) {\n\t\tthis.mgdDrone = mgdDrone;\n\t}\n\n}\n\n"}, {"id": "MonitoringFrequencyAdaptor.java", "body": "package edu.nd.dronology.monitoring;\n//package edu.nd.dronology.gstation.connector.monitoring;\n//\n//import java.util.HashMap;\n//import java.util.List;\n//import java.util.Map;\n//import java.util.concurrent.ConcurrentHashMap;\n//import java.util.concurrent.atomic.AtomicBoolean;\n//\n//import com.google.common.util.concurrent.RateLimiter;\n//\n//import edu.nd.dronology.core.exceptions.DroneException;\n//import edu.nd.dronology.core.fleet.DroneFleetManager;\n//import edu.nd.dronology.core.vehicle.ManagedDrone;\n//import edu.nd.dronology.core.vehicle.commands.SetMonitoringFrequencyCommand;\n//import edu.nd.dronology.validation.trust.TrustManager;\n//import edu.nd.dronology.validation.util.BenchmarkLogger;\n//import edu.nd.dronology.validation.validation.MonitoringValidator;\n//import net.mv.logging.ILogger;\n//import net.mv.logging.LoggerProvider;\n//\n//public class MonitoringFrequencyAdaptor implements Runnable {\n//\n//\tRateLimiter limiter = RateLimiter.create(0.2);\n//\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(MonitoringFrequencyAdaptor.class);\n//\tprivate AtomicBoolean cont = new AtomicBoolean(true);\n//\tprivate Map<String, Double> frequencies = new ConcurrentHashMap<>();\n//\tprivate Map<String, Double> means = new HashMap<>();\n//\n//\tpublic MonitoringFrequencyAdaptor() {\n//\n//\t}\n//\n//\t@Override\n//\tpublic void run() {\n//\n//\t\twhile (cont.get()) {\n//\t\t\tlimiter.acquire();\n//\t\t\ttry {\n//\t\t\t\t// LOGGER.info(\"Recalculating monitoring frequencies...\");\n//\t\t\t\tfor (MonitoringValidator validator : UAVMonitoringManager.getInstance().getValidators()) {\n//\t\t\t\t\tString vid = validator.getUavId();\n//\t\t\t\t\tupdateMeanDistance(vid);\n//\t\t\t\t\tdouble currentReputation = TrustManager.getInstance().getReputationRating(vid);\n//\t\t\t\t\tdouble newFrequency = calculateFrequency(\n//\t\t\t\t\t\t\tmeans.get(vid) != null ? means.get(vid) : 1 / DISTANCE_FACTOR, currentReputation);\n//\t\t\t\t\tDouble oldFrequncy = frequencies.get(vid);\n//\t\t\t\t\tif (oldFrequncy == null || oldFrequncy != newFrequency) {\n//\t\t\t\t\t\tLOGGER.info(\"Updating monitoring frequncy for '\" + vid + \" from:\" + oldFrequncy + \" to: \"\n//\t\t\t\t\t\t\t\t+ newFrequency);\n//\t\t\t\t\t\tBenchmarkLogger.reportFrequency(vid, newFrequency);\n//\t\t\t\t\t\tfrequencies.put(vid, Double.valueOf(newFrequency));\n//\t\t\t\t\t\tupdateFrequency(vid, newFrequency);\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\n//\t\t\t} catch (Exception e) {\n//\t\t\t\tLOGGER.error(e);\n//\t\t\t}\n//\n//\t\t}\n//\t}\n//\n//\tprivate void updateMeanDistance(String vid) throws DroneException {\n//\t\tlong start = System.currentTimeMillis();\n//\t\tdouble dist = 0;\n//\t\tint count = 0;\n//\t\tManagedDrone drone = DroneFleetManager.getInstance().getRegisteredDrone(vid);\n//\t\tList<ManagedDrone> drns = DroneFleetManager.getInstance().getRegisteredDrones();\n//\t\tfor (ManagedDrone toCheck : drns) {\n//\t\t\tif (toCheck == drone) {\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\t\t\tif (true || toCheck.getFlightModeState().isFlying() || toCheck.getFlightModeState().isInAir()) {\n//\t\t\t\tdist += Math.abs(drone.getCoordinates().distance(toCheck.getCoordinates()));\n//\t\t\t}\n//\t\t\tcount++;\n//\t\t}\n//\t\tdouble mean = dist / (count - 1);\n//\t\tlong duration = System.currentTimeMillis() - start;\n//\n//\t\tmean = mean / Math.pow((Math.sqrt(ZONE_WIDHT) + Math.sqrt(ZONE_HEIGHT)), 2);\n//\t\t//LOGGER.info(\"Mean Distance: \" + mean + \"(\" + duration + \"ms)\");\n//\t\tif (mean > 0) {\n//\t\t\tmeans.put(drone.getDroneName(), mean);\n//\t\t}\n//\t}\n//\n//\tprivate void updateFrequency(String vid, double frequency) {\n//\t\tManagedDrone drone;\n//\t\ttry {\n//\t\t\tdrone = DroneFleetManager.getInstance().getRegisteredDrone(vid);\n//\t\t\tdrone.sendCommand(new SetMonitoringFrequencyCommand(vid, new Double(frequency).longValue() * 1000));\n//\t\t} catch (DroneException e) {\n//\t\t\tLOGGER.error(e);\n//\t\t}\n//\n//\t}\n//\n//\tprivate final double LOWER = 5;\n//\tprivate final double UPPER = 25;\n//\tprivate final double ZONE_WIDHT = 1000;\n//\tprivate final double ZONE_HEIGHT = 1000;\n//\tprivate final double DISTANCE_FACTOR = 2;\n//\n//\tprivate double calculateFrequency(double distance, double currentReputation) {\n//\n//\t\t// double frequency = (currentReputation / (distance * DISTANCE_FACTOR)) *\n//\t\t// (UPPER - LOWER) + LOWER;\n//\t\tdouble frequency = (currentReputation + (1 - distance) * distance) / (DISTANCE_FACTOR + 1) * (UPPER - LOWER)\n//\t\t\t\t+ LOWER;\n//\t\treturn Math.floor(frequency);\n//\t}\n//\n//}\n"}, {"id": "IRemoteConnectionServiceInstance.java", "body": "package edu.nd.dronology.services.instances.remote;\n\nimport java.util.Collection;\n\nimport edu.nd.dronology.services.core.api.IServiceInstance;\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\nimport edu.nd.dronology.services.core.remote.RemoteInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic interface IRemoteConnectionServiceInstance extends IServiceInstance{\n\n\tvoid register(RemoteInfo rInfo);\n\n\tCollection<RemoteInfo> getRegisteredRemoteClients();\n\n\tvoid unregister(RemoteInfo rInfo);\n\n\t//void logExternal(LogEventAdapter event);\n\n\tvoid addRemoteManager(IRemoteManager manager)  throws DronologyServiceException;\n\n}\n"}, {"id": "MissionPlanningPersistenceProvider.java", "body": "package edu.nd.dronology.services.core.persistence;\n\nimport edu.nd.dronology.services.core.items.IMissionPlan;\nimport edu.nd.dronology.services.core.persistence.internal.MissionPlanningXStreamPersistor;\n\n\n/**\n * Provider implementation for {@link IMissionPlan}.<br>\n * Details see {@link AbstractItemPersistenceProvider}\n * \n * @author Michael Vierhauser\n * \n */\npublic class MissionPlanningPersistenceProvider extends AbstractItemPersistenceProvider<IMissionPlan> {\n\n\tpublic MissionPlanningPersistenceProvider() {\n\t\tsuper();\n\t}\n\n\t@Override\n\tprotected void initPersistor() {\n\t\tPERSISTOR = new MissionPlanningXStreamPersistor();\n\n\t}\n\n\t@Override\n\tprotected void initPersistor(String type) {\n\t\tinitPersistor();\n\t}\n\n\tpublic static MissionPlanningPersistenceProvider getInstance() {\n\t\treturn new MissionPlanningPersistenceProvider();\n\t}\n\n}\n"}, {"id": "AFMapComponent.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport java.awt.MouseInfo;\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.vaadin.addon.leaflet.LMap;\nimport org.vaadin.addon.leaflet.LMarker;\nimport org.vaadin.addon.leaflet.LeafletMouseOverEvent;\nimport org.vaadin.addon.leaflet.LeafletMouseOverListener;\nimport org.vaadin.addon.leaflet.shared.Point;\n\nimport com.vaadin.ui.AbsoluteLayout;\nimport com.vaadin.ui.Component;\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.Label;\nimport com.vaadin.ui.Notification;\nimport com.vaadin.ui.PopupView;\nimport com.vaadin.ui.UI;\nimport com.vaadin.ui.VerticalLayout;\n\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.info.FlightPlanInfo;\nimport edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;\nimport edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;\nimport edu.nd.dronology.ui.vaadin.map.LeafletmapFactory;\nimport edu.nd.dronology.ui.vaadin.start.MyUI;\nimport edu.nd.dronology.ui.vaadin.utils.Configuration;\n\n/**\n * This is the map component for the Active Flights UI\n * \n * @author Jinghui Cheng\n * \n */\npublic class AFMapComponent extends CustomComponent { \n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate LMap leafletMap;\n\t// private ArrayList<LMarker> markers = new ArrayList<>();\n\tprivate Collection<IUAVProxy> drones;\n\tprivate Collection<FlightPlanInfo> currentFlights;\n\tprivate IDroneSetupRemoteService service;\n\tprivate IFlightManagerRemoteService flightManagerService;\n\tprivate BaseServiceProvider provider = MyUI.getProvider();\n\n\tprivate boolean follow = false;\n\tprivate boolean followZoom = false;\n\tprivate VerticalLayout content = new VerticalLayout();\n\tprivate AbsoluteLayout followLayout = new AbsoluteLayout();\n\tprivate AFFollowBar followBar;\n\tprivate AbsoluteLayout layout = new AbsoluteLayout();\n\tprivate PopupView popup;\n\tprivate PopupView dronePopup;\n\n\tprivate AFInfoPanel panel;\n \n\tprivate MapDrawingUtil drawingutil;\n\n\tpublic AFMapComponent(AFInfoPanel panel) {\n\t\tthis.panel = panel;\n\n\t\tthis.setWidth(\"100%\");\n\t\taddStyleName(\"map_component\");\n\t\taddStyleName(\"af_map_component\");\n\n\t\tleafletMap = LeafletmapFactory.generateMap();\n\t\tdrawingutil = new MapDrawingUtil(leafletMap, this);\n\n\t\ttry {\n\t\t\tservice = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);\n\t\t\tflightManagerService = (IFlightManagerRemoteService) provider.getRemoteManager()\n\t\t\t\t\t.getService(IFlightManagerRemoteService.class);\n\t\t\t// currentFlights = flightRouteService.getFlightDetails().getCurrentFlights();\n\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\te.printStackTrace();\n\t\t\tMyUI.setConnected(false);\n\t\t}\n\t\tList<String> temp = new ArrayList<>();\n\t\tdrawingutil.addDroneMarkers(\"\", temp);\n\t\tdrawingutil.addActiveFlightRoutes(\"\", temp);\n\t\tthis.setAverageCenter();\n\t\tdouble screenHeight = UI.getCurrent().getPage().getBrowserWindowHeight();\n\t\tint layoutHeight = (int) Math.rint(screenHeight * 0.9);\n\t\tlayout.setHeight(Integer.toString(layoutHeight) + \"px\");\n\t\tlayout.addComponent(leafletMap);\n\t\tpopup = createWayPointPopupView();\n\t\tdronePopup = createDronePopupView();\n\t\tlayout.addComponents(popup, dronePopup);\n\t\tcontent.addComponent(layout);\n\t\tsetCompositionRoot(content);\n\t}\n\n\tpublic void setCenter(double centerLat, double centerLon) {\n\t\tleafletMap.setCenter(centerLat, centerLon);\n\t}\n\n\tpublic void setZoomLevel(double zoomLevel) {\n\t\tleafletMap.setZoomLevel(zoomLevel);\n\t}\n\n\tpublic double getCenterLat() {\n\t\treturn leafletMap.getCenter().getLat();\n\t}\n\n\tpublic double getCenterLon() {\n\t\treturn leafletMap.getCenter().getLon();\n\t}\n\n\tpublic double getZoomLevel() {\n\t\treturn leafletMap.getZoomLevel();\n\t}\n \n\tpublic LMap getMapInstance() {\n\t\treturn leafletMap;\n\t}\n\n\t/**\n\t * This function sets the center and zoom of the map to include all drones and their flight routes. It finds the average latitude and longitude first. It then finds the point farthest from the\n\t * center and bases the zoom level off of that point.\n\t */\n\tpublic void setAverageCenter() {\n\t\tif (content.getComponentIndex(layout) == -1) { // if coming out of follow mode\n\t\t\tcontent.removeAllComponents();\n\t\t\tleafletMap.removeStyleName(\"af_leaflet_map_edit_mode\");\n\t\t\tcontent.addComponent(layout);\n\t\t}\n\t\tConfiguration configuration = Configuration.getInstance();\n\t\ttry {\n\t\t\tservice = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);\n\t\t\tdrones = service.getActiveUAVs();\n\t\t\tdouble avgLat = 0;\n\t\t\tdouble avgLon = 0;\n\t\t\tint numPoints = 0;\n\t\t\tfor (IUAVProxy e : drones) { // finding the average latitude and longitude of the drones and flight routes\n\t\t\t\tavgLat += e.getLatitude();\n\t\t\t\tavgLon += e.getLongitude();\n\t\t\t\tnumPoints++;\n\t\t\t}\n\t\t\tcurrentFlights = flightManagerService.getCurrentFlights();\n\t\t\tfor (FlightPlanInfo e : currentFlights) {\n\t\t\t\tList<Waypoint> coordinates = e.getWaypoints();\n\t\t\t\tfor (Waypoint coord : coordinates) {\n\t\t\t\t\tavgLat += coord.getCoordinate().getLatitude();\n\t\t\t\t\tavgLon += coord.getCoordinate().getLongitude();\n\t\t\t\t\tnumPoints++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tavgLat /= (numPoints * 1.0);\n\t\t\tavgLon /= (numPoints * 1.0);\n\t\t\tdouble farthestLat = 0;\n\t\t\tdouble farthestLon = 0; // finding the farthest point from the center\n\t\t\tfor (IUAVProxy e : drones) {\n\t\t\t\tif (Math.abs(e.getLatitude() - avgLat) > farthestLat) {\n\t\t\t\t\tfarthestLat = Math.abs(e.getLatitude() - avgLat);\n\t\t\t\t}\n\t\t\t\tif (Math.abs(e.getLongitude() - avgLon) > farthestLon) {\n\t\t\t\t\tfarthestLon = Math.abs(e.getLongitude() - avgLon);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (FlightPlanInfo e : currentFlights) {\n\t\t\t\tList<Waypoint> coordinates = e.getWaypoints();\n\t\t\t\tfor (Waypoint coord : coordinates) {\n\t\t\t\t\tif (Math.abs(coord.getCoordinate().getLatitude() - avgLat) > farthestLat) {\n\t\t\t\t\t\tfarthestLat = Math.abs(coord.getCoordinate().getLatitude() - avgLat);\n\t\t\t\t\t}\n\t\t\t\t\tif (Math.abs(coord.getCoordinate().getLongitude() - avgLon) > farthestLon) {\n\t\t\t\t\t\tfarthestLon = Math.abs(coord.getCoordinate().getLongitude() - avgLon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPoint point = new Point(avgLat, avgLon);\n\t\t\tdouble zoom;\n\t\t\tif (farthestLat == 0 && farthestLon == 0) {\n\t\t\t\tzoom = 14;\n\t\t\t} else { // sets the zoom based on the calculation of degrees on the map per zoom level\n\t\t\t\tzoom = Math.floor(Math.log10(180.0 / Math.max(farthestLat, farthestLon)) / Math.log10(2));\n\t\t\t}\n\t\t\tleafletMap.setCenter(point, zoom);\n\t\t} catch (RemoteException | DronologyServiceException e1) {\n\t\t\tMyUI.setConnected(false);\n\t\t\te1.printStackTrace();\n\t\t} \n\t\tif (drones.size() < 1) {\n\t\t\tPoint point = new Point(configuration.getMapCenterLat(), configuration.getMapCenterLon());\n\t\t\tdouble zoom = configuration.getMapDefaultZoom();\n\t\t\tleafletMap.setCenter(point, zoom);\n\t\t}\n\n\t}\n\n\t/**\n\t * @return follow is a boolean variable that is true when the map is following drones\n\t */\n\tpublic boolean getFollow() {\n\t\treturn this.follow;\n\t}\n\n\tpublic void setFollow(boolean follow) {\n\t\tthis.follow = follow;\n\t}\n\n\t/**\n\t * @return followZoom determines whether the map should zoom in on the drones in follow mode. Only happens once initially when the user clicks the button to follow the drones on the map.\n\t */\n\tpublic boolean getFollowZoom() {\n\t\treturn this.followZoom;\n\t}\n\n\tpublic void setFollowZoom(boolean followZoom) {\n\t\tthis.followZoom = followZoom;\n\t}\n\n\t/**\n\t * This function sets the center of the map as an average of the drones that it is following. This will constantly change as each drone flies.\n\t * \n\t * @param names\n\t *          The list of drone names that the map should be following\n\t */\n\tpublic void followDrones(List<String> names) {\n\t\tif (names.size() < 1) {\n\t\t\tthis.follow = false;\n\t\t\tif (content.getComponentIndex(layout) == -1) { // if not in follow mode\n\t\t\t\tcontent.removeAllComponents();\n\t\t\t\tleafletMap.removeStyleName(\"af_leaflet_map_edit_mode\");\n\t\t\t\tcontent.addComponent(layout);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (this.follow == false) {\n\t\t\tif (content.getComponentIndex(layout) == -1) { // if not in follow mode\n\t\t\t\tcontent.removeAllComponents();\n\t\t\t\tleafletMap.removeStyleName(\"af_leaflet_map_edit_mode\");\n\t\t\t\tcontent.addComponent(layout);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tservice = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);\n\t\t\tdrones = service.getActiveUAVs();\n\t\t\tdouble avgLat = 0; // finds the average latitude and longitude\n\t\t\tdouble avgLon = 0;\n\t\t\tint numPoints = 0;\n\t\t\tfor (IUAVProxy e : drones) {\n\t\t\t\tfor (String name : names) {\n\t\t\t\t\tif (e.getID().equals(name)) {\n\t\t\t\t\t\tavgLat += e.getLatitude();\n\t\t\t\t\t\tavgLon += e.getLongitude();\n\t\t\t\t\t\tnumPoints++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tavgLat /= (numPoints * 1.0);\n\t\t\tavgLon /= (numPoints * 1.0);\n\t\t\tdouble farthestLat = 0; // finds the farthest point from the center\n\t\t\tdouble farthestLon = 0;\n\t\t\tfor (IUAVProxy e : drones) {\n\t\t\t\tfor (String name : names) {\n\t\t\t\t\tif (e.getID().equals(name)) {\n\t\t\t\t\t\tif (Math.abs(e.getLatitude() - avgLat) > farthestLat) {\n\t\t\t\t\t\t\tfarthestLat = Math.abs(e.getLatitude() - avgLat);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Math.abs(e.getLongitude() - avgLon) > farthestLon) {\n\t\t\t\t\t\t\tfarthestLon = Math.abs(e.getLongitude() - avgLon);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tPoint point = new Point(avgLat, avgLon); \n\t\t\tif (this.followZoom) { // if the first time after the button click, set the zoom level to fit all drones\n\t\t\t\tdouble zoom;\n\t\t\t\tif (farthestLat == 0 && farthestLon == 0) {\n\t\t\t\t\tzoom = 17;\n\t\t\t\t} else {\n\t\t\t\t\tzoom = Math.floor(Math.log10(180.0 / Math.max(farthestLat, farthestLon)) / Math.log10(2));\n\t\t\t\t}\n\t\t\t\tleafletMap.setCenter(point, zoom);\n\t\t\t\tthis.followZoom = false;\n\t\t\t} else {\n\t\t\t\tleafletMap.setCenter(point);\n\t\t\t}\n\t\t\tif (content.getComponentIndex(layout) != -1) { // change the map layout to display the follow bar.\n\t\t\t\tleafletMap.addStyleName(\"af_leaflet_map_edit_mode\");\n\t\t\t\tfollowBar = new AFFollowBar(this, names);\n\t\t\t\tfollowLayout.addStyleName(\"af_mapabsolute_layout\");\n\t\t\t\tfollowBar.addStyleName(\"bring_front\");\n\t\t\t\tdouble screenHeight = UI.getCurrent().getPage().getBrowserWindowHeight();\n\t\t\t\tint layoutHeight = (int) Math.rint(screenHeight * 0.9);\n\t\t\t\tfollowLayout.setHeight(Integer.toString(layoutHeight) + \"px\");\n\t\t\t\tfollowLayout.addComponent(layout);\n\t\t\t\tfollowLayout.addComponent(followBar);\n\t\t\t\tcontent.removeAllComponents();\n\t\t\t\tcontent.addComponent(followLayout); \n\t\t\t} else {\n\t\t\t\tfollowBar.updateUAVList(names);\n\t\t\t}\n\t\t} catch (RemoteException | DronologyServiceException e1) {\n\t\t\tMyUI.setConnected(false);\n\t\t\te1.printStackTrace();\n\t\t}\n\t}\n\n\t/**\n\t * this is a listener that displays an AFInfoBox in a popup over the drone that was just hovered over\n\t * \n\t * @author Patrick Falvey\n\t *\n\t */\n\tprivate class DroneMouseListener implements LeafletMouseOverListener {\n\n\t\t@Override\n\t\tpublic void onMouseOver(LeafletMouseOverEvent event) {\n\t\t\ttry {\n\t\t\t\tdrones = service.getActiveUAVs();\n\t\t\t} catch (RemoteException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t\tdronePopup.setVisible(false);\n\t\t\tdronePopup.setPopupVisible(false);\n\t\t\tLMarker leafletMarker = (LMarker) event.getSource();\n\n\t\t\tVerticalLayout popupContent = (VerticalLayout) dronePopup.getContent().getPopupComponent();\n\t\t\tpopupContent.removeAllComponents();\n\t\t\tfor (IUAVProxy e : drones) { // change the popup content to display the right AFInfoBox\n\t\t\t\tif (e.getID().equals(leafletMarker.getId())) {\n\t\t\t\t\tUAVStatusWrapper status = new UAVStatusWrapper(e);\n\t\t\t\t\tAFInfoBox box = new AFInfoBox(false, status, false);\n\t\t\t\t\tbox.createContents();\n\t\t\t\t\tbox.setBoxVisible(false);\n\t\t\t\t\tVerticalLayout boxes = panel.getBoxes();\n\t\t\t\t\tint numUAVs = panel.getNumUAVS();\n\t\t\t\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\t\t\t\tAFInfoBox panelBox = (AFInfoBox) boxes.getComponent(i);\n\t\t\t\t\t\tif (panelBox.getName().equals(box.getName())) { // get the updated information from the AFInfoPanel\n\t\t\t\t\t\t\tbox.setIsChecked(panelBox.getIsChecked());\n\t\t\t\t\t\t\tbox.setHoverInPlace(panelBox.getHoverInPlace());\n\t\t\t\t\t\t\tbox.update(status);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbox.getRouteButton().addClickListener(click -> {\n\t\t\t\t\t\tdronePopup.setPopupVisible(false);\n\t\t\t\t\t});\n\t\t\t\t\tbox.getHomeButton().addClickListener(click -> {\n\t\t\t\t\t\tdronePopup.setPopupVisible(false);\n\t\t\t\t\t});\n\t\t\t\t\tbox.getHoverSwitch().addValueChangeListener(click -> {\n\t\t\t\t\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\t\t\t\t\tAFInfoBox panelBox = (AFInfoBox) boxes.getComponent(i);\n\t\t\t\t\t\t\tif (panelBox.getName().equals(box.getName())) {\n\t\t\t\t\t\t\t\tpanelBox.setHoverInPlace(box.getHoverInPlace());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbox.getCheckBox().addValueChangeListener(click -> { // if checkbox clicked in popup, it will change in AFInfoPanel\n\t\t\t\t\t\tif (box.getCheckBox().getValue()) {\n\t\t\t\t\t\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\t\t\t\t\t\tAFInfoBox panelBox = (AFInfoBox) boxes.getComponent(i);\n\t\t\t\t\t\t\t\tif (panelBox.getName().equals(box.getName())) {\n\t\t\t\t\t\t\t\t\tpanelBox.setIsChecked(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\t\t\t\t\t\tAFInfoBox panelBox = (AFInfoBox) boxes.getComponent(i);\n\t\t\t\t\t\t\t\tif (panelBox.getName().equals(box.getName())) {\n\t\t\t\t\t\t\t\t\tpanelBox.setIsChecked(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tpopupContent.addComponent(box);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * find the location on the screen to display the popup. Takes the absolute position of the mouse and converts that to the relative position of the mouse on the map. Uses the map dimensions and\n\t\t\t * the map position within the layout\n\t\t\t */\n\t\t\tdouble mapWidth = UI.getCurrent().getPage().getBrowserWindowWidth() - 366.0;\n\t\t\tdouble mapHeight = UI.getCurrent().getPage().getBrowserWindowHeight() * 0.9;\n\n\t\t\tdouble xDegreeDifference = -(leafletMap.getCenter().getLon() - leafletMarker.getPoint().getLon());\n\t\t\tdouble yDegreeDifference = leafletMap.getCenter().getLat() - leafletMarker.getPoint().getLat();\n\t\t\tdouble degreePerZoom = (360.0 / (Math.pow(2, leafletMap.getZoomLevel())));\n\t\t\tdouble degreePerPixel = degreePerZoom / mapWidth;\n\t\t\tdouble xPixelDifference = (xDegreeDifference / degreePerPixel) / 3.0;\n\t\t\tdouble yPixelDifference = (yDegreeDifference / degreePerPixel) / 3.0;\n\n\t\t\txPixelDifference = xPixelDifference * 0.55;\n\n\t\t\tdouble pixelsToLeftBorder = (mapWidth / 2.0) + xPixelDifference;\n\t\t\tdouble pixelsToTopBorder = (mapHeight / 2.0) + yPixelDifference;\n\t\t\tdouble mouseX = MouseInfo.getPointerInfo().getLocation().getX();\n\t\t\tdouble mouseY = MouseInfo.getPointerInfo().getLocation().getY();\n\t\t\tdouble mapTopLeftX = mouseX - pixelsToLeftBorder;\n\t\t\tdouble mapTopLeftY = mouseY - pixelsToTopBorder;\n\n\t\t\tdouble adjustedXLocation = mouseX - mapTopLeftX;\n\t\t\tdouble adjustedYLocation = mouseY - mapTopLeftY;\n\n\t\t\tlayout.addComponent(dronePopup, \"top:\" + String.valueOf((int) adjustedYLocation) + \"px;left:\"\n\t\t\t\t\t+ String.valueOf((int) adjustedXLocation) + \"px\");\n\n\t\t\tdronePopup.setVisible(true);\n\t\t\tdronePopup.setPopupVisible(true);\n\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @return returns the waypoint popup\n\t */\n\tpublic PopupView createWayPointPopupView() {\n\t\tVerticalLayout popupContent = new VerticalLayout();\n\t\tpopupContent.removeAllComponents();\n\n\t\tLabel latitudeLabel = new Label();\n\t\tlatitudeLabel.setId(\"latitude\");\n\n\t\tLabel longitudeLabel = new Label();\n\t\tlongitudeLabel.setId(\"longitude\");\n\n\t\tLabel altitudeLabel = new Label();\n\t\taltitudeLabel.setId(\"altitude\");\n\n\t\tLabel transitSpeedLabel = new Label();\n\t\ttransitSpeedLabel.setId(\"transitSpeed\");\n\n\t\tpopupContent.addComponent(latitudeLabel);\n\t\tpopupContent.addComponent(longitudeLabel);\n\t\tpopupContent.addComponent(altitudeLabel);\n\t\tpopupContent.addComponent(transitSpeedLabel);\n\n\t\tPopupView popup = new PopupView(null, popupContent);\n\n\t\tpopup.addStyleName(\"bring_front\");\n\t\tpopup.setVisible(false);\n\t\tpopup.setPopupVisible(false);\n\n\t\treturn popup;\n\t}\n\n\t/**\n\t * \n\t * @return returns the drone popup\n\t */\n\tpublic PopupView createDronePopupView() {\n\t\tVerticalLayout popupContent = new VerticalLayout();\n\t\tpopupContent.removeAllComponents();\n\n\t\tpopupContent.addComponent(new Label(\"Drone Information\"));\n\t\tPopupView popup = new PopupView(null, popupContent);\n\n\t\tpopup.addStyleName(\"bring_front\");\n\t\tpopup.setVisible(false);\n\t\tpopup.setPopupVisible(false);\n\t\treturn popup;\n\t}\n\n\t/**\n\t * This listener displays a popup of information about a certain waypoint. Virtually the same listener used in the flight routes UI.\n\t * \n\t * @author Patrick Falvey\n\t *\n\t */\n\tpublic class WaypointMouseListener implements LeafletMouseOverListener {\n\n\t\t@Override\n\t\tpublic void onMouseOver(LeafletMouseOverEvent event) {\n\n\t\t\tpopup.setVisible(false);\n\t\t\tpopup.setPopupVisible(false);\n\t\t\tLMarker leafletMarker = (LMarker) event.getSource();\n\n\t\t\tVerticalLayout popupContent = (VerticalLayout) popup.getContent().getPopupComponent();\n\t\t\tIterator<Component> it = popupContent.iterator(); // iterates through the popup content and updates the waypoint information\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tComponent c = it.next();\n\t\t\t\ttry {\n\t\t\t\t\tcurrentFlights = flightManagerService.getCurrentFlights();\n\t\t\t\t\tfor (FlightPlanInfo e : currentFlights) {\n\t\t\t\t\t\tList<Waypoint> coordinates = e.getWaypoints();\n\t\t\t\t\t\tfor (Waypoint coord : coordinates) {\n\t\t\t\t\t\t\tif (coord.getCoordinate().getLatitude() == leafletMarker.getPoint().getLat()\n\t\t\t\t\t\t\t\t\t&& coord.getCoordinate().getLongitude() == leafletMarker.getPoint().getLon()) {\n\t\t\t\t\t\t\t\tif (c.getId() != null && c.getId().equals(\"latitude\")) {\n\t\t\t\t\t\t\t\t\tLabel l = (Label) c;\n\t\t\t\t\t\t\t\t\tl.setValue(\"Latitude: \" + coord.getCoordinate().getLatitude());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (c.getId() != null && c.getId().equals(\"longitude\")) {\n\t\t\t\t\t\t\t\t\tLabel l = (Label) c;\n\t\t\t\t\t\t\t\t\tl.setValue(\"Longitude: \" + coord.getCoordinate().getLongitude());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (c.getId() != null && c.getId().equals(\"altitude\")) {\n\t\t\t\t\t\t\t\t\tLabel l = (Label) c;\n\t\t\t\t\t\t\t\t\tl.setValue(\"Altitude: \" + coord.getCoordinate().getAltitude());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (c.getId() != null && c.getId().equals(\"transitSpeed\")) {\n\t\t\t\t\t\t\t\t\tLabel l = (Label) c;\n\t\t\t\t\t\t\t\t\tl.setValue(\"Transit Speed: \" + coord.getApproachingspeed());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (RemoteException e) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tNotification.show(\"Reconnecting...\");\n\t\t\t\t\t\tservice = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);\n\t\t\t\t\t\tflightManagerService = (IFlightManagerRemoteService) provider.getRemoteManager()\n\t\t\t\t\t\t\t\t.getService(IFlightManagerRemoteService.class);\n\t\t\t\t\t} catch (RemoteException | DronologyServiceException e1) {\n\t\t\t\t\t\tMyUI.setConnected(false);\n\t\t\t\t\t\tNotification.show(\"Reconnecting...\");\n\t\t\t\t\t}\n\t\t\t\t\tNotification.show(\"Reconnecting...\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * find the location on the screen to display the popup. Takes the absolute position of the mouse and converts that to the relative position of the mouse on the map. Uses the map dimensions and\n\t\t\t * the map position within the layout\n\t\t\t */\n\t\t\tdouble mapWidth = UI.getCurrent().getPage().getBrowserWindowWidth() - 366.0;\n\t\t\tdouble mapHeight = UI.getCurrent().getPage().getBrowserWindowHeight() * 0.9;\n\n\t\t\tdouble xDegreeDifference = -(leafletMap.getCenter().getLon() - leafletMarker.getPoint().getLon());\n\t\t\tdouble yDegreeDifference = leafletMap.getCenter().getLat() - leafletMarker.getPoint().getLat();\n\t\t\tdouble degreePerZoom = (360.0 / (Math.pow(2, leafletMap.getZoomLevel())));\n\t\t\tdouble degreePerPixel = degreePerZoom / mapWidth;\n\t\t\tdouble xPixelDifference = (xDegreeDifference / degreePerPixel) / 3.0;\n\t\t\tdouble yPixelDifference = (yDegreeDifference / degreePerPixel) / 3.0;\n\n\t\t\txPixelDifference = xPixelDifference * 0.55;\n\t\t\tyPixelDifference = yPixelDifference * 0.6;\n\n\t\t\tdouble pixelsToLeftBorder = (mapWidth / 2.0) + xPixelDifference;\n\t\t\tdouble pixelsToTopBorder = (mapHeight / 2.0) + yPixelDifference;\n\t\t\tdouble mouseX = MouseInfo.getPointerInfo().getLocation().getX();\n\t\t\tdouble mouseY = MouseInfo.getPointerInfo().getLocation().getY();\n\t\t\tdouble mapTopLeftX = mouseX - pixelsToLeftBorder;\n\t\t\tdouble mapTopLeftY = mouseY - pixelsToTopBorder;\n\n\t\t\tdouble adjustedXLocation = mouseX - mapTopLeftX;\n\t\t\tdouble adjustedYLocation = mouseY - mapTopLeftY;\n\n\t\t\tlayout.addComponent(popup, \"top:\" + String.valueOf((int) adjustedYLocation) + \"px;left:\"\n\t\t\t\t\t+ String.valueOf((int) adjustedXLocation) + \"px\");\n\n\t\t\tpopup.setVisible(true);\n\t\t\tpopup.setPopupVisible(true);\n\t\t}\n\t}\n\n\tpublic LeafletMouseOverListener getWaypointListener() {\n\t\treturn new WaypointMouseListener();\n\t}\n\n\tpublic LeafletMouseOverListener getDroneListener() { \n\t\treturn new DroneMouseListener();\n\t} \n\n\tpublic void refresh(String focused, List<String> checkedNames) {\n\t\tdrawingutil.updateDroneMarkers(focused, checkedNames); \n\t\tdrawingutil.updateActiveFlightRoutes(focused, checkedNames);\n\t}\n\n}"}, {"id": "DronologySeriviceListener.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.service.internal;\n\nimport edu.nd.dronology.core.status.IDronologyChangeListener;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic class DronologySeriviceListener implements IDronologyChangeListener {\n\n\t@Override\n\tpublic void notifyUAVRemoved(String uavid) {\n\t\ttry {\n\t\t\tMissionPlanningService.getInstance().removeUAV(uavid);\n\t\t} catch (DronologyServiceException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void notifyGCSShutdown(String groundstationid) {\n\t\ttry {\n\t\t\tMissionPlanningService.getInstance().cancelMission();\n\t\t} catch (DronologyServiceException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n}\n"}, {"id": "FlightManagerServiceRemoteFacade.java", "body": "package edu.nd.dronology.services.facades;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\nimport java.util.List;\n\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.services.core.info.FlightInfo;\nimport edu.nd.dronology.services.core.info.FlightPlanInfo;\nimport edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.instances.flightmanager.FlightManagerService;\nimport edu.nd.dronology.services.remote.AbstractRemoteFacade;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Remote facade for handling UAV fligths<br>\n * Allows assigning flight plans to UAVs <br>\n * Allows sending flight related commands to UAVs (take-off, return to home...).\n * \n * \n * @author Michael Vierhauser\n *\n */\npublic class FlightManagerServiceRemoteFacade  extends AbstractRemoteFacade implements IFlightManagerRemoteService {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -4580658378477037955L;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(FlightManagerServiceRemoteFacade.class);\n\tprivate static volatile FlightManagerServiceRemoteFacade INSTANCE;\n\n\tprotected FlightManagerServiceRemoteFacade() throws RemoteException {\n\t\tsuper(FlightManagerService.getInstance());\n\t}\n\n\tpublic static IFlightManagerRemoteService getInstance() throws RemoteException {\n\t\tif (INSTANCE == null) {\n\t\t\ttry {\n\t\t\t\tsynchronized (FlightManagerServiceRemoteFacade.class) {\n\t\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\t\tINSTANCE = new FlightManagerServiceRemoteFacade();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} catch (RemoteException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tpublic FlightInfo getFlightInfo(String uavId) throws RemoteException, Exception {\n\t\treturn FlightManagerService.getInstance().getFlightInfo(uavId);\n\t}\n\n\t@Override\n\tpublic void planFlight(String uavid, String planName, List<Waypoint> waypoints) throws Exception {\n\t\tFlightManagerService.getInstance().planFlight(uavid, planName, waypoints);\n\n\t}\n\n\t@Override\n\tpublic void planFlight(String planName, List<Waypoint> waypoints) throws Exception {\n\t\tFlightManagerService.getInstance().planFlight(planName, waypoints);\n\n\t}\n\n\t@Override\n\tpublic void returnToHome(String uavid) throws RemoteException, Exception {\n\t\tFlightManagerService.getInstance().returnToHome(uavid);\n\n\t}\n\n\t@Override\n\tpublic void pauseFlight(String uavid) throws RemoteException, Exception {\n\t\tFlightManagerService.getInstance().pauseFlight(uavid);\n\n\t}\n\n\t@Override\n\tpublic Collection<FlightPlanInfo> getCurrentFlights() throws RemoteException {\n\t\treturn FlightManagerService.getInstance().getCurrentFlights();\n\t}\n\n\t@Override\n\tpublic void cancelPendingFlights(String uavid) throws RemoteException, Exception {\n\t\tFlightManagerService.getInstance().cancelPendingFlights(uavid);\n\t}\n\n\t@Override\n\tpublic void takeoff(String uavid, double altitude) throws RemoteException, DronologyServiceException {\n\t\tFlightManagerService.getInstance().takeoff(uavid, altitude);\n\n\t}\n\n}"}, {"id": "IUAVRegistrationRemoteService.java", "body": "package edu.nd.dronology.services.core.remote;\n\nimport edu.nd.dronology.services.core.info.UAVRegistrationInfo;\n\npublic interface IUAVRegistrationRemoteService extends IRemoteableService, IFileTransmitRemoteService<UAVRegistrationInfo> {\n\n\t\n\t\n}\n"}, {"id": "StopEveryoneWaypoint.java", "body": "package edu.nd.dronology.core.collisionavoidance.strategy;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand;\n\npublic class StopEveryoneWaypoint extends StopEveryone {\n\n    public static final double STOP_SPEED = 2.0;\n\n    public StopEveryoneWaypoint(double threshold) {\n        super(threshold);\n    }\n\n    @Override\n    protected void onStopTrigger(DroneSnapshot drone) {\n        drone.getCommands().clear();\n        drone.getCommands().add(new WaypointCommand(drone.getPosition(), STOP_SPEED));\n    }\n\n}"}, {"id": "GetNameMessage.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal.message;\n\nimport java.util.concurrent.SynchronousQueue;\n\npublic class GetNameMessage extends AbstractMessage {\n    public final SynchronousQueue<String> returnBox = new SynchronousQueue<>();\n}\n"}, {"id": "FlightRouteXStreamPersistor.java", "body": "package edu.nd.dronology.services.core.persistence.internal;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.nio.charset.Charset;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport com.thoughtworks.xstream.XStream;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\n\nimport edu.nd.dronology.services.core.items.IFlightRoute;\nimport edu.nd.dronology.services.core.persistence.DronologyPersistenceUtil;\nimport edu.nd.dronology.services.core.persistence.IPersistenceManager;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class FlightRouteXStreamPersistor implements IPersistenceManager<IFlightRoute> {\n\n\tprivate static final XStream xstream = new XStream(new XppDriver());\n\tprivate static ILogger LOGGER = LoggerProvider.getLogger(FlightRouteXStreamPersistor.class);\n\n\tstatic final boolean useCompression = false;\n\n\t@Override\n\tpublic IFlightRoute open(InputStream fin) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t\t// xstream.setMode(XStream.);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\n\t\tif (useCompression) {\n\t\t\treturn loadedCompressedStream(fin);\n\t\t} else {\n\t\t\treturn loadUncompressedStream(fin);\n\t\t}\n\t}\n\n\tprivate IFlightRoute loadUncompressedStream(InputStream fin) throws PersistenceException {\n\t\ttry {\n\t\t\tInputStreamReader reader = new InputStreamReader(new BufferedInputStream(fin), Charset.forName(\"UTF-8\"));\n\t\t\tObject model = xstream.fromXML(reader);\n\t\t\treturn (IFlightRoute) model;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (fin != null) {\n\t\t\t\t\tfin.close();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate IFlightRoute loadedCompressedStream(InputStream fin) throws PersistenceException {\n\t\tInputStream zIn = null;\n\t\ttry {\n\t\t\tzIn = new GZIPInputStream(fin);\n\t\t\tObject model = xstream.fromXML(new BufferedReader(new InputStreamReader(zIn, \"UTF-8\")));\n\n\t\t\treturn (IFlightRoute) model;\n\t\t} catch (IOException e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (zIn != null) {\n\t\t\t\t\tzIn.close();\n\t\t\t\t}\n\t\t\t\tif (fin != null) {\n\t\t\t\t\tfin.close();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean save(IFlightRoute o, OutputStream fout) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t\t// xstream.setMode(XStream.ID_REFERENCES);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\t\t// xstream.addImplicitMap(ImplMEEvent.class, \"relatedEvents\", ImplMEEvent.class,\n\t\t// \"relatedEvents\");\n\n\t\tif (useCompression) {\n\t\t\treturn saveCompressedStream(o, fout);\n\t\t} else {\n\t\t\treturn saveUncompressedStream(o, fout);\n\t\t}\n\n\t}\n\t\n\tpublic boolean save(IFlightRoute o, OutputStream fout,boolean closestream) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t\t// xstream.setMode(XStream.ID_REFERENCES);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\t\t// xstream.addImplicitMap(ImplMEEvent.class, \"relatedEvents\", ImplMEEvent.class,\n\t\t// \"relatedEvents\");\n\n\t\tif (useCompression) {\n\t\t\treturn saveCompressedStream(o, fout);\n\t\t} else {\n\t\t\treturn saveUncompressedStream(o, fout,closestream);\n\t\t}\n\n\t}\n\n\tprivate boolean saveUncompressedStream(IFlightRoute o, OutputStream fout) throws PersistenceException {\n\t\tOutputStreamWriter writer = null;\n\t\ttry {\n\t\t\twriter = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(\"UTF-8\"));\n\t\t\txstream.toXML(o, writer);\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (writer != null) {\n\t\t\t\t\twriter.close();\n\t\t\t\t}\n\t\t\t\tif (fout != null) {\n\t\t\t\t\tfout.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean saveUncompressedStream(IFlightRoute o, OutputStream fout, boolean closestream)\n\t\t\tthrows PersistenceException {\n\t\tOutputStreamWriter writer = null;\n\t\ttry {\n\t\t\twriter = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(\"UTF-8\"));\n\t\t\txstream.toXML(o, writer);\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (writer != null && closestream) {\n\t\t\t\t\twriter.close();\n\t\t\t\t}\n\t\t\t\tif (fout != null && closestream) {\n\t\t\t\t\tfout.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean saveCompressedStream(IFlightRoute o, OutputStream fout) throws PersistenceException {\n\t\ttry {\n\t\t\tGZIPOutputStream zOut = new GZIPOutputStream(fout);\n\t\t\txstream.toXML(o, new BufferedWriter(new OutputStreamWriter(zOut, \"UTF-8\")));\n\n\t\t\tzOut.close();\n\t\t\tfout.close();\n\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t}\n\t}\n\n}\n"}, {"id": "AFFollowBar.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport java.util.List;\n\nimport com.vaadin.ui.Button;\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.HorizontalLayout;\nimport com.vaadin.ui.Label;\n\n/**\n * This is the bar that indicates when the active flights UI is in follow mode\n * \n * @author Patrick Falvey\n * \n */\npublic class AFFollowBar extends CustomComponent{\n\n\tprivate static final long serialVersionUID = 2389713576038720628L;\n\tprivate HorizontalLayout totalLayout = new HorizontalLayout();\n\tprivate Button stopFollowingButton = new Button(\"Stop Following\");\n\t \n\tprivate Label textLabel = new Label(\"Following UAV(s): \");\n\tprivate Label smallText = new Label();\n\t\n\tprivate String UAVNames;\n\t \n\tpublic AFFollowBar(AFMapComponent map, List<String> uavs) {\n\t\tUAVNames = \"\";\n\t\tfor (int i = 0; i < uavs.size() - 1; i++){\n\t\t\tUAVNames = UAVNames + uavs.get(i) + \", \";\n\t\t}\n\t\tUAVNames = UAVNames + uavs.get(uavs.size() - 1);\n\t\tsmallText.setValue(UAVNames);\n\t\tsetStyleName(\"af_follow_bar\");\n\t\ttextLabel.setStyleName(\"large_text\");\n\t\tsmallText.setStyleName(\"small_text\");\n\t\t\n\t\tstopFollowingButton.setHeight(\"25px\");\n\t\ttotalLayout.addComponents(textLabel, smallText, stopFollowingButton);\n\t\tsetCompositionRoot(totalLayout);\n\t\t\n\t\tstopFollowingButton.addClickListener(e->{\n\t\t\tmap.setAverageCenter();\n\t\t\tmap.setFollow(false);\n\t\t});\n\n\t}\n\t\n\tpublic Button getStopFollowingButton(){\n\t\treturn stopFollowingButton;\n\t}\n\t\n\tpublic void updateUAVList(List<String> uavs){\n\t\tUAVNames = \"\";\n\t\tfor (int i = 0; i < uavs.size() - 1; i++){\n\t\t\tUAVNames = UAVNames + uavs.get(i) + \", \";\n\t\t}\n\t\tUAVNames = UAVNames + uavs.get(uavs.size() - 1);\n\t\tsmallText.setValue(UAVNames);\n\t}\n\t\n\t\n\t\n}"}, {"id": "FlightRoute.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.UUID;\n\nimport edu.nd.dronology.core.Discuss;\nimport edu.nd.dronology.core.DronologyConstants;\nimport edu.nd.dronology.core.util.Waypoint;\n\n/**\n * \n * Implementation of a flight route, containing a series of waypoints and additional meta-data.\n * \n * @author Michael Vierhauser\n *\n */\npublic class FlightRoute implements IFlightRoute, Serializable {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -3151158691427417882L;\n\tprivate String name;\n\tprivate String id;\n\tprivate String category = \"Default\";\n\tprivate LinkedList<Waypoint> waypoints;\n\tprivate double takeoffaltitude = DronologyConstants.TAKE_OFF_ALTITUDE;\n\tprivate String description;\n\n\tpublic double setTakeoffAltitude() {\n\t\treturn takeoffaltitude;\n\t}\n\n\tpublic FlightRoute() {\n\t\tid = UUID.randomUUID().toString();\n\t\twaypoints = new LinkedList<>();\n\t\tname = id;\n\t}\n\n\t@Override\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\t@Override\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\n\t}\n\n\t@Override\n\tpublic void setCategory(String category) {\n\t\tthis.category = category;\n\n\t}\n\n\t@Override\n\tpublic String getCategory() {\n\t\treturn category;\n\t}\n\n\t@Override\n\tpublic List<Waypoint> getWaypoints() {\n\t\treturn Collections.unmodifiableList(waypoints);\n\t}\n\n\t@Override\n\tpublic void addWaypoint(Waypoint waypoint) {\n\t\twaypoints.add(waypoint);\n\t}\n\n\t@Discuss(discuss = \"this currently breaks if you add 2 identical coordinates...\")\n\t@Override\n\tpublic int removeWaypoint(Waypoint coordinate) {\n\t\tint index = waypoints.indexOf(coordinate);\n\t\tif (index != -1) {\n\t\t\twaypoints.remove(coordinate);\n\t\t}\n\t\treturn index;\n\t}\n\n\t@Override\n\tpublic void addWaypoint(Waypoint waypoint, int index) {\n\t\twaypoints.add(index, waypoint);\n\t}\n\n\t@Override\n\tpublic Waypoint removeWaypoint(int index) {\n\t\treturn waypoints.remove(index);\n\n\t}\n\n\t@Override\n\tpublic void setTakeoffAltitude(double altitude) {\n\t\tif (altitude <= 0) {\n\t\t\tthrow new IllegalArgumentException(\"Takeoff altitude must not be a postive number > 0\");\n\t\t}\n\t\tthis.takeoffaltitude = altitude;\n\t}\n}\n"}, {"id": "ReadDispatcher.java", "body": "package edu.nd.dronology.gstation.connector.dispatch;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport edu.nd.dronology.core.monitoring.DronologyMonitoringManager;\nimport edu.nd.dronology.core.util.FormatUtil;\nimport edu.nd.dronology.gstation.connector.messages.AbstractUAVMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVAcknowledgeMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVHandshakeMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVMessageFactory;\nimport edu.nd.dronology.gstation.connector.messages.UAVModeChangeMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVStateMessage;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * \n * Threat handling incoming messages from a GCS. <br>\n * The {@link ReadDispatcher} can handle json messages that are transformed into UAV Messages (extending {@link AbstractUAVMessage}) by the {@link UAVMessageFactory}.\n * \n * \n * @author Michael Vierhauser\n * \n *\n */\npublic class ReadDispatcher implements Runnable {\n\n\tprivate InputStream inputStream;\n\tprivate AtomicBoolean cont = new AtomicBoolean(false);\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(ReadDispatcher.class);\n\n\tprivate BufferedReader reader;\n\tprivate DispatchQueueManager dispatchQueueManager;\n\n\tpublic ReadDispatcher(Socket pythonSocket, DispatchQueueManager dispatchQueueManager) {\n\t\ttry {\n\t\t\tthis.dispatchQueueManager = dispatchQueueManager;\n\t\t\tinputStream = pythonSocket.getInputStream();\n\t\t\tcont.set(true);\n\t\t} catch (IOException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tLOGGER.info(\"Read-Dispatcher started\");\n\t\t\treader = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\twhile (cont.get() && !Thread.currentThread().interrupted()) {\n\t\t\t\tString line = reader.readLine();\n\t\t\t\tif (line != null) {\n\t\t\t\t\t// TODO: create the timestamp before deserializing the\n\t\t\t\t\t// object....\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAbstractUAVMessage<?> msg = UAVMessageFactory.create(line);\n\t\t\t\t\t\tprocessMessage(msg);\n\t\t\t\t\t\tif (msg == null) {\n\t\t\t\t\t\t\tLOGGER.hwFatal(\"Error when parsing incomming message '\" + line + \"'\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\tex.printStackTrace();\n\t\t\t\t\t\tLOGGER.hwFatal(\"Error when parsing incomming message '\" + line + \"' \" + ex.getMessage());\n\t\t\t\t\t} \n\n\t\t\t\t} else {\n\t\t\t\t\tLOGGER.hwInfo(\"null message received: closing socket.\");\n\t\t\t\t\ttearDown();\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tLOGGER.info(\"Reader Thread shutdown\");\n\t\t\ttry {\n\t\t\t\tif (inputStream != null) {\n\t\t\t\t\tinputStream.close();\n\t\t\t\t}\n\t\t\t\tif (reader != null) {\n\t\t\t\t\treader.close();\n\t\t\t\t}\n\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\n\t\t} catch (SocketException sex) {\n\t\t\tLOGGER.error(\"Socket Exception groundstation \" + dispatchQueueManager.getGroundstationid()\n\t\t\t\t\t+ \" disconnected - shutting down connection -- Error: \" + sex.getMessage());\n\t\t\tdispatchQueueManager.tearDown();\n\t\t\tcont.set(false);\n\n\t\t} catch (Throwable t) {\n\t\t\tLOGGER.error(t);\n\t\t} finally {\n\t\t\tif (inputStream != null) {\n\t\t\t\ttry {\n\t\t\t\t\tinputStream.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLOGGER.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (reader != null) {\n\t\t\t\ttry {\n\t\t\t\t\treader.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLOGGER.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void processMessage(AbstractUAVMessage<?> message) {\n\t\tif (message instanceof UAVStateMessage) {\n\t\t\tLOGGER.hwTrace(UAVMessageFactory.toJson(message));\n\t\t\tdispatchQueueManager.postDroneStatusUpdate(message.getUavid(), message);\n\n\t\t} else if (message instanceof UAVModeChangeMessage) {\n\t\t\tdispatchQueueManager.postDroneStatusUpdate(message.getUavid(), message);\n\t\t} else if (message instanceof UAVHandshakeMessage) {\n\t\t\tLOGGER.hwInfo(FormatUtil.formatTimestamp(message.getTimestamp(), FormatUtil.FORMAT_YEAR_FIRST_MILLIS) + \" - \"\n\t\t\t\t\t+ message.toString()); \n\t\t\tdispatchQueueManager.postDoneHandshakeMessage(message.getUavid(), (UAVHandshakeMessage) message);\n \n\t\t} else if (message instanceof UAVMonitoringMessage) {\n\t\t\tdispatchQueueManager.postMonitoringMessage((UAVMonitoringMessage) message);\n\n\t\t} else if (message instanceof UAVAcknowledgeMessage) {\n\t\t\tDronologyMonitoringManager.getInstance().publish(message);\n\t\t}\n\t}\n\n\tpublic void tearDown() {\n\t\tcont.set(false);\n\t\tdispatchQueueManager.tearDown();\n\t}\n\n\tpublic String getConnectionId() {\n\t\treturn \"ADS\";\n\t}\n}\n"}, {"id": "UAVTypeRegistration.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\npublic class UAVTypeRegistration implements IUAVTypeRegistration {\n\n\tprivate String id;\n\tprivate String name;\n\tprivate String description;\n\tprivate String type = \"Default\";\n\tprivate Map<String, Serializable> attributes;\n\tprivate byte[] image;\n\n\tpublic UAVTypeRegistration() {\n\t\tid = UUID.randomUUID().toString();\n\t\tattributes = new HashMap<>();\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\t@Override\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\n\t}\n\n\t@Override\n\tpublic Serializable getAttribute(String key) {\n\t\treturn attributes.get(key);\n\t}\n\n\t@Override\n\tpublic void addAttribute(String key, Serializable value) {\n\t\tattributes.put(key, value);\n\t}\n\n\t@Override\n\tpublic void setUAVImage(byte[] image) {\n\t\tthis.image = image;\n\t}\n\n\t@Override\n\tpublic byte[] getImage() {\n\t\treturn image;\n\t}\n}\n"}, {"id": "SimpleTakeoffFlightPlan.java", "body": "package edu.nd.dronology.core.flight.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport edu.nd.dronology.core.Discuss;\nimport edu.nd.dronology.core.DronologyConstants;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.exceptions.FlightZoneException;\nimport edu.nd.dronology.core.flight.IFlightPlan;\nimport edu.nd.dronology.core.util.FormatUtil;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * Stores flight information including its waypoints and current status.\n * \n * @author Jane Cleland-Huang\n * @version 0.1\n *\n */\npublic class SimpleTakeoffFlightPlan implements IFlightPlan {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -3288935042986922882L;\n\n\tprivate transient static final ILogger LOGGER = LoggerProvider.getLogger(SimpleTakeoffFlightPlan.class);\n\n\tprivate static int flightNumber = 0;\n\tprivate String flightID;\n\n\tprivate Status status;\n\tprivate transient ManagedDrone drone = null;\n\n\tprivate long startTime = -1;\n\tprivate long endTime = -1;\n\tprivate String uavid;\n\n\tprivate double altitude;\n\n\tprivate List<Waypoint> wayPoints = new ArrayList<>();\n\n\tprivate enum Status {\n\t\tPLANNED, FLYING, COMPLETED, ON_HOLD;\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn name().charAt(0) + name().substring(1).toLowerCase();\n\t\t}\n\n\t}\n\n\tpublic SimpleTakeoffFlightPlan(ManagedDrone drone, String planName, double altitude) {\n\t\tthis.altitude = altitude;\n\t\tif (altitude > DronologyConstants.MAX_ALTITUDE) {\n\t\t\taltitude = DronologyConstants.MAX_ALTITUDE;\n\t\t\tLOGGER.warn(\"Altitude override - Takeoff altitude exceeding max altitude of \"\n\t\t\t\t\t+ DronologyConstants.MAX_ALTITUDE + \"m\");\n\t\t}\n\t\tthis.drone = drone; \n\t\tthis.uavid = drone.getDroneName();\n\t\tLlaCoordinate current = drone.getCoordinates();\n\t\twayPoints.add(new Waypoint(new LlaCoordinate(current.getLatitude(), current.getLongitude(), altitude)));\n\t\tthis.flightID = \"DF-\" + Integer.toString(++flightNumber) + \" - \" + planName;\n\t\tstatus = Status.PLANNED;\n\n\t}\n\n\t/**\n\t * \n\t * @return flight ID\n\t */\n\t@Override\n\tpublic String getFlightID() {\n\t\treturn flightID;\n\t}\n\n\t/**\n\t * \n\t * @return Starting Coordinates\n\t */\n\t@Override\n\tpublic LlaCoordinate getStartLocation() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * \n\t * @return Ending Coordinates\n\t */\n\t@Override\n\tpublic LlaCoordinate getEndLocation() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the drone assigned to the flight plan. Will return null if no drone\n\t * is yet assigned.\n\t * \n\t * @return iDrone\n\t */\n\t@Override\n\tpublic ManagedDrone getAssignedDrone() {\n\t\treturn drone;\n\t}\n\n\t@Override\n\tpublic void clearAssignedDrone() {\n\t\tdrone = null;\n\t}\n\n\t/**\n\t * \n\t * @param drone\n\t * @return true if drone is currently flying, false otherwise.\n\t * @throws FlightZoneException\n\t */\n\t@Override\n\tpublic boolean setStatusToFlying(ManagedDrone drone) throws FlightZoneException {\n\t\tif (status == Status.PLANNED) {\n\t\t\tstatus = Status.FLYING;\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t\tthis.drone = drone;\n\t\t\tLOGGER.missionInfo(\"Flight Plan '\" + getFlightID() + \"'\" + drone.getDroneName() + \"' started \");\n\t\t\treturn true;\n\t\t} else\n\t\t\tthrow new FlightZoneException(\"Only currently planned flights can have their status changed to flying\");\n\t}\n\n\t/**\n\t * Sets flightplan status to completed when called.\n\t * \n\t * @return true\n\t * @throws FlightZoneException\n\t */\n\t@Override\n\tpublic boolean setStatusToCompleted() throws FlightZoneException {\n\t\tif (status == Status.FLYING) {\n\t\t\tstatus = Status.COMPLETED;\n\t\t\tendTime = System.currentTimeMillis();\n\t\t\tLOGGER.missionInfo(\"Flight Plan '\" + getFlightID() + \"'\" + drone.getDroneName() + \"' completed \"\n\t\t\t\t\t+ FormatUtil.formatTimestamp(startTime) + \"-\" + FormatUtil.formatTimestamp(endTime));\n\t\t\treturn true; // success (may add real check here later)\n\t\t} else\n\t\t\tthrow new FlightZoneException(\"Only currently flying flights can have their status changed to completed\");\n\t}\n\n\t/**\n\t * Returns current flightplan status (Planned, Flying, Completed)\n\t * \n\t * @return status\n\t */\n\tpublic String getStatus() {\n\n\t\treturn status.toString();\n\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn flightID + \"\\n\" + getStartLocation() + \" - \" + getEndLocation() + \"\\n\" + getStatus();\n\t}\n\n\t/**\n\t * Returns way points\n\t * \n\t * @return List<Waypoint>\n\t */\n\t@Override\n\tpublic List<Waypoint> getWayPoints() {\n\t\treturn Collections.unmodifiableList(wayPoints);\n\t}\n\n\t/**\n\t * Returns start time of flight.\n\t * \n\t * @return date object\n\t */\n\t@Override\n\tpublic long getStartTime() {\n\t\treturn startTime;\n\t}\n\n\t/**\n\t * REturns end time of flight.\n\t * \n\t * @return date object\n\t */\n\t@Override\n\tpublic long getEndTime() {\n\t\treturn endTime;\n\t}\n\n\t@Override\n\tpublic String getDesignatedDroneId() {\n\t\treturn uavid;\n\t}\n\n\t@Override\n\t@Discuss(discuss = \"unessecary double check of plan complete.. needs to be fixed\")\n\tpublic boolean isCompleted() {\n\t\treturn status == Status.COMPLETED || getWayPoints().get(0).isReached();\n\t}\n\n\t@Override\n\tpublic double getTakeoffAltitude() {\n\t\treturn altitude;\n\t}\n \n\t@Override\n\tpublic void setDesignatedDroneId(String uavid) {\n\t\tthis.uavid=uavid;\n\t\t\n\t}\n\t\n}\n"}, {"id": "MissionElementFactory.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.service.internal;\n\nimport edu.nd.dronology.services.core.items.IMissionPlan;\nimport edu.nd.dronology.services.extensions.missionplanning.persistence.PersistableMissionPlan;\n\npublic class MissionElementFactory {\n\n\tpublic static IMissionPlan createNewMissionPlan() {\n\t\treturn new PersistableMissionPlan();\n\t}\n\n}\n"}, {"id": "FlightDirectorFactory.java", "body": "package edu.nd.dronology.core.flight;\n\nimport edu.nd.dronology.core.flight.internal.SoloDirector;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\n\npublic class FlightDirectorFactory {\n\n\tpublic static IFlightDirector getFlightDirector(ManagedDrone managedDrone) {\n\t\treturn new SoloDirector(managedDrone);\n\t}\n\n}\n"}, {"id": "RemoteInfoFactory.java", "body": "//package edu.nd.dronology.services.info;\n//\n//import java.util.List;\n//\n//import edu.nd.dronology.core.flight.Flights;\n//import edu.nd.dronology.core.flight.IFlightPlan;\n//import edu.nd.dronology.core.util.LlaCoordinate;\n//import edu.nd.dronology.core.util.Waypoint;\n//import edu.nd.dronology.services.core.info.FlightInfo;\n//import edu.nd.dronology.services.core.info.FlightPlanInfo;\n//\n//public class RemoteInfoFactory {\n//\n//\tpublic static FlightInfo createFlightInfo(Flights flights) {\n//\n//\t\tFlightInfo info = new FlightInfo(\"FlightInfo\", \"FlightInfo\");\n//\n//\t\tfor (IFlightPlan flt : flights.getCurrentFlights()) {\n//\t\t\tFlightPlanInfo fpl = createPlanInfo(flt);\n//\t\t\tinfo.addCurrentFlight(fpl);\n//\n//\t\t}asdsa\n//\n//\t\tfor (IFlightPlan flt : flights.getAwaitingTakeOffFlights()) {\n//\t\t\tFlightPlanInfo fpl = createPlanInfo(flt);\n//\t\t\tinfo.addAwaitingTakeoff(fpl);\n//\t\t}\n//\n//\t\tfor (IFlightPlan flt : flights.getCompletedFlights()) {\n//\t\t\tFlightPlanInfo fpl = createPlanInfo(flt);\n//\t\t\tinfo.addCompleted(fpl);\n//\t\t}\n//\n//\t\tfor (IFlightPlan flt : flights.getPendingFlights()) {\n//\t\t\tFlightPlanInfo fpl = createPlanInfo(flt);\n//\t\t\tinfo.addPending(fpl);\n//\t\t}\n//\n//\t\treturn info;\n//\n//\t}\n//\n//\tprivate static FlightPlanInfo createPlanInfo(IFlightPlan flt) {\n//\t\tFlightPlanInfo flightPlanInfo = new FlightPlanInfo(flt.getFlightID(), flt.getFlightID());\n//\t\tString droneId = flt.getAssignedDrone() != null ? flt.getAssignedDrone().getDroneName() : \"--\";\n//\t\t\n//\t\n//\t\t\n//\t\tList<Waypoint> waypoints = flt.getWayPoints();\n//\t\tLlaCoordinate start = flt.getStartLocation();\n//\t\tlong startTime = flt.getStartTime();\n//\t\tlong endTime = flt.getEndTime();\n//\n//\t\tflightPlanInfo.setDroneId(droneId);\n//\t\tflightPlanInfo.setWaypoints(waypoints);\n//\t\tflightPlanInfo.setStartLocation(start);\n//\t\tflightPlanInfo.setStartTime(startTime);\n//\t\tflightPlanInfo.setEndTime(endTime);\n//\n//\t\treturn flightPlanInfo;\n//\t}\n//\n//}\n"}, {"id": "IMonitoringDataHandler.java", "body": "package edu.nd.dronology.core.monitoring;\n\nimport java.util.concurrent.BlockingQueue;\n\npublic interface IMonitoringDataHandler extends Runnable {\n\n\tvoid setQueue(BlockingQueue<IMonitorableMessage> queue);\n\n}\n"}, {"id": "TakeOffMessage.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal.message;\n\npublic class TakeOffMessage extends AbstractMessage {\n}\n"}, {"id": "RandomRouteSelector.java", "body": "package edu.nd.dronology.services.extensions.areamapping.selection.random;\n\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.IntStream;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.areamapping.MetricsStatistics;\nimport edu.nd.dronology.services.core.items.IAreaMapping;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.extensions.areamapping.internal.Geometry;\nimport edu.nd.dronology.services.extensions.areamapping.metrics.AllocationInformation;\nimport edu.nd.dronology.services.extensions.areamapping.metrics.Drone;\nimport edu.nd.dronology.services.extensions.areamapping.metrics.MetricsRunner;\nimport edu.nd.dronology.services.extensions.areamapping.metrics.MetricsUtilities;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\nimport edu.nd.dronology.services.extensions.areamapping.selection.GeneratedRoutesInfo;\nimport edu.nd.dronology.services.extensions.areamapping.selection.IRouteSelectionStrategy;\nimport edu.nd.dronology.services.extensions.areamapping.selection.ResultCreationUtil;\nimport edu.nd.dronology.services.extensions.areamapping.selection.RouteSelectionResult;\nimport edu.nd.dronology.services.extensions.areamapping.util.Utilities;\n\npublic class RandomRouteSelector implements IRouteSelectionStrategy {\n\n\tprivate static final double APERATURE_WIDTH = 10;\n\tprivate static final double APERATURE_HEIGHT = 0.8 * APERATURE_WIDTH;\n\tprivate static final double OVERLAP_FACTOR = 0.7;\n\tprivate static final int DEFAULT_RESULTS = 100;\n\tprivate double avgLatitude;\n\t// private int availableDrones;\n\tprivate List<RoutePrimitive> routePrimitives;\n\tprivate MetricsRunner metricsRunner;\n\tprivate List<IUAVProxy> uavs;\n\tprivate long start;\n\tprivate long end;\n\tprivate List<AllocationInformation> allAllocations;\n\n\t@Override\n\tpublic void initialize(GeneratedRoutesInfo info, Collection<IUAVProxy> uavs, IAreaMapping mapping)\n\t\t\tthrows DronologyServiceException {\n\n\t\ttry {\n\t\t\troutePrimitives = Utilities.splitRoutePrimitives(info.getRoutePrimitives(), APERATURE_HEIGHT, OVERLAP_FACTOR);\n\t\t\tthis.avgLatitude = info.getAverageLatitude();\n\t\t\tthis.uavs = new ArrayList<>(uavs);\n\t\t\tmetricsRunner = new MetricsRunner(routePrimitives, info.getTotalRiverSegment(), info.getBankList(),\n\t\t\t\t\tAPERATURE_WIDTH, APERATURE_HEIGHT, uavs.size());\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new DronologyServiceException(e.getMessage());\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic RouteSelectionResult generateAssignments(int numAssignments) throws DronologyServiceException {\n\t\ttry {\n\t\t\tallAllocations = new ArrayList<>();\n\n\t\t\tIntStream.range(0, numAssignments).forEach(i -> createAssignment());\n\n\t\t\treturn createResult();\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t\tthrow new DronologyServiceException(t.getMessage());\n\t\t}\n\n\t}\n\n\tprivate void createAssignment() {\n\t\tList<Drone> assignments = generateRandomAssingments();\n\t\tAllocationInformation currentAllocation = new AllocationInformation();\n\t\tcurrentAllocation.setDroneAllocations(assignments);\n\t\tcurrentAllocation.setMetricsStatistics(generateMetricsStatistics(assignments));\n\t\tallAllocations.add(currentAllocation);\n\n\t}\n\n\tprivate RouteSelectionResult createResult() {\n\t\tCollections.sort(allAllocations);\n\t\tResultCreationUtil rcUtil = new ResultCreationUtil(routePrimitives);\n\t\trcUtil.createRoutes(avgLatitude);\n\n\t\tRouteSelectionResult result = rcUtil.createResult(allAllocations);\n\t\tresult.setSelectionTime(end - start);\n\n\t\treturn result;\n\n\t}\n\n\t// GeneratedRouteAssignment....\n\tprivate List<Drone> generateRandomAssingments() {\n\t\ttry {\n\t\tSet<Integer> assignedRoutes = new HashSet<>();\n\t\tint availableDrones = uavs.size();\n\t\tint droneNum;\n\t\tint routeNum;\n\n\t\tint routeAssignmentNum = MetricsUtilities.generateRandomNumber(routePrimitives.size() - 1, 1);\n\t\tList<Drone> droneList = new ArrayList<>();\n\t\tfor (int i = 0; i < availableDrones; i++) {\n\t\t\tdroneList.add(new Drone());\n\t\t\tLlaCoordinate home = uavs.get(i).getHomeLocation();\n\t\t\tLlaCoordinate currentLocation = uavs.get(i).getCoordinates();\n\t\t\tdroneList.get(i).setDroneHomeLocation(\n\t\t\t\t\tGeometry.gpsToCartesian(new Point2D.Double(home.getLatitude(), home.getLongitude()), avgLatitude));\n\t\t\tdroneList.get(i).setDroneStartPoint(Geometry.gpsToCartesian(\n\t\t\t\t\tnew Point2D.Double(currentLocation.getLatitude(), currentLocation.getLongitude()), avgLatitude));\n\t\t\tdroneList.get(i).setUAVId(uavs.get(i).getID());\n\t\t}\n\n\t\t// while (assignedRoutes.size() < routeAssignmentNum) {\n\t\t// // assign drone routes in here\n\t\t// droneNum = MetricsUtilities.generateRandomNumber(availableDrones - 1, 0);\n\t\t// routeNum = MetricsUtilities.generateRandomNumber(routeAssignmentNum, 0);\n\t\t// while (assignedRoutes.contains(routeNum)) {\n\t\t// routeNum = MetricsUtilities.generateRandomNumber(routeAssignmentNum, 0);\n\t\t// }\n\t\t// droneList.get(droneNum).getDroneRouteAssignment().add(routePrimitives.get(routeNum));\n\t\t// assignedRoutes.add(routeNum);\n\t\t// }\n\t\tList<RoutePrimitive> shuffledRoutes = new ArrayList<>(routePrimitives);\n\t\tCollections.shuffle(shuffledRoutes);\n\t\tList<RoutePrimitive> availableRoutes = new ArrayList(shuffledRoutes.subList(0, (routeAssignmentNum+1)));\n\t\tAtomicInteger assignCounter = new AtomicInteger(0);\n\t\twhile (assignCounter.get() < routeAssignmentNum) {\n\t\t\tdroneNum = MetricsUtilities.generateRandomNumber(availableDrones - 1, 0);\n\t\t\trouteNum = MetricsUtilities.generateRandomNumber(availableRoutes.size()-1, 0);\n\t\t\tRoutePrimitive toAssign = availableRoutes.remove(routeNum);\n\t\t\tdroneList.get(droneNum).getDroneRouteAssignment().add(toAssign);\n\t\t\tassignCounter.incrementAndGet();\n\t\t}\n\t\treturn droneList;\n\t\t}catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\treturn Collections.EMPTY_LIST;\n\t\t}\n\t}\n\n\tprivate MetricsStatistics generateMetricsStatistics(List<Drone> drones) {\n\t\tlong start = System.currentTimeMillis();\n\t\tmetricsRunner.setDroneAssignments(drones);\n\t\tMetricsStatistics metrics = metricsRunner.runMetrics();\n\t\tlong end  = System.currentTimeMillis();\n//\t\tSystem.out.println(end-start);\n\t\treturn metrics;\n\t}\n\n\t@Override\n\tpublic RouteSelectionResult generateAssignments() throws DronologyServiceException {\n\t\treturn generateAssignments(DEFAULT_RESULTS);\n\t}\n\n}\n"}, {"id": "ConnectionResponseCommand.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n\npublic class ConnectionResponseCommand extends AbstractDroneCommand implements IDroneCommand {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -2039989878208633422L;\n\n\tpublic ConnectionResponseCommand(String groundstationId, boolean success) {\n\t\tsuper(groundstationId, CommandIds.CONNECTION_RESPONSE);\n\t\tdata.put(ATTRIBUTE_SUCCESS, Boolean.toString(success));\n\t}\n\n}\n"}, {"id": "LandMessage.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal.message;\n\npublic class LandMessage extends AbstractMessage {\n}\n"}, {"id": "IDrone.java", "body": "package edu.nd.dronology.core.vehicle;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.exceptions.FlightZoneException;\nimport edu.nd.dronology.core.vehicle.commands.AbstractDroneCommand;\nimport edu.nd.dronology.core.vehicle.proxy.UAVProxy;\n\n\n/**\n * iDrone interface\n * \n * @author Jane Cleland-Huang\n * @version 0.01\n *\n */\npublic interface IDrone {\n\n\tpublic UAVProxy getDroneStatus();\n\n\t/**\n\t * \n\t * @return latitude of drone\n\t */\n\tpublic double getLatitude();\n\n\t/**\n\t * \n\t * @return longitude of drone\n\t */\n\tpublic double getLongitude();\n\n\t/**\n\t * \n\t * @return altitude of drone\n\t */\n\tpublic double getAltitude();\n\n\t/**\n\t * Fly drone to target coordinates\n\t * \n\t * @param targetCoordinates\n\t * @param speed\n\t */\n\tpublic void flyTo(LlaCoordinate targetCoordinates, Double speed);\n\n\t/**\n\t * \n\t * @return current coordinates\n\t */\n\tpublic LlaCoordinate getCoordinates();\n\n\t/**\n\t * \n\t * @return unique name of drone\n\t */\n\tpublic String getDroneName();\n\n\t/**\n\t * Land the drone. Update status.\n\t * \n\t * @throws FlightZoneException\n\t */\n\tvoid land() throws FlightZoneException;\n\n\t/**\n\t * Takeoff. Update status.\n\t * \n\t * @throws FlightZoneException\n\t */\n\tvoid takeOff(double altitude) throws FlightZoneException;\n\n\t/**\n\t * Sets drones coordinates\n\t * \n\t * @param lat\n\t *          latitude\n\t * @param lon\n\t *          Longitude\n\t * @param alt\n\t *          Altitude\n\t */\n\tpublic void setCoordinates(double lat, double lon, double alt);\n\n\tpublic double getBatteryStatus();\n\n\tpublic boolean move(double i);\n\n\tpublic void setVoltageCheckPoint();\n\n\tpublic boolean isDestinationReached(int distanceMovedPerTimeStep);\n\n\tvoid setBaseCoordinates(LlaCoordinate basePosition);\n\n\tpublic LlaCoordinate getBaseCoordinates();\n\n\tpublic void setGroundSpeed(double speed);\n\n\tpublic void setVelocity(double x, double y, double z);\n\n\tvoid setCoordinates(LlaCoordinate coordinate);\n\n\tpublic void sendCommand(AbstractDroneCommand command) throws DroneException;\n\n\tpublic DroneSnapshotInternal getLatestDroneSnapshot();\n\n\tpublic void setManagedDrone(ManagedDrone managedDrone);\n\n\tpublic void resendCommand() throws DroneException;\n\n}\n"}, {"id": "DroneCollector.java", "body": "package edu.nd.dronology.core.collisionavoidance;\n\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\n\nimport java.util.List;\n\n/**\n * I think of this as an agent who's one job is to find a list of ManagedDrones. The motivation for this to exist comes\n * from making it easier to isolate CollisionAvoidanceCheckTask under test.\n */\npublic interface DroneCollector {\n    List<ManagedDrone> getManagedDrones();\n}\n"}, {"id": "MonitoringDispatchThread.java", "body": "package edu.nd.dronology.gstation.connector.dispatch;\n\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.Callable;\n\nimport edu.nd.dronology.core.IUAVPropertyUpdateNotifier;\nimport edu.nd.dronology.core.monitoring.DronologyMonitoringManager;\nimport edu.nd.dronology.gstation.connector.messages.AbstractUAVMessage;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class MonitoringDispatchThread extends AbstractStatusDispatchThread<AbstractUAVMessage> implements Callable {\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(MonitoringDispatchThread.class);\n\n\tprivate IUAVPropertyUpdateNotifier listener;\n\n\tpublic MonitoringDispatchThread(final BlockingQueue<AbstractUAVMessage> queue) {\n\t\tsuper(queue);\n\t}\n\n\t@Override\n\tpublic Object call() {\n\t\twhile (cont.get() && !Thread.currentThread().isInterrupted()) {\n\n\t\t\ttry {\n\t\t\t\tAbstractUAVMessage message = queue.take();\n\t\t\t\tDronologyMonitoringManager.getInstance().publish(message);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLOGGER.info(\"Monitoring Dispatcher shutdown! -- \" + e.getMessage());\n\n\t\t\t} catch (Throwable e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\n\t\t}\n\t\tLOGGER.info(\"Monitoring Dispatcher shutdown!\");\n\t\treturn null;\n\t}\n\n}\n"}, {"id": "GetSnapshotMessage.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal.message;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshotOption;\n\nimport java.util.concurrent.ArrayBlockingQueue;\n\npublic class GetSnapshotMessage extends AbstractMessage {\n    public final ArrayBlockingQueue<DroneSnapshotOption> returnBox;\n    public GetSnapshotMessage(ArrayBlockingQueue<DroneSnapshotOption> returnQueue) {\n        this.returnBox = returnQueue;\n    }\n}\n"}, {"id": "AMControlsComponent.java", "body": "package edu.nd.dronology.ui.vaadin.areamapping;\n\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.VerticalLayout;\n\n/**\n * This controls component shows the info panel (list of mappings) and contains the main layout.\n * \n * @author Andrew Slavin\n *\n */\n\npublic class AMControlsComponent extends CustomComponent {\n\t\n\tprivate static final long serialVersionUID = 1L;\n\tprivate AMInfoPanel info = new AMInfoPanel(this);\n\tAMMainLayout mainLayout;\n\t\n\tpublic AMControlsComponent(AMMainLayout layout) {\n\t\tthis.setWidth(\"100%\");\n\t\taddStyleName(\"controls_component\");\n\t\t\n\t\tVerticalLayout content = new VerticalLayout();\n\n\t\tcontent.addComponent(info);\n\t\tsetCompositionRoot(content);\n\t\tmainLayout = layout;\n\t}\n\t\n\t// Returns the list of area mappings, which appears on the left hand side of the display.\n\tpublic AMInfoPanel getInfoPanel(){\n\t\treturn info;\n\t}\n\t// Returns the table and grid combination, which appears on the right hand side of the display.\n\tpublic AMMainLayout getMainLayout() {\n\t\treturn mainLayout;\n\t\t\n\t}\n\n}\n"}, {"id": "UAVMessageFactory.java", "body": "package edu.nd.dronology.gstation.connector.messages;\n\nimport java.text.DateFormat;\nimport java.util.Map;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.json.JSONObject;\n\nimport com.google.gson.FieldNamingPolicy;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\nimport edu.nd.dronology.gstation.connector.GroundStationException;\n\n/**\n * \n * Factory class for creating {@link AbstractUAVMessage} from JSON strings.\n * \n * @author Michael Vierhauser  \n *\n */\npublic class UAVMessageFactory {\n\n\tprivate static final String MESSAGE_TYPE = \"type\";\n\n\tpublic static final transient Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()\n\t\t\t.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).setVersion(1.0)\n\t\t\t.serializeSpecialFloatingPointValues().serializeSpecialFloatingPointValues()\n\t\t\t.registerTypeAdapter(UAVModeChangeMessage.class, new ModeChangeMessageTypeAdapter()).create();\n\n\tstatic final Gson TYPE_GSON = new GsonBuilder().serializeNulls().setDateFormat(DateFormat.LONG)\n\t\t\t.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).setVersion(1.0)\n\t\t\t.serializeSpecialFloatingPointValues().registerTypeAdapter(Map.class, new StateMessageTypeAdapter())\n\n\t\t\t.create();\n\n\tpublic static AbstractUAVMessage<?> create(String messagestring) throws Exception {\n\n\t\tJSONObject messageObject = new JSONObject(messagestring);\n\t\tString messagetype = messageObject.optString(MESSAGE_TYPE);\n\n\t\tif (messagetype == null || StringUtils.isEmpty(messagetype)) {\n\t\t\tthrow new GroundStationException(\"Message Type of received message was null!\");\n\t\t}\n\t\tAbstractUAVMessage<?> message = null;\n\t\tswitch (messagetype) {\n\t\t\tcase UAVStateMessage.MESSAGE_TYPE: {\n\t\t\t\tmessage = TYPE_GSON.fromJson(messagestring, UAVStateMessage.class);\n\t\t\t\tmessage.timestamp();\n\t\t\t\treturn message;\n\t\t\t}\n\n\t\t\tcase UAVHandshakeMessage.MESSAGE_TYPE: {\n\t\t\t\tmessage = GSON.fromJson(messagestring, UAVHandshakeMessage.class);\n\t\t\t\tmessage.timestamp();\n\t\t\t\treturn message;\n\t\t\t}\n\t\t\tcase UAVMonitoringMessage.MESSAGE_TYPE: {\n\t\t\t\tmessage = GSON.fromJson(messagestring, UAVMonitoringMessage.class);\n\t\t\t\tmessage.timestamp();\n\t\t\t\treturn message;\n\t\t\t}\n\t\t\tcase ConnectionRequestMessage.MESSAGE_TYPE: {\n\t\t\t\tmessage = GSON.fromJson(messagestring, ConnectionRequestMessage.class);\n\t\t\t\tmessage.timestamp();\n\t\t\t\treturn message;\n\t\t\t}\n\t\t\tcase UAVModeChangeMessage.MESSAGE_TYPE: {\n\t\t\t\tmessage = GSON.fromJson(messagestring, UAVModeChangeMessage.class);\n\t\t\t\tmessage.timestamp();\n\t\t\t\treturn message;\n\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tthrow new GroundStationException(\"Unknown Message Type! '\" + messagetype + \"'\");\n\t\t}\n\t}\n\n\tpublic static String toJson(AbstractUAVMessage<?> message) {\n\t\treturn GSON.toJson(message);\n\t}\n\n}\n"}, {"id": "AssignFlightMessage.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal.message;\n\nimport edu.nd.dronology.core.flight.IFlightDirector;\n\npublic class AssignFlightMessage extends AbstractMessage {\n    public final IFlightDirector flightDirective;\n\n    public AssignFlightMessage(IFlightDirector flightDirective) {\n        this.flightDirective = flightDirective;\n    }\n}\n"}, {"id": "FakePassivPythonGroundstation.java", "body": "package edu.nd.dronology.misc.gcs;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.text.DateFormat;\nimport java.util.Random;\n\nimport com.google.gson.FieldNamingPolicy;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\nimport edu.nd.dronology.core.vehicle.commands.ConnectionResponseCommand;\nimport edu.nd.dronology.gstation.connector.messages.ConnectionRequestMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class FakePassivPythonGroundstation {\n\n\t//private static Socket socket;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(FakePassivPythonGroundstation.class);\n\t\n\tfinal static Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()\n\t\t\t.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)\n\t\t\t.setVersion(1.0).serializeSpecialFloatingPointValues().create();\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tint port = 1234;\n\t\t\t// ServerSocket serverSocket = new ServerSocket(port);\n\t\t\t// Server is running always. This is done using this while(true) loop\n\n\t\t\t// socket = serverSocket.accept();\n\t\t\tString hostAddr = \"localhost\";\n\n\t\t\tLOGGER.info(\"Connecting to Python base \" + hostAddr + \"@\" + port);\n\t\t\tSocket pythonSocket = new Socket();\n\t\t\tpythonSocket.connect(new InetSocketAddress(hostAddr, port), 5000);\n\n\t\t\tSystem.out.println(\"Client has connected!\");\n\t\t\tInputStream is = pythonSocket.getInputStream();\n\t\t\tInputStreamReader isr = new InputStreamReader(is);\n\t\t\tBufferedReader br = new BufferedReader(isr);\n\n\t\t\t//UAVHandshakeMessage handshake = new UAVHandshakeMessage(\"Drone1\", \"Drone1\");\n\t\t\tConnectionRequestMessage connect = new ConnectionRequestMessage(\"FAKE_GROUND_1\");\n\t\t\t\n\t\t\n\t\t\tString handshakeString = GSON.toJson(connect);\n\t\t\tThread.sleep(10000);\n\t\t\tOutputStream os = pythonSocket.getOutputStream();\n\t\t\tOutputStreamWriter osw = new OutputStreamWriter(os);\n\t\t\tBufferedWriter bw = new BufferedWriter(osw);\n\t\t\tbw.write(handshakeString);\n\t\t\tbw.write(\"\\n\");\n\t\t\tSystem.out.println(\"Message sent to the client is \" + handshakeString);\n\t\t\tbw.flush();\n\t\t\t\n\t\t\t\n\n\t\t\tString ackMesasge = br.readLine();\n\t\t\tConnectionResponseCommand response = GSON.fromJson(ackMesasge, ConnectionResponseCommand.class);\n\t\t\tSystem.out.println(\"RESPONSE:\" + response.toJsonString());\n\t\t\tThread.sleep(3000);\n\t\t\t\n\t\t\tThread.sleep(10000);\n\n\t\t\tint i=2;\n\t\t\twhile (i>1) {\n\n\t\t\t\tUAVMonitoringMessage mm = new UAVMonitoringMessage(\"Drone1\",  \"FAKE\",\"Drone1\");\n\t\t\t\tRandom rand = new Random();\n\t\t\t\tmm.setType(UAVMonitoringMessage.MESSAGE_TYPE);\n\t\t\t\t// mm.setuavid(\"DRONE1\");\n\t\t\t\tmm.addPropery(\"NR_SATELITES\", \"5\");\n\t\t\t\tmm.addPropery(\"GPS_BIAS\", \"3.125\");\n\t\t\t\tmm.addPropery(\"CURRENT_SPEED\", \"5.25\");\n\t\t\t\tmm.addPropery(\"BLEVEL_VOLTAGE\", \"3\");\n\t\t\t\tmm.addPropery(\"BATTERY_MAXPOWERX\", \"50\");\n\t\t\t\tmm.addPropery(\"BATTERY_VOLTAGE\", rand.nextInt(10));\n\t\t\t\tmm.addPropery(\"BATTERY_POWER\", rand.nextInt(10));\n\t\t\t\tmm.addPropery(\"BLEVEL_POWER\", rand.nextInt(10));\n\n\t\t\t\t// if flying mission mlevel > 20%\n\t\t\t\t// if retunr home blvel > 10;\n\n\t\t\t\tString toSend = GSON.toJson(mm);\n\n\t\t\t\t// Reading the message from the client\n\n\t\t\t\t// String number = br.readLine();\n\t\t\t\t// System.out.println(\"Message received from client is \" + number);\n\n\t\t\t\t// Multiplying the number by 2 and forming the return message\n\t\t\t\t// String returnMessage;\n\t\t\t\t// try {\n\t\t\t\t// int numberInIntFormat = Integer.parseInt(number);\n\t\t\t\t// int returnValue = numberInIntFormat * 2;\n\t\t\t\t// returnMessage = String.valueOf(returnValue) + \"\\n\";\n\t\t\t\t// } catch (NumberFormatException e) {\n\t\t\t\t// // Input was not a number. Sending proper message back to client.\n\t\t\t\t// returnMessage = \"Please send a proper number\\n\";\n\t\t\t\t// }\n\n\t\t\t\t// Sending the response back to the client.\n\t\t\t\t// OutputStream os = socket.getOutputStream();\n\t\t\t\t// OutputStreamWriter osw = new OutputStreamWriter(os);\n\t\t\t\t// BufferedWriter bw = new BufferedWriter(osw);\n\t\t\t\tbw.write(toSend);\n\t\t\t\tbw.write(\"\\n\");\n\t\t\t\tSystem.out.println(\"Message sent to the client is \" + toSend);\n\t\t\t\tbw.flush();\n\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}"}, {"id": "SetTargetAltitudeMessage.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal.message;\n\npublic class SetTargetAltitudeMessage extends AbstractMessage {\n    public final double altitude;\n\n    public SetTargetAltitudeMessage(double altitude) {\n        this.altitude = altitude;\n    }\n}\n"}, {"id": "StopLayer.java", "body": "package edu.nd.dronology.core.collisionavoidance.strategy.onionbackend;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\nimport edu.nd.dronology.core.collisionavoidance.strategy.StopEveryone;\n\npublic class StopLayer implements ILayer {\n    private final double triggerDistance;\n\n    public StopLayer(double triggerDistance) {\n        this.triggerDistance = triggerDistance;\n    }\n\n\t@Override\n\tpublic void applyAction(DroneSnapshot snapshot) {\n\t\tStopEveryone.stopDroneIfNotStopped(snapshot);\n\t}\n\n\t@Override\n\tpublic boolean isTriggered(double distance) {\n\t\treturn distance < this.triggerDistance;\n\t}\n\n\t@Override\n\tpublic double getTriggerDistance() {\n\t\treturn triggerDistance;\n\t}\n}"}, {"id": "BaseServiceProvider.java", "body": "package edu.nd.dronology.monitoring.simplechecker;\n\nimport java.net.MalformedURLException;\nimport java.rmi.Naming;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\n\nimport edu.nd.dronology.services.core.api.IBaseServiceProvider;\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n/**\n * Configurable utility class providing remote services via RMI.\n * \n * @author Michael Vierhauser\n * \n */\npublic class BaseServiceProvider implements IBaseServiceProvider {\n\n\tprivate static String ADDRESS_SCHEME = \"rmi://%s:%s/Remote\";\n\n\tprivate static IBaseServiceProvider INSTANCE = new BaseServiceProvider();\n\n\tprivate static final String DEFAULT_ADDRESS = \"localhost\";\n\tprivate static final int DEFAULT_PORT = 9779;\n\n\tprivate String ip;\n\tprivate int port;\n\n\t/**\n\t * \n\t * @param ip\n\t *            The ip address of the server\n\t * @param port\n\t *            The port of the remote service.\n\t */\n\tpublic BaseServiceProvider(String ip, int port) {\n\t\tthis.ip = ip;\n\t\tthis.port = port;\n\t}\n\n\t/**\n\t * Default constructor using standard port and localhost.\n\t */\n\tpublic BaseServiceProvider() {\n\t\tthis(DEFAULT_ADDRESS, DEFAULT_PORT);\n\t}\n\n\t/**\n\t * @return The remote manager instance via RMI\n\t * @throws DistributionException\n\t *             if the service can not be retrieved.\n\t */\n\t@Override\n\tpublic IRemoteManager getRemoteManager() throws DronologyServiceException {\n\t\ttry {\n\t\t\tIRemoteManager manager = (IRemoteManager) Naming.lookup(String.format(ADDRESS_SCHEME, ip, port));\n\t\t\treturn manager;\n\t\t} catch (MalformedURLException e) {\n\t\t\tthrow new DronologyServiceException(e);\n\t\t} catch (RemoteException e) {\n\t\t\tthrow new DronologyServiceException(e);\n\t\t} catch (NotBoundException e) {\n\t\t\tthrow new DronologyServiceException(e);\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void init(String ip, int port) {\n\t\tthis.ip = ip;\n\t\tthis.port = port;\n\n\t}\n\n\tpublic static IBaseServiceProvider getInstance() {\n\t\treturn INSTANCE;\n\t}\n\n}\n"}, {"id": "SimulatorScenarioPersistenceProvider.java", "body": "package edu.nd.dronology.services.core.persistence;\n\nimport edu.nd.dronology.services.core.items.ISimulatorScenario;\nimport edu.nd.dronology.services.core.persistence.internal.SimulatorScenarioXStreamPersistor;\n\n/**\n * Provider implementation for {@link ISimulatorScenario}.<br>\n * Details see {@link AbstractItemPersistenceProvider}\n * \n * @author Michael Vierhauser\n * \n */\npublic class SimulatorScenarioPersistenceProvider extends AbstractItemPersistenceProvider<ISimulatorScenario> {\n\n\tpublic SimulatorScenarioPersistenceProvider() {\n\t\tsuper();\n\t}\n\n\t@Override\n\tprotected void initPersistor() {\n\t\tPERSISTOR = new SimulatorScenarioXStreamPersistor();\n\n\t}\n\n\t@Override\n\tprotected void initPersistor(String type) {\n\t\tinitPersistor();\n\t}\n\n\tpublic static SimulatorScenarioPersistenceProvider getInstance() {\n\t\treturn new SimulatorScenarioPersistenceProvider();\n\t}\n\n}\n"}, {"id": "DroneSnapshot.java", "body": "package edu.nd.dronology.core.collisionavoidance;\n\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.goal.AbstractGoal;\nimport edu.nd.dronology.core.goal.IGoalSnapshot;\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\nimport java.util.ArrayList;\nimport java.util.Set;\n\npublic interface DroneSnapshot {\n    LlaCoordinate getPosition();\n    ArrayList<Command> getCommands();\n    String getName();\n    Vector3D getVelocity();\n    Vector3D getAttitude();\n    String getState();\n    Set<IGoalSnapshot> getGoals();\n}\n"}, {"id": "AFEmergencyComponent.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.HorizontalLayout;\nimport com.vaadin.ui.Label;\nimport com.vaadin.ui.NativeButton;\nimport com.vaadin.ui.VerticalLayout;\n\n/**\n * This is the set of emergency buttons in the AFInfoPanel\n * \n * @author Patrick Falvey \n *\n */\npublic class AFEmergencyComponent extends CustomComponent{\n\tprivate static final long serialVersionUID = -650745296345774988L;\n\tprivate HorizontalLayout buttons = new HorizontalLayout();\n\tprivate NativeButton hover = new NativeButton(\"All UAVs<br>Hover in Place\");\n  private NativeButton home = new NativeButton(\"All UAVs<br>Return to Home\");\n  \n\tpublic AFEmergencyComponent(){\n\t\tVerticalLayout layout = new VerticalLayout();\n\t\tlayout.addStyleName(\"af_operations_group\");\n    \n\t\tLabel caption = new Label(\"Emergency Operations\");\n    \n    hover.setCaptionAsHtml(true);\n    hover.addStyleName(\"btn-warning\");\n    home.setCaptionAsHtml(true);\n    home.addStyleName(\"btn-warning\");\n    \n    buttons.addComponents(hover, home);\n    layout.addComponents(caption, buttons);\n    \n    setCompositionRoot(layout);\n\t}\n\t\n\tpublic NativeButton getHome(){\n\t\treturn home;\n\t}\n\t\n\tpublic NativeButton getHover(){\n\t\treturn hover;\n\t}\n\t\n}\n"}, {"id": "UAVTypeRegistrationInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\npublic class UAVTypeRegistrationInfo extends RemoteInfoObject {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 2844123024068335148L;\n\tprivate String type = \"Default\";\n\n\tpublic UAVTypeRegistrationInfo(String name, String id) {\n\t\tsuper(name, id);\n\t}\n\n\tpublic String getType() {\n\t\treturn type;\n\t}\n\n\tpublic void setType(String type) {\n\t\tthis.type = type;\n\n\t}\n\n}\n"}, {"id": "PassThrough.java", "body": "package edu.nd.dronology.core.collisionavoidance.strategy;\n\nimport java.util.ArrayList;\n\nimport edu.nd.dronology.core.collisionavoidance.CollisionAvoider;\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\nimport edu.nd.dronology.core.goal.WaypointGoalSnapshot;\n\npublic class PassThrough implements CollisionAvoider {\n\n\t@Override\n\tpublic void avoid(ArrayList<DroneSnapshot> drones) {\n        ArrayList<DroneSnapshot> flyingDrones = StopEveryone.findFlyingDrones(drones);\n        for (DroneSnapshot drone : flyingDrones) {\n            WaypointGoalSnapshot waypointGoal = StopEveryone.findActiveWaypointGoal(drone.getGoals());\n            if (waypointGoal != null) {\n                StopEveryone.flyToGoalIfNotAlready(drone, waypointGoal);\n            }\n        }\n    }\n    \n}"}, {"id": "IAction.java", "body": "package edu.nd.dronology.core.collisionavoidance.strategy.onionbackend;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\n\npublic interface IAction {\n    public void applyAction(DroneSnapshot snapshot);\n}"}, {"id": "RemoteInfo.java", "body": "package edu.nd.dronology.services.core.remote;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport javax.xml.bind.annotation.XmlRootElement;\n\nimport edu.nd.dronology.services.core.base.AbstractRegisterableUnit;\n\n/**\n * \n * Transmittable object for a Remote Clients containing information on the Subscriber.\n * \n * @author Michael Vierhauser\n * \n */\n@XmlRootElement\npublic class RemoteInfo extends AbstractRegisterableUnit {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 1876222975522920266L;\n\n\t/** Flag for subscribing to all sources. */\n\tpublic static final String ALL = \"all\";\n\n\tprivate Set<String> subscribeIDs = new HashSet<>();\n\n\tprotected RemoteInfo(String ID, String hostname) {\n\t\tsuper(ID, hostname);\n\t}\n\n\t/**\n\t * @return A list of subscribed sources.\n\t */\n\tpublic Set<String> getSubscribeIDs() {\n\t\treturn Collections.unmodifiableSet(subscribeIDs);\n\t}\n\n\n\t/**\n\t * \n\t * @param id The source to be added.\n\t */\n\tpublic void addSourceID(String id) {\n\t\tsubscribeIDs.add(id);\n\n\t}\n\n\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"REMOTE CLIENT  [id: \" + ID /* + \" | callbackURL: \" + callbackURL + \" subscribeIDs: \" + getRegisteredIds() */\n\t\t\t\t+ \"]\";\n\t}\n\n\t@Override\n\tpublic String getUnitType() {\n\t\treturn \"Subscriber\";\n\t}\n}\n"}, {"id": "SyncTask.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.tasks;\n\npublic class SyncTask extends AbstractMissionTask {\n\n\tprotected SyncTask(String uavID, String taskName) {\n\t\tsuper(uavID, taskName);\n\t}\n}"}, {"id": "UAVTypeRegistrationService.java", "body": "package edu.nd.dronology.services.instances.registration.types;\n\nimport edu.nd.dronology.services.core.base.AbstractFileTransmitServerService;\nimport edu.nd.dronology.services.core.info.UAVTypeRegistrationInfo;\n\npublic class UAVTypeRegistrationService\n\t\textends AbstractFileTransmitServerService<IUAVTypeRegistrationServiceInstance, UAVTypeRegistrationInfo> {\n\n\tprivate static volatile UAVTypeRegistrationService INSTANCE;\n\n\tprotected UAVTypeRegistrationService() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @return The singleton ConfigurationService instance\n\t */\n\tpublic static UAVTypeRegistrationService getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (UAVTypeRegistrationService.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new UAVTypeRegistrationService();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\n\t}\n\n\t@Override\n\tprotected IUAVTypeRegistrationServiceInstance initServiceInstance() {\n\t\treturn new UAVTypeRegistrationServiceInstance();\n\t}\n\n\n\n}\n"}, {"id": "SetVelocityCommand.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n\npublic class SetVelocityCommand extends AbstractDroneCommand implements IDroneCommand {\n\n\t/**\n\t * \n\t * Command sent to the GCS for setting a velocity vector to the UAV.<br>\n\t * The vector is specified in NED (north,east,down).\n\t * \n\t * \n\t * @author Michael Vierhauser\n\t */\n\tprivate static final long serialVersionUID = 2864106869131015180L;\n\n\tpublic SetVelocityCommand(String uavid, double x, double y, double z) {\n\t\tsuper(uavid, CommandIds.SET_VELOCITY_COMMAND);\n\t\tdata.put(ATTRIBUTE_X, x);\n\t\tdata.put(ATTRIBUTE_Y, y);\n\t\tdata.put(ATTRIBUTE_Z, z);\n\t}\n\n}\n"}, {"id": "OpenUniversityDemoScript.java", "body": "package edu.nd.dronology.misc.scripts;\n\nimport java.net.MalformedURLException;\nimport java.rmi.Naming;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo.DroneMode;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;\nimport edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;\nimport edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic class OpenUniversityDemoScript {\n\n\tprivate static final String ADDRESS_SCHEME = \"rmi://%s:%s/Remote\";\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\t// Flying Field\n\t\t\tLlaCoordinate cord1 = new LlaCoordinate(52.024928, -0.705930, 0);\n\t\t\tLlaCoordinate cord2 = new LlaCoordinate(52.026177, -0.713478,0);\n\t\t\tLlaCoordinate cord3 = new LlaCoordinate(52.023837, -0.714029, 0);\n\n\t\t\tIRemoteManager manager = (IRemoteManager) Naming.lookup(String.format(ADDRESS_SCHEME, \"localhost\", 9779));\n\n\t\t\tIDroneSetupRemoteService service = (IDroneSetupRemoteService) manager.getService(IDroneSetupRemoteService.class);\n\n\t\t\tIFlightManagerRemoteService managerService = (IFlightManagerRemoteService) manager\n\t\t\t\t\t.getService(IFlightManagerRemoteService.class);\n\n\t\t\tIFlightRouteplanningRemoteService planningService = (IFlightRouteplanningRemoteService) manager\n\t\t\t\t\t.getService(IFlightRouteplanningRemoteService.class);\n\t\t\t//\n\n\t\t\tDroneInitializationInfo inff = new DroneInitializationInfo(\"Bashars-UAV\", DroneMode.MODE_VIRTUAL,\n\t\t\t\t\t\"IRIS+\", cord1);\n\t\t\tservice.initializeDrones(inff);\n\n\t\t\tDroneInitializationInfo inff2 = new DroneInitializationInfo(\"Yijuns-UAV\", DroneMode.MODE_VIRTUAL,\n\t\t\t\t\t\"IRIS+\", cord2);\n\t\t\tservice.initializeDrones(inff2);\n\n\t\t\tDroneInitializationInfo inff3 = new DroneInitializationInfo(\"Royal-UAV\", DroneMode.MODE_VIRTUAL,\n\t\t\t\t\t\"IRIS+\", cord3);\n\t\t\tservice.initializeDrones(inff3);\n\n\t\t\tList<FlightRouteInfo> allRoutes = new ArrayList<>(planningService.getItems());\n//\t\t\tint NUM_DRONES = 0;\n//\t\t\tfor (int i = 0; i < NUM_DRONES; i++) {\n//\t\t\t\tdouble coordofset = (double) i / 10000;\n//\t\t\t\tLlaCoordinate coord = new LlaCoordinate((41.519400 + coordofset), -86.239927, 0);\n//\t\t\t\tDroneInitializationInfo dr = new DroneInitializationInfo(\"Sim-Drone\" + i, DroneMode.MODE_VIRTUAL, \"IRIS+\",\n//\t\t\t\t\t\tcoord);\n//\n//\t\t\t\tservice.initializeDrones(dr);\n//\t\t\t}\n\n\t\t\t// for (DroneStatus dr : service.getDrones().values()) {\n\t\t\t// FlightRouteInfo inf = getRandomRoute(allRoutes);\n\t\t\t//\n\t\t\t// managerService.planFlight(dr.getID(), \"randplan\", inf.getWaypoints());\n\t\t\t//\n\t\t\t// }\n\n\t\t\t// for (DroneStatus dr : service.getDrones().values()) {\n\t\t\t// FlightRouteInfo inf = allRoutes.remove(0);\n\t\t\t//\n\t\t\t// managerService.planFlight(dr.getID(), \"randplan\", inf.getWaypoints());\n\t\t\t//\n\t\t\t// }\n\n\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedURLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (NotBoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tstatic Random rand = new Random();\n\n\tprivate static FlightRouteInfo getRandomRoute(List<FlightRouteInfo> allRoutes) {\n\t\tint routeSize = allRoutes.size();\n\n\t\tint randomNumber = rand.nextInt(routeSize);\n\n\t\treturn allRoutes.get(randomNumber);\n\n\t}\n\n}\n"}, {"id": "RemindsConnector.java", "body": "package edu.nd.dronology.monitoring.reminds;\n\nimport java.text.DateFormat;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport com.google.gson.FieldNamingPolicy;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport at.jku.mevss.eventdistributor.core.transmit.TransmittableEventObject;\nimport at.jku.mevss.eventdistributor.core.transmit.TransmittableObjectFactory;\nimport at.jku.mevss.eventpublisher.core.internal.Publisher;\nimport at.jku.mevss.util.utils.PreciseTimestamp;\nimport edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVStateMessage;\n\npublic class RemindsConnector {\n\tstatic Gson gson = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()\n\t\t\t.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).setVersion(1.0)\n\t\t\t.serializeSpecialFloatingPointValues().create();\n\tprivate static Map<String, MockupProbe> stateProbes = new ConcurrentHashMap();\n\tprivate static Map<String, MockupProbe> dronologyProbes = new ConcurrentHashMap<>();\n\tprivate static Map<String, MockupProbe> monitoringProbes = new ConcurrentHashMap<>();\n\tstatic {\n\t\ttry {\n\t\t\tPublisher.setMode(Publisher.Mode.M_SOCKET);\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static synchronized void notify(UAVStateMessage message) {\n\t\tMockupProbe probePoint = getStateProbe(message.getUavid());\n\t\t// p.publish();\n\t\tTransmittableEventObject event = transform(message);\n\t\ttry {\n\t\t\tprobePoint.sendData(event);\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static synchronized void notify(UAVMonitoringMessage message) {\n\t\tMockupProbe probePoint = getMonitoringProbes(message.getUavid());\n\t\t// p.publish();\n\t\tTransmittableEventObject event = transform(message);\n\t\ttry {\n\t\t\tprobePoint.sendData(event);\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t}\n\t}\n\n\t// public static void notify(UAVStateChangeMessage message) {\n\t//\n\t// MockupProbe probePoint = getDronologyProbes(message.getType().name(),\n\t// message.getUavid());\n\t// // p.publish();\n\t// TransmittableEventObject event = transform(message);\n\t// try {\n\t// probePoint.sendData(event);\n\t// } catch (Throwable t) {\n\t// t.printStackTrace();\n\t// }\n\t// }\n\tpublic static void notify(UAVMonitorableMessage message) {\n\t\tMockupProbe probePoint = getProbe(message);\n\t\t// p.publish();\n\t\tTransmittableEventObject event = transform(message);\n\t\ttry {\n\t\t\tprobePoint.sendData(event);\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t}\n\t}\n\n\tprivate static MockupProbe getProbe(UAVMonitorableMessage message) {\n\t\tString uavid = message.getUavid();\n\t\tString msgType = message.getData() != null ? message.getDataType() : message.getType().name();\n\t\tif (msgType.equals(\"GoToCommand\") || msgType.equals(\"TakeoffCommand\") || msgType.equals(\"SetGroundSpeedCommand\")\n\t\t\t\t|| msgType.equals(\"SetModeCommand\")) {\n\t\t\tmsgType = \"flightcontrol\";\n\t\t} else if (message.getDataType().equals(\"STATE_CHANGE\")\n\t\t\t\t|| message.getType().toString().equals(\"STATE_CHANGE\")) {\n\t\t\tmsgType = \"uavcontrol\";\n\t\t}\n\n\t\telse if (msgType.equals(\"planchange\") || message.getType().toString().equals(\"WAYPOINT_REACHED\")\n\t\t\t\t|| msgType.equals(\"FlightPlan\")|| msgType.equals(\"SimpleTakeoffFlightPlan\")) {\n\t\t\tmsgType = \"routeplanning\";\n\t\t} else if (message.getType().toString().equals(\"PHYSICAL_UAV_ACTIVATED\") || message.getDataType().equals(\"FlightMode\")) {\n\t\t\tmsgType = \"uavcontrol\";\n\t\t} else {\n\t\t\tSystem.out.println(\">>>>>>>>>\" + message.toString() + \"::::\" + message.getData());\n\t\t}\n\t\tString id = \"dronology.\" + msgType + \".\" + uavid;\n\t\tif (dronologyProbes.containsKey(id)) {\n\t\t\treturn dronologyProbes.get(id);\n\t\t}\n\t\tString scope = (\"dronology.\" + msgType);\n\t\t// String probename = id + \"-dronologymessage\";\n\t\tMockupProbe pp = new MockupProbe(id, \"DRONOLOGY_INTERNAL\", scope);\n\t\tdronologyProbes.put(id, pp);\n\t\treturn pp;\n\t}\n\n\t// public static void notify(UAVPlanChangeMessage message) {\n\t//\n\t// MockupProbe probePoint = getProbe(message.getType().name(),\n\t// message.getUavid());\n\t// // p.publish();\n\t// TransmittableEventObject event = transform(message);\n\t// try {\n\t// probePoint.sendData(event);\n\t// } catch (Throwable t) {\n\t// t.printStackTrace();\n\t// }\n\t// }\n\tprivate static synchronized MockupProbe getStateProbe(String uavid) {\n\t\tif (stateProbes.containsKey(uavid)) {\n\t\t\treturn stateProbes.get(uavid);\n\t\t}\n\t\tString scope = (\"dronology.gcs1.uav@\" + uavid);\n\t\tString probename = uavid + \"-statemessages\";\n\t\tMockupProbe pp = new MockupProbe(probename, \"CS\", scope);\n\t\tstateProbes.put(uavid, pp);\n\t\treturn pp;\n\t}\n\n\t// private static synchronized MockupProbe getDronologyProbes(String\n\t// messageType, String uavid) {\n\t// String id = \"dronology.\" + messageType + \".\" + uavid;\n\t// if (dronologyProbes.containsKey(id)) {\n\t// return dronologyProbes.get(id);\n\t// }\n\t// String scope = (\"dronology.\" + messageType);\n\t// // String probename = id + \"-dronologymessage\";\n\t// MockupProbe pp = new MockupProbe(id, \"DRONOLOGY_INTERNAL\", scope);\n\t// dronologyProbes.put(id, pp);\n\t// return pp;\n\t// }\n\tprivate static synchronized MockupProbe getMonitoringProbes(String uavid) {\n\t\tif (monitoringProbes.containsKey(uavid)) {\n\t\t\treturn monitoringProbes.get(uavid);\n\t\t}\n\t\tString scope = (\"dronology.gcs1.uav@\" + uavid);\n\t\tString probename = uavid + \"-monitoringmessage\";\n\t\tMockupProbe pp = new MockupProbe(probename, \"CS\", scope);\n\t\tmonitoringProbes.put(uavid, pp);\n\t\treturn pp;\n\t}\n\n\tprivate static TransmittableEventObject transform(UAVStateMessage message) {\n\t\tTransmittableEventObject event = TransmittableObjectFactory.createEventObject(PreciseTimestamp.create(),\n\t\t\t\t\"UAVStateMessage\");\n\t\tevent.addData(TransmittableObjectFactory.createEventData(gson.toJson(message), \"state\"));\n\t\treturn event;\n\t}\n\n\tprivate static TransmittableEventObject transform(UAVMonitoringMessage message) {\n\t\tTransmittableEventObject event = TransmittableObjectFactory.createEventObject(PreciseTimestamp.create(),\n\t\t\t\t\"UAVMonitoringMessage\");\n\t\tevent.addData(TransmittableObjectFactory.createEventData(gson.toJson(message), \"monitoring\"));\n\t\treturn event;\n\t}\n\n\t// private static TransmittableEventObject transform(UAVStateChangeMessage\n\t// message) {\n\t// TransmittableEventObject event =\n\t// TransmittableObjectFactory.createEventObject(PreciseTimestamp.create(),\n\t// \"UAVStateChangeMessage\");\n\t// event.addData(TransmittableObjectFactory.createEventData(gson.toJson(message),\n\t// \"statechange\"));\n\t// return event;\n\t// }\n\t//\n\t// private static TransmittableEventObject transform(UAVPlanChangeMessage\n\t// message) {\n\t// TransmittableEventObject event =\n\t// TransmittableObjectFactory.createEventObject(PreciseTimestamp.create(),\n\t// \"UAVPlanChangeMessage\");\n\t// event.addData(TransmittableObjectFactory.createEventData(gson.toJson(message),\n\t// \"planchange\"));\n\t// return event;\n\t// }\n\tpublic static TransmittableEventObject transform(UAVMonitorableMessage message) {\n\t\tString msgType = message.getData() != null ? message.getDataType() : message.getType().name();\n\t\tif(message.getType().toString().equals(\"WAYPOINT_REACHED\")) {\n\t\t\tmsgType = \"WaypointReached\";\n\t\t}\n\t\tif(message.getType().toString().equals(\"PLAN_ACTIVATED\")) {\n\t\t\tmsgType = \"FlightPlanActivated\";\n\t\t}\n\t\tif(message.getType().toString().equals(\"PLAN_COMPLETE\")) {\n\t\t\tmsgType = \"FlightPlanComplete\";\n\t\t}\n\t\tif(message.getType().toString().equals(\"PHYSICAL_UAV_ACTIVATED\")) {\n\t\t\tmsgType = \"UAVActivation\";\n\t\t}\n\t\tif(message.getType().toString().equals(\"STATE_CHANGE\")) {\n\t\t\tmsgType = \"StateChange\";\n\t\t}\n\t\t\n\t\t\n\t\tif(msgType.equals(\"FlightPlan\")) {\n\t\t\tSystem.out.println(\"xx\");\n\t\t}\n\t\tTransmittableEventObject event = TransmittableObjectFactory.createEventObject(PreciseTimestamp.create(),\n\t\t\t\tmsgType);\n\t\tif (message.getData() != null) {\n\t\t\tevent.addData(TransmittableObjectFactory.createEventData(message.getData(), \"data\"));\n\t\t}\n\t\treturn event;\n\t}\n}"}, {"id": "FlightRouteplanningService.java", "body": "package edu.nd.dronology.services.instances.flightroute;\n\nimport java.util.Collection;\n\nimport edu.nd.dronology.services.core.base.AbstractFileTransmitServerService;\nimport edu.nd.dronology.services.core.info.FlightRouteCategoryInfo;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n/**\n * \n * Service for handling flight routes.<br>\n * Allows creating new routes, retrieving existing routus, and transmitting modified routes.\n * \n * \n * @author Michael Vierhauser  \n *\n */\npublic class FlightRouteplanningService\n\t\textends AbstractFileTransmitServerService<IFlightRouteplanningServiceInstance, FlightRouteInfo> {\n\n\tprivate static volatile FlightRouteplanningService INSTANCE;\n\n\tprotected FlightRouteplanningService() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @return The singleton ConfigurationService instance\n\t */\n\tpublic static FlightRouteplanningService getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (FlightRouteplanningService.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new FlightRouteplanningService();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tprotected IFlightRouteplanningServiceInstance initServiceInstance() {\n\t\treturn new FlightRouteplanningServiceInstance();\n\t}\n\n\tpublic Collection<FlightRouteCategoryInfo> getFlightPathCategories() {\n\t\treturn serviceInstance.getFlightPathCategories();\n\t}\n\n\tpublic FlightRouteInfo getItem(String name) throws DronologyServiceException {\n\t\treturn serviceInstance.getItem(name);\n\t}\n\n\tpublic FlightRouteInfo getRouteByName(String routeName) throws DronologyServiceException {\n\t\treturn serviceInstance.getRouteByName(routeName);\n\t}\n\n}\n"}, {"id": "UAVProxyManager.java", "body": "package edu.nd.dronology.core.vehicle.proxy;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.util.Immutables;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * Singleton class that keeps track of all {@link UAVProxy} instances that have\n * been created.\n */\npublic class UAVProxyManager {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(UAVProxyManager.class);\n\n\tprivate Map<String, IUAVProxy> drones;\n\tprivate static volatile UAVProxyManager INSTANCE = null;\n\n\tprotected UAVProxyManager() {\n\t\tdrones = new HashMap<>();\n\t}\n\n\tpublic static UAVProxyManager getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (UAVProxyManager.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new UAVProxyManager();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\tpublic void testStatus() {\n\t\tLOGGER.info(\"Print current drone dump\");\n\t\tfor (IUAVProxy droneStatus : drones.values()) {\n\t\t\tLOGGER.info(droneStatus.toString());\n\t\t}\n\t}\n\n\t// @Deprecated\n\t// public Map<String, IUAVProxy> getDrones() {\n\t// return Collections.unmodifiableMap(drones);\n\t// }\n\n\tpublic Collection<IUAVProxy> getActiveUAVs() {\n\t\treturn Immutables.linkedListCopy(drones.values());\n\t}\n\n\tpublic void addDrone(IUAVProxy drone) {\n\t\tdrones.put(drone.getID(), drone);\n\t}\n\n\tpublic void removeDrone(String droneID) {\n\t\tif (drones.containsKey(droneID)) {\n\t\t\tdrones.remove(droneID);\n\t\t} else {\n\t\t\tLOGGER.error(\"UAV with '\" + droneID + \"' not found\");\n\t\t}\n\t}\n\n\tpublic void removeDrone(UAVProxy drone) {\n\t\tif (drones.containsKey(drone.getID())) {\n\t\t\tdrones.remove(drone.getID());\n\t\t} else {\n\t\t\tLOGGER.error(\"UAV with '\" + drone.getID() + \"' not found\");\n\t\t}\n\t}\n\n\tpublic IUAVProxy getActiveUAV(String droneID) {\n\t\tif (drones.containsKey(droneID)) {\n\t\t\treturn drones.get(droneID);\n\t\t}\n\t\treturn null;\n\t}\n}\n"}, {"id": "AMMainLayout.java", "body": "package edu.nd.dronology.ui.vaadin.areamapping;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\nimport java.util.LinkedList;\n\nimport com.vaadin.ui.CssLayout;\nimport com.vaadin.ui.CustomComponent;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.areamapping.EdgeLla;\nimport edu.nd.dronology.services.core.areamapping.GeneratedMappedArea;\nimport edu.nd.dronology.services.core.info.AreaMappingInfo;\nimport edu.nd.dronology.services.core.remote.IAreaMappingRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.ui.vaadin.areamapping.windows.AMDeleteMappingConfirmation;\nimport edu.nd.dronology.ui.vaadin.areamapping.windows.AMUnsavedChangesConfirmation;\nimport edu.nd.dronology.ui.vaadin.start.MyUI;\nimport edu.nd.dronology.ui.vaadin.utils.WaitingWindow;\nimport edu.nd.dronology.ui.vaadin.utils.WaypointReplace;\n\n/**\n * This is the main layout for the Area Mapping UI.\n * \n * @author Andrew Slavin\n */\n\npublic class AMMainLayout extends CustomComponent {\n\n\tprivate static final long serialVersionUID = -4912347541234441237L;\n\tprivate AMControlsComponent controls = new AMControlsComponent(this);\n\tprivate AMMapComponent mapComponent;\n\tprivate AMDeleteMappingConfirmation deleteMappingConfirmation;\n\tprivate AMUnsavedChangesConfirmation unsavedChangesConfirmation;\n\tprivate WaitingWindow waitingWindow = new WaitingWindow();\n\tprivate Boolean deletingMapping = false;\n\n\t@WaypointReplace\n\tpublic AMMainLayout() {\n\t\taddStyleName(\"main_layout\");\n\t\tCssLayout content = new CssLayout();\n\t\tcontent.setSizeFull();\n\n\t\tmapComponent = new AMMapComponent(this);\n\n\t\tdeleteMappingConfirmation = new AMDeleteMappingConfirmation(this);\n\t\tunsavedChangesConfirmation = new AMUnsavedChangesConfirmation(this);\n\n\t\tcontent.addComponents(controls, mapComponent);\n\t\tsetCompositionRoot(content);\n\t}\n\n\tpublic AMDeleteMappingConfirmation getDeleteMappingConfirmation() {\n\t\treturn deleteMappingConfirmation;\n\t}\n\n\tpublic AMUnsavedChangesConfirmation getUnsavedChangesConfirmation() {\n\t\treturn unsavedChangesConfirmation;\n\t}\n\n\tpublic WaitingWindow getWaitingWindow() {\n\t\treturn waitingWindow;\n\t}\n\n\t// Displays the mapping that is clicked\n\tpublic void switchMapping(AMInfoBox switchToInfoBox) {\n\t\t// When one mapping is clicked, the others go back to default background color.\n\t\tcontrols.getInfoPanel().unhighlightAllInfoBoxes();\n\t\tcontrols.getInfoPanel()\n\t\t\t\t.highlightInfoBox(controls.getInfoPanel().getMappingIndex(switchToInfoBox.getAreaMappingInfo()));\n\n\t\t// Displays the mapping on map.\n\t\tmapComponent.displayAreaMapping(switchToInfoBox.getAreaMappingInfo());\n\t}\n\n\t// runs the algorithm when \"generate route\" is clicked in metainfo\n\tpublic void generateRouteFromMapping(Collection<IUAVProxy> dronesToSend) {\n\t\t// send stuff to Dronology\n\t\ttry {\n\t\t\tIAreaMappingRemoteService service = (IAreaMappingRemoteService) MyUI.getProvider().getRemoteManager()\n\t\t\t\t\t.getService(IAreaMappingRemoteService.class);\n\n\t\t\tAreaMappingInfo info = mapComponent.getMetaInfo().getMappingInfo();\n\t\t\t\n\t\t\t// if upstream is opposite the way that it was drawn, flip the points around\n\t\t\tif (!mapComponent.getMapUtilities().getUpstream()) {\n\t\t\t\tLinkedList<EdgeLla> originalList1 = info.getCoordinates(0);\n\t\t\t\tLinkedList<EdgeLla> swappedList1 = new LinkedList<>();\n\t\t\t\tfor (int i = originalList1.size()-1; i >= 0; i--) {\n\t\t\t\t\tswappedList1.add(originalList1.get(i));\n\t\t\t\t\tinfo.removeCoordinate(0, originalList1.get(i));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < swappedList1.size(); i++) {\n\t\t\t\t\tinfo.addCoordinate(0, swappedList1.get(i));\n\t\t\t\t}\n\t\t\t\tLinkedList<EdgeLla> originalList2 = info.getCoordinates(1);\n\t\t\t\tLinkedList<EdgeLla> swappedList2 = new LinkedList<>();\n\t\t\t\tfor (int i = originalList2.size()-1; i >= 0; i--) {\n\t\t\t\t\tswappedList2.add(originalList2.get(i));\n\t\t\t\t\tinfo.removeCoordinate(1, originalList2.get(i));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < swappedList2.size(); i++) {\n\t\t\t\t\tinfo.addCoordinate(1, swappedList2.get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tGeneratedMappedArea generated = service.generateAreaMapping(info, dronesToSend);\n\t\t\tservice.executeAreaMapping(generated);\n\n\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t// Gets the controls component that holds the infoPanel and mainLayout.\n\tpublic AMControlsComponent getControls() {\n\t\treturn controls;\n\t}\n\n\t// Gets the currently displayed map.\n\tpublic AMMapComponent getMapComponent() {\n\t\treturn mapComponent;\n\t}\n\n\t// sets the map component\n\tpublic void setMapComponent(AMMapComponent mapComponent) {\n\t\tthis.mapComponent = mapComponent;\n\t}\n\n\tpublic Boolean getDeletingMapping() {\n\t\treturn deletingMapping;\n\t}\n\n\tpublic void setDeletingMapping(Boolean deletingMapping) {\n\t\tthis.deletingMapping = deletingMapping;\n\t}\n}"}, {"id": "ExportAllocationInformation.java", "body": "package edu.nd.dronology.services.core.areamapping;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ExportAllocationInformation {\n\tprivate List<ExportDrone> droneAllocations;\n\tprivate MetricsStatistics metricsStatistics;\n\t\n\tpublic ExportAllocationInformation() {\n\t\tdroneAllocations = new ArrayList<>();\n\t}\n\t\n\tpublic List<ExportDrone> getDroneAllocations(){\n\t\treturn droneAllocations;\n\t}\n\t\n\tpublic MetricsStatistics getMetricStatistics() {\n\t\treturn metricsStatistics;\n\t}\n\t\n\tpublic void addDroneAllocation(ExportDrone droneAllocation) {\n\t\tdroneAllocations.add(droneAllocation);\n\t}\n\t\n\tpublic void setDroneAllocations(List<ExportDrone> droneAllocations) {\n\t\tthis.droneAllocations = droneAllocations;\n\t}\n\t\n\tpublic void setMetricsStatistics(MetricsStatistics metricsStatistics) {\n\t\tthis.metricsStatistics = metricsStatistics;\n\t}\n}\n"}, {"id": "GeneratedMappedArea.java", "body": "package edu.nd.dronology.services.core.areamapping;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class GeneratedMappedArea implements Serializable {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 5991442648634740620L;\n\n\tList<ExportDrone> uavList = new ArrayList<>();\n\n\tpublic void addUAVRouteAssignment(ExportDrone ed) {\n\t\tuavList.add(ed);\n\n\t}\n\n\tpublic List<ExportDrone> getUAVAssignments() {\n\t\treturn Collections.unmodifiableList(uavList);\n\t}\n\n}\n"}, {"id": "WorkspaceInitializer.java", "body": "package edu.nd.dronology.services.supervisor;\n\nimport java.io.File;\nimport java.security.CodeSource;\n\nimport edu.nd.dronology.services.core.util.DronologyConstants;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.util.FileUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class WorkspaceInitializer {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(WorkspaceInitializer.class);\n\tprivate String root;\n\tprivate static WorkspaceInitializer instance = new WorkspaceInitializer();\n\n\tprivate void prepareRoot() throws DronologyServiceException {\n\t\tif (root == null) {\n\t\t\troot = getDefaultRootFolder();\n\t\t}\n\t\tif (root == null) {\n\t\t\troot = DronologyConstants.DEFAULT_ROOT_FOLDER;\n\t\t}\n\n\t\t// Replace file path in Windows\n\t\troot = root.replace(\"file:\\\\\", \"\");\n\t\t// Replace file path on Linux/MAC\n\t\troot = root.replace(\"file:/\", \"/\");\n\n\t\tLOGGER.info(\"Server workspace root location is: '\" + root + \"'\");\n\n\t\tFile f = new File(root);\n\t\tLOGGER.info(\"Absolute path is: '\" + f.getPath().toString() + \"'\");\n\t\tif (!f.exists()) {\n\t\t\tf.mkdirs();\n\t\t}\n\t\ttry {\n\t\t\troot = f.getPath();\n\t\t} catch (Exception e) {\n\t\t\tthrow new DronologyServiceException(\"Error when setting workspace root '\" + root + \"'\");\n\t\t}\n\t}\n\n\tprivate String getDefaultRootFolder() throws DronologyServiceException {\n\t\tCodeSource codeSource = WorkspaceInitializer.class.getProtectionDomain().getCodeSource();\n\t\tFile codeFolder;\n\t\tcodeFolder = new File(codeSource.getLocation().toExternalForm());\n\t\tFile parent = codeFolder.getParentFile();\n\t\tif (parent == null) {\n\t\t\treturn null;\n\t\t}\n\t\tFile ws = parent.getParentFile();\n\t\tif (ws == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn ws.getPath() + File.separator + DronologyConstants.DRONOLOGY_ROOT_FOLDER;\n\t}\n\n\tpublic void prepareServerWorkspace(String workspace) throws DronologyServiceException {\n\t\tthis.root = formatPath(workspace);\n\t\tprepareRoot();\n\t\tprepareFlightPathWorkspace();\n\t\tprepareSpecificationWorkspace();\n\t\tprepareAreaMappingWorkspace();\n\t\tprepareMissionPlanningWorkspace();\n\t}\n\n\tprivate String formatPath(String workspace) {\n\t\tif (workspace == null) {\n\t\t\treturn null;\n\t\t}\n\t\tString formated = workspace.replace(\"/\", \"\\\\\");\n\t\treturn formated;\n\t}\n\n\tprivate void prepareFlightPathWorkspace() {\n\t\tString folderPath = getFlightRouteLocation();\n\t\tFile f = new File(folderPath);\n\t\tif (!f.exists()) {\n\t\t\tf.mkdirs();\n\t\t}\n\t}\n\n\tprivate void prepareSpecificationWorkspace() {\n\t\tString folderPath = getDroneSpecificationLocation();\n\t\tFile f = new File(folderPath);\n\t\tif (!f.exists()) {\n\t\t\tf.mkdirs();\n\t\t}\n\t}\n\t\n\tprivate void prepareMissionPlanningWorkspace() {\n\t\tString folderPath = getMissionPlanningLocation();\n\t\tFile f = new File(folderPath);\n\t\tif (!f.exists()) {\n\t\t\tf.mkdirs();\n\t\t}\n\t}\n\t\n\tprivate void prepareAreaMappingWorkspace() {\n\t\tString folderPath = getAreaMappingLocation();\n\t\tFile f = new File(folderPath);\n\t\tif (!f.exists()) {\n\t\t\tf.mkdirs();\n\t\t}\n\t}\n\n\tString getWorkspaceLocation() {\n\t\treturn root;\n\t}\n\n\tString getFlightRouteLocation() {\n\t\treturn root + File.separator + DronologyConstants.FOLDER_FLIGHTROUTE;\n\t}\n\n\tpublic String getSimScenarioLocation() {\n\t\treturn root + File.separator + DronologyConstants.FOLDERN_SIM_SCENARIO;\n\t}\n\n\tpublic String getDroneSpecificationLocation() {\n\t\treturn root + File.separator + DronologyConstants.FOLDER_REGISTRATION;\n\t}\n\t\n\tpublic String getAreaMappingLocation() {\n\t\treturn root + File.separator + DronologyConstants.FOLDER_AREAMAPPING;\n\t}\n\n\tpublic String getMissionPlanningLocation() {\n\t\treturn root + File.separator + DronologyConstants.FOLDER_MISSIONPLANNING;\n\t}\n\n\tpublic static WorkspaceInitializer getInstance() {\n\t\treturn instance;\n\t}\n\n\tpublic boolean importItem(String fileName, byte[] byteArray, boolean overwrite) throws DronologyServiceException {\n\t\tString ext = FileUtil.getExtension(fileName);\n\t\tif (ext == null) {\n\t\t\tLOGGER.warn(\"File with no extension found '\" + fileName + \"'\");\n\t\t\treturn false;\n\t\t}\n\t\tswitch (ext) {\n\t\tcase DronologyConstants.EXTENSION_FLIGHTROUTE:\n\t\t\treturn importFlightPath(fileName, byteArray, overwrite);\n\t\tdefault:\n\t\t\tLOGGER.warn(\"File with extension '\" + FileUtil.getExtension(fileName) + \"' not processable\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean importFlightPath(String fileName, byte[] content, boolean overwrite) {\n\t\tString location = getFlightRouteLocation();\n\t\tString fName = location + File.separator + fileName;\n\t\treturn importFile(fName, content, overwrite);\n\n\t}\n\n\tprivate boolean importFile(String absolutePath, byte[] content, boolean overwrite) {\n\t\tFile f = new File(absolutePath);\n\t\tif (f.exists() && !overwrite) {\n\t\t\treturn false;\n\t\t}\n\t\treturn FileUtil.saveByteArrayToFile(f, content);\n\t}\n\n\n\n}\n"}, {"id": "GroundStationException.java", "body": "package edu.nd.dronology.gstation.connector;\n\npublic class GroundStationException extends Exception {\n\n\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 4245430380511186933L;\n\t\n\t\n\tpublic GroundStationException(String text) {\n\t\tsuper(text);\n\t}\n\n}\n"}, {"id": "SoloDirector.java", "body": "package edu.nd.dronology.core.flight.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport edu.nd.dronology.util.NullUtil;\nimport edu.nd.dronology.core.Discuss;\nimport edu.nd.dronology.core.DronologyConstants;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.exceptions.FlightZoneException;\nimport edu.nd.dronology.core.flight.IFlightDirector;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * Directions for one flight containing multiple waypoints.\n * \n * @author Jane Cleland-Huang\n * \n */\npublic class SoloDirector implements IFlightDirector {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(SoloDirector.class);\n\n\tprivate final ManagedDrone drone;\n\tprivate boolean safetyDiversion = false;\n\tprivate LlaCoordinate targetPosition = null;\n\tprivate List<Waypoint> wayPoints = new ArrayList<>();\n\tprivate List<LlaCoordinate> roundaboutPath = new ArrayList<>();\n\n\t@Override\n\tpublic LlaCoordinate flyToNextPoint() {\n\t\ttargetPosition = flyToNextWayPoint();\n\t\treturn targetPosition;\n\t}\n\n\tpublic List<Waypoint> getWayPoints() {\n\t\treturn new ArrayList<>(this.wayPoints);\n\t}\n\n\t/**\n\t * Constructor\n\t * \n\t * @param managedDrone\n\t */\n\tpublic SoloDirector(ManagedDrone managedDrone) {\n\t\tthis.drone = managedDrone;\n\t}\n\n\t@Override\n\tpublic void setWayPoints(List<Waypoint> wayPoints) {\n\t\tthis.wayPoints = new ArrayList<>(wayPoints);\n\t}\n\n\t@Override\n\tpublic void clearWayPoints() {\n\t\twayPoints.clear();\n\t}\n\n\t@Override\n\tpublic boolean hasMoreWayPoints() {\n\t\treturn !wayPoints.isEmpty();\n\t}\n\n\t@Discuss(discuss = \"this is called way to often.. needs fixing\")\n\tprivate LlaCoordinate flyToNextWayPoint() {\n\t\t// LOGGER.info(\"Flying to next waypoint\");\n\t\tif (!wayPoints.isEmpty()) {\n\t\t\tWaypoint nextWaypoint = wayPoints.get(0);\n\t\t\tdrone.flyTo(nextWaypoint.getCoordinate(), nextWaypoint.getApproachingspeed());\n\t\t\treturn nextWaypoint.getCoordinate();\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean isUnderSafetyDirectives() {\n\t\treturn safetyDiversion;\n\t}\n\n\t@Override\n\tpublic void clearCurrentWayPoint() {\n\t\tif (isUnderSafetyDirectives()) {\n\t\t\tif (!roundaboutPath.isEmpty()) {\n\t\t\t\troundaboutPath.remove(0);\n\t\t\t\tif (roundaboutPath.isEmpty()) { \n\t\t\t\t\tsafetyDiversion = false;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!wayPoints.isEmpty()) {\n\t\t\t\tWaypoint wp = wayPoints.remove(0);\n\t\t\t\twp.reached(true);\n\t\t\t}\n\t\t\tif (wayPoints.isEmpty()) {\n\t\t\t\ttry { \n\t\t\t\t\tdrone.getFlightModeState().setModeToInAir(); \n\t\t\t\t} catch (FlightZoneException e) {\n\t\t\t\t\tLOGGER.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addWayPoint(Waypoint wayPoint) {\n\t\twayPoints.add(wayPoint);\n\t}\n\n\t@Override\n\tpublic void flyHome() {\n\t\tdrone.flyTo(drone.getBaseCoordinates(), DronologyConstants.RETURN_TO_HOME_SPEED);\n\n\t}\n\n\t@Override\n\tpublic void returnHome(Waypoint home) {\n\t\tNullUtil.checkNull(home);\n\t\taddWayPoint(home);\n\t\tArrayList<Waypoint> tempWayPoints = new ArrayList<>(wayPoints);\n\n\t\tfor (Waypoint wayPoint : tempWayPoints) {\n\t\t\tif (!wayPoint.equals(home)) {\n\t\t\t\twayPoints.remove(wayPoint);\n\t\t\t}\n\t\t}\n\n\t\t// Should only have one waypoint left and ready to go home!!\n\t}\n\n\t@Override\n\tpublic boolean readyToLand() {\n\t\treturn hasMoreWayPoints();\n\n\t}\n\n\t@Override\n\tpublic boolean readyToTakeOff() {\n\t\tif (!hasMoreWayPoints()) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n}\n"}, {"id": "Drone.java", "body": "package edu.nd.dronology.services.extensions.areamapping.metrics;\n\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.collections4.Get;\nimport org.apache.logging.log4j.core.appender.routing.Route;\n\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\n\npublic class Drone {\n\tprivate Point2D.Double startPoint;\n\tprivate Point2D.Double homeLocation;\n\tprivate DroneRouteAssignment routeAssignment;\n\tprivate String UAVId;\n\t\n\tpublic Drone() {\n\t\tstartPoint = new Point2D.Double();\n\t\thomeLocation = new Point2D.Double();\n\t\trouteAssignment = new DroneRouteAssignment();\n\t}\n\t\n\tpublic Point2D.Double getDroneStartPoint(){\n\t\treturn startPoint;\n\t}\n\t\n\tpublic Point2D.Double getDroneHomeLocation(){\n\t\treturn homeLocation;\n\t}\n\t\n\tpublic DroneRouteAssignment getDroneRouteAssignment() {\n\t\treturn routeAssignment;\n\t}\n\t\n\tpublic List<Point2D.Double> getDroneFullRoute() {\n\t\tList<Point2D.Double> fullRoute = new ArrayList<>();\n\t\tfor(RoutePrimitive route : routeAssignment.get()) {\n\t\t\tfullRoute.addAll(route.getRoute());\n\t\t}\n\t\treturn fullRoute;\n\t}\n\t\n\tpublic void setDroneStartPoint(Point2D.Double start) {\n\t\tstartPoint = start;\n\t}\n\t\n\tpublic void setDroneHomeLocation(Point2D.Double home) {\n\t\thomeLocation = home;\n\t}\n\t\n\tpublic void setDroneRouteAssignment(DroneRouteAssignment route) {\n\t\trouteAssignment = route;\n\t}\n\n\tpublic String getUAVId() {\n\t\treturn UAVId;\n\t}\n\n\tpublic void setUAVId(String UAVId) {\n\t\tthis.UAVId = UAVId;\n\t}\n}\n"}, {"id": "IUAVSafetyValidator.java", "body": "package edu.nd.dronology.gstation.connector;\n\npublic interface IUAVSafetyValidator {\n\n\tboolean validate(String uavid, String safetyCase);\n\n}\n"}, {"id": "DronologyElementFactory.java", "body": "package edu.nd.dronology.services.extensions.areamapping.instances;\n\nimport edu.nd.dronology.services.core.items.AreaMapping;\nimport edu.nd.dronology.services.core.items.IAreaMapping;\n\npublic class DronologyElementFactory {\n\n\t\n\n\tpublic static IAreaMapping createNewAreaMapping() {\n\t\treturn new AreaMapping();\n\t}\n\n\n}\n"}, {"id": "IncommingGroundstationConnectionServer.java", "body": "package edu.nd.dronology.gstation.connector.connect;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\n\nimport edu.nd.dronology.gstation.connector.GroundstationConnector;\nimport edu.nd.dronology.gstation.connector.service.connector.DroneConnectorService;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * The {@link IncommingGroundstationConnectionServer} listens on a predefined port for new connections from GCS.\n * \n * \n * @author Michael Vierhauser\n */\n \npublic class IncommingGroundstationConnectionServer implements Runnable {\n\tprivate int port = 1234;\n\tprivate ServerSocket serverSocket;\n\tprivate boolean cont = true;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(IncommingGroundstationConnectionServer.class);\n\tprivate String URL = \"127.0.0.1\";\n\n\tpublic IncommingGroundstationConnectionServer() {\n\n\t}\n\n\t@Override\n\tpublic void run() {\n\n\t\tserverSocket = null;\n\t\ttry {\n\t\t\tserverSocket = new ServerSocket(port, 3000);\n\t\t\t// server.setReuseAddress(true);\n\n\t\t\tLOGGER.info(\"Incomming-Groundstation Connection Server listening on port: \" + port);\n\t\t\t// server.setSoTimeout(1000);\n\n\t\t\twhile (cont) {\n\t\t\t\tSocket socket = null;\n\t\t\t\ttry {\n\t\t\t\t\tsocket = serverSocket.accept();\n\t\t\t\t\tGroundstationConnector handler = new GroundstationConnector(this, socket);\n\t\t\t\t\tDroneConnectorService.getInstance().handleConnection(handler);\n\n\t\t\t\t} catch (SocketException e) {\n\t\t\t\t\tLOGGER.info(\"Socket was closed!\");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLOGGER.error(e);\n\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (serverSocket != null) {\n\t\t\t\t\tserverSocket.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n\n}\n"}, {"id": "UAVTypeRegistrationServiceRemoteFacade.java", "body": "package edu.nd.dronology.services.facades;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\n\nimport org.apache.commons.lang.NotImplementedException;\n\nimport edu.nd.dronology.services.core.info.UAVTypeRegistrationInfo;\nimport edu.nd.dronology.services.core.listener.IItemChangeListener;\nimport edu.nd.dronology.services.core.remote.IUAVTypeRegistrationRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.instances.registration.types.UAVTypeRegistrationService;\nimport edu.nd.dronology.services.remote.AbstractRemoteFacade;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class UAVTypeRegistrationServiceRemoteFacade extends AbstractRemoteFacade implements IUAVTypeRegistrationRemoteService {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -4580658378477037955L;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(UAVTypeRegistrationServiceRemoteFacade.class);\n\tprivate static volatile UAVTypeRegistrationServiceRemoteFacade INSTANCE;\n\n\tprotected UAVTypeRegistrationServiceRemoteFacade() throws RemoteException {\n\t\tsuper(UAVTypeRegistrationService.getInstance());\n\t}\n\n\tpublic static IUAVTypeRegistrationRemoteService getInstance() throws RemoteException {\n\t\tif (INSTANCE == null) {\n\t\t\ttry {\n\t\t\t\tsynchronized (UAVTypeRegistrationServiceRemoteFacade.class) {\n\t\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\t\tINSTANCE = new UAVTypeRegistrationServiceRemoteFacade();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (RemoteException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tpublic byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException {\n\t\treturn UAVTypeRegistrationService.getInstance().requestFromServer(id);\n\t}\n\n\t@Override\n\tpublic void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException {\n\t\tUAVTypeRegistrationService.getInstance().transmitToServer(id, content);\n\n\t}\n\n\t@Override\n\tpublic boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException {\n\t\tthrow new NotImplementedException();\n\t}\n\n\t@Override\n\tpublic boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException {\n\t\tthrow new NotImplementedException();\n\t}\n\n\t@Override\n\tpublic Collection<UAVTypeRegistrationInfo> getItems() throws RemoteException {\n\t\treturn UAVTypeRegistrationService.getInstance().getItems();\n\t}\n\n\t@Override\n\tpublic UAVTypeRegistrationInfo createItem() throws RemoteException, DronologyServiceException {\n\t\treturn UAVTypeRegistrationService.getInstance().createItem();\n\t}\n\n\t@Override\n\tpublic void deleteItem(String itemid) throws RemoteException, DronologyServiceException {\n\t\t// TODO Auto-generated method stub\n\t\tthrow new NotImplementedException();\n\t}\n\n\n\n}"}, {"id": "ISupervisorServiceInstance.java", "body": "package edu.nd.dronology.services.supervisor;\n\nimport java.util.Map;\n\nimport edu.nd.dronology.services.core.api.IServiceInstance;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n\n/**\n * \n * \n * @author Michael Vierhauser\n * \n */\npublic interface ISupervisorServiceInstance extends IServiceInstance {\n\n\tvoid shutdownServer();\n\n\tvoid restartAllServices();\n\n\n\tString getWorkspaceLocation();\n\n\tMap<String, String> getGlobalProperties();\n\n\tboolean importItem(String fileName, byte[] byteArray, boolean overwrite) throws DronologyServiceException;\n\n\t\n\n\tString getFlightPathLocation();\n\n\tString getDroneSpecificationLocation();\n\n\tString getSimScenarioLocation();\n\n\tString getAreaMappingLocation();\n\n\tString getMissionPlanningLocation();\n\n\n\n}\n"}, {"id": "GeofenceRectangle.java", "body": "package edu.nd.dronology.monitoring.simplechecker.checker;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\npublic class GeofenceRectangle {\n\n\tdouble lonStart;\n\tdouble lonEnd;\n\tdouble latStart;\n\tdouble latEnd;\n\n\tpublic GeofenceRectangle(double latStart, double latEnd, double lonStart, double lonEnd) {\n\t\tthis.latStart = latStart;\n\t\tthis.latEnd = latEnd;\n\t\tthis.lonStart = lonStart;\n\t\tthis.lonEnd = lonEnd;\n\t}\n\n\tpublic GeofenceRectangle(LlaCoordinate topLeft, LlaCoordinate bottomRight) {\n\t\tthis(topLeft.getLatitude(), bottomRight.getLatitude(), topLeft.getLongitude(), bottomRight.getLongitude());\n\t}\n\n\tpublic boolean isInside(LlaCoordinate toCheck) {\n\t\tdouble lat = toCheck.getLatitude();\n\t\tdouble lon = toCheck.getLongitude();\n\t\treturn lat < latStart && lat > latEnd && lon > lonStart && lon < lonEnd;\n\n\t}\n}\n"}, {"id": "RemoteManager.java", "body": "package edu.nd.dronology.services.remote;\n\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport edu.nd.dronology.services.core.api.ServiceInfo;\nimport edu.nd.dronology.services.core.base.AbstractServerService;\nimport edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;\nimport edu.nd.dronology.services.core.remote.IDroneSimulatorRemoteService;\nimport edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;\nimport edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\nimport edu.nd.dronology.services.core.remote.IRemoteServiceListener;\nimport edu.nd.dronology.services.core.remote.IRemoteableService;\nimport edu.nd.dronology.services.core.remote.IUAVEquipmentTypeRegistrationRemoteService;\nimport edu.nd.dronology.services.core.remote.IUAVRegistrationRemoteService;\nimport edu.nd.dronology.services.core.remote.IUAVTypeRegistrationRemoteService;\nimport edu.nd.dronology.services.core.remote.RemoteInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.facades.DroneSetupServiceRemoteFacade;\nimport edu.nd.dronology.services.facades.DroneSimulatorServiceRemoteFacade;\nimport edu.nd.dronology.services.facades.FlightManagerServiceRemoteFacade;\nimport edu.nd.dronology.services.facades.FlightRouteplanningServiceRemoteFacade;\nimport edu.nd.dronology.services.facades.UAVEquipmentTypeRegistrationServiceRemoteFacade;\nimport edu.nd.dronology.services.facades.UAVRegistrationServiceRemoteFacade;\nimport edu.nd.dronology.services.facades.UAVTypeRegistrationServiceRemoteFacade;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class RemoteManager implements IRemoteManager {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -2718289978864805774L;\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(RemoteManager.class);\n\n\tprivate static RemoteManager instance;\n\n\tprivate Map<Class, IRemoteableService> externalServices = new HashMap<>();\n\n\t/**\n\t * @return The singleton instance of the RemoteManager.\n\t */\n\tpublic static IRemoteManager getInstance() {\n\t\tif (instance == null) {\n\t\t\tinstance = new RemoteManager();\n\t\t}\n\t\treturn instance;\n\t}\n\n\t@Override\n\tpublic Object getService(Class<?> service) throws RemoteException, DronologyServiceException {\n\t\tif (!IRemoteableService.class.isAssignableFrom(service)) {\n\t\t\tthrow new DronologyServiceException(\n\t\t\t\t\t\"Invalid service requested - Valid services extend \" + IRemoteableService.class.getCanonicalName());\n\t\t}\n\n\t\tif (service.equals(IFlightRouteplanningRemoteService.class)) {\n\t\t\treturn FlightRouteplanningServiceRemoteFacade.getInstance();\n\t\t}\n\n\t\tif (service.equals(IFlightManagerRemoteService.class)) {\n\t\t\treturn FlightManagerServiceRemoteFacade.getInstance();\n\t\t}\n\n\t\tif (service.equals(IDroneSetupRemoteService.class)) {\n\t\t\treturn DroneSetupServiceRemoteFacade.getInstance();\n\t\t}\n\n\t\tif (service.equals(IUAVRegistrationRemoteService.class)) {\n\t\t\treturn UAVRegistrationServiceRemoteFacade.getInstance();\n\t\t}\n\n\t\tif (service.equals(IUAVTypeRegistrationRemoteService.class)) {\n\t\t\treturn UAVTypeRegistrationServiceRemoteFacade.getInstance();\n\t\t}\n\n\t\tif (service.equals(IDroneSimulatorRemoteService.class)) {\n\t\t\treturn DroneSimulatorServiceRemoteFacade.getInstance();\n\t\t}\n\t\tif (service.equals(IUAVEquipmentTypeRegistrationRemoteService.class)) {\n\t\t\treturn UAVEquipmentTypeRegistrationServiceRemoteFacade.getInstance();\n\t\t}\n\n\t\tif (externalServices.containsKey(service)) {\n\t\t\treturn externalServices.get(service);\n\t\t}\n\n\t\tthrow new DronologyServiceException(\"Service\" + service.getCanonicalName() + \" not found!\");\n\n\t}\n\n\t@Override\n\tpublic void addServiceListener(IRemoteServiceListener processListener) throws RemoteException {\n\t\tAbstractServerService.addUniversialServiceListener(new RemoteServerProcessListenerAdapter(processListener));\n\n\t}\n\n\t@Override\n\tpublic void removeServiceListener(IRemoteServiceListener processListener) throws RemoteException {\n\t\tAbstractServerService.removeUniversialServiceListener(new RemoteServerProcessListenerAdapter(processListener));\n\n\t}\n\n\t@Override\n\tpublic List<ServiceInfo> getServices() throws RemoteException, DronologyServiceException {\n\n\t\tList<ServiceInfo> allServices = new ArrayList<>();\n\n\t\tallServices.addAll(getCoreServices());\n\t\t// allServices.addAll(getExtensionServices());\n\n\t\treturn Collections.unmodifiableList(allServices);\n\n\t}\n\n\t@Override\n\tpublic List<ServiceInfo> getCoreServices() throws RemoteException, DronologyServiceException {\n\t\treturn AbstractServerService.getCoreServices();\n\t}\n\n\t@Override\n\tpublic List<ServiceInfo> getAllServices() throws RemoteException, DronologyServiceException {\n\t\treturn AbstractServerService.getServiceInfos();\n\t}\n\n\t@Override\n\tpublic List<ServiceInfo> getFileServices() throws RemoteException, DronologyServiceException {\n\t\treturn AbstractServerService.getFileServiceInfos();\n\t}\n\n\t@Override\n\tpublic void contributeService(Class service, IRemoteableService serviceInstance)\n\t\t\tthrows RemoteException, DronologyServiceException {\n\t\texternalServices.put(service, serviceInstance);\n\t}\n\n\t@Override\n\tpublic void register(RemoteInfo rInfo) throws RemoteException {\n\t\tRemoteService.getInstance().register(rInfo);\n\n\t}\n\n\t@Override\n\tpublic void unregister(RemoteInfo rInfo) throws RemoteException {\n\t\tRemoteService.getInstance().unregister(rInfo);\n\t}\n\n\t@Override\n\tpublic void initialize() throws RemoteException, DronologyServiceException {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n\t@Override\n\tpublic void tearDown() throws RemoteException, DronologyServiceException {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"}, {"id": "ImageWaypoints.java", "body": "package edu.nd.dronology.services.extensions.areamapping.internal;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Vector;\n\npublic class ImageWaypoints {\n\t\n\tprivate List<ImageWaypoint> imageWaypoints;\n\t\n\t\n\tpublic ImageWaypoints() {\n\t\timageWaypoints = new Vector<ImageWaypoint>();\n\t}\n\t\n\tpublic void add(ImageWaypoint bankNode) {\n\t\timageWaypoints.add(bankNode);\n\t}\n\t\n\tpublic void reverse() {\n\t\tCollections.reverse(imageWaypoints);\n\t}\n\t\n\tpublic List<ImageWaypoint> get(){\n\t\treturn Collections.unmodifiableList(imageWaypoints);\n\t}\n\t\n\tpublic ImageWaypoint get(int entry){\n\t\treturn imageWaypoints.get(entry);\n\t}\n\t\n\tpublic void set(int index, ImageWaypoint entry) {\n\t\timageWaypoints.set(index, entry);\n\t}\n\t\n\tpublic int size() {\n\t\treturn imageWaypoints.size();\n\t}\n\n\n}\n"}, {"id": "IServiceInstance.java", "body": "package edu.nd.dronology.services.core.api;\n\nimport java.util.Properties;\n\nimport edu.nd.dronology.services.core.listener.IServiceListener;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n/**\n * Base interface for all server processes.\n * \n * \n * @author Michael Vierhauser\n * \n */\npublic interface IServiceInstance {\n\n\t/**\n\t * \n\t * @return The id of the service.\n\t */\n\tpublic String getServiceID();\n\n\t/**\n\t * \n\t * @return The human readable description for this service.\n\t */\n\tpublic String getDescription();\n\n\t/**\n\t * @return The configuration properties of the service containing infos on host, port...\n\t */\n\tpublic Properties getConfigurationProperties();\n\n\t/**\n\t * \n\t * @return The current status of the service.\n\t */\n\tpublic ServiceStatus getStatus();\n\n\t/**\n\t * Starts the services.\n\t * \n\t * @throws DronologyServiceException\n\t */\n\tvoid startService() throws DronologyServiceException;\n\n\t/**\n\t * Stops the service.\n\t * \n\t * @throws DronologyServiceException\n\t */\n\tvoid stopService() throws DronologyServiceException;\n\n\t/**\n\t * @return The {@link ServiceInfo} object.\n\t */\n\tpublic ServiceInfo getServiceInfo();\n\n\t/**\n\t * Adds a new {@link IServiceListener} to the service.<br>\n\t * The listener is triggered when the status of the service changes.\n\t * \n\t * @param listener\n\t *          The listener to be added.\n\t * @return True if adding was performed successfully, false otherwise.\n\t */\n\tboolean addServiceListener(IServiceListener listener);\n\n\t/**\n\t * \n\t * @param listener\n\t *          The listener to be removed.\n\t * @return True if removing was performed successfully, false otherwise.\n\t */\n\tboolean remoteServiceListener(IServiceListener listener);\n\n\n\n\n}\n"}, {"id": "EdgeLla.java", "body": "package edu.nd.dronology.services.core.areamapping;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\n/**\n * Implements Coordinate, but also has an edge member, which denotes the side of the mapping that a coordinate belongs to.\n * \n * @author Andrew Slavin\n *\n */\n\npublic class EdgeLla extends LlaCoordinate {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate int side;\n\t\n\t\n\tpublic EdgeLla(double latitude, double longitude, double side) {\n\t\tsuper(latitude, longitude, 0);\n\t\tthis.side = (int)side;\n\t}\n\t\n\tpublic int getSide() {\n\t\treturn side;\n\t}\n\t\n\tpublic void setSide(int side) {\n\t\tthis.side = side;\n\t}\n\t\n\n}\n"}, {"id": "MetricsRunner.java", "body": "package edu.nd.dronology.services.extensions.areamapping.metrics;\n\nimport java.awt.geom.Path2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.thoughtworks.xstream.io.path.Path;\n\nimport edu.nd.dronology.services.core.areamapping.MetricsStatistics;\nimport edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\nimport edu.nd.dronology.services.extensions.areamapping.util.Utilities;\n\npublic class MetricsRunner {\n\tprivate List<Drone> drones;\n\tprivate List<RoutePrimitive> allRoutes;\n\tprivate Path2D.Double totalRiverSegment;\n\tprivate List<RiverBank> bankList;\n\tprivate double APERATURE_WIDTH;\n\tprivate double APERATURE_HEIGHT;\n\t\n\tpublic MetricsRunner(List<RoutePrimitive> routes, Path2D.Double riverSegment, List<RiverBank> listOfBanks, double A_W, double A_H, int uavs) {\n\t\tdrones = new ArrayList<>();\n\t\tfor(int i = 0; i < uavs; i++) {\n\t\t\tdrones.add(new Drone());\n\t\t}\n\t\tallRoutes = routes;\n\t\ttotalRiverSegment = riverSegment;\n\t\tbankList = listOfBanks;\n\t\tAPERATURE_WIDTH = A_W;\n\t\tAPERATURE_HEIGHT = A_H;\n\t\t//droneSetup();\n\t}\n\t\n\tpublic void droneSetup() {\n\t\tint counter = 0;\n\t\tfor(Drone drone : drones) {\n\t\t\tDroneRouteAssignment routeAssignment = new DroneRouteAssignment();\n\t\t\trouteAssignment.add(allRoutes.get(counter));\n\t\t\tcounter += 1;\n\t\t\tdrone.setDroneRouteAssignment(routeAssignment);\n\t\t}\n\t\tdrones.get(0).setDroneStartPoint(new Point2D.Double(4639658.290263815, -7163020.664734639));\n\t\tdrones.get(0).setDroneHomeLocation(new Point2D.Double(4639658.290263815, -7163020.664734639));\n\t\tdrones.get(1).setDroneStartPoint(new Point2D.Double(4639698.333003777, -7163031.375602997));\n\t\tdrones.get(1).setDroneHomeLocation(new Point2D.Double(4639698.333003777, -7163031.375602997));\n\t\tdrones.get(2).setDroneStartPoint(new Point2D.Double(4639719.355442258, -7163044.2452510195));\n\t\tdrones.get(2).setDroneHomeLocation(new Point2D.Double(4639719.355442258, -7163044.2452510195));\n\t\tdrones.get(3).setDroneStartPoint(new Point2D.Double(4639658.290263815, -7163020.664734639));\n\t\tdrones.get(3).setDroneHomeLocation(new Point2D.Double(4639658.290263815, -7163020.664734639));\n\t}\n\t\n\tpublic void setDroneAssignments(List<Drone> drones) {\n\t\tthis.drones = drones;\n\t}\n\t\n\tpublic MetricsStatistics runMetrics() {\n\t\tdouble equalityOfTasks =  MetricsUtilities.equalityOfTasks(drones);\n\n\t\tdouble allocationCoverage =  MetricsUtilities.calculateRouteCoverage(drones, totalRiverSegment, bankList, APERATURE_WIDTH, APERATURE_HEIGHT);\n\n\t\tdouble downstreamRatio =  MetricsUtilities.calculateDownstreamRatio(drones);\n\n\t\tboolean batteryFailed = false;\n\t\tfor(Drone drone : drones) {\n\t\t\tif(MetricsUtilities.batteryFailure(drone)) {\n\t\t\t\tbatteryFailed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(Drone drone : drones) {\n\t\t\tif(MetricsUtilities.routeAssignmentOutsideRiver(drone.getDroneRouteAssignment(), totalRiverSegment, APERATURE_HEIGHT)) {\n\t\t\t\tSystem.out.println(\"route transition goes outside river segment\");\n\t\t\t}\n\t\t}\n\n\t\tint collisions = MetricsUtilities.collisionCheck(drones);\n\n\t\tdouble totalDistance = MetricsUtilities.totalAllocationDistance(drones);\n\t\t\n\t\tList<Double> droneDistances = MetricsUtilities.calculateDroneDistances(drones);\n\t\t\n\t\tdouble priorityCoverage = MetricsUtilities.calculateAllocationPriorityCoverage(drones);\n\t\n\t\treturn new MetricsStatistics(equalityOfTasks, allocationCoverage, downstreamRatio, batteryFailed, collisions, totalDistance, droneDistances, priorityCoverage);\n\t}\n}\n"}, {"id": "UpdateGuidanceMessage.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal.message;\n\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;\n\nimport java.util.List;\n\npublic class UpdateGuidanceMessage extends AbstractMessage {\n    public final List<Command> commands;\n    public UpdateGuidanceMessage(List<Command> commands) {\n        this.commands = commands;\n    }\n}\n"}, {"id": "AbstractRemoteFacade.java", "body": "package edu.nd.dronology.services.remote;\n\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\n\nimport edu.nd.dronology.services.core.api.ServiceInfo;\nimport edu.nd.dronology.services.core.base.AbstractServerService;\nimport edu.nd.dronology.services.core.listener.IServiceListener;\nimport edu.nd.dronology.services.core.remote.IRemoteableService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n/** \n * Base implementation for all services implementing {@link IRemoteableService}\n * @author Michael Vierhauser\n *\n */\npublic class AbstractRemoteFacade extends UnicastRemoteObject implements IRemoteableService {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -7820839372017475896L;\n\tprotected AbstractServerService<?> service;\n\n\tprotected AbstractRemoteFacade(AbstractServerService<?> service) throws RemoteException {\n\t\tsuper();\n\t\tthis.service = service;\n\t}\n\n\t@Override\n\tpublic ServiceInfo getServiceInfo() throws RemoteException {\n\t\treturn service.getServerInfo();\n\t}\n\n\t@Override\n\tpublic void startService() throws RemoteException, DronologyServiceException {\n\t\tservice.startService();\n\t}\n\n\t@Override\n\tpublic void stopService() throws RemoteException, DronologyServiceException {\n\t\tservice.stopService();\n\n\t}\n\n\t@Override\n\tpublic boolean removeServiceListener(IServiceListener servicelistener) throws RemoteException {\n\t\treturn service.removeServiceListener(servicelistener);\n\n\t}\n\n\t@Override\n\tpublic boolean addServiceListener(IServiceListener servicelistener) throws RemoteException {\n\t\treturn service.removeServiceListener(servicelistener);\n\n\t}\n\n\t@Override\n\tpublic void restartService() throws RemoteException, DronologyServiceException {\n\t\tservice.restartService();\n\t}\n\n}\n"}, {"id": "IStopStrategy.java", "body": "package edu.nd.dronology.core.vehicle.uav;\n\npublic interface IStopStrategy {\n\n\tvoid execute();\n\n}\n"}, {"id": "UAVEquipmentTypeRegistrationService.java", "body": "package edu.nd.dronology.services.instances.registration.equipment;\n\nimport edu.nd.dronology.services.core.base.AbstractFileTransmitServerService;\n\nimport edu.nd.dronology.services.core.info.UAVEquipmentTypeRegistrationInfo;\n\npublic class UAVEquipmentTypeRegistrationService\n\t\textends AbstractFileTransmitServerService<IUAVEquipmentTypeRegistrationServiceInstance, UAVEquipmentTypeRegistrationInfo> {\n\n\tprivate static volatile UAVEquipmentTypeRegistrationService INSTANCE;\n\n\tprotected UAVEquipmentTypeRegistrationService() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @return The singleton ConfigurationService instance\n\t */\n\tpublic static UAVEquipmentTypeRegistrationService getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (UAVEquipmentTypeRegistrationService.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new UAVEquipmentTypeRegistrationService();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\n\t}\n\n\t@Override\n\tprotected IUAVEquipmentTypeRegistrationServiceInstance initServiceInstance() {\n\t\treturn new UAVEquipmentTypeRegistrationServiceInstance();\n\t}\n\n\n\n}\n"}, {"id": "RemoteServerProcessListenerAdapter.java", "body": "package edu.nd.dronology.services.remote;\n\nimport java.rmi.RemoteException;\n\nimport edu.nd.dronology.services.core.api.ServiceStatus;\nimport edu.nd.dronology.services.core.listener.IServiceListener;\nimport edu.nd.dronology.services.core.remote.IRemoteServiceListener;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class RemoteServerProcessListenerAdapter implements IServiceListener {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(RemoteServerProcessListenerAdapter.class);\n\tprivate IRemoteServiceListener listener;\n\n\tpublic RemoteServerProcessListenerAdapter(IRemoteServiceListener listener) {\n\t\tthis.listener = listener;\n\t}\n\n\t@Override\n\tpublic void statusChanged(ServiceStatus newState) {\n\t\ttry {\n\t\t\tlistener.statusChanged(newState);\n\t\t} catch (RemoteException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object thatObject) {\n\t\tif (this == thatObject) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!(thatObject instanceof RemoteServerProcessListenerAdapter)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.listener.equals(((RemoteServerProcessListenerAdapter) thatObject).listener);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((listener == null) ? 0 : listener.hashCode());\n\t\treturn result;\n\t}\n\t\n\t\n\t\n\n}\n"}, {"id": "FlightManagerServiceInstance.java", "body": "package edu.nd.dronology.services.instances.flightmanager;\n\nimport java.util.Collection;\nimport java.util.List;\n\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.exceptions.FlightZoneException;\nimport edu.nd.dronology.core.flightzone.FlightZoneManager2;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.services.core.base.AbstractServiceInstance;\nimport edu.nd.dronology.services.core.info.FlightInfo;\nimport edu.nd.dronology.services.core.info.FlightPlanInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.core.util.ServiceIds;\n\npublic class FlightManagerServiceInstance extends AbstractServiceInstance implements IFlightManagerServiceInstance {\n\n\tprivate FlightZoneManager2 flightManager;\n\n\tpublic FlightManagerServiceInstance() {\n\t\tsuper(ServiceIds.SERVICE_FLIGHTMANAGER, \"Flight Management\");\n\t}\n\n\t@Override\n\tprotected Class<?> getServiceClass() {\n\t\treturn FlightManagerService.class;\n\t}\n\n\t@Override\n\tprotected int getOrder() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 2;\n\t}\n\n\t@Override\n\tprotected String getPropertyPath() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void doStartService() throws Exception {\n\t\tflightManager = new FlightZoneManager2();\n\t}\n\n\t@Override\n\tprotected void doStopService() throws Exception {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n\t@Override\n\tpublic FlightInfo getFlightDetails() {\n\n\t\t// return\n\t\t// RemoteInfoFactory.createFlightInfo(flightManager.getFlights());\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void planFlight(String uavid, String planName, List<Waypoint> waypoints) throws Exception {\n\t\tflightManager.planFlight(uavid, planName, waypoints);\n\n\t}\n\n\t@Override\n\tpublic void planFlight(String planName, List<Waypoint> waypoints) throws Exception {\n\t\tflightManager.planFlight(planName, waypoints);\n\n\t}\n\n\t@Override\n\tpublic void returnToHome(String uavid) throws Exception {\n\t\tflightManager.returnToHome(uavid);\n\n\t}\n\n\t@Override\n\tpublic void pauseFlight(String uavid) throws Exception {\n\t\tflightManager.pauseFlight(uavid);\n\n\t}\n\n\t@Override\n\tpublic FlightInfo getFlightInfo(String uavId) throws DronologyServiceException {\n\t\treturn FlightInfoCreator.createInfo(uavId);\n\t}\n\n\t@Override\n\tpublic Collection<FlightPlanInfo> getCurrentFlights() {\n\t\treturn FlightInfoCreator.getCurrenctFlights();\n\t}\n\n\t@Override\n\tpublic void cancelPendingFlights(String uavid) throws Exception {\n\t\tflightManager.cancelPendingFlights(uavid);\n\t}\n\n\n \n\t@Override\n\tpublic void takeoff(String uavid, double altitude) throws DronologyServiceException {\n\t\ttry {\n\t\t\tflightManager.takeoff(uavid, altitude);\n\t\t} catch (DroneException | FlightZoneException e) {\n\t\t\tthrow new DronologyServiceException(e.getMessage());\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void emergencyStop(String uavid) throws DronologyServiceException {\n\t\ttry {\n\t\t\tflightManager.emergencyStop(uavid);\n\t\t} catch (DroneException e) {\n\t\t\tthrow new DronologyServiceException(e.getMessage());\n\t\t}\n\n\t}\n\n}\n"}, {"id": "GetCoordinatesMessage.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal.message;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\nimport java.util.concurrent.SynchronousQueue;\n\npublic class GetCoordinatesMessage extends AbstractMessage {\n    public final SynchronousQueue<LlaCoordinate> returnBox = new SynchronousQueue<>();\n}\n"}, {"id": "AreaMappingCategoryInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\npublic class AreaMappingCategoryInfo extends RemoteInfoObject {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -7327376857430499641L;\n\n\tpublic AreaMappingCategoryInfo(String name, String id) {\n\t\tsuper(name, id);\n\t}\n}\n"}, {"id": "FlyingFieldDemoScript.java", "body": "package edu.nd.dronology.services.launch;\n\nimport java.net.MalformedURLException;\nimport java.rmi.Naming;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo.DroneMode;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;\nimport edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;\nimport edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic class FlyingFieldDemoScript {\n\n\tprivate static final String ADDRESS_SCHEME = \"rmi://%s:%s/Remote\";\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\t// Flying Field\n\t\t\tLlaCoordinate cord1 = new LlaCoordinate(41.694116,  -86.253591, 0);\n\t\t\tLlaCoordinate cord2 = new LlaCoordinate(41.519400, -86.239527, 0);\n\t\t\tLlaCoordinate cord4 = new LlaCoordinate(41.717158, -86.228932, 0);\n\n\t\t\tIRemoteManager manager = (IRemoteManager) Naming.lookup(String.format(ADDRESS_SCHEME, \"localhost\", 9779));\n\n\t\t\tIDroneSetupRemoteService service = (IDroneSetupRemoteService) manager.getService(IDroneSetupRemoteService.class);\n\n\t\t\tIFlightManagerRemoteService managerService = (IFlightManagerRemoteService) manager\n\t\t\t\t\t.getService(IFlightManagerRemoteService.class);\n\n\t\t\tIFlightRouteplanningRemoteService planningService = (IFlightRouteplanningRemoteService) manager\n\t\t\t\t\t.getService(IFlightRouteplanningRemoteService.class);\n\t\t\t//\n\n\t\t\tDroneInitializationInfo inff = new DroneInitializationInfo(\"S&R-UAV1\", DroneMode.MODE_VIRTUAL,\n\t\t\t\t\t\"IRIS+\", cord1);\n\t\t\tservice.initializeDrones(inff);\n\n\t\t\tDroneInitializationInfo inff2 = new DroneInitializationInfo(\"S&R-UAV2\", DroneMode.MODE_VIRTUAL,\n\t\t\t\t\t\"IRIS+\", cord4);\n\t\t\tservice.initializeDrones(inff2);\n\n\t\t\tDroneInitializationInfo inff3 = new DroneInitializationInfo(\"S&R-UAV3\", DroneMode.MODE_VIRTUAL,\n\t\t\t\t\t\"IRIS+\", cord4);\n\t\t\tservice.initializeDrones(inff3);\n\n\t\t\tList<FlightRouteInfo> allRoutes = new ArrayList<>(planningService.getItems());\n//\t\t\tint NUM_DRONES = 0;\n//\t\t\tfor (int i = 0; i < NUM_DRONES; i++) {\n//\t\t\t\tdouble coordofset = (double) i / 10000;\n//\t\t\t\tLlaCoordinate coord = new LlaCoordinate((41.519400 + coordofset), -86.239927, 0);\n//\t\t\t\tDroneInitializationInfo dr = new DroneInitializationInfo(\"Sim-Drone\" + i, DroneMode.MODE_VIRTUAL, \"IRIS+\",\n//\t\t\t\t\t\tcoord);\n//\n//\t\t\t\tservice.initializeDrones(dr);\n//\t\t\t}\n\n\t\t\t// for (DroneStatus dr : service.getDrones().values()) {\n\t\t\t// FlightRouteInfo inf = getRandomRoute(allRoutes);\n\t\t\t//\n\t\t\t// managerService.planFlight(dr.getID(), \"randplan\", inf.getWaypoints());\n\t\t\t//\n\t\t\t// }\n\n\t\t\t// for (DroneStatus dr : service.getDrones().values()) {\n\t\t\t// FlightRouteInfo inf = allRoutes.remove(0);\n\t\t\t//\n\t\t\t// managerService.planFlight(dr.getID(), \"randplan\", inf.getWaypoints());\n\t\t\t//\n\t\t\t// }\n\n\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedURLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (NotBoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tstatic Random rand = new Random();\n\n\tprivate static FlightRouteInfo getRandomRoute(List<FlightRouteInfo> allRoutes) {\n\t\tint routeSize = allRoutes.size();\n\n\t\tint randomNumber = rand.nextInt(routeSize);\n\n\t\treturn allRoutes.get(randomNumber);\n\n\t}\n\n}\n"}, {"id": "AdaptedCreepingLinePrimitive.java", "body": "package edu.nd.dronology.services.extensions.areamapping.internal;\n\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.math3.ml.neuralnet.twod.util.TopographicErrorHistogram;\nimport org.apache.logging.log4j.core.appender.routing.Route;\n\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive.RouteType;\nimport edu.nd.dronology.services.extensions.areamapping.util.Utilities;\n\npublic class AdaptedCreepingLinePrimitive implements SearchPatternStrategy{\n\t\n\tprivate List<SourcePoints> sourcePoints;\n\tprivate RoutePrimitive.RouteType routeType;\n\t\n\tpublic AdaptedCreepingLinePrimitive() {\n\t\tsourcePoints = new ArrayList<>();\n\t}\n\t\n\t@Override\n\tpublic void setSourcePoints(List<SourcePoints> points) {\n\t\tsourcePoints = points;\n\t}\n\t\n\tpublic void setRouteType(RoutePrimitive.RouteType routeType) {\n\t\tthis.routeType = routeType;\n\t}\n\t\n\t\n\t/**\n\t * This method generates the creeping line route between the source points.\n\t * @param sideA\n\t * @param sideB\n\t * @return RoutePrimitive\n\t */\n\tprivate RoutePrimitive generateCreepingLineRoute(SourcePoints sideA, SourcePoints sideB) {\n\t\tint opposingRouteIndex = 0;\n\t\tint firstOpposingRouteIndex = 0;\n\t\tint lastOpposingRouteIndex = 0;\n\t\tboolean missedFirstPoints = false;\n\t\tboolean missedLastPoints = false;\n\t\tRoutePrimitive newRoute = new RoutePrimitive(routeType, sideA.getWeight());\n\t\tPoint2D.Double startPoint = new Point2D.Double();\n\t\tPoint2D.Double opposingPoint = new Point2D.Double();\n\t\tPoint2D.Double previousOpposingPoint = new Point2D.Double();\n\t\t//main for loop for adding waypoints to the route primitive\n\t\tfor(int i = 0; i < sideA.size(); i++) {\n\t\t\tstartPoint = sideA.getSourcePoint(i);\n\t\t\tnewRoute.addRouteWaypoint(startPoint);\n\t\t\topposingPoint = Geometry.findClosestOpposingPoint(startPoint, sideB.getSourcePoints());\n\t\t\tif(i > 0) {\n\t\t\t\tif(sideB.getSourcePoints().indexOf(opposingPoint) - opposingRouteIndex > 1) {\n\t\t\t\t\tgenerateCreepingLineMiddle(sideA, sideB, newRoute, opposingRouteIndex, sideB.getSourcePoints().indexOf(opposingPoint));\n\t\t\t\t}\n\t\t\t}\n\t\t\topposingRouteIndex = sideB.getSourcePoints().indexOf(opposingPoint);\n\t\t\tif(i == 0) {\n\t\t\t\tif(opposingRouteIndex > 0) {\n\t\t\t\t\tmissedFirstPoints = true;\n\t\t\t\t\tfirstOpposingRouteIndex = opposingRouteIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(\"index of opposing point: \" + opposingRouteIndex);\n\t\t\t//do I want this portion? --- attempts to minimize doubling of routes\n\t\t\tif(opposingPoint == previousOpposingPoint && i < sideA.size()-1) {\n\t\t\t\tpreviousOpposingPoint = new Point2D.Double();\n\t\t\t} else {\n\t\t\t\tnewRoute.addRouteWaypoint(opposingPoint);\n\t\t\t\tpreviousOpposingPoint = opposingPoint;\n\t\t\t}\n\t\t}\n\t\t//checking for any missed waypoint nodes\n\t\tif(opposingRouteIndex != sideB.size()) {\n\t\t\tmissedLastPoints = true;\n\t\t\tlastOpposingRouteIndex = opposingRouteIndex;\n\t\t}\n\t\tif(missedFirstPoints) {\n\t\t\tgenerateCreepingLineBeginning(sideA, sideB, newRoute, firstOpposingRouteIndex);\n\t\t}\n\t\tif(missedLastPoints) {\n\t\t\tgenerateCreepinLineEnd(sideA, sideB, newRoute, lastOpposingRouteIndex);\n\t\t} \n\t\treturn newRoute;\n\t}\n\t\n\tprivate void generateCreepingLineMiddle(SourcePoints sideA, SourcePoints sideB, RoutePrimitive newRoute, int previousOpposingRouteIndex, int newOpposingRouteIndex) {\n\t\tPoint2D.Double pointA = newRoute.getRouteEndPoint();\n\t\tif((newOpposingRouteIndex - previousOpposingRouteIndex) % 2 == 0) {\n\t\t\tnewRoute.addRouteWaypoint(sideB.getSourcePoint(previousOpposingRouteIndex + 1));\n\t\t\tif(newOpposingRouteIndex - previousOpposingRouteIndex > 1) {\n\t\t\t\tfor(int i = previousOpposingRouteIndex + 2; i < newOpposingRouteIndex; i++) {\n\t\t\t\t\tnewRoute.addRouteWaypoint(sideB.getSourcePoint(i));\n\t\t\t\t\tnewRoute.addRouteWaypoint(pointA);\n\t\t\t\t\tnewRoute.addRouteWaypoint(sideB.getSourcePoint(i+1));\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor(int i = previousOpposingRouteIndex + 1; i < newOpposingRouteIndex; i++) {\n\t\t\t\tnewRoute.addRouteWaypoint(sideB.getSourcePoint(i));\n\t\t\t\tnewRoute.addRouteWaypoint(sideB.getSourcePoint(i+1));\n\t\t\t\tnewRoute.addRouteWaypoint(pointA);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * This is a helper method for generateCreepingLineRoute() to handle any source points \n\t * missed at the beginning of the route.\n\t * @param sideA\n\t * @param sideB\n\t * @param newRoute\n\t * @param firstOpposingRouteIndex\n\t */\n\tprivate void generateCreepingLineBeginning(SourcePoints sideA, SourcePoints sideB, RoutePrimitive newRoute, int firstOpposingRouteIndex) {\n\t\tif(firstOpposingRouteIndex % 2 == 0) {\n\t\t\tint counter = 0;\n\t\t\tfor(int i = 0; i < firstOpposingRouteIndex; i++) {\n\t\t\t\tnewRoute.insertRouteWaypoint(counter, sideA.getSourcePoint(0));\n\t\t\t\tnewRoute.insertRouteWaypoint(counter + 1, sideB.getSourcePoint(i));\n\t\t\t\tnewRoute.insertRouteWaypoint(counter + 2, sideB.getSourcePoint(i+1));\n\t\t\t\tcounter += 3;\n\t\t\t\ti++;\n\t\t\t}\n\t\t} else {\n\t\t\tint counter = 1;\n\t\t\tnewRoute.insertRouteWaypoint(0, sideB.getSourcePoint(0));\n\t\t\tif(firstOpposingRouteIndex > 1) {\n\t\t\t\tfor(int i = 1; i < firstOpposingRouteIndex; i++) {\n\t\t\t\t\tnewRoute.insertRouteWaypoint(counter, sideA.getSourcePoint(0));\n\t\t\t\t\tnewRoute.insertRouteWaypoint(counter + 1, sideB.getSourcePoint(i));\n\t\t\t\t\tnewRoute.insertRouteWaypoint(counter + 1, sideB.getSourcePoint(i+1));\n\t\t\t\t\tcounter += 2;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * This is a helper method for generateCreepingLineRoute() to handle and source point \n\t * missed at the end of the route.\n\t * @param sideA\n\t * @param sideB\n\t * @param newRoute\n\t * @param lastOpposingRouteIndex\n\t */\n\tprivate void generateCreepinLineEnd(SourcePoints sideA, SourcePoints sideB, RoutePrimitive newRoute, int lastOpposingRouteIndex) {\n\t\tfor(int i = lastOpposingRouteIndex + 1; i < sideB.size(); i++) {\n\t\t\tnewRoute.addRouteWaypoint(sideB.getSourcePoint(i));\n\t\t\tnewRoute.addRouteWaypoint(sideA.getSourcePoint(sideA.size()-1));\n\t\t\tif(i < sideB.size()-1) {\n\t\t\t\tnewRoute.addRouteWaypoint(sideB.getSourcePoint(i+1));\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic List<RoutePrimitive> generateRoutePrimitive(double APERATURE_HEIGHT, double OVERLAP_FACTOR){\n\t\tList<RoutePrimitive> routes = new ArrayList<>();\n\t\tSourcePoints source1 = sourcePoints.get(0);\n\t\tSourcePoints source2 = sourcePoints.get(1);\n\t\tRoutePrimitive creepingLineRoute;\n\t\tif(source1.size() < source2.size()) {\n\t\t\tcreepingLineRoute = generateCreepingLineRoute(source2, source1);\n\t\t} else {\n\t\t\tcreepingLineRoute = generateCreepingLineRoute(source1, source2);\n\t\t}\n\t\t//NOTE: should actually be APERATURE_HEIGHT\n\t\tUtilities.generateImageWaypoints(creepingLineRoute, APERATURE_HEIGHT, OVERLAP_FACTOR);\n\t\troutes.add(creepingLineRoute);\n\t\treturn routes;\n\t}\n}\n"}, {"id": "IRemoteServiceListener.java", "body": "package edu.nd.dronology.services.core.remote;\n\nimport java.rmi.RemoteException;\n\nimport edu.nd.dronology.services.core.api.IRemotable;\nimport edu.nd.dronology.services.core.api.ServiceStatus;\n/**\n * Listener for notifying clients on status changes of the registered service.\n * \n * \n * @author Michael Vierhauser\n *\n */\npublic interface IRemoteServiceListener extends IRemotable{\n\t\n\t/**\n\t * \n\t * @param newState The current status of the service.\n\t * @throws RemoteException\n\t */\n\tpublic void statusChanged(ServiceStatus newState) throws RemoteException;\n\n\n}\n"}, {"id": "LandingStrategy.java", "body": "package edu.nd.dronology.core.vehicle.uav;\n\npublic class LandingStrategy implements IStopStrategy {\n\n\t@Override\n\tpublic void execute() {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n}\n"}, {"id": "DroneSetupServiceRemoteFacade.java", "body": "package edu.nd.dronology.services.facades;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo;\nimport edu.nd.dronology.services.core.listener.IDroneStatusChangeListener;\nimport edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.instances.dronesetup.DroneSetupService;\nimport edu.nd.dronology.services.remote.AbstractRemoteFacade;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Remote facade for handling UAVs.<br>\n * Allows initializing new UAVs. <br>\n * Allows retrieving active UAVs which returns a proxy ({@link IUAVProxy}) of the actual physical or virtual uav.\n * \n * \n * @author Michael Vierhauser\n *\n */\npublic class DroneSetupServiceRemoteFacade extends AbstractRemoteFacade implements IDroneSetupRemoteService {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -4580658378477037955L;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(DroneSetupServiceRemoteFacade.class);\n\tprivate static volatile DroneSetupServiceRemoteFacade INSTANCE;\n\n\tprotected DroneSetupServiceRemoteFacade() throws RemoteException {\n\t\tsuper(DroneSetupService.getInstance());\n\t}\n\n\tpublic static IDroneSetupRemoteService getInstance() throws RemoteException {\n\t\tif (INSTANCE == null) {\n\t\t\ttry {\n\t\t\t\tsynchronized (DroneSetupServiceRemoteFacade.class) {\n\t\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\t\tINSTANCE = new DroneSetupServiceRemoteFacade();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (RemoteException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\n\t}\n\n\n\t@Override\n\tpublic void initializeDrones(DroneInitializationInfo... info) throws RemoteException, DronologyServiceException {\n\t\tDroneSetupService.getInstance().initializeDrones(info);\n\n\t}\n\n\t@Override\n\tpublic void addDroneStatusChangeListener(IDroneStatusChangeListener listener) {\n\t\tDroneSetupService.getInstance().addDroneStatusChangeListener(listener);\n\t}\n\n\t@Override\n\tpublic void removeDroneStatusChangeListener(IDroneStatusChangeListener listener) {\n\t\tDroneSetupService.getInstance().removeDroneStatusChangeListener(listener);\n\n\t}\n\n\t@Override\n\tpublic Collection<IUAVProxy> getActiveUAVs() throws RemoteException {\n\t\treturn DroneSetupService.getInstance().getActiveUAVs();\n\t}\n\n\t@Override\n\tpublic void resendCommand(String uavid) throws RemoteException, DronologyServiceException {\n\t\tDroneSetupService.getInstance().resendCommand(uavid);\n\t}\n\n}"}, {"id": "AbstractMissionTask.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.tasks;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\npublic class AbstractMissionTask implements IMissionTask {\n\tprivate final String uavID;\n\tprivate final String taskName;\n\n\tprotected AbstractMissionTask(String uavID, String taskName) {\n\t\tthis.uavID = uavID;\n\n\t\tthis.taskName = taskName;\n\t}\n\n\t@Override\n\tpublic String getTaskName() {\n\t\treturn taskName;\n\t}\n\n\t@Override\n\tpublic String getUAVId() {\n\t\treturn uavID;\n\t}\n\n\t@Override\n\tpublic LlaCoordinate getWaypoint() {\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n}"}, {"id": "UAVTypeRegistrationXStreamPersistor.java", "body": "package edu.nd.dronology.services.core.persistence.internal;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.nio.charset.Charset;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport com.thoughtworks.xstream.XStream;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\n\nimport edu.nd.dronology.services.core.items.IUAVRegistration;\nimport edu.nd.dronology.services.core.items.IUAVTypeRegistration;\nimport edu.nd.dronology.services.core.persistence.DronologyPersistenceUtil;\nimport edu.nd.dronology.services.core.persistence.IPersistenceManager;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class UAVTypeRegistrationXStreamPersistor implements IPersistenceManager<IUAVTypeRegistration> {\n\n\tprivate static final XStream xstream = new XStream(new XppDriver());\n\tprivate static ILogger LOGGER = LoggerProvider.getLogger(UAVTypeRegistrationXStreamPersistor.class);\n\n\tstatic final boolean useCompression = false;\n\n\t@Override\n\tpublic IUAVTypeRegistration open(InputStream fin) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t//\t xstream.setMode(XStream.);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\t\t\n\t\tif (useCompression) {\n\t\t\treturn loadedCompressedStream(fin);\n\t\t} else {\n\t\t\treturn loadUncompressedStream(fin);\n\t\t}\n\t}\n\n\tprivate IUAVTypeRegistration loadUncompressedStream(InputStream fin) throws PersistenceException {\n\t\ttry {\n\t\t\tInputStreamReader reader = new InputStreamReader(new BufferedInputStream(fin), Charset.forName(\"UTF-8\"));\n\t\t\tObject model = xstream.fromXML(reader);\n\t\t\treturn (IUAVTypeRegistration) model;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (fin != null) {\n\t\t\t\t\tfin.close();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate IUAVTypeRegistration loadedCompressedStream(InputStream fin) throws PersistenceException {\n\t\tInputStream zIn = null;\n\t\ttry {\n\t\t\tzIn = new GZIPInputStream(fin);\n\t\t\tObject model = xstream.fromXML(new BufferedReader(new InputStreamReader(zIn, \"UTF-8\")));\n\n\t\t\treturn (IUAVTypeRegistration) model;\n\t\t} catch (IOException e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (zIn != null) {\n\t\t\t\t\tzIn.close();\n\t\t\t\t}\n\t\t\t\tif (fin != null) {\n\t\t\t\t\tfin.close();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\n\t\t}\n\t}\n \n\t@Override\n\tpublic boolean save(IUAVTypeRegistration o, OutputStream fout) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t\t// xstream.setMode(XStream.ID_REFERENCES);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\t\t// xstream.addImplicitMap(ImplMEEvent.class, \"relatedEvents\", ImplMEEvent.class, \"relatedEvents\");\n\n\t\tif (useCompression) {\n\t\t\treturn saveCompressedStream(o, fout);\n\t\t} else {\n\t\t\treturn saveUncompressedStream(o, fout);\n\t\t}\n\n\t}\n\n\tprivate boolean saveUncompressedStream(IUAVTypeRegistration o, OutputStream fout) throws PersistenceException {\n\t\tOutputStreamWriter writer = null;\n\t\ttry {\n\t\t\twriter = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(\"UTF-8\"));\n\t\t\txstream.toXML(o, writer);\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (writer != null) {\n\t\t\t\t\twriter.close();\n\t\t\t\t}\n\t\t\t\tif (fout != null) {\n\t\t\t\t\tfout.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean saveCompressedStream(IUAVTypeRegistration o, OutputStream fout) throws PersistenceException {\n\t\ttry {\n\t\t\tGZIPOutputStream zOut = new GZIPOutputStream(fout);\n\t\t\txstream.toXML(o, new BufferedWriter(new OutputStreamWriter(zOut, \"UTF-8\")));\n\n\t\t\tzOut.close();\n\t\t\tfout.close();\n\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t}\n\t}\n\n}\n"}, {"id": "SetGimbalTargetCommand.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n\nimport edu.nd.dronology.core.CoordinateChange;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\n@CoordinateChange\npublic class SetGimbalTargetCommand extends AbstractDroneCommand implements IDroneCommand {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 364759212900805189L;\n\n\tpublic SetGimbalTargetCommand(String uavid, LlaCoordinate coord) {\n\t\tsuper(uavid, \"\");\n\n\t}\n\n}\n"}, {"id": "UAVEquipmentTypeRegistrationServiceInstance.java", "body": "package edu.nd.dronology.services.instances.registration.equipment;\n\nimport java.io.File;\n\nimport java.util.Set;\n\nimport edu.nd.dronology.services.core.api.IFileChangeNotifyable;\nimport edu.nd.dronology.services.core.api.ServiceInfo;\nimport edu.nd.dronology.services.core.base.AbstractFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.info.UAVEquipmentTypeRegistrationInfo;\nimport edu.nd.dronology.services.core.items.IUAVEquipmentTypeRegistration;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport edu.nd.dronology.services.core.persistence.UAVEquipmentTypeRegistrationPersistenceProvider;\nimport edu.nd.dronology.services.core.util.DronologyConstants;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.core.util.ServiceIds;\nimport edu.nd.dronology.services.instances.DronologyElementFactory;\nimport edu.nd.dronology.services.supervisor.SupervisorService;\nimport edu.nd.dronology.util.FileUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class UAVEquipmentTypeRegistrationServiceInstance extends AbstractFileTransmitServiceInstance<UAVEquipmentTypeRegistrationInfo>\n\t\timplements IFileChangeNotifyable, IUAVEquipmentTypeRegistrationServiceInstance {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(UAVEquipmentTypeRegistrationServiceInstance.class);\n\n\tprivate static final int ORDER = 2;\n\n\tpublic static final String EXTENSION = DronologyConstants.EXTENSION_EQUIPMENT_TYPEREGISTRATION;\n\n\n\tpublic UAVEquipmentTypeRegistrationServiceInstance() {\n\t\tsuper(ServiceIds.SERVICE_EQUIP_TYPE_REGISTRATION, \"UAV Equipment TypeRegistration Management\", EXTENSION);\n\t}\n\n\t@Override\n\tprotected Class<?> getServiceClass() {\n\t\treturn UAVEquipmentTypeRegistrationServiceInstance.class;\n\t}\n\n\t@Override\n\tprotected int getOrder() {\n\t\treturn ORDER;\n\t}\n\n\t@Override\n\tprotected String getPropertyPath() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void doStartService() throws Exception {\n\t\treloadItems();\n\t}\n\n\t@Override\n\tprotected void doStopService() throws Exception {\n\t\tfileManager.tearDown();\n\t}\n\n\t@Override\n\tpublic ServiceInfo getServiceInfo() {\n\t\tServiceInfo sInfo = super.getServiceInfo();\n\t\tsInfo.addAttribute(ServiceInfo.ATTRIBUTE_TYPE, ServiceInfo.ATTRIBUTE_FILE);\n\t\treturn sInfo;\n\t}\n\n\t@Override\n\tpublic UAVEquipmentTypeRegistrationInfo createItem() throws DronologyServiceException {\n\t\tUAVEquipmentTypeRegistrationPersistenceProvider persistor = UAVEquipmentTypeRegistrationPersistenceProvider.getInstance();\n\t\tIUAVEquipmentTypeRegistration specification = DronologyElementFactory.createNewUAVEquipmentTypeSpecification();\n\t\tspecification.setName(\"New-UAVEquipmentTypeSpecification\"); \n\t\tString savePath = FileUtil.concat(storagePath, specification.getId(), EXTENSION);\n\n\t\ttry {\n\t\t\tpersistor.saveItem(specification, savePath);\n\t\t} catch (PersistenceException e) {\n\t\t\tthrow new DronologyServiceException(\"Error when creating drone euqipment: \" + e.getMessage());\n\t\t}\n\t\treturn new UAVEquipmentTypeRegistrationInfo(specification.getName(), specification.getId());\n\t}\n\n\t@Override\n\tprotected String getPath() {\n\t\tString path = SupervisorService.getInstance().getDroneSpecificationLocation();\n\t\treturn path;\n\t}\n\n\t@Override\n\tprotected UAVEquipmentTypeRegistrationInfo fromFile(String id, File file) throws Throwable {\n\t\tIUAVEquipmentTypeRegistration atm = UAVEquipmentTypeRegistrationPersistenceProvider.getInstance().loadItem(file.toURI().toURL());\n\t\tUAVEquipmentTypeRegistrationInfo info = new UAVEquipmentTypeRegistrationInfo(atm.getName(), id);\n\t\treturn info;\n\t}\n\n\t@Override\n\tprotected boolean hasProperties() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void notifyFileChange(Set<String> changed) {\n\t\tfor (String s : changed) {\n\t\t\tupdateItem(s);\n\t\t}\n\t\tsuper.notifyFileChange(changed);\n\t\tfor (String s : changed) {\n\t\t\tString id = s.replace(\".\" + extension, \"\");\n\t\t\tif (!itemmap.containsKey(id)) {\n\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void updateItem(String s) {\n\t\tSystem.out.println(\"UPDATE\");\n\n\t}\n\n}\n"}, {"id": "CheckerTaskMessage.java", "body": "package edu.nd.dronology.core.collisionavoidance.backendmessage;\n\npublic class CheckerTaskMessage extends AbstractMessage {\n}\n"}, {"id": "Waypoint.java", "body": "package edu.nd.dronology.core.util;\n\nimport java.io.Serializable;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.flight.internal.FlightPlan;\nimport edu.nd.dronology.util.NullUtil;\n\n/**\n * \n * Waypoint implementation used in {@link FlightPlan} and Fight Route to represent coordinates (as {@link LlaCoordinate})<br>\n * and the approaching speed towards the respective waypoint. <br>\n * <br>\n * This class (and all its constituent fields) have to be {@link Serializable} as this class is passed via the remote interface.\n * \n * @author Michael Vierhauser\n *\n */\npublic class Waypoint implements Serializable {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 5855436372355880741L;\n\n\tprivate final LlaCoordinate coordinate;\n\tprivate boolean destinationReached = false;\n\n\tprivate double approachingspeed = 0.0d;\n\n\tpublic LlaCoordinate getCoordinate() {\n\t\treturn coordinate;\n\t}\n\n\tpublic Waypoint() {\n\t\tcoordinate = new LlaCoordinate(0, 0, 0);\n\t}\n\n\tpublic Waypoint(LlaCoordinate coordinate) {\n\t\tsuper();\n\t\tNullUtil.checkNull(coordinate);\n\t\tthis.coordinate = coordinate;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (!(obj instanceof Waypoint))\n\t\t\treturn false;\n\t\tWaypoint other = (Waypoint) obj;\n\t\treturn coordinate.equals(other.getCoordinate());\n\t}\n\n\tpublic boolean isReached() {\n\t\treturn destinationReached;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn coordinate.hashCode();\n\t}\n\n\tpublic void reached(boolean reached) {\n\t\tthis.destinationReached = reached;\n\n\t}\n\n\tpublic double getApproachingspeed() {\n\t\treturn approachingspeed;\n\t}\n\n\tpublic void setApproachingspeed(double approachingspeed) {\n\t\tthis.approachingspeed = approachingspeed;\n\t}\n\n}\n"}, {"id": "TypeRegistrationInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\npublic class TypeRegistrationInfo extends RemoteInfoObject {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 2844123024068335148L;\n\n\tpublic TypeRegistrationInfo(String name, String id) {\n\t\tsuper(name, id);\n\t}\n\n}\n"}, {"id": "DroneSetupServiceInstance.java", "body": "package edu.nd.dronology.services.instances.dronesetup;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.fleet.AbstractDroneFleetFactory;\nimport edu.nd.dronology.core.fleet.DroneFleetManager;\nimport edu.nd.dronology.core.fleet.PhysicalDroneFleetFactory;\nimport edu.nd.dronology.core.fleet.VirtualDroneFleetFactory;\nimport edu.nd.dronology.core.flight.PlanPoolManager;\nimport edu.nd.dronology.core.status.DroneCollectionStatus;\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\nimport edu.nd.dronology.core.vehicle.proxy.UAVProxyManager;\nimport edu.nd.dronology.services.core.base.AbstractServiceInstance;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo.DroneMode;\nimport edu.nd.dronology.services.core.listener.IDroneStatusChangeListener;\nimport edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.util.NullUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Service instance for handling UAVs<br>\n * See {@link IDroneSetupRemoteService} for details.\n *\n */\npublic class DroneSetupServiceInstance extends AbstractServiceInstance implements IDroneSetupServiceInstance {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(DroneSetupServiceInstance.class);\n\n\tprivate AbstractDroneFleetFactory physicalDroneFleetFactory;\n\tprivate AbstractDroneFleetFactory virtualDroneFleetFactory;\n\n\tprivate List<IDroneStatusChangeListener> listenerList = new ArrayList<>();\n\n\tpublic DroneSetupServiceInstance() {\n\t\tsuper(\"DRONESETUP\");\n\t}\n\n\t@Override\n\tprotected Class<?> getServiceClass() {\n\t\treturn DroneSetupService.class;\n\t}\n\n\t@Override\n\tprotected int getOrder() {\n\t\treturn 3;\n\t}\n\n\t@Override\n\tprotected String getPropertyPath() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void doStartService() throws Exception {\n\t\tphysicalDroneFleetFactory = PhysicalDroneFleetFactory.getInstance();\n\t\tvirtualDroneFleetFactory = VirtualDroneFleetFactory.getInstance();\n\n\t}\n\n\t@Override\n\tprotected void doStopService() throws Exception {\n\t}\n\n\t@Override\n\tpublic void initializeDrones(DroneInitializationInfo[] info) throws DronologyServiceException {\n\t\tNullUtil.checkArrayNull(info);\n\t\tfor (DroneInitializationInfo di : info) {\n\t\t\ttry {\n\t\t\t\tdoInitDrone(di);\n\t\t\t} catch (DroneException e) {\n\t\t\t\tthrow new DronologyServiceException(e.getMessage());\n\t\t\t}\n\t\t}\n\t}\n \n\tprivate void doInitDrone(DroneInitializationInfo di) throws DroneException {\n\t\tif (di.getMode() == DroneMode.MODE_PHYSICAL) {\n\t\t\tphysicalDroneFleetFactory.initializeDrone(di.getId(), di.getType(), di.getInitialLocation());\n\t\t} else {\n\t\t\tvirtualDroneFleetFactory.initializeDrone(di.getId(), di.getType(), di.getInitialLocation());\n\t\t}\n\n\t\tIUAVProxy drStat = UAVProxyManager.getInstance().getActiveUAV(di.getId());\n\t\tnotifyDroneStatusChange(drStat);\n\t}\n\n\t@Override\n\tpublic void addDroneStatusChangeListener(IDroneStatusChangeListener listener) {\n\t\tsynchronized (listenerList) {\n\t\t\tboolean success = listenerList.add(listener);\n\t\t\tif (!success) {\n\t\t\t\t// throw exception\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void removeDroneStatusChangeListener(IDroneStatusChangeListener listener) {\n\t\tsynchronized (listenerList) {\n\t\t\tboolean success = listenerList.remove(listener);\n\t\t\tif (!success) {\n\t\t\t\t// throw exception\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void notifyDroneStatusChange(IUAVProxy status) {\n\t\tList<IDroneStatusChangeListener> notifyList;\n\t\tsynchronized (listenerList) {\n\t\t\tnotifyList = new ArrayList<>(listenerList);\n\t\t}\n\t\tfor (IDroneStatusChangeListener listener : notifyList) {\n\t\t\ttry {\n\t\t\t\tlistener.droneStatusChanged(status);\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t\tlistenerList.remove(listener);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic Collection<IUAVProxy> getActiveUAVs() {\n\t\treturn UAVProxyManager.getInstance().getActiveUAVs();\n\t}\n\n\t@Override\n\tpublic void deactivateDrone(IUAVProxy status) throws DronologyServiceException {\n\t\ttry {\n\t\t\tLOGGER.info(\"Unregistering UAV '\" + status.getID() + \"'\");\n\t\t\tDroneFleetManager.getInstance().unregisterDroe(status.getID());\n\t\t\tDroneCollectionStatus.getInstance().removeDrone(status);\n\t\t\tcancelPlans(status.getID());\n\t\t\tnotifyDroneStatusChange(status);\n\t\t} catch (DroneException e) {\n\t\t\tthrow new DronologyServiceException(e.getMessage());\n\t\t}\n\n\t}\n\n\tprivate void cancelPlans(String id) {\n\t\tif (PlanPoolManager.getInstance().getCurrentPlan(id) != null) {\n\t\t\ttry {\n\t\t\t\tPlanPoolManager.getInstance().overridePlan(null, id);\n\t\t\t} catch (DroneException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t\tif (PlanPoolManager.getInstance().getPendingPlans(id).size() > 0) {\n\t\t\ttry {\n\t\t\t\tPlanPoolManager.getInstance().cancelPendingPlans(id);\n\t\t\t} catch (DroneException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic IUAVProxy getActiveUAV(String uavId) throws DronologyServiceException {\n\t\tIUAVProxy uavProxy = UAVProxyManager.getInstance().getActiveUAV(uavId);\n\t\tif (uavProxy == null) {\n\t\t\tthrow new DronologyServiceException(\"UAV '\" + uavId + \"' not active\");\n\t\t}\n\t\treturn uavProxy;\n\t}\n\n\t@Override\n\tpublic void resendCommand(String uavId) throws DronologyServiceException {\n\n\t\ttry {\n\t\t\tManagedDrone drone = DroneFleetManager.getInstance().getRegisteredDrone(uavId);\n\t\t\tdrone.resendCommand();\n\n\t\t} catch (DroneException e) {\n\t\t\tLOGGER.info(e.getMessage());\n\t\t\tthrow new DronologyServiceException(e.getMessage());\n\t\t}\n\n\t}\n\n}\n"}, {"id": "SimpleCheckerMessageHandler.java", "body": "package edu.nd.dronology.monitoring.simplechecker.checker;\n\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.text.DateFormat;\n\nimport com.google.gson.FieldNamingPolicy;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\nimport edu.nd.dronology.core.DronologyConstants;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.monitoring.DronologyMonitoringManager;\nimport edu.nd.dronology.core.monitoring.IMonitorableMessage;\nimport edu.nd.dronology.core.monitoring.MessageMarshaller;\nimport edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;\nimport edu.nd.dronology.gstation.connector.messages.UAVStateMessage;\nimport edu.nd.dronology.monitoring.IRemoteMonitoringMessageHandler;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class SimpleCheckerMessageHandler extends UnicastRemoteObject implements IRemoteMonitoringMessageHandler {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 3680886616398014407L;\n\n\tprivate static final transient ILogger LOGGER = LoggerProvider.getLogger(SimpleCheckerMessageHandler.class);\n\n\tstatic final transient Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()\n\t\t\t.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)\n\t\t\t.setVersion(1.0).serializeSpecialFloatingPointValues().create();\n\n\tpublic SimpleCheckerMessageHandler() throws RemoteException {\n\n\t\tsuper();\n\t}\n\n\tGeofenceRectangle geofence = new GeofenceRectangle(new LlaCoordinate(41.682, -86.253, 0),\n\t\t\tnew LlaCoordinate(41.676, -86.244, 0));\n\n\t// 'LlaCoordinate(41.679517, -86.252505, 10.000000)\n\t@Override\n\tpublic void notifyMonitoringMessage(IMonitorableMessage message) throws RemoteException {\n\t\tif (message.getType().equals(MessageType.PHYSICAL_UAV_ACTIVATED)) {\n\t\t\tString data = message.getData();\n\t\t\tLlaCoordinate cord = GSON.fromJson(data, LlaCoordinate.class);\n\t\t\tboolean latOK = checkLat(cord);\n\t\t\tboolean longOK = checkLong(cord);\n\t\t\tboolean altOK = checkAlt(cord);\n\n\t\t\tboolean fence = geofence.isInside(cord);\n\n\t\t\tif (latOK && longOK && altOK) {\n\t\t\t\tLOGGER.info(\"Home Location of '\" + message.getUavid() + \"' OK\");\n\n\t\t\t}\n\t\t\tif (fence) {\n\t\t\t\tLOGGER.info(\"Home Location of '\" + message.getUavid() + \"inside of geofence!\");\n\t\t\t\tDronologyMonitoringManager.getInstance().publish(MessageMarshaller\n\t\t\t\t\t\t.createMessage(MessageType.FENCE_CHECK, message.getUavid(), message.getData()));\n\n\t\t\t} else {\n\t\t\t\tLOGGER.error(\"Home Location of '\" + message.getUavid() + \"outside  of geofence!\");\n\t\t\t\tDronologyMonitoringManager.getInstance().publish(MessageMarshaller\n\t\t\t\t\t\t.createMessage(MessageType.FENCE_BREACH, message.getUavid(), message.getData()));\n\t\t\t}\n\t\t} else if (message instanceof UAVStateMessage) {\n\t\t\tUAVStateMessage msg = (UAVStateMessage) message;\n\n\t\t\tboolean fence = true || geofence.isInside(msg.getLocation());\n\n\t\t\tDistanceChecker.getInstance().notify(message);\n\n\t\t\tif (fence) {\n\t\t\t\t// LOGGER.info(\"Location of '\" + message.getUavid() + \"inside of geofence!\");\n\n\t\t\t} else {\n\t\t\t\tLOGGER.missionError(\"GEOFENCE BREACH! -- '\" + message.getUavid() + \"outside  of geofence!\");\n\t\t\t\tDronologyMonitoringManager.getInstance().publish(\n\t\t\t\t\t\tMessageMarshaller.createMessage(MessageType.FENCE_BREACH, message.getUavid(), msg.getData()));\n\t\t\t\tSimpleChecker.getInstance().emergencyStop(msg.getUavid());\n\t\t\t}\n\n\t\t} else {\n\t\t\t// System.out.println(message.toString());\n\t\t}\n\t}\n\n\tprivate boolean checkAlt(LlaCoordinate cord) {\n\t\tif (cord.getAltitude() < 0 || cord.getAltitude() > DronologyConstants.TAKE_OFF_ALTITUDE) {\n\t\t\tLOGGER.error(\"WRONG LATITUDE\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate boolean checkLong(LlaCoordinate cord) {\n\t\tif (cord.getLongitude() > -86 || cord.getLongitude() < -87) {\n\t\t\tLOGGER.error(\"WRONG LATITUDE\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate boolean checkLat(LlaCoordinate cord) {\n\t\tif (cord.getLatitude() > 42 || cord.getLatitude() < 41) {\n\t\t\tLOGGER.error(\"WRONG LATITUDE\");\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n}\n"}, {"id": "KMLExporter.java", "body": "package edu.nd.dronology.misc.kml;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport edu.nd.dronology.core.util.FormatUtil;\nimport edu.nd.dronology.gstation.connector.messages.UAVMessageFactory;\nimport edu.nd.dronology.gstation.connector.messages.UAVStateMessage;\nimport edu.nd.dronology.util.FileUtil;\n\npublic class KMLExporter {\n\n\tprivate static final String UAVID = \"IRIS2\";\n\tprivate String name = \"test.kml\";\n\tprivate String datapath = \"d:\\\\kmlexport\";\n\tprivate String rootTemplate;\n\tprivate String pointTemplate;\n\n\tpublic static void main(String[] args) {\n\n\t\tnew KMLExporter().createKMLFile(\"d:\\\\log.log\");\n\n\t}\n\n\tpublic void createKMLFile(String logfile) {\n\n\t\trootTemplate = FileUtil.readFile(\"./template/track.txt\");\n\t\tpointTemplate = FileUtil.readFile(\"./template/trackpoint.txt\");\n\n\t\t// System.out.println(pointTemplate);\n\n\t\tList<UAVStateMessage> messages = readMessages(logfile);\n\n\t\tString kmlString = createKMLBody(messages);\n\n\t\twriteToFile(kmlString);\n\t}\n\n\tprivate List<UAVStateMessage> readMessages(String logfile) {\n\t\tList<UAVStateMessage> messageList = new ArrayList<>();\n\t\ttry {\n\n\t\t\tList<String> lines = Files.readAllLines(Paths.get(logfile));\n\n\t\t\tlines.forEach(l -> messageList.add(parseLine(l)));\n\t\t\treturn messageList;\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn messageList;\n\t}\n\n\tprivate UAVStateMessage parseLine(String l) {\n\t\tint start = l.indexOf(\"{\");\n\t\tString msgText = l.substring(start);\n\n\t\tUAVStateMessage msg;\n\t\ttry {\n\t\t\tmsg = (UAVStateMessage) UAVMessageFactory.create(msgText);\n\t\t\treturn msg;\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\n\t}\n\n\tprivate void writeToFile(String kmlString) {\n\t\tFile testexists = new File(datapath + \"/\" + name + \".kml\");\n\t\tWriter fwriter;\n\n\t\tif (!testexists.exists()) {\n\t\t\ttry {\n\n\t\t\t\tfwriter = new FileWriter(datapath + \"/\" + name + \".kml\");\n\t\t\t\tfwriter.write(kmlString);\n\t\t\t\tfwriter.flush();\n\t\t\t\tfwriter.close();\n\t\t\t} catch (IOException e1) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te1.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\telse {\n\n\t\t\t// schleifenvariable\n\t\t\tString filecontent = \"\";\n\n\t\t\tArrayList<String> newoutput = new ArrayList<String>();\n\t\t\t;\n\n\t\t\ttry {\n\t\t\t\tBufferedReader in = new BufferedReader(new FileReader(testexists));\n\t\t\t\twhile ((filecontent = in.readLine()) != null)\n\n\t\t\t\t\tnewoutput.add(filecontent);\n\n\t\t\t} catch (FileNotFoundException e1) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te1.printStackTrace();\n\t\t\t} catch (IOException e1) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te1.printStackTrace();\n\t\t\t}\n\n\t\t\t// newoutput.add(2, kmlelement);\n\n\t\t\tString rewrite = \"\";\n\t\t\tfor (String s : newoutput) {\n\t\t\t\trewrite += s;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfwriter = new FileWriter(datapath + \"/\" + name + \".kml\");\n\t\t\t\tfwriter.write(rewrite);\n\t\t\t\tfwriter.flush();\n\t\t\t\tfwriter.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tprivate String createKMLBody(List<UAVStateMessage> messages) {\n\n\t\tString tqFile = new String(rootTemplate);\n\n\t\tStringBuilder cordBuilder = new StringBuilder();\n\t\tfor (UAVStateMessage m : messages) {\n\t\t\tString res = createKMLElement(m);\n\t\t\tif (res != null) {\n\t\t\t\tcordBuilder.append(res);\n\t\t\t}\n\t\t}\n\n\t\ttqFile = tqFile.replace(\"%points\", cordBuilder.toString());\n\n\t\t// StringBuilder sb = new StringBuilder();\n\t\t// content.forEach(str -> {\n\t\t// sb.append(str);\n\t\t// sb.append(\"\\n\");\n\t\t// });\n\t\treturn tqFile;\n\n\t}\n\n\tprivate String createKMLElement(UAVStateMessage m) {\n\n\t\t// DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n\t\t// df.setTimeZone(TimeZone.getTimeZone(\"Zulu\"));\n\t\tString ts = FormatUtil.formatTimestamp(m.getTimestamp(), \"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n\n\t\tif (!m.getUavid().equals(UAVID)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString tp = new String(pointTemplate);\n\n\t\ttp = tp.replace(\"%lat\", Double.toString(m.getLocation().getLatitude()));\n\t\ttp = tp.replace(\"%lon\", Double.toString(m.getLocation().getLongitude()));\n\t\ttp = tp.replace(\"%alt\", Double.toString(m.getLocation().getAltitude()));\n\t\ttp = tp.replace(\"%time\", ts);\n\n\t\treturn tp + \"\\n\";\n\t}\n}\n"}, {"id": "PersistableUAVMissionDescription.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.persistence;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport edu.nd.dronology.services.core.items.IUAVMissionDescription;\nimport edu.nd.dronology.services.core.items.IUAVMissionTask;\n\npublic class PersistableUAVMissionDescription implements Serializable, IUAVMissionDescription {\n\n\tprivate static final long serialVersionUID = 1278076975080384731L;\n\tprivate String name;\n\tprivate String description;\n\tprivate Map<String, Serializable> attributes = new HashMap<>();\n\tprivate List<IUAVMissionTask> tasks = new ArrayList<>();\n\n\tpublic PersistableUAVMissionDescription(String name) {\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn description;\n\n\t}\n\n\t@Override\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\t@Override\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic void addAttribute(String key, Serializable value) {\n\t\tattributes.put(key, value);\n\t}\n\n\t@Override\n\tpublic Serializable getAttributes(String key) {\n\t\treturn attributes.get(key);\n\t}\n\n\t@Override\n\tpublic void addTask(IUAVMissionTask task) {\n\t\ttasks.add(task);\n\t}\n\n\t@Override\n\tpublic void addTask(IUAVMissionTask task, int index) {\n\t\ttasks.add(index, task);\n\t}\n\n\t@Override\n\tpublic boolean removeTask(int index) {\n\t\tif (index >= tasks.size()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn tasks.remove(index) != null;\n\t}\n\n\t@Override\n\tpublic boolean removeTask(IUAVMissionTask task) {\n\t\treturn tasks.remove(task);\n\t}\n\n\t@Override\n\tpublic List<IUAVMissionTask> getTasks() {\n\t\treturn Collections.unmodifiableList(tasks);\n\t}\n\n}\n"}, {"id": "FlightInfoCreator.java", "body": "package edu.nd.dronology.services.instances.flightmanager;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport edu.nd.dronology.core.flight.IFlightPlan;\nimport edu.nd.dronology.core.flight.PlanPoolManager;\nimport edu.nd.dronology.services.core.info.FlightInfo;\nimport edu.nd.dronology.services.core.info.FlightPlanInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.instances.dronesetup.DroneSetupService;\n\npublic class FlightInfoCreator {\n\n\tpublic static FlightInfo createInfo(String uavId) throws DronologyServiceException {\n\t\tDroneSetupService.getInstance().getActiveUAV(uavId);\n\n\t\tFlightInfo info = new FlightInfo(uavId, uavId);\n\n\t\tIFlightPlan currentFlight = PlanPoolManager.getInstance().getCurrentPlan(uavId);\n\t\tif (currentFlight != null) {\n\t\t\tFlightPlanInfo currPl = new FlightPlanInfo(currentFlight.getFlightID(), currentFlight.getFlightID());\n\t\t\tcurrPl.setWaypoints(currentFlight.getWayPoints());\n\t\t\tcurrPl.setDroneId(currentFlight.getDesignatedDroneId());\n\t\t\tinfo.setCurrentFlight(currPl);\n\n\t\t}\n\n\t\tList<IFlightPlan> pendingPlans = PlanPoolManager.getInstance().getPendingPlans(uavId);\n\t\tfor (IFlightPlan plan : pendingPlans) {\n\t\t\tFlightPlanInfo pinfo = new FlightPlanInfo(plan.getFlightID(), plan.getFlightID());\n\t\t\tpinfo.setWaypoints(plan.getWayPoints());\n\t\t\tpinfo.setDroneId(plan.getDesignatedDroneId());\n\t\t\tinfo.addPending(pinfo);\n\t\t}\n\t\tList<IFlightPlan> completedPlans = PlanPoolManager.getInstance().getCompletedPlans(uavId);\n\t\tfor (IFlightPlan plan : completedPlans) {\n\t\t\tFlightPlanInfo pinfo = new FlightPlanInfo(plan.getFlightID(), plan.getFlightID());\n\t\t\tpinfo.setWaypoints(plan.getWayPoints());\n\t\t\tpinfo.setDroneId(plan.getDesignatedDroneId());\n\t\t\tinfo.addCompleted(pinfo);\n\t\t}\n\n\t\treturn info;\n\t}\n\n\tpublic static Collection<FlightPlanInfo> getCurrenctFlights() {\n\t\tList<IFlightPlan> current = new ArrayList<>(PlanPoolManager.getInstance().getCurrentFlights());\n\t\tList<FlightPlanInfo> planInfo = new ArrayList<>();\n\t\tfor (IFlightPlan plan : current) {\n\t\t\tFlightPlanInfo pinfo = new FlightPlanInfo(plan.getFlightID(), plan.getFlightID());\n\t\t\tpinfo.setWaypoints(plan.getWayPoints());\n\t\t\tpinfo.setDroneId(plan.getDesignatedDroneId());\n\t\t\tplanInfo.add(pinfo);\n\t\t}\n\t\treturn planInfo;\n\t}\n\n}\n"}, {"id": "IRouteSelectionStrategy.java", "body": "package edu.nd.dronology.services.extensions.areamapping.selection;\n\nimport java.util.Collection;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.items.IAreaMapping;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic interface IRouteSelectionStrategy {\n\n\tvoid initialize(GeneratedRoutesInfo info, Collection<IUAVProxy> uavs, IAreaMapping mapping)\n\t\t\tthrows DronologyServiceException;\n\n\tRouteSelectionResult generateAssignments() throws DronologyServiceException;\n\n\tRouteSelectionResult generateAssignments(int numAssignments) throws DronologyServiceException;\n\n}"}, {"id": "PysicalDroneIdGenerator.java", "body": "package edu.nd.dronology.gstation.connector.dispatch;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class PysicalDroneIdGenerator {\n\n\tprivate static final String pattern =\"\\\\:(%s$)\";\n\t\n\tpublic static String generate(String id, String groundstationid) {\n\t\treturn id + \":\" + groundstationid;\n\t}\n\t\n\t\n\tpublic static boolean isAssociatedWithGroundstation(String id, String groundstationid) {\n\t\tString pat = String.format(pattern, groundstationid);\n\t\t\n\t\tMatcher m = Pattern.compile(pat).matcher(id);\n\t\treturn m.find();\n\t\n\t}\n\n}\n\n"}, {"id": "MissionExecutionException.java", "body": "package edu.nd.dronology.services.extensions.missionplanning;\n\npublic class MissionExecutionException extends Exception {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -6239074784039693199L;\n\n\tpublic MissionExecutionException(String message) {\n\t\tsuper(message);\n\t}\n\n}\n"}, {"id": "MonitorDialog.java", "body": "package edu.nd.dronology.monitoring.simplechecker.monitor;\n\nimport java.awt.BorderLayout;\nimport java.awt.EventQueue;\nimport java.awt.Font;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTextArea;\nimport javax.swing.ScrollPaneConstants;\nimport javax.swing.SwingUtilities;\nimport javax.swing.border.EtchedBorder;\nimport javax.swing.border.TitledBorder;\nimport javax.swing.BoxLayout;\n\npublic class MonitorDialog {\n\n\tprivate static JFrame frmMonitor;\n\tprivate static JTextArea textArea;\n\n\t/**\n\t * Launch the application.\n\t */\n\tpublic static void main(String[] args) {\n\t\tEventQueue.invokeLater(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tMonitorDialog window = new MonitorDialog();\n\t\t\t\t\twindow.frmMonitor.setVisible(true);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Create the application.\n\t */\n\tpublic MonitorDialog() {\n\t\tinitialize();\n\t}\n\n\t/**\n\t * Initialize the contents of the frame.\n\t */\n\tprivate void initialize() {\n\t\tfrmMonitor = new JFrame();\n\t\tfrmMonitor.setTitle(\"Simple-Monitor\");\n\t\tfrmMonitor.setBounds(100, 100, 705, 500);\n\t\tfrmMonitor.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n\t\tJPanel middlePanel = new JPanel();\n\t\tmiddlePanel.setBorder(new TitledBorder(new EtchedBorder(), \"\"));\n\t\tfrmMonitor.getContentPane().add(middlePanel);\n\t\tmiddlePanel.setLayout(new BoxLayout(middlePanel, BoxLayout.X_AXIS));\n\t\t// create the middle panel components\n\n\t\ttextArea = new JTextArea();\n\t\ttextArea.setLineWrap(true);\n\t\ttextArea.setWrapStyleWord(true);\n\n\t\ttextArea.setEditable(false); // set textArea non-editable\n\t\tJScrollPane scroll = new JScrollPane(textArea);\n\t\tscroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n\n\t\t// Add Textarea in to middle panel\n\t\tmiddlePanel.add(scroll);\n\n\t\ttextArea.setFont(new Font(\"Courier New\", Font.BOLD, 20));\n\t\ttextArea.setEditable(false);\n\t\t// textArea.getDocument().addDocumentListener(this);\n\t}\n\n\tpublic void addLine(String line) {\n\t\tSwingUtilities.invokeLater(() -> {\n\t\t\ttextArea.append(line);\n\t\t\ttextArea.append(\"\\n\");\n\t\t\ttextArea.setSelectionEnd(textArea.getText().length());\n\t\t});\n\n\t}\n\n}\n"}, {"id": "IMonitoringMessage.java", "body": "package edu.nd.dronology.monitoring;\n\npublic interface IMonitoringMessage {\n\n}\n"}, {"id": "SynchronizationState.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.sync;\n\n/**\n * Possible state of a {@link SynchronizationPoint}\n * \n * @author Jane Cleland-Huang \n *\n */\npublic enum SynchronizationState {\n\tNOTACTIVATED, ACTIVE, SYNCHED; \n}\n"}, {"id": "IDroneSetupServiceInstance.java", "body": "package edu.nd.dronology.services.instances.dronesetup;\n\nimport java.util.Collection;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.api.IServiceInstance;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo;\nimport edu.nd.dronology.services.core.listener.IDroneStatusChangeListener;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic interface IDroneSetupServiceInstance extends IServiceInstance {\n\n\n\tvoid initializeDrones(DroneInitializationInfo[] info) throws DronologyServiceException;\n\n\tvoid addDroneStatusChangeListener(IDroneStatusChangeListener listener);\n\n\tvoid removeDroneStatusChangeListener(IDroneStatusChangeListener listener);\n\n\tCollection<IUAVProxy> getActiveUAVs();\n\n\tvoid deactivateDrone(IUAVProxy status) throws DronologyServiceException;\n\n\tIUAVProxy getActiveUAV(String uavId) throws DronologyServiceException;\n\n\tvoid resendCommand(String uavId) throws DronologyServiceException;\n\n}\n"}, {"id": "IRemoteInfoObject.java", "body": "package edu.nd.dronology.services.core.api;\n\nimport java.util.Map.Entry;\nimport java.util.Set;\n\n/**\n * Base interface for all serializable objects sent over remote interfaces containing information on constraints, requirements, models etc.\n * \n * @author Michael Vierhauser\n * \n */\npublic interface IRemoteInfoObject extends IRemoteTransferObject, Comparable<IRemoteInfoObject> {\n\n\t/**\n\t * \n\t * @param key\n\t *          The key of the attribute.\n\t * @return The value for the given attribute key.<br>\n\t *         Returns {@code null} if no value for the given key is available.\n\t */\n\tString getAttribute(String key);\n\n\tString getName();\n\n\tString getId();\n\n\tSet<Entry<String, String>> getAttributes();\n\n\tvoid addAttribute(String key, String value);\n\n}\n"}, {"id": "ImageWaypoint.java", "body": "package edu.nd.dronology.services.extensions.areamapping.internal;\n\nimport java.awt.geom.Point2D;\n\n\npublic class ImageWaypoint {\n\tprivate Point2D.Double waypoint;\n\tprivate double orientationAngle;\n\t\n\tpublic ImageWaypoint() {\n\t\twaypoint = new Point2D.Double();\n\t}\n\t\n\tpublic ImageWaypoint(Point2D.Double point, double angle) {\n\t\twaypoint = new Point2D.Double();\n\t\tsetWaypoint(point.getX(), point.getY());\n\t\tsetOrientationAngle(angle);\n\t}\n\t\n\tpublic Point2D.Double getWaypoint() {\n\t\treturn waypoint;\n\t}\n\t\n\tpublic double getOrientationAngle() {\n\t\treturn orientationAngle;\n\t}\n\t\n\tpublic void setImageWaypoint(double latitude, double longitude, double angle) {\n\t\tsetWaypoint(latitude, longitude);\n\t\tsetOrientationAngle(angle);\n\t}\n\t\n\tpublic void setWaypoint(double latitude, double longitude) {\n\t\twaypoint.setLocation(latitude, longitude);\n\t}\n\t\n\tpublic void setOrientationAngle(double angle) {\n\t\torientationAngle = angle;\n\t}\n}\n"}, {"id": "UAVTypeRegistrationServiceInstance.java", "body": "package edu.nd.dronology.services.instances.registration.types;\n\nimport java.io.File;\nimport java.util.Set;\n\nimport edu.nd.dronology.services.core.api.IFileChangeNotifyable;\nimport edu.nd.dronology.services.core.api.ServiceInfo;\nimport edu.nd.dronology.services.core.base.AbstractFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.info.UAVTypeRegistrationInfo;\nimport edu.nd.dronology.services.core.items.IUAVTypeRegistration;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport edu.nd.dronology.services.core.persistence.UAVTypeRegistrationPersistenceProvider;\nimport edu.nd.dronology.services.core.util.DronologyConstants;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.core.util.ServiceIds;\nimport edu.nd.dronology.services.instances.DronologyElementFactory;\nimport edu.nd.dronology.services.supervisor.SupervisorService;\nimport edu.nd.dronology.util.FileUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class UAVTypeRegistrationServiceInstance extends AbstractFileTransmitServiceInstance<UAVTypeRegistrationInfo>\n\t\timplements IFileChangeNotifyable, IUAVTypeRegistrationServiceInstance {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(UAVTypeRegistrationServiceInstance.class);\n\n\tprivate static final int ORDER = 2;\n\n\tpublic static final String EXTENSION = DronologyConstants.EXTENSION_TYPEREGISTRATION;\n\n\n\tpublic UAVTypeRegistrationServiceInstance() {\n\t\tsuper(ServiceIds.SERVICE_REGISTRATION, \"UAV TypeRegistration Management\", EXTENSION);\n\t}\n\n\t@Override\n\tprotected Class<?> getServiceClass() {\n\t\treturn UAVTypeRegistrationServiceInstance.class;\n\t}\n\n\t@Override\n\tprotected int getOrder() {\n\t\treturn ORDER;\n\t}\n\n\t@Override\n\tprotected String getPropertyPath() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void doStartService() throws Exception {\n\t\treloadItems();\n\t}\n\n\t@Override\n\tprotected void doStopService() throws Exception {\n\t\tfileManager.tearDown();\n\t}\n\n\t@Override\n\tpublic ServiceInfo getServiceInfo() {\n\t\tServiceInfo sInfo = super.getServiceInfo();\n\t\tsInfo.addAttribute(ServiceInfo.ATTRIBUTE_TYPE, ServiceInfo.ATTRIBUTE_FILE);\n\t\treturn sInfo;\n\t}\n\n\t@Override\n\tpublic UAVTypeRegistrationInfo createItem() throws DronologyServiceException {\n\t\tUAVTypeRegistrationPersistenceProvider persistor = UAVTypeRegistrationPersistenceProvider.getInstance();\n\t\tIUAVTypeRegistration specification = DronologyElementFactory.createNewUAVTypeSpecification();\n\t\tspecification.setName(\"New-UAVTypeSpecification\");\n\t\tString savePath = FileUtil.concat(storagePath, specification.getId(), EXTENSION);\n\n\t\ttry {\n\t\t\tpersistor.saveItem(specification, savePath);\n\t\t} catch (PersistenceException e) {\n\t\t\tthrow new DronologyServiceException(\"Error when creating drone euqipment: \" + e.getMessage());\n\t\t}\n\t\treturn new UAVTypeRegistrationInfo(specification.getName(), specification.getId());\n\t}\n\n\t@Override\n\tprotected String getPath() {\n\t\tString path = SupervisorService.getInstance().getDroneSpecificationLocation();\n\t\treturn path;\n\t}\n\n\t@Override\n\tprotected UAVTypeRegistrationInfo fromFile(String id, File file) throws Throwable {\n\t\tIUAVTypeRegistration atm = UAVTypeRegistrationPersistenceProvider.getInstance().loadItem(file.toURI().toURL());\n\t\tUAVTypeRegistrationInfo info = new UAVTypeRegistrationInfo(atm.getName(), id);\n\t\treturn info;\n\t}\n\n\t@Override\n\tprotected boolean hasProperties() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void notifyFileChange(Set<String> changed) {\n\t\tfor (String s : changed) {\n\t\t\tupdateItem(s);\n\t\t}\n\t\tsuper.notifyFileChange(changed);\n\t\tfor (String s : changed) {\n\t\t\tString id = s.replace(\".\" + extension, \"\");\n\t\t\tif (!itemmap.containsKey(id)) {\n\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void updateItem(String s) {\n\t\tSystem.out.println(\"UPDATE\");\n\n\t}\n\n}\n"}, {"id": "MAVLinkUAVConnector.java", "body": "package edu.nd.dronology.gstation.connector;\n//package edu.nd.dronology.gstation.python.connector;\n//\n//import java.io.IOException;\n//import java.net.InetAddress;\n//import java.net.InetSocketAddress;\n//import java.net.Socket;\n//import java.net.UnknownHostException;\n//import java.util.Map;\n//import java.util.concurrent.ConcurrentHashMap;\n//import java.util.concurrent.ExecutorService;\n//import java.util.concurrent.Executors;\n//\n//import edu.nd.dronology.core.IUAVPropertyUpdateNotifier;\n//import edu.nd.dronology.core.exceptions.DroneException;\n//import edu.nd.dronology.core.vehicle.IDroneCommandHandler;\n//import edu.nd.dronology.core.vehicle.commands.IDroneCommand;\n//import edu.nd.dronology.gstation.python.connector.dispatch.DispatchQueueManager;\n//import edu.nd.dronology.gstation.python.connector.dispatch.ReadDispatcher;\n//import edu.nd.dronology.gstation.python.connector.dispatch.WriteDispatcher;\n//import edu.nd.dronology.util.NamedThreadFactory;\n//import net.mv.logging.ILogger;\n//import net.mv.logging.LoggerProvider;\n//\n//public class MAVLinkUAVConnector implements IDroneCommandHandler {\n//\n//\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(MAVLinkUAVConnector.class);\n//\n//\tprotected static final ExecutorService servicesExecutor = Executors.newFixedThreadPool(10,\n//\t\t\tnew NamedThreadFactory(\"Groundstation-Threads\"));\n//\n//\t// socket for communication with python ground station\n//\tprivate Socket pythonSocket;\n//\tprivate final Map<String, IUAVPropertyUpdateNotifier> registeredListeners = new ConcurrentHashMap<>();\n//\tprivate ReadDispatcher readDispatcher;\n//\tprivate WriteDispatcher writeDispatcher;\n//\tprivate final String groundstationid;\n//\tprivate final DispatchQueueManager dispatchQueueManager;\n//\tprivate final String host;\n//\tprivate final int port;\n//\tprivate boolean connected;\n//\n//\tpublic MAVLinkUAVConnector(String groundstationid, String host, int port) {\n//\t\tthis.groundstationid = groundstationid;\n//\t\tdispatchQueueManager = new DispatchQueueManager(groundstationid);\n//\t\tthis.host = host;\n//\t\tthis.port = port;\n//\t\tthis.connected = false;\n//\t\tconnect();\n//\t}\n//\n//\tprivate void connect() {\n//\t\ttry {\n//\t\t\tInetAddress hostAddr = InetAddress.getByName(host);\n//\n//\t\t\tString hostStr = hostAddr.toString();\n//\n//\t\t\tLOGGER.info(\"Connecting to Python base \" + hostStr + \"@\" + port);\n//\t\t\tpythonSocket = new Socket();\n//\t\t\tpythonSocket.connect(new InetSocketAddress(hostAddr, port), 5000);\n//\t\t\t// pythonSocket.setSoTimeout(20000);\n//\n//\t\t\tLOGGER.hwInfo(\"Connected to \" + pythonSocket.getInetAddress().toString() + \"@\" + pythonSocket.getPort());\n//\t\t//\treadDispatcher = new ReadDispatcher(pythonSocket, dispatchQueueManager);\n//\t\t\twriteDispatcher = new WriteDispatcher(pythonSocket, dispatchQueueManager.getOutgoingCommandQueue());\n//\t\t\tservicesExecutor.submit(readDispatcher);\n//\t\t\tservicesExecutor.submit(writeDispatcher);\n//\t\t\tconnected = true;\n//\t\t} catch (UnknownHostException e) {\n//\t\t\tLOGGER.hwFatal(\"Can't connect to Python Groundstation \");\n//\t\t\tscheduleReconnect();\n//\t\t} catch (Throwable e) {\n//\t\t\tLOGGER.hwFatal(\"Can't connect to Python Groundstation \" + e.getMessage());\n//\t\t\tscheduleReconnect();\n//\t\t}\n//\t}\n//\n//\tprivate void scheduleReconnect() {\n//\t\t// TODO implement me...\n//\n//\t}\n//\n//\t@Override\n//\tpublic void sendCommand(IDroneCommand cmd) throws DroneException {\n//\t\tLOGGER.hwInfo(groundstationid + \" Sending Command to UAV \" + cmd.toString());\n//\t\tdispatchQueueManager.send(cmd);\n//\t}\n//\n//\t@Override\n//\tpublic void setStatusCallbackNotifier(String id, IUAVPropertyUpdateNotifier listener) throws DroneException {\n//\t\tif (registeredListeners.containsKey(id)) {\n//\t\t\tthrow new DroneException(\"An listener with '\" + id + \"' is already registered\");\n//\t\t}\n//\t\tregisteredListeners.put(id, listener);\n//\t\tdispatchQueueManager.createDispatchThread(id, listener);\n//\t}\n//\n//\tpublic void tearDown() {\n//\t\ttry {\n//\t\t\tpythonSocket.close();\n//\t\t\treadDispatcher.tearDonw();\n//\t\t\twriteDispatcher.tearDown();\n//\t\t\tdispatchQueueManager.tearDown();\n//\t\t} catch (IOException e) {\n//\t\t\tLOGGER.hwFatal(e);\n//\t\t}\n//\t}\n//\n//\t@Override\n//\tpublic String getHandlerId() {\n//\t\treturn groundstationid;\n//\t}\n//\n//\tpublic void registerMonitoringMessageHandler(IMonitoringMessageHandler monitoringhandler) {\n//\t\tdispatchQueueManager.registerMonitoringMessageHandler(monitoringhandler);\n//\n//\t}\n//\n//\tpublic void registerSafetyValidator(IUAVSafetyValidator validator) {\n//\t\tdispatchQueueManager.registerSafetyValidator(validator);\n//\n//\t}\n//\n//}\n"}, {"id": "MissionExecutionTester.java", "body": "package edu.nd.dronology.services.launch;\n\nimport java.net.MalformedURLException;\nimport java.rmi.Naming;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Random;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo.DroneMode;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.info.MissionInfo;\nimport edu.nd.dronology.services.core.info.UAVMappingInfo;\nimport edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;\nimport edu.nd.dronology.services.core.remote.IMissionPlanningRemoteService;\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic class MissionExecutionTester {\n\n\tprivate static final String ADDRESS_SCHEME = \"rmi://%s:%s/Remote\";\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\t// Flying Field\n\t\t\tLlaCoordinate cord1 = new LlaCoordinate(41.694116, -86.253591, 0);\n\t\t\tLlaCoordinate cord2 = new LlaCoordinate(41.519400, -86.239527, 0);\n\t\t\tLlaCoordinate cord4 = new LlaCoordinate(41.717158, -86.228932, 0);\n\n\t\t\tIRemoteManager manager = (IRemoteManager) Naming.lookup(String.format(ADDRESS_SCHEME, \"localhost\", 9779));\n\n\t\t\tIMissionPlanningRemoteService service = (IMissionPlanningRemoteService) manager\n\t\t\t\t\t.getService(IMissionPlanningRemoteService.class);\n\n\t\t\tIDroneSetupRemoteService dservice = (IDroneSetupRemoteService) manager\n\t\t\t\t\t.getService(IDroneSetupRemoteService.class);\n\n\t\t\tDroneInitializationInfo inff = new DroneInitializationInfo(\"frank\", DroneMode.MODE_VIRTUAL, \"IRIS+\", cord1);\n\t\t//\tdservice.initializeDrones(inff);\n\n\t\t\tCollection<MissionInfo> items = service.getItems();\n\t\t\tSystem.out.println(\"INFIS:\" + items.size());\n\t\t\tfor (MissionInfo mi : items) {\n\t\t\t\tSystem.out.println(\"MI:\" + mi.getName());\n\t\t\t\tif (mi.getName().equals(\"mission1\")) {\n\t\t\t\t\tUAVMappingInfo mapping = new UAVMappingInfo();\n\t\t\t\t\tmapping.addAttribute(\"uav1\", \"frank\");\n\t\t\t\t\tservice.executeMissionPlan(mi,mapping);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\n\t\t\t//\n\t\t\t// DroneInitializationInfo inff2 = new DroneInitializationInfo(\"S&R-UAV2\",\n\t\t\t// DroneMode.MODE_VIRTUAL, \"IRIS+\",\n\t\t\t// cord4);\n\t\t\t// dservice.initializeDrones(inff2);\n\t\t\t//\n\t\t\t// DroneInitializationInfo inff3 = new DroneInitializationInfo(\"S&R-UAV3\",\n\t\t\t// DroneMode.MODE_VIRTUAL, \"IRIS+\",\n\t\t\t// cord4);\n\t\t\t// dservice.initializeDrones(inff3);\n\n\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (MalformedURLException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (NotBoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tstatic Random rand = new Random();\n\n\tprivate static FlightRouteInfo getRandomRoute(List<FlightRouteInfo> allRoutes) {\n\t\tint routeSize = allRoutes.size();\n\n\t\tint randomNumber = rand.nextInt(routeSize);\n\n\t\treturn allRoutes.get(randomNumber);\n\n\t}\n\n}\n"}, {"id": "PhysicalDroneTest.java", "body": "package edu.nd.dronology.groundstation.connector;\n//package TestCases;\n//import java.util.Calendar;\n//\n//import org.junit.Test;\n//\n//import edu.nd.dronology.core.exceptions.FlightZoneException;\n//import edu.nd.dronology.core.util.Coordinate;\n//import edu.nd.dronology.core.vehicle.IDrone;\n//import model.drone.groundstation.PythonBase;\n//import model.drone.runtime.PhysicalDrone;\n//\n//public class PhysicalDroneTest {\n//\n//\t@Test\n//\tpublic void test() throws FlightZoneException, InterruptedException {\n//\t\tPythonBase baseStation = new PythonBase();\n//\t\t\n//\t\tDroneSet\n//\t\t\n//\t\tIDrone drone = DroneFleetfacotry.(\"test_drone\", baseStation);\n//\t\tlong alt_tolerance = 1;\n//\t\tlong init_lat = drone.getLatitude();\n//\t\tlong init_lon = drone.getLongitude();\n//\t\tlong init_alt = drone.getAltitude();\n//\t\tSystem.out.println(init_lat);\n//\t\tSystem.out.println(init_lon);\n//\t\tSystem.out.println(init_alt);\n//\t\t\n//\t\tassert(init_alt<=alt_tolerance);\n//\t\t\n//\t\tlong dest_lat = init_lat + 1000;\n//\t\tlong dest_lon = init_lon + 1000;\n//\t\tint dest_alt = 20;\n//\t\t\n//\t\t//TestTakeoff(drone,alt_tolerance,45000,dest_alt);\n//\t\t//TestLand(drone,0,45000);\n//\t\t\n//\t\t//Thread.sleep(1000); //TODO: figure out why land then takeoff doesn't work\n//\t\t\n//\t\tTestTakeoff(drone,alt_tolerance,45000,dest_alt);\n//\t\tTestFlyTo(drone, 60000, dest_lat, dest_lon, dest_alt);\n//\t\tTestFlyTo(drone, 60000, init_lat, init_lon, dest_alt);\n//\t\tTestLand(drone,alt_tolerance,45000);\n//\t}\n//\t\n//\tprivate void TestTakeoff(IDrone drone, long alt_tolerance, long timeout, int dest_alt) throws FlightZoneException, InterruptedException {\n//\t\tdrone.takeOff(dest_alt);\n//\t\tlong init_time = Calendar.getInstance().getTimeInMillis();\n//\t\t//long init_time = System.currentTimeMillis();\n//\t\tlong current_time = init_time;\n//\t\tboolean still_taking_off = true;\n//\t\twhile(((current_time-init_time)<timeout) && still_taking_off) {\n//\t\t\tThread.sleep(10);\n//\t\t\tif(drone.getAltitude()>=(dest_alt-alt_tolerance)) {\n//\t\t\t\tstill_taking_off = false;\n//\t\t\t}\n//\t\t\tcurrent_time = Calendar.getInstance().getTimeInMillis();\n//\t\t}\n//\t\tassert(!still_taking_off);\n//\t}\n//\t\n//\tprivate void TestLand(IDrone drone, long alt_tolerance, long timeout) throws FlightZoneException, InterruptedException {\n//\t\tdrone.land();\n//\t\tlong init_time = Calendar.getInstance().getTimeInMillis();\n//\t\tlong current_time = init_time;\n//\t\tboolean still_landing = true;\n//\t\twhile(((current_time-init_time)<timeout) && still_landing) {\n//\t\t\tThread.sleep(10);\n//\t\t\tif(drone.getAltitude()<=alt_tolerance) {\n//\t\t\t\tstill_landing = false;\n//\t\t\t}\n//\t\t\tcurrent_time = Calendar.getInstance().getTimeInMillis();\n//\t\t}\n//\t\tassert(!still_landing);\n//\t}\n//\t\n//\tprivate void TestFlyTo(IDrone drone, long timeout, long lat, long lon, long alt) throws FlightZoneException, InterruptedException {\n//\t\tdrone.flyTo(new Coordinate(lat, lon, (int)alt));\n//\t\tlong init_time = Calendar.getInstance().getTimeInMillis();\n//\t\tlong current_time = init_time;\n//\t\tboolean still_flying = true;\n//\t\twhile(((current_time-init_time)<timeout) && still_flying) {\n//\t\t\tThread.sleep(10);\n//\t\t\tif(drone.isDestinationReached(0)) {\n//\t\t\t\tstill_flying = false;\n//\t\t\t}\n//\t\t\tcurrent_time = Calendar.getInstance().getTimeInMillis();\n//\t\t}\n//\t\tassert(!still_flying);\n//\t}\n//}\n"}, {"id": "MissionController.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.plan;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport com.google.common.util.concurrent.RateLimiter;\n\nimport edu.nd.dronology.services.core.info.UAVMappingInfo;\nimport edu.nd.dronology.services.core.items.IMissionPlan;\nimport edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;\nimport edu.nd.dronology.services.extensions.missionplanning.sync.SynchronizationManager;\nimport edu.nd.dronology.services.extensions.missionplanning.v1.FullMissionPlan;\nimport edu.nd.dronology.services.instances.dronesetup.DroneSetupService;\nimport edu.nd.dronology.util.NamedThreadFactory;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Central control class responsible for building, initializing, and executing a\n * {@link FullMissionPlan}.<br>\n * The {@link MissionController} periodically checks for new tasks that can be\n * activated and activates them on demand.\n * \n * @author Michael Vierhauser\n */\npublic class MissionController implements Runnable {\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(MissionController.class);\n\tRateLimiter barrier = RateLimiter.create(1);\n\tAtomicBoolean missionrunning = new AtomicBoolean(true);\n\tprivate transient IExecuteableMissionPlan missionPlan;\n\tprivate static final ExecutorService SERVICE_EXECUTOR = Executors\n\t\t\t.newSingleThreadExecutor(new NamedThreadFactory(\"MissionControl\"));\n\tprivate transient static MissionController INSTANCE;\n\n\t@Deprecated\n\tpublic void executeMission(String mission) throws MissionExecutionException {\n\t\tif (missionPlan != null) {\n\t\t\tthrow new MissionExecutionException(\"Another mission is currently running!\");\n\t\t}\n\n\t\tFullMissionPlan mp = new FullMissionPlan(mission);\n\t\tmp.build();\n\t\tmissionPlan = mp;\n\t\tSERVICE_EXECUTOR.submit(this);\n\t}\n\n\tpublic void executeMission(IMissionPlan mission, UAVMappingInfo mapping) throws MissionExecutionException {\n\t\tif (missionPlan != null) {\n\t\t\tthrow new MissionExecutionException(\"Another mission is currently running!\");\n\t\t}\n\t\t\n\t\tFullMissionPlan2 mp = new FullMissionPlan2(mission);\n\t\tmp.build(mapping);\n\t\tmissionPlan = mp;\n\t\tSERVICE_EXECUTOR.submit(this);\n\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tmissionrunning.getAndSet(true);\n\t\twhile (missionrunning.get() && missionPlan.isMissionActive()) {\n\t\t\tbarrier.acquire();\n\t\t\ttry {\n\t\t\t\tmissionPlan.checkAndActivateTask();\n\t\t\t} catch (MissionExecutionException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t\ttry {\n\t\t\t\t\tcancelMission();\n\t\t\t\t} catch (MissionExecutionException e1) {\n\t\t\t\t\tLOGGER.error(e1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLOGGER.info(\"Mission complete\");\n\t\tSynchronizationManager.getInstance().resetAltitudes();\n\t\tmissionPlan = null;\n\t}\n\n\t/**\n\t * @return The singleton MissionController instance\n\t */\n\tpublic static MissionController getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (DroneSetupService.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new MissionController();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\tpublic void cancelMission() throws MissionExecutionException {\n\t\tif (missionPlan == null) {\n\t\t\tthrow new MissionExecutionException(\"No mission currently active\");\n\t\t}\n\t\tSynchronizationManager.getInstance().resetAltitudes();\n\t\tmissionrunning.getAndSet(false);\n\t\tmissionPlan.cancelMission();\n\t\tmissionPlan = null;\n\t}\n\n}\n"}, {"id": "WatchServiceRunner.java", "body": "package edu.nd.dronology.services.core.util;\n\nimport static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n\nimport java.io.IOException;\nimport java.nio.file.ClosedWatchServiceException;\nimport java.nio.file.FileSystems;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.StandardWatchEventKinds;\nimport java.nio.file.WatchEvent;\nimport java.nio.file.WatchKey;\nimport java.nio.file.WatchService;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\nimport edu.nd.dronology.services.core.api.IFileChangeNotifyable;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class WatchServiceRunner implements Runnable {\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(WatchServiceRunner.class);\n\tprivate boolean recursive;\n\tprivate IFileChangeNotifyable manager;\n\tprivate String[] fileExtensions;\n\n\tpublic WatchServiceRunner(String dir, boolean recursive, IFileChangeNotifyable manager, String... fileExtensions) {\n\t\tthis.dir = dir;\n\t\tthis.fileExtensions = fileExtensions;\n\t\tthis.recursive = recursive;\n\t\tthis.manager = manager;\n\t}\n\n\tprivate WatchService watcher;\n\tprivate String dir;\n\tprivate Object notifyTask;\n\tprivate List<String> changeList = new ArrayList<>();\n\tprivate static Map<WatchKey, Path> keys = new HashMap<>();\n\n\t@Override\n\tpublic void run() {\n\n\t\ttry {\n\t\t\twatcher = FileSystems.getDefault().newWatchService();\n\t\t\tregister(Paths.get(dir));\n\n\t\t\twhile (true) {\n\t\t\t\tWatchKey watchKey = watcher.take();\n\t\t\t\tfor (WatchEvent<?> watchEvent : watchKey.pollEvents()) {\n\t\t\t\t\tPath context = (Path) watchEvent.context();\n\t\t\t\t\tfor (String ext : fileExtensions) {\n\t\t\t\t\t\tif (context.getFileName().toString().endsWith(ext)) {\n\t\t\t\t\t\t\tif (\"ENTRY_DELETE\".equals(watchEvent.kind().toString())\n\t\t\t\t\t\t\t\t\t|| \"ENTRY_CREATE\".equals(watchEvent.kind().toString())\n\t\t\t\t\t\t\t\t\t|| \"ENTRY_MODIFY\".equals(watchEvent.kind().toString())) {\n\t\t\t\t\t\t\t\tchanged(context.getFileName().toString());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twatchKey.reset();\n\t\t\t}\n\t\t} catch (ClosedWatchServiceException e) {\n\t\t} catch (IOException e) {\n\t\t\tLOGGER.error(e);\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\n\t}\n\n\tprivate void changed(String fileName) {\n\t\tchangeList.add(fileName);\n\t\tif (notifyTask != null) {\n\t\t\treturn;\n\t\t}\n\t\tTimer timer = new Timer();\n\t\ttimer.schedule(new NotifyChangeTask(), 500);\n\t\tnotifyTask = new NotifyChangeTask();\n\t}\n\n\tclass NotifyChangeTask extends TimerTask {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tSet<String> changed = new HashSet<>();\n\t\t\tsynchronized (changeList) {\n\t\t\t\tchanged.addAll(changeList);\n\t\t\t\tchangeList.clear();\n\t\t\t\tnotifyTask = null;\n\t\t\t}\n\t\t\tmanager.notifyFileChange(changed);\n\n\t\t}\n\t}\n\n\tprivate void registerAll(final Path start) throws IOException {\n\t\t// register directory and sub-directories\n\n\t\tFiles.walkFileTree(start, new SimpleFileVisitor<Path>() {\n\t\t\t@Override\n\t\t\tpublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n\t\t\t\ttry {\n\t\t\t\t\tif (dir.getFileName() != null && (dir.getFileName().toString().startsWith(\".\")\n\t\t\t\t\t\t\t|| dir.getFileName().toString().startsWith(\"$\"))) {\n\t\t\t\t\t\treturn FileVisitResult.SKIP_SUBTREE;\n\t\t\t\t\t}\n\t\t\t\t\tregister(dir);\n\t\t\t\t\treturn FileVisitResult.CONTINUE;\n\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\treturn FileVisitResult.SKIP_SUBTREE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic FileVisitResult visitFileFailed(Path file, IOException exc) {\n\t\t\t\tSystem.err.format(\"Unable to register:\" + \" %s: %s%n\", file, exc);\n\t\t\t\treturn FileVisitResult.CONTINUE;\n\t\t\t}\n\t\t});\n\n\t}\n\n\t/**\n\t * Register the given directory with the WatchService\n\t */\n\tprivate void register(Path dir) throws IOException {\n\n\t\t// WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE,\n\t\t// ENTRY_MODIFY);\n\t\tWatchKey key = dir.register(watcher, ENTRY_CREATE, StandardWatchEventKinds.ENTRY_MODIFY,\n\t\t\t\tStandardWatchEventKinds.ENTRY_DELETE);\n\t\tif (true) {\n\t\t\t// System.out.println(\"VALID: \"+dir.getFileName().toString());\n\t\t\tPath prev = keys.get(key);\n\t\t\tif (prev == null) {\n\t\t\t\t// System.out.format(\"register: %s\\n\", dir);\n\t\t\t} else {\n\t\t\t\tif (!dir.equals(prev)) {\n\t\t\t\t\t// System.out.format(\"update: %s -> %s\\n\", prev, dir);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tkeys.put(key, dir);\n\t}\n\n\tpublic void stop() {\n\t\ttry {\n\t\t\twatcher.close();\n\t\t} catch (IOException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\n}\n"}, {"id": "PersistenceException.java", "body": "package edu.nd.dronology.services.core.persistence;\n\npublic class PersistenceException extends Throwable {\n\n\tpublic PersistenceException(Exception e) {\n\t\tsuper(e);\n\t}\n\n\tpublic PersistenceException() {\n\t\tsuper();\n\t}\n\n\tpublic PersistenceException(String message) {\n\t\tsuper(message);\n\t}\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -7093839510895063175L;\n\n}\n"}, {"id": "IFlightManagerServiceInstance.java", "body": "package edu.nd.dronology.services.instances.flightmanager;\n\nimport java.util.Collection;\nimport java.util.List;\n\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.services.core.api.IServiceInstance;\nimport edu.nd.dronology.services.core.info.FlightInfo;\nimport edu.nd.dronology.services.core.info.FlightPlanInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic interface IFlightManagerServiceInstance extends IServiceInstance {\n\n\tpublic FlightInfo getFlightDetails();\n\n\tpublic void planFlight(String uavid, String planName, List<Waypoint> waypoints) throws Exception;\n\n\tpublic void planFlight(String planName, List<Waypoint> waypoints) throws Exception;\n\n\tpublic void returnToHome(String uavid) throws Exception;\n\n\tpublic void pauseFlight(String uavid) throws Exception;\n\n\tpublic FlightInfo getFlightInfo(String uavId) throws DronologyServiceException;\n\n\tCollection<FlightPlanInfo> getCurrentFlights();\n\n\tpublic void cancelPendingFlights(String uavid) throws Exception;\n\n\tpublic void takeoff(String uavid, double altitude) throws DronologyServiceException;\n\n\tpublic void emergencyStop(String uavid) throws DronologyServiceException;\n\n}\n"}, {"id": "ServiceInfo.java", "body": "package edu.nd.dronology.services.core.api;\n\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.TreeMap;\n\nimport edu.nd.dronology.util.NullUtil;\n\n/**\n * \n * Wrapper object for various attributes and properties of an {@link IServiceInstance}\n * \n * \n * @author Michael Vierhauser\n * \n */\npublic class ServiceInfo implements IRemoteTransferObject, Comparable<ServiceInfo> {\n\n\tpublic static final String ATTRIBUTE_SERVICEID = \"Service ID\";\n\tpublic static final String ATTRIBUTE_SOCKET = \"Socket\";\n\tpublic static final String ATTRIBUTE_REMOTE = \"Remote\";\n\tpublic static final String ATTRIBUTE_FILE = \"File\";\n\t\n\tpublic static final String ATTRIBUTE_TYPE= \"Type\";\n\tpublic static final String ATTRIBUTE_DISPATCHQUEUESIZE = \"Queue Size\";\n\tpublic static final String ATTRIBUTE_DISTRIBUTORPRIORITY = \"Priority\";\n\tpublic static final String ATTRIBUTE_SUBSCRIBER = \"Registered Subscriber\";\n\tpublic static final String ATTRIBUTE_TYPE_DISTRIBUTOR = \"Distributor\";\n\tpublic static final String ATTRIBUTE_TYPE_SERVICE = \"Service\";\n\n\tpublic static final String ATTRIBUTE_TIMESTAMP = \"Timestamp\";\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 376263095158789667L;\n\n\t\n\n\n\tprivate Map<String, String> attributes = new TreeMap<>();\n\tprivate Map<String, String> properties = new TreeMap<>();\n\tprivate String serviceID;\n\tprivate String description;\n\tprivate ServiceStatus serviceStatus = ServiceStatus.STOPPED;\n\tprivate String className;\n\tprivate final int order;\n\n\t/**\n\t * \n\t * @param serviceID\n\t * @param serviceStatus\n\t * @param description\n\t * @param attributes\n\t * @param properties\n\t * @param order\n\t */\n\tpublic ServiceInfo(String serviceID, ServiceStatus serviceStatus, String description, Map<String, String> attributes,\n\t\t\tMap<String, String> properties, int order) {\n\t\tsuper();\n\t\tNullUtil.checkNull(attributes, properties);\n\t\tthis.attributes = new TreeMap<>(attributes);\n\t\tthis.properties = new TreeMap<>(properties);\n\t\tthis.serviceID = serviceID;\n\t\tthis.serviceStatus = serviceStatus;\n\t\tthis.description = description;\n\t\tthis.order = order;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tfor (Entry<String, String> e : attributes.entrySet()) {\n\t\t\tsb.append(e.getKey());\n\t\t\tsb.append(\":\");\n\t\t\tsb.append(e.getValue());\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * \n\t * @return The attributes of the server process.\n\t */\n\tpublic Map<String, String> getDetails() {\n\t\treturn attributes;\n\t}\n\n\t/**\n\t * \n\t * @return The configuration properties of the server process.\n\t */\n\tpublic Map<String, String> getProperties() {\n\t\treturn properties;\n\t}\n\n\t/**\n\t * @return The id of the service.\n\t */\n\tpublic String getServiceID() {\n\t\treturn serviceID;\n\t}\n\n\t/**\n\t * @return A description for the service.\n\t */\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\t/**\n\t * @return M map of configuration properties.\n\t */\n\tpublic Map<String, String> getConfigurationProperties() {\n\t\treturn properties;\n\t}\n\n\t/**\n\t * @return The current status of the service.\n\t */\n\tpublic ServiceStatus getStatus() {\n\t\treturn serviceStatus;\n\t}\n\n\t/**\n\t * @return The canonical name of the service class.\n\t */\n\tpublic String getServiceClass() {\n\t\treturn className;\n\t}\n\n\t/**\n\t * @param className\n\t *          The canonical name of the service class.\n\t */\n\tpublic void setServiceClass(String className) {\n\t\tthis.className = className;\n\t}\n\n\t@Override\n\tpublic int compareTo(ServiceInfo that) {\n\t\treturn Integer.compare(this.order, that.order);\n\t}\n\n\t/**\n\t * Adds an key-value attribute pair to the attribute table.\n\t * \n\t * @param key\n\t * @param value\n\t */\n\tpublic void addAttribute(String key, String value) {\n\t\tattributes.put(key, value);\n\n\t}\n\n\tpublic void setStatus(ServiceStatus serviceStatus) {\n\t\tthis.serviceStatus = serviceStatus;\n\t}\n\n}\n"}, {"id": "PriorityPolygonPrimitive.java", "body": "package edu.nd.dronology.services.extensions.areamapping.internal;\n\n\nimport java.awt.Point;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.Vector;\n\nimport javax.xml.transform.Source;\n\nimport edu.nd.dronology.services.extensions.areamapping.model.RiverSubsegment;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive.RouteType;\nimport edu.nd.dronology.services.extensions.areamapping.util.Utilities;\n\npublic class PriorityPolygonPrimitive implements SearchPatternStrategy {\n\tprivate List<SourcePoints> sourcePoints;\n\tprivate List<Point2D.Double> priorityPolygonPoints;\n\tprivate RoutePrimitive.RouteType routeType;\n\t\n\t@Override\n\tpublic void setSourcePoints(List<SourcePoints> points) {\n\t\tsourcePoints = points;\n\t}\n\t\n\t@Override\n\tpublic void setRouteType(RouteType routeType) {\n\t\tthis.routeType = routeType;\n\t}\n\t\n\tprivate List<Line2D.Double> findBoundingRectangleCrossingLines(Point2D.Double minPoint, Point2D.Double maxPoint, double APERATURE_HEIGHT, double OVERLAP_FACTOR){\n\t\tList<Line2D.Double> crossingLines = new ArrayList<>();\n\t\tPoint2D.Double pointA = new Point2D.Double(minPoint.getX(), maxPoint.getY());\n\t\tPoint2D.Double pointB = minPoint;\n\t\tPoint2D.Double newPoint  = new Point2D.Double();\n\t\tdouble totalDistance = Geometry.findCartesianDistance(pointA, pointB);\n\t\tdouble traverseDistance = 10 * OVERLAP_FACTOR;\n\t\tcrossingLines.add(new Line2D.Double(pointA, maxPoint));\n\t\twhile(traverseDistance < totalDistance) {\n\t\t\tnewPoint = Geometry.findOffsetPoint(pointA, pointB, traverseDistance / totalDistance);\n\t\t\tcrossingLines.add(new Line2D.Double(newPoint, new Point2D.Double(maxPoint.getX(), newPoint.getY())));\n\t\t\tpointA = newPoint;\n\t\t\ttotalDistance = totalDistance - traverseDistance;\n\t\t}\n\t\tcrossingLines.add(new Line2D.Double(minPoint, new Point2D.Double(maxPoint.getX(),minPoint.getY())));\n\t\treturn crossingLines;\n\t}\n\t\n\tprivate RoutePrimitive generateRouteWaypoints(List<Line2D.Double> crossingLines, SourcePoints sourcePoints) {\n\t\tRoutePrimitive newRoutePrimitive = new RoutePrimitive(routeType, sourcePoints.getWeight());\n\t\tLine2D.Double polygonSegment = new Line2D.Double();\n\t\tfor(int i = 0; i < crossingLines.size(); i++) {\n\t\t\tList<Point2D.Double> intersectionPoints = new ArrayList<>();\n\t\t\tfor(int j = 0; j < priorityPolygonPoints.size()-1; j++) {\n\t\t\t\tpolygonSegment.setLine(priorityPolygonPoints.get(j), priorityPolygonPoints.get(j+1));\n\t\t\t\tif(crossingLines.get(i).intersectsLine(polygonSegment)) {\n\t\t\t\t\tintersectionPoints.add(Geometry.findLineIntersection(crossingLines.get(i), polygonSegment));\n\t\t\t\t}\n\t\t\t}\n\t\t\t//does this comparison thing work? \n\t\t\tCollections.sort(intersectionPoints, Comparator.comparingDouble(Point2D.Double::getX));\n\t\t\tfor(Point2D.Double entry : intersectionPoints) {\n\t\t\t\t//there is probably a better way to do this\n\t\t\t\tif(!newRoutePrimitive.getRoute().contains(entry)) {\n\t\t\t\t\tnewRoutePrimitive.addRouteWaypoint(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn newRoutePrimitive; \n\t}\n\n\t@Override\n\tpublic List<RoutePrimitive> generateRoutePrimitive(double APERATURE_HEIGHT, double OVERLAP_FACTOR) {\n\t\tList<RoutePrimitive> priorityPolygonRoute = new ArrayList<>();\n\t\tList<SourcePoints> priorityAreas = new ArrayList<>();\n\t\tfor(SourcePoints source : sourcePoints) {\n\t\t\tpriorityPolygonPoints = new ArrayList<>(source.getSourcePoints());\n\t\t\tpriorityPolygonPoints.add(priorityPolygonPoints.get(0));\n\t\t\tVector<Point2D.Double> boundPoints = Geometry.simplePriorityPolygonBoundingRectangle(priorityPolygonPoints);\n\t\t\tList<Line2D.Double> crossingLines = findBoundingRectangleCrossingLines(boundPoints.get(0), boundPoints.get(1), APERATURE_HEIGHT, OVERLAP_FACTOR);\n\t\t\tRoutePrimitive newRoute = generateRouteWaypoints(crossingLines, source);\n\t\t\tpriorityPolygonRoute.add(newRoute);\n\t\t\tUtilities.generateImageWaypoints(newRoute, APERATURE_HEIGHT, OVERLAP_FACTOR);\n\t\t\t\n\t\t\t//simply for printout visualization purposes\n\t\t\tSourcePoints area = new SourcePoints();\n\t\t\tarea.setSourcePoints(priorityPolygonPoints);\n\t\t\tpriorityAreas.add(area);\n\t\t}\n\t\tSystem.out.println(\"Priority area boundaries: \");\n\t\tUtilities.printSourcePoints(priorityAreas);\n\t\tUtilities.printRoutePrimitives(priorityPolygonRoute);\n\t\tUtilities.printImageWaypoints(priorityPolygonRoute);\n\t\treturn priorityPolygonRoute;\n\t}\n}\n"}, {"id": "IRemoteManager.java", "body": "package edu.nd.dronology.services.core.remote;\n\nimport java.rmi.RemoteException;\nimport java.util.List;\n\nimport edu.nd.dronology.services.core.api.IRemotable;\nimport edu.nd.dronology.services.core.api.ServiceInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n/**\n * Interface for handling communication between server UI and server services.\n * \n * \n * @author Michael Vierhauser\n * \n */\npublic interface IRemoteManager extends IRemotable {\n\n\t/**\n\t * Retrieve the desired service to offer remote operations.<br>\n\t * Requested service has to extends {@link IRemoteableService}.\n\t * \n\t * \n\t * @param service\n\t *          The Service to retrieve.\n\t * @return The requested Service.\n\t * @throws RemoteException\n\t * @throws DronologyServiceException\n\t */\n\tpublic Object getService(Class<?> service) throws RemoteException, DronologyServiceException;\n\n\t\n\t/**\n\t * @return A list of all registered Services.\n\t * @throws RemoteException\n\t * @throws DronologyServiceException\n\t */\n\tpublic List<ServiceInfo> getServices() throws RemoteException, DronologyServiceException;\n\n\n\t/**\n\t * Adds a service listener to all currently available services informing on service status changes.\n\t * \n\t * @param listener\n\t *          The listener to be added.\n\t * @throws RemoteException\n\t */\n\tpublic void addServiceListener(IRemoteServiceListener listener) throws RemoteException;\n\n\t/**\n\t * \n\t * @param listener\n\t *          The listener to be removed.\n\t * @throws RemoteException\n\t */\n\tpublic void removeServiceListener(IRemoteServiceListener listener) throws RemoteException;\n\n\tpublic void register(RemoteInfo rInfo) throws RemoteException;\n\n\tpublic void unregister(RemoteInfo create) throws RemoteException;\n\n\t/**\n\t * @return\n\t * @throws RemoteException\n\t * @throws DronologyServiceException\n\t */\n\n\tList<ServiceInfo> getCoreServices() throws RemoteException, DronologyServiceException;\n\n\n\tpublic List<ServiceInfo> getFileServices() throws RemoteException, DronologyServiceException;\n\n\tList<ServiceInfo> getAllServices() throws RemoteException, DronologyServiceException;\n\n\tpublic void initialize() throws RemoteException, DronologyServiceException;\n\tpublic void tearDown()throws RemoteException, DronologyServiceException;\n\n\n\tvoid contributeService(Class service, IRemoteableService serviceInstance) throws RemoteException, DronologyServiceException;\n\n}\n"}, {"id": "SelectionWriter.java", "body": "package edu.nd.dronology.services.extensions.areamapping.util;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.text.DateFormat;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\nimport org.apache.commons.io.FileUtils;\n\nimport com.google.gson.FieldNamingPolicy;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\nimport edu.nd.dronology.core.util.FormatUtil;\nimport edu.nd.dronology.services.core.areamapping.ExportAllocationInformation;\nimport edu.nd.dronology.services.core.areamapping.ExportDrone;\nimport edu.nd.dronology.services.core.areamapping.MetricsStatistics;\nimport edu.nd.dronology.services.core.items.IFlightRoute;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport edu.nd.dronology.services.core.persistence.internal.FlightRouteXStreamPersistor;\nimport edu.nd.dronology.services.extensions.areamapping.selection.RouteSelectionResult;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class SelectionWriter {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(SelectionWriter.class);\n\n\tprivate static final String WRITE_LOCATION = \"/home/michael/mapping/\";\n\n\tpublic static final transient Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()\n\t\t\t.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).setVersion(1.0)\n\t\t\t.serializeSpecialFloatingPointValues().serializeSpecialFloatingPointValues().create();\n\n\tprivate static final String SEPARATOR = \",\";\n\tprivate FileOutputStream dest;\n\tprivate ZipOutputStream out;\n\n\tpublic void writeRouteSelection(RouteSelectionResult selection) {\n\n\t\tlong runid = System.currentTimeMillis();\n\t\tString format = FormatUtil.formatTimestamp(runid, FormatUtil.FORMAT_FILE);\n\t\tif (Files.notExists(Paths.get(WRITE_LOCATION))) {\n\t\t\tnew File(WRITE_LOCATION).mkdirs();\n\t\t}\n\n\t\twriteStatFile(WRITE_LOCATION + \"\" + format + \".csv\", selection);\n\t\twriteJSONFile(WRITE_LOCATION + \"\" + format + \".txt\", selection);\n\n\t\tcreateNewZipFile(WRITE_LOCATION + \"\" + format + \".zip\");\n\n\t\tzipRoutes(selection);\n\n\t}\n\n\tprivate void writeJSONFile(String filename, RouteSelectionResult selection) {\n\n\t\tList<ExportAllocationInformation> allocations = selection.getEportAllocationInformation();\n\t\tList<WriteAllocation> writeAllocations = new ArrayList<>();\n\t\tfor (ExportAllocationInformation info : allocations) {\n\t\t\tWriteAllocation alloc = new WriteAllocation();\n\t\t\tfor (ExportDrone dro : info.getDroneAllocations()) {\n\t\t\t\tWriteData wd = new WriteData(dro.getUAVId());\n\t\t\t\tdro.getDroneRouteAssignment().forEach(route -> {\n\t\t\t\t\twd.addRoute(route.getName());\n\t\t\t\t});\n\t\t\t\talloc.addAssignment(wd);\n\t\t\t}\n\t\t\twriteAllocations.add(alloc);\n\t\t}\n\n\t\tString jsonString = GSON.toJson(writeAllocations);\n\t\ttry {\n\t\t\tFileUtils.writeStringToFile(new File(filename), jsonString);\n\t\t} catch (IOException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\n\t}\n\n\tprivate void zipRoutes(RouteSelectionResult selection) {\n\t\tHashMap<String, IFlightRoute> routes = new HashMap<>();\n\n\t\tfor (ExportAllocationInformation alloc : selection.getEportAllocationInformation()) {\n\t\t\tfor (ExportDrone a : alloc.getDroneAllocations()) {\n\t\t\t\tfor (IFlightRoute r : a.getDroneRouteAssignment()) {\n\t\t\t\t\troutes.put(r.getName(), r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLOGGER.info(\"UNIQUE ROUTES:\" + routes.size());\n\t\troutes.forEach((name, route) -> {\n\t\t\tzipRoute(route);\n\t\t});\n\t\ttry {\n\t\t\tout.flush();\n\t\t\tout.finish();\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\n\t}\n\n\tFlightRouteXStreamPersistor provider = new FlightRouteXStreamPersistor();\n\n\tprivate void zipRoute(IFlightRoute route) {\n\t\ttry {\n\t\t\tString filename = route.getName().replace(\" \", \"_\");\n\n\t\t\tLOGGER.info(\"new zip entry:\" + filename + \".froute\");\n\t\t\tZipEntry entry = new ZipEntry(filename + \".froute\");\n\t\t\tout.putNextEntry(entry);\n\t\t\tprovider.save(route, out, false);\n\t\t\tout.closeEntry();\n\n\t\t} catch (PersistenceException e) {\n\t\t\tLOGGER.error(e);\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tprivate boolean createNewZipFile(final String location) {\n\t\tdest = null;\n\t\tout = null;\n\n\t\ttry {\n\t\t\tdest = new FileOutputStream(location);\n\t\t\tout = new ZipOutputStream(new BufferedOutputStream(dest));\n\t\t\tout.setMethod(ZipOutputStream.DEFLATED);\n\t\t\treturn true;\n\t\t} catch (IOException e) {\n\t\t\tLOGGER.error(\"Error adding file\", e);\n\t\t} finally {\n\n\t\t\t// if (out != null) {\n\t\t\t// try {\n\t\t\t// out.close();\n\t\t\t// } catch (IOException e) {\n\t\t\t// LOGGER.error(e);\n\t\t\t// }\n\t\t\t// }\n\t\t\t// if (dest != null) {\n\t\t\t// try {\n\t\t\t// dest.close();\n\t\t\t// } catch (IOException e) {\n\t\t\t// LOGGER.error(e);\n\t\t\t// }\n\t\t\t// }\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void writeStatFile(String filename, RouteSelectionResult selection) {\n\t\tList<String> lines = new ArrayList<>();\n\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"time\");\n\t\tsb.append(SEPARATOR);\n\t\tsb.append(\"overall\");\n\t\tsb.append(SEPARATOR);\n\t\tsb.append(\"battery\");\n\t\tsb.append(SEPARATOR);\n\t\tsb.append(\"collision\");\n\t\tsb.append(SEPARATOR);\n\t\tsb.append(\"coverage-score\");\n\t\tsb.append(SEPARATOR);\n\t\tsb.append(\"taskequality\");\n\t\tsb.append(SEPARATOR);\n\t\tsb.append(\"allocation-priority\");\n\t\tsb.append(SEPARATOR);\n\t\tsb.append(\"allocation-score\");\n\t\tsb.append(SEPARATOR);\n\t\tsb.append(\"total-distance\");\n\t\tsb.append(SEPARATOR);\n\t\tsb.append(\"USDS-ratio\");\n\t\tsb.append(SEPARATOR);\n\t\tsb.append(\"drone-distances\");\n\n\t\tlines.add(sb.toString());\n\n\t\tfor (ExportAllocationInformation allocation : selection.getEportAllocationInformation()) {\n\n\t\t\tMetricsStatistics stat = allocation.getMetricStatistics();\n\t\t\tdouble overall = stat.getAllocationScore();\n\t\t\tboolean battery = stat.getBatteryFailed();\n\t\t\tint collision = stat.getCollisions();\n\t\t\tdouble dsus = stat.getDownstreamToUpstreamRatio();\n\t\t\tdouble cover = stat.getAllocationCoverage();\n\t\t\tdouble equality = stat.getEqualityOfTasks();\n\n\t\t\tdouble allocationPrority = stat.getAllocationPriorityCoverage();\n\t\t\tdouble allocationScope = stat.getAllocationScore();\n\t\t\tdouble totalDistance = stat.getTotalDistance();\n\t\t\tList<Double> distances = stat.getDroneDistances();\n\n\t\t\tsb = new StringBuilder();\n\n\t\t\tdouble time = selection.getSelectionTime();\n\t\t\tsb.append(time);\n\t\t\tsb.append(SEPARATOR);\n\t\t\tsb.append(overall);\n\t\t\tsb.append(SEPARATOR);\n\t\t\tsb.append(battery);\n\t\t\tsb.append(SEPARATOR);\n\t\t\tsb.append(collision);\n\t\t\tsb.append(SEPARATOR);\n\t\t\tsb.append(cover);\n\t\t\tsb.append(SEPARATOR);\n\t\t\tsb.append(equality);\n\t\t\tsb.append(SEPARATOR);\n\t\t\tsb.append(allocationPrority);\n\t\t\tsb.append(SEPARATOR);\n\t\t\tsb.append(allocationScope);\n\t\t\tsb.append(SEPARATOR);\n\t\t\tsb.append(totalDistance);\n\t\t\tsb.append(SEPARATOR);\n\t\t\tsb.append(dsus);\n\t\t\tsb.append(SEPARATOR);\n\t\t\tsb.append(distances.stream().map(i -> i.toString()).collect(Collectors.joining(\";\")));\n\t\t\tlines.add(sb.toString());\n\n\t\t}\n\n\t\ttry {\n\t\t\tFiles.write(Paths.get(filename), lines, Charset.forName(\"UTF-8\"));\n\t\t} catch (IOException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\n\t}\n\n\tpublic class WriteData implements Serializable {\n\n\t\t/**\n\t\t * \n\t\t */\n\t\tprivate static final long serialVersionUID = 1L;\n\t\tprivate final String uavId;\n\t\tprivate List<String> routes = new ArrayList<>();\n\n\t\tpublic WriteData(String uavId) {\n\t\t\tthis.uavId = uavId;\n\t\t}\n\n\t\tpublic void addRoute(String routeid) {\n\t\t\troutes.add(routeid);\n\t\t}\n\n\t}\n\n\tpublic class WriteAllocation implements Serializable {\n\t\t/**\n\t\t * \n\t\t */\n\t\tprivate static final long serialVersionUID = 1L;\n\t\tprivate List<WriteData> assignments = new ArrayList<>();\n\n\t\tpublic void addAssignment(WriteData ass) {\n\t\t\tassignments.add(ass);\n\t\t}\n\t}\n\n}\n"}, {"id": "DroneSetupService.java", "body": "package edu.nd.dronology.services.instances.dronesetup;\n\nimport java.util.Collection;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.base.AbstractServerService;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo;\nimport edu.nd.dronology.services.core.listener.IDroneStatusChangeListener;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n\n/**\n * \n * Service for handling UAVs.<br>\n * Allows initializing new UAVs. <br>\n * Allows retrieving active UAVs which returns a proxy ({@link IUAVProxy}) of the actual physical or virtual uav.\n * \n * \n\n * @author Michael Vierhauser\n * \n *\n */\npublic class DroneSetupService extends AbstractServerService<IDroneSetupServiceInstance> {\n\n\tprivate static volatile DroneSetupService INSTANCE;\n\n\tprotected DroneSetupService() {\n\t}\n\n\t/**\n\t * @return The singleton ConfigurationService instance\n\t */\n\tpublic static DroneSetupService getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (DroneSetupService.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new DroneSetupService();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tprotected IDroneSetupServiceInstance initServiceInstance() {\n\t\treturn new DroneSetupServiceInstance();\n\t}\n \n\tpublic void initializeDrones(DroneInitializationInfo... info) throws DronologyServiceException {\n\t\tserviceInstance.initializeDrones(info);\n\t}\n\n\tpublic void addDroneStatusChangeListener(IDroneStatusChangeListener listener) {\n\t\tserviceInstance.addDroneStatusChangeListener(listener);\n\n\t}\n\n\tpublic void removeDroneStatusChangeListener(IDroneStatusChangeListener listener) {\n\t\tserviceInstance.removeDroneStatusChangeListener(listener);\n\n\t}\n\n\tpublic Collection<IUAVProxy> getActiveUAVs() {\n\t\treturn serviceInstance.getActiveUAVs();\n\t}\n\n\tpublic void deactivateDrone(IUAVProxy status) throws DronologyServiceException {\n\t\tserviceInstance.deactivateDrone(status);\n\n\t}\n\n\tpublic IUAVProxy getActiveUAV(String uavId) throws DronologyServiceException {\n\t\treturn serviceInstance.getActiveUAV(uavId);\n \n\t}\n\n\tpublic void resendCommand(String uavid) throws DronologyServiceException {\n\t\tserviceInstance.resendCommand(uavid);\n\t}\n\n}\n"}, {"id": "MonitoringConnectionTester.java", "body": "package edu.nd.dronology.test;\n\nimport edu.nd.dronology.core.monitoring.ArtifactIdentifier;\nimport edu.nd.dronology.monitoring.reminds.RemoteMessageHandler;\nimport edu.nd.dronology.monitoring.service.IDroneMonitoringRemoteService;\n\npublic class MonitoringConnectionTester {\n\n\tpublic static void main(String[] args) {\n\t\tBaseServiceProvider provider = new BaseServiceProvider();\n\n\t\ttry {\n\t\t\tSystem.setProperty(\"java.rmi.server.hostname\", \"localhost\");\n\t\t\t\n\t\t\tIDroneMonitoringRemoteService sevice = (IDroneMonitoringRemoteService) provider.getRemoteManager()\n\t\t\t\t\t.getService(IDroneMonitoringRemoteService.class);\n\n\t\t//\tArtifactIdentifier id = new ArtifactIdentifier(ArtifactIdentifier.ROOT, \"INTERNAL\");\n\t\t\tArtifactIdentifier id = new ArtifactIdentifier(ArtifactIdentifier.ROOT);\n\t\t\t// DroneMonitoringService.getInstance().registerMonitoringMessageHandler(new\n\t\t\t// RemoteMessageHandler(), id);\n\t\t\tRemoteMessageHandler handler = new RemoteMessageHandler();\n\t\t\tsevice.registerMonitoringMessageHandler(handler, id);\n\t\t\t\n\t\t\t//ProcessorManager.getInstance().initListener();\n\t\t\t\n\t\t\t\n\t\n\t//\t\tnew SeparationDistanceChecker();\n\t\t\t\n\t\t\t\n\n\t\t} catch (Throwable e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n"}, {"id": "DispatchQueueManager.java", "body": "package edu.nd.dronology.gstation.connector.dispatch;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.LinkedBlockingDeque;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport edu.nd.dronology.core.DronologyConstants;\nimport edu.nd.dronology.core.IUAVPropertyUpdateNotifier;\nimport edu.nd.dronology.core.vehicle.commands.IDroneCommand;\nimport edu.nd.dronology.core.vehicle.internal.PhysicalDrone;\nimport edu.nd.dronology.gstation.connector.IUAVSafetyValidator;\nimport edu.nd.dronology.gstation.connector.messages.AbstractUAVMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVHandshakeMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVStateMessage;\nimport edu.nd.dronology.gstation.connector.service.connector.DroneConnectorService;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo.DroneMode;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.instances.dronesetup.DroneSetupService;\nimport edu.nd.dronology.util.NamedThreadFactory;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * The {@link DispatchQueueManager} handles both <i>incoming</i> and <i>outgoing</i> queues. </br>\n * Incoming queues contain {@link UAVState} received from the UAV to be dispatched to the {@link PhysicalDrone}.<br>\n * The outgoing queue contains {@link IDroneCommand}s being sent to the UAV.\n * \n * @author Michael Vierhauser\n *\n */\n@SuppressWarnings(\"rawtypes\")\npublic class DispatchQueueManager {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(DispatchQueueManager.class);\n\n\tprivate static final int NUM_THREADS = 20;\n\tprivate static final ExecutorService SERVICE_EXECUTOR = Executors.newFixedThreadPool(NUM_THREADS,\n\t\t\tnew NamedThreadFactory(\"Dispatch-Threads\"));\n\n\tprivate static final boolean USE_MONITORING = true;\n\n\tMap<String, BlockingQueue<AbstractUAVMessage>> queueMap = new ConcurrentHashMap<>();\n\tList<Future> dispatchThreads = new ArrayList<>();\n\n\tprivate BlockingQueue<IDroneCommand> outgoingCommandQueue = new LinkedBlockingDeque<>(100);\n\tprivate BlockingQueue<AbstractUAVMessage> monitoringQueue = new LinkedBlockingDeque<>(100);\n\n\tprivate final String groundstationid;\n\n\tpublic String getGroundstationid() {\n\t\treturn groundstationid;\n\t}\n\n\tprivate IUAVSafetyValidator validator;\n\n\tpublic DispatchQueueManager(String groundstationid) {\n\t\tthis.groundstationid = groundstationid;\n\t\tif (USE_MONITORING) {\n\t\t\tcreateMonitoringDispatchThread(monitoringQueue);\n\t\t}\n\t} \n\n\tpublic void postDroneStatusUpdate(String id, AbstractUAVMessage<?> status) {\n\t\ttry {\n\t\t\tsynchronized (queueMap) {\n\t\t\t\tboolean success = false;\n\t\t\t\tif (queueMap.containsKey(id)) {\n\t\t\t\t\tsuccess = queueMap.get(id).offer(status);\n\t\t\t\t} else {\n\t\t\t\t\tLOGGER.hwInfo(\"No uav with id '\" + id + \"' registered - discarding message\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!success) {\n\t\t\t\t\tLOGGER.hwFatal(\"Buffer overflow! '\" + id + \"'\");\n\t\t\t\t}\n\t\t\t\tif (status instanceof UAVStateMessage) {\n\t\t\t\t\tforwardToValidator((UAVStateMessage) status);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (Throwable t) {\n\t\t\tLOGGER.error(t);\n\t\t}\n\t}\n\n\tprivate void forwardToValidator(UAVStateMessage status) {\n\t\ttry {\n\t\t\tif (!DronologyConstants.USE_MONITORING) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tboolean success = false;\n\t\t\tsuccess = monitoringQueue.offer(status);\n\t\t\tif (!success) {\n\t\t\t\tLOGGER.warn(\"MonitoringQueue is Full!\");\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\tLOGGER.error(e);\n\t\t} \n\t}\n\n\tprivate void registerNewDrone(String uavid, UAVHandshakeMessage message) {\n\t\tLOGGER.hwInfo(\"New drone registered with  '\" + uavid + \"' -> \" + message.toString());\n\t\tDroneInitializationInfo info = new DroneInitializationInfo(PysicalDroneIdGenerator.generate(uavid, groundstationid),\n\t\t\t\tDroneMode.MODE_PHYSICAL, uavid, message.getHome());\n\t\ttry {\n\t\t\tDroneSetupService.getInstance().initializeDrones(info);\n\t\t} catch (DronologyServiceException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\n\t}\n\n\tpublic void createDispatchThread(String id, IUAVPropertyUpdateNotifier listener) {\n\t\ttry {\n\t\t\tBlockingQueue<AbstractUAVMessage> queue;\n\t\t\tsynchronized (queueMap) {\n\t\t\t\tif (queueMap.containsKey(id)) {\n\t\t\t\t\tqueue = queueMap.get(id);\n\t\t\t\t} else {\n\t\t\t\t\tqueue = new LinkedBlockingQueue<>(DronologyConstants.NR_MESSAGES_IN_QUEUE);\n\t\t\t\t\tqueueMap.put(id, queue);\n\t\t\t\t}\n\t\t\t}\n\t\t\tStatusDispatchThread thread = new StatusDispatchThread(queue, listener);\n\n\t\t\tLOGGER.hwInfo(\"New Dispatch-Thread for UAV '\" + id + \"' created\");\n\t\t\tFuture<Object> ftr = SERVICE_EXECUTOR.submit(thread);\n\t\t\tdispatchThreads.add(ftr);\n\t\t} catch (Throwable t) {\n\t\t\tLOGGER.error(t);\n\t\t}\n\t}\n\n\tprivate void createMonitoringDispatchThread(BlockingQueue<AbstractUAVMessage> queue) {\n\t\tMonitoringDispatchThread thread = new MonitoringDispatchThread(queue);\n\n\t\tLOGGER.hwInfo(\"New Monitoring Dispatch-Thread created\");\n\t\tFuture ftr = SERVICE_EXECUTOR.submit(thread);\n\t\tdispatchThreads.add(ftr);\n\t}\n\n\tpublic void tearDown() { \n\n\t\tLOGGER.hwInfo(\"Ground Control Station '\" + groundstationid + \"' terminated\");\n\t\ttry {\n\t\t\tDroneConnectorService.getInstance().unregisterConnection(groundstationid);\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(\"No groundstation connection with id '\" + groundstationid + \"' registered\");\n\t\t}\n\t\tfor (Future<?> ft : dispatchThreads) {\n\t\t\tft.cancel(true);\n\t\t}\n\t\t// SERVICE_EXECUTOR.shutdown();\n\t}\n\n\tpublic BlockingQueue<IDroneCommand> getOutgoingCommandQueue() {\n\t\treturn outgoingCommandQueue;\n\t}\n\n\tpublic void send(IDroneCommand cmd) {\n\t\tboolean taken = outgoingCommandQueue.offer(cmd);\n\t\tLOGGER.trace(\"Command added to queue!\");\n\t\tif (!taken) {\n\t\t\tLOGGER.hwFatal(\"Outgoing Command queue limit reached - command dropped!\");\n\t\t}\n\n\t}\n\n\tpublic void postMonitoringMessage(UAVMonitoringMessage message) {\n\t\tif (!DronologyConstants.USE_MONITORING) {\n\t\t\treturn;\n\t\t}\n\t\tString uavid = message.getUavid();\n\t\tsynchronized (queueMap) {\n\t\t\tif (!queueMap.containsKey(uavid)) {\n\t\t\t\tLOGGER.hwInfo(\"No uav with id '\" + uavid + \"' registered - discarding message\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// LOGGER.info(\"Message \" + message.getClass().getSimpleName() + \" received :: \" + groundstationid);\n\t\tboolean success = false;\n\t\tsuccess = monitoringQueue.offer(message);\n\t\tif (!success) {\n\t\t\tLOGGER.warn(\"MonitoringQueue is Full!\");\n\t\t}\n\t}\n\n\tpublic void postDoneHandshakeMessage(String uavid, UAVHandshakeMessage message) {\n \n\t\tif (DronologyConstants.USE_SAFETY_CHECKS) {\n\t\t\tif (validator != null) {\n\t\t\t\tif (message.getSafetyCase() == null) {\n\t\t\t\t\tLOGGER.error(\"No safety information provided\");\n\t\t\t\t} else {\n\t\t\t\t\tboolean success = validator.validate(uavid, message.getSafetyCase());\n\t\t\t\t\tif (success) {\n\t\t\t\t\t\tregisterNewDrone(uavid, message);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOGGER.error(\"Safety checks failed - uav '\" + uavid + \"' not registered!\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOGGER.error(\"No validator provided\");\n\t\t\t}\n\t\t} else {\n\t\t\tregisterNewDrone(uavid, message);\n\t\t}\n\n\t}\n\n\tpublic void registerSafetyValidator(IUAVSafetyValidator validator) {\n\t\tthis.validator = validator;\n\n\t}\n\n}\n"}, {"id": "ServiceStatus.java", "body": "package edu.nd.dronology.services.core.api;\n\n/**\n * \n * Reflects the current status of an {@link IServiceInstance}\n * \n * @author Michael Vierhauser\n * \n */\npublic enum ServiceStatus {\n\n\tRUNNING, STOPPED, STARTING, ERROR;\n\n}\n"}, {"id": "AbstractDroneFleetFactory.java", "body": "package edu.nd.dronology.core.fleet;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\n\n/**\n * Abstract factory class for drone fleet factory\n * \n * @author Jane\n * \n */\npublic abstract class AbstractDroneFleetFactory {\n//\tprivate final List<ManagedDrone> drones = new ArrayList<>();\n\n\tpublic AbstractDroneFleetFactory() {\n\t}\n\n\tprotected String createDroneID(String droneID) {\n\t\treturn droneID;\n\t}\n\n\t/**\n\t * Returns list of drones\n\t * \n\t * @return array list of iDrones\n\t * @throws DroneException \n\t */\n//\tpublic List<ManagedDrone> getDrones() {\n//\t\treturn drones;\n//\t}\n\n\t@Deprecated\n\tabstract public ManagedDrone initializeDrone(String DroneID, String DroneType, double latitude, double longitude,\n\t\t\tdouble altitude) throws DroneException;\n\n\tpublic void initializeDrone(String id, String type, LlaCoordinate initialLocation) throws DroneException {\n\t\tinitializeDrone(id, type, initialLocation.getLatitude(), initialLocation.getLongitude(),\n\t\t\t\tinitialLocation.getAltitude());\n\n\t}\n\n}\n"}, {"id": "PersistableMissionPlan.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.persistence;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport edu.nd.dronology.services.core.items.IMissionPlan;\nimport edu.nd.dronology.services.core.items.IUAVMissionDescription;\n\npublic class PersistableMissionPlan implements IMissionPlan {\n\n\tprivate String name;\n\tprivate String id;\n\tprivate String description;\n\tprivate Map<String, Serializable> attributes = new HashMap<>();\n\tprivate List<IUAVMissionDescription> missionDescriptions = new ArrayList<>();\n\n\tpublic PersistableMissionPlan() {\n\t\tid = UUID.randomUUID().toString();\n\t\tname = id;\n\t}\n\n\t@Override\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\t@Override\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\n\t}\n\n\tpublic void addAttribute(String key, Serializable value) {\n\t\tattributes.put(key, value);\n\t}\n\n\tpublic Serializable getAttributes(String key) {\n\t\treturn attributes.get(key);\n\t}\n\n\t@Override\n\tpublic List<IUAVMissionDescription> getMissionDescriptions() {\n\t\treturn Collections.unmodifiableList(missionDescriptions);\n\t}\n\n\t@Override\n\tpublic void addMissionDescription(IUAVMissionDescription description) {\n\t\tmissionDescriptions.add(description);\n\t}\n\n\tpublic boolean removeMissionDescription(String name) {\n\t\tfor (IUAVMissionDescription desc : new ArrayList<>(missionDescriptions)) {\n\t\t\tif (desc.getName().equals(name)) {\n\t\t\t\tmissionDescriptions.remove(desc);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t}\n\t\treturn false;\n\t}\n\n}\n"}, {"id": "GeneratedRoutesInfo.java", "body": "package edu.nd.dronology.services.extensions.areamapping.selection;\n\nimport java.awt.geom.Path2D.Double;\nimport java.util.List;\n\nimport edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\n\npublic class GeneratedRoutesInfo {\n\n\tprivate final double avgLatitude;\n\tprivate final List<RoutePrimitive> routePrimitives;\n\tprivate final Double totalRiverSegment;\n\tprivate final List<RiverBank> bankList;\n\n\tpublic GeneratedRoutesInfo(List<RoutePrimitive> routePrimitives, double avgLatitude, Double totalRiverSegment,\n\t\t\tList<RiverBank> bankList) {\n\t\tsuper();\n\t\tthis.avgLatitude = avgLatitude;\n\t\tthis.routePrimitives = routePrimitives;\n\t\tthis.totalRiverSegment = totalRiverSegment;\n\t\tthis.bankList = bankList;\n\t}\n\n\tpublic List<RoutePrimitive> getRoutePrimitives() {\n\t\treturn routePrimitives;\n\t}\n\n\tpublic double getAverageLatitude() {\n\t\treturn avgLatitude;\n\t}\n\n\tpublic Double getTotalRiverSegment() {\n\t\treturn totalRiverSegment;\n\t}\n\n\tpublic List<RiverBank> getBankList() {\n\t\treturn bankList;\n\t}\n\n}\n"}, {"id": "DronologyMonitoringManager.java", "body": "package edu.nd.dronology.core.monitoring;\n\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport edu.nd.dronology.util.NamedThreadFactory;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class DronologyMonitoringManager {\n\n\tprivate static DronologyMonitoringManager INSTANCE = new DronologyMonitoringManager();\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(DronologyMonitoringManager.class);\n\n\tprivate static final BlockingQueue<IMonitorableMessage> queue = new ArrayBlockingQueue<>(500);\n\n\tprivate static final ExecutorService SERVICE_EXECUTOR = Executors\n\t\t\t.newSingleThreadExecutor(new NamedThreadFactory(\"Monitoring-Manager\"));\n\n\tprivate boolean handlerRegistered;\n\n\t/**\n\t * \n\t * @return The singleton instance.\n\t */\n\tpublic static DronologyMonitoringManager getInstance() {\n\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (DronologyMonitoringManager.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new DronologyMonitoringManager();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\tpublic void publish(IMonitorableMessage message) {\n\t\ttry {\n\t\t\tif (!handlerRegistered) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tboolean taken = queue.offer(message);\n\t\t\tif (!taken) {\n\t\t\t\tLOGGER.error(\"Monitoring queue full!\");\n\t\t\t}\n\t\t} catch (Throwable t) {\n\t\t\tLOGGER.error(t); \n\t\t}\n\n\t}\n\n\tpublic void registerHandler(IMonitoringDataHandler handler) {\n\t\thandler.setQueue(queue);\n\t\thandlerRegistered = true;\n\t\tSERVICE_EXECUTOR.submit(handler);\n\t}\n\n}\n"}, {"id": "IManagedDroneStateChangeListener.java", "body": "package edu.nd.dronology.core.vehicle;\n\npublic interface IManagedDroneStateChangeListener {\n\n\tpublic void notifyStateChange();\n\n}\n"}, {"id": "DroneConnectorServiceInstance.java", "body": "package edu.nd.dronology.gstation.connector.service.connector;\n\nimport java.text.DateFormat;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\nimport com.google.gson.FieldNamingPolicy;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\nimport edu.nd.dronology.core.DronologyConstants;\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.fleet.RuntimeDroneTypes;\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.gstation.connector.GroundStationException;\nimport edu.nd.dronology.gstation.connector.GroundstationConnector;\nimport edu.nd.dronology.gstation.connector.connect.IncommingGroundstationConnectionServer;\nimport edu.nd.dronology.gstation.connector.messages.ConnectionRequestMessage;\nimport edu.nd.dronology.services.core.base.AbstractServiceInstance;\nimport edu.nd.dronology.services.instances.dronesetup.DroneSetupService;\nimport edu.nd.dronology.util.NamedThreadFactory;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class DroneConnectorServiceInstance extends AbstractServiceInstance implements IDroneConnectorServiceInstance {\n\tExecutorService connectionExecutor = Executors.newFixedThreadPool(DronologyConstants.MAX_GROUNDSTATIONS,\n\t\t\tnew NamedThreadFactory(\"Connection-Socket-Threads\"));\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(DroneConnectorServiceInstance.class);\n\n\tstatic final transient Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()\n\t\t\t.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)\n\t\t\t.setVersion(1.0).serializeSpecialFloatingPointValues().create();\n\n\tprivate IncommingGroundstationConnectionServer server;\n\tprivate Map<String, GroundstationConnector> activeConnections = new HashMap<>();\n\n\tpublic DroneConnectorServiceInstance() {\n\t\tsuper(\"DRONECONNECTOR\");\n\t}\n\n\t@Override\n\tprotected Class<?> getServiceClass() {\n\t\treturn DroneConnectorService.class;\n\t}\n\n\t@Override\n\tprotected int getOrder() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 3;\n\t}\n\n\t@Override\n\tprotected String getPropertyPath() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void doStartService() throws Exception {\n\t\tserver = new IncommingGroundstationConnectionServer();\n\t\tservicesExecutor.submit(server);\n\t}\n\n\t@Override\n\tprotected void doStopService() throws Exception {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n\t@Override\n\tpublic void unregisterConnection(String connectionId) throws GroundStationException {\n\t\tif (activeConnections.containsKey(connectionId)) {\n\t\t\tLOGGER.info(\"Removing connection!\" + connectionId);\n\t\t\tGroundstationConnector conn = activeConnections.remove(connectionId);\n\t\t\tconn.tearDown(); \n\t\t\tunregisterDrones(connectionId);\n\t\t\ttry {\n\t\t\t\tRuntimeDroneTypes.getInstance().unregisterCommandHandler(connectionId);\n\t\t\t} catch (DroneException e) {\n\t\t\t\tthrow new GroundStationException(\"Connection with id \" + connectionId + \" not found\");\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new GroundStationException(\"Connection with id \" + connectionId + \" not found\");\n\t\t}\n\t}\n\n\tprivate synchronized void unregisterDrones(String groundstationid) {\n\n\t\tCollection<IUAVProxy> activeDrones = DroneSetupService.getInstance().getActiveUAVs();\n\t\tfor (IUAVProxy st : activeDrones) {\n\t\t\tif (st.getGroundstationId().equals(groundstationid)) {\n\t\t\t\ttry {\n\t\t\t\t\tDroneSetupService.getInstance().deactivateDrone(st);\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\tLOGGER.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void handleConnection(GroundstationConnector connectionHandler) {\n\t\tif (activeConnections.size() >= DronologyConstants.MAX_GROUNDSTATIONS) {\n\t\t\tLOGGER.warn(\"Connection Limit reached - no new parallel connections can be added!\");\n\t\t\treturn;\n\t\t}\n\n\t\tFuture<?> future = connectionExecutor.submit(connectionHandler);\n\t}\n\n\t@Override\n\tpublic void registerConnection(GroundstationConnector connector, ConnectionRequestMessage msg)\n\t\t\tthrows GroundStationException {\n\t\tLOGGER.info(\"Connection requested by groundstation '\" + msg.getGCSId() + \"'\");\n\t\tString groundstationId = msg.getGCSId();\n\t\tif (activeConnections.containsKey(groundstationId)) {\n\t\t\tthrow new GroundStationException(\"Groundstation already registered! \" + groundstationId);\n\t\t}\n\t\tactiveConnections.put(groundstationId, connector);\n\t}\n\n}\n"}, {"id": "SupervisorServiceInstance.java", "body": "package edu.nd.dronology.services.supervisor;\n\nimport java.util.Collections;\nimport java.util.Map;\n\nimport edu.nd.dronology.services.core.api.ServiceInfo;\nimport edu.nd.dronology.services.core.base.AbstractServerService;\nimport edu.nd.dronology.services.core.base.AbstractServiceInstance;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class SupervisorServiceInstance extends AbstractServiceInstance implements ISupervisorServiceInstance {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(SupervisorServiceInstance.class);\n\n\tprivate static String customWorkspace;\n\n\tpublic SupervisorServiceInstance() {\n\t\tsuper(\"SUPERVISOR\", \"Managing the server\");\n\t}\n\n\t@Override\n\tprotected Class<?> getServiceClass() {\n\t\treturn SupervisorService.class;\n\t}\n\n\t@Override\n\tprotected int getOrder() {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tprotected String getPropertyPath() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void doStartService() throws Exception {\n\t\tWorkspaceInitializer.getInstance().prepareServerWorkspace(SupervisorService.getWorkspace());\n\t\tLogCleaner.run();\n\t\t\n\t\t\n\t}\n\n\t@Override\n\tprotected void doStopService() throws Exception {\n\t\t// TODO Auto-generated method stub\n\t}\n\n\t@Override\n\tpublic void shutdownServer() {\n\t\tLOGGER.info(\"Shuting Down - Services\");\n\t\tAbstractServerService.stopAll();\n\t\tLOGGER.info(\"Shutting down application - bye!\");\n\t\tSystem.exit(0);\n\t}\n\n\t@Override\n\tpublic void restartAllServices() {\n\t\tLOGGER.info(\"Restarting all Services!\");\n\n\t\tAbstractServerService.restartAll();\n\n\t}\n\n\t@Override\n\tpublic ServiceInfo getServiceInfo() {\n\t\tServiceInfo sInfo = super.getServiceInfo();\n\t\tsInfo.addAttribute(ServiceInfo.ATTRIBUTE_TYPE, ServiceInfo.ATTRIBUTE_REMOTE);\n\t\treturn sInfo;\n\t}\n\n\t@Override\n\tpublic String getFlightPathLocation() {\n\t\treturn WorkspaceInitializer.getInstance().getFlightRouteLocation();\n\t}\n\n\n\n\t@Override\n\tpublic String getWorkspaceLocation() {\n\t\treturn WorkspaceInitializer.getInstance().getWorkspaceLocation();\n\t}\n\n\t@Override\n\tpublic Map<String, String> getGlobalProperties() {\n\t\t//return GlobalConfReader.getGlobalPropertySet();\\\n\t\treturn Collections.emptyMap();\n\t}\n\n\t@Override\n\tpublic boolean importItem(String fileName, byte[] byteArray, boolean overwrite) throws DronologyServiceException {\n\t\treturn WorkspaceInitializer.getInstance().importItem(fileName, byteArray, overwrite);\n\t}\n\n\t@Override\n\tprotected boolean hasProperties() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String getDroneSpecificationLocation() {\n\t\treturn WorkspaceInitializer.getInstance().getDroneSpecificationLocation();\n\t}\n\n\t@Override\n\tpublic String getSimScenarioLocation() {\n\t\treturn WorkspaceInitializer.getInstance().getSimScenarioLocation();\n\t}\n\n\t@Override\n\tpublic String getAreaMappingLocation() {\n\t\treturn WorkspaceInitializer.getInstance().getAreaMappingLocation();\n\t}\n\n\t@Override\n\tpublic String getMissionPlanningLocation() {\n\t\treturn WorkspaceInitializer.getInstance().getMissionPlanningLocation();\n\t}\n\n\n\n}"}, {"id": "ManagedDrone.java", "body": "package edu.nd.dronology.core.vehicle;\n\nimport java.util.*;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.stream.Collectors;\n\nimport com.google.common.util.concurrent.RateLimiter;\n\nimport edu.nd.dronology.core.Discuss;\nimport edu.nd.dronology.core.DronologyConstants;\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshotOption;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.NedCommand;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand;\nimport edu.nd.dronology.core.coordinate.AbstractPosition;\nimport edu.nd.dronology.core.goal.AbstractGoal;\nimport edu.nd.dronology.core.goal.AbstractGoal.GoalState;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.exceptions.FlightZoneException;\nimport edu.nd.dronology.core.fleet.DroneFleetManager;\nimport edu.nd.dronology.core.flight.FlightDirectorFactory;\nimport edu.nd.dronology.core.flight.IFlightDirector;\nimport edu.nd.dronology.core.monitoring.DronologyMonitoringManager;\nimport edu.nd.dronology.core.monitoring.MessageMarshaller;\nimport edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;\nimport edu.nd.dronology.core.goal.IGoalSnapshot;\nimport edu.nd.dronology.core.goal.WaypointGoal;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.core.vehicle.commands.AbstractDroneCommand;\nimport edu.nd.dronology.core.vehicle.commands.EmergencyStopCommand;\nimport edu.nd.dronology.core.vehicle.manageddroneinternal.*;\nimport edu.nd.dronology.core.vehicle.manageddroneinternal.message.AbstractMessage;\nimport edu.nd.dronology.core.vehicle.manageddroneinternal.message.AssignFlightMessage;\nimport edu.nd.dronology.core.vehicle.manageddroneinternal.message.GetSnapshotMessage;\nimport edu.nd.dronology.core.vehicle.manageddroneinternal.message.GoalUpdateMessage;\nimport edu.nd.dronology.core.vehicle.manageddroneinternal.message.UnassignFlightMessage;\nimport edu.nd.dronology.core.vehicle.manageddroneinternal.message.UpdateGuidanceMessage;\nimport edu.nd.dronology.core.vehicle.proxy.UAVProxyManager;\nimport edu.nd.dronology.util.NamedThreadFactory;\nimport edu.nd.dronology.util.NullUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Handler class for both {@link VirtualDrone} and {@link PhysicalDrone}.<br>\n * Handles basic functionality that is independent of a virtual or physical endpoint.<br>\n * Contains information on coordinates, state, and flight instructions.\n *  \n *  \n * @author Jane Cleland-Huang\n */\n@Discuss(discuss = \"does the drone need to be observable?\")\npublic class ManagedDrone extends Observable implements Runnable, Observer {\n\t// region fields\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(ManagedDrone.class);\n\n\tprivate AtomicBoolean cont = new AtomicBoolean(true);\n\n\tprivate RateLimiter LIMITER = RateLimiter.create(10);\n\n\tprivate static final ExecutorService EXECUTOR_SERVICE = Executors\n\t\t\t.newFixedThreadPool(DronologyConstants.MAX_DRONE_THREADS, new NamedThreadFactory(\"ManagedDrone\"));\n\n\tprivate final IDrone drone; // Controls primitive flight commands for drone\n\n\tprivate DroneFlightStateManager droneState;\n\tprivate DroneSafetyStateManager droneSafetyState;\n\n\t@Discuss(discuss = \"why not final? - new flight director for each flight??\")\n\tprivate IFlightDirector flightDirector = null; // Each drone can be assigned\n\t// a single flight plan.\n\tprivate volatile double targetAltitude = 0;\n\n\tprivate Timer haltTimer = new Timer();\n\tprivate HaltTimerTask currentHaltTimer;\n\n\tprivate List<AbstractGoal> goals;\n\tprivate Set<AbstractGoal> activeGoals = new HashSet<>();\n\tprivate List<Command> commandQueue = new ArrayList<>();\n\tprivate List<Command> completedCommands = new ArrayList<>();\n\tprivate Command currentCommand;\n\tprivate CommandExecutor currentExecutor;\n\n\tprivate final ManagedDroneMessenger messenger;\n\t// TODO figure out what this value should be\n\tprivate static final int MAILBOX_CAPACITY = 50;\n\tprivate static final boolean FIFO_MAILBOX = true;\n\tprivate final ArrayBlockingQueue<AbstractMessage> mailbox = new ArrayBlockingQueue<>(MAILBOX_CAPACITY,\n\t\t\tFIFO_MAILBOX);\n\tprivate final CommandExecutorFactory executorFactory;\n\tprivate final CountDownLatch startGate = new CountDownLatch(1);\n\t// endregion\n\n\t/**\n\t * Constructs drone\n\t *\n\t * @param drone\n\t */\n\tpublic ManagedDrone(IDrone drone) {\n\t\tNullUtil.checkNull(drone);\n\t\tthis.drone = drone;// specify\n\t\tdroneState = new DroneFlightStateManager(this);\n\t\tdroneSafetyState = new DroneSafetyStateManager();\n\t\tdrone.getDroneStatus().setStatus(droneState.getStatus());\n\t\tthis.flightDirector = FlightDirectorFactory.getFlightDirector(this); // Don't\n\t\tdroneState.addStateChangeListener(() -> notifyStateChange());\n\t\tthis.goals = new ArrayList<>();\n\t\tthis.messenger = new ManagedDroneMessenger(mailbox);\n\t\tthis.executorFactory = new CommandExecutorFactory(this.drone);\n\t}\n\n\tprivate class HaltTimerTask extends TimerTask {\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tsynchronized (droneSafetyState) {\n\t\t\t\tif (!droneSafetyState.isSafetyModeHalted()) {\n\t\t\t\t\tcurrentHaltTimer = null;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tdroneSafetyState.setSafetyModeToNormal();\n\t\t\t\t\tdroneState.setModeToFlying();\n\t\t\t\t\tcurrentHaltTimer = null;\n\t\t\t\t} catch (FlightZoneException e) {\n\t\t\t\t\tLOGGER.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// region public methods\n\t/**\n\t * Get the messenger associated with this drone. Client code needing to access\n\t * this drone's functionality must do so through the messenger.\n\t * \n\t * @return The messenger that can command this managed drone to carry out\n\t *         operations.\n\t */\n\tpublic ManagedDroneMessenger getMessenger() {\n\t\treturn messenger;\n\t}\n\n\t/**\n\t * Blocks until the ManagedDrone run method has been called.\n\t */\n\tpublic void awaitStart() {\n\t\ttry {\n\t\t\tthis.startGate.await();\n\t\t} catch (InterruptedException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic void returnToHome() {\n\t\tsynchronized (droneSafetyState) {\n\t\t\tgetFlightSafetyModeState().setSafetyModeToNormal();\n\n\t\t\tif (currentHaltTimer != null) {\n\t\t\t\tcurrentHaltTimer.cancel();\n\t\t\t\tcurrentHaltTimer = null;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t *\n\t * @param targetAltitude Sets target altitude for takeoff\n\t */\n\tpublic void setTargetAltitude(double targetAltitude) {\n\t\tthis.targetAltitude = targetAltitude;\n\t}\n\n\t/**\n\t * Controls takeoff of drone\n\t *\n\t * @throws FlightZoneException\n\t */\n\tpublic void takeOff() throws FlightZoneException {\n\t\tif (targetAltitude == 0) {\n\t\t\tthrow new FlightZoneException(\"Target Altitude is 0\");\n\t\t}\n\t\tdroneState.setModeToTakingOff();\n\t\tdrone.takeOff(targetAltitude);\n\n\t}\n\n\t/**\n\t * Delegates flyto behavior to virtual or physical drone\n\t *\n\t * @param targetCoordinates\n\t * @param speed\n\t */\n\tpublic void flyTo(LlaCoordinate targetCoordinates, Double speed) {\n\t\tdrone.flyTo(targetCoordinates, speed);\n\t}\n\n\t/**\n\t * Gets current coordinates from virtual or physical drone\n\t *\n\t * @return current coordinates\n\t */\n\tpublic LlaCoordinate getCoordinates() {\n\t\treturn drone.getCoordinates();\n\t}\n\n\tpublic void start() {\n\t\t// thread.start();\n\t\tLOGGER.info(\"Starting Drone '\" + drone.getDroneName() + \"'\");\n\t\tEXECUTOR_SERVICE.submit(this);\n\t}\n\n\tpublic boolean isStarted() {\n    \ttry {\n\t\t\treturn this.startGate.await(0, TimeUnit.NANOSECONDS);\n\t\t} catch (InterruptedException e) {\n\t\t\tLOGGER.error(e);\n\t\t\treturn false;\n\t\t}\n\t}\n\t\t\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tthis.startGate.countDown();\n\t\t\twhile (cont.get() && !Thread.currentThread().isInterrupted()) {\n\t\t\t\tLIMITER.acquire();\n\t\t\t\t\n\t\t\t\tprocessAllMessages();\n\n\t\t\t\t// Probably not necessary anymore... TODO: fix- do not try to assign point in\n\t\t\t\t// every iteration of the loop...\n\t\t\t\tif (flightDirector != null && droneState.isFlying()) {\n\t\t\t\t\tthis.flyDrone();\n\t\t\t\t\t/*\n\t\t\t\t\t * LlaCoordinate targetCoordinates = flightDirector.flyToNextPoint();\n\t\t\t\t\t * drone.flyTo(); if (!drone.move(0.1)) {\n\t\t\t\t\t * LOGGER.missionInfo(drone.getDroneName() + \" - Waypoint reached - \" +\n\t\t\t\t\t * targetCoordinates.toString()); flightDirector.clearCurrentWayPoint(); }\n\t\t\t\t\t */\n\t\t\t\t\tcheckForEndOfFlight();\n\t\t\t\t}\n\t\t\t\tif (droneState.isTakingOff()) {\n\t\t\t\t\tif (Math.abs(drone.getAltitude() - targetAltitude) < DronologyConstants.THRESHOLD_TAKEOFF_HEIGHT) {\n\t\t\t\t\t\tLOGGER.info(\"Target Altitude reached - ready for flying\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdroneState.setModeToFlying();\n\t\t\t\t\t\t} catch (FlightZoneException e) {\n\t\t\t\t\t\t\tLOGGER.error(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t\tLOGGER.info(\"UAV-Thread '\" + drone.getDroneName() + \"' terminated\");\n\t\tUAVProxyManager.getInstance().removeDrone(getDroneName());\n\t}\n\t// needs refactoring to improve performance...\n\tpublic boolean permissionForTakeoff() {\n\t\tdouble dronDistance = 0;\n\t\tList<ManagedDrone> flyingDrones = DroneFleetManager.getInstance().getRegisteredDrones();\n\t\tfor (ManagedDrone drone2 : flyingDrones) {\n\t\t\tif (!this.equals(flyingDrones) \n\t\t\t\t\t&& (drone2.getFlightModeState().isFlying() || drone2.getFlightModeState().isInAir())) {\n\t\t\t\tdronDistance = this.getCoordinates().distance(drone2.getCoordinates());\n\t\t\t\tif (dronDistance < DronologyConstants.SAFETY_ZONE) {\n\t\t\t\t\tLOGGER.error(\"Safety Distance Violation - Drone not allowed to TakeOff! distance: \" + dronDistance\n\t\t\t\t\t\t\t+ \" safety zone: \" + DronologyConstants.SAFETY_ZONE + \" => \" + dronDistance);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t *\n\t * @return unique drone ID\n\t */\n\tpublic String getDroneName() {\n\t\treturn drone.getDroneName();\n\t}\n\n\t/**\n\t * Land the drone. Delegate land functions to virtual or physical drone\n\t *\n\t * @throws FlightZoneException\n\t */\n\tpublic void land() throws FlightZoneException {\n\t\tif (!droneState.isLanding() || !droneState.isOnGround()) {\n\t\t\tdroneState.setModeToLanding();\n\t\t\tdrone.land();\n\t\t\tdroneState.setModeToOnGround();\n\t\t\tunassignFlight();\n\t\t}\n\t}\n\n\t/**\n\t * Temporarily Halt\n\t *\n\t * @param haltinms\n\t */\n\tpublic void haltInPlace(int haltinms) {\n\t\tsynchronized (droneSafetyState) {\n\t\t\ttry {\n\t\t\t\tif (currentHaltTimer != null) {\n\t\t\t\t\treturn;\n\t\t\t\t\t// currentHaltTimer.cancel();\n\t\t\t\t\t// droneSafetyState.setSafetyModeToNormal();\n\t\t\t\t\t// droneState.setModeToFlying();\n\t\t\t\t\t// currentHaltTimer = null;\n\t\t\t\t} else {\n\t\t\t\t\tdroneSafetyState.setSafetyModeToHalted();\n\t\t\t\t\tdroneState.setModeToInAir();\n\t\t\t\t\tcurrentHaltTimer = new HaltTimerTask();\n\t\t\t\t\thaltTimer.schedule(currentHaltTimer, haltinms);\n\t\t\t\t}\n\n\t\t\t} catch (FlightZoneException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Temporarily Halt\n\t * \n\t * @param haltinms\n\t * @throws FlightZoneException\n\t */\n\tpublic void resumeFlight() throws FlightZoneException {\n\t\tsynchronized (droneSafetyState) {\n\t\t\tif (currentHaltTimer == null) {\n\t\t\t\tthrow new FlightZoneException(\"UAV not halted\");\n\t\t\t} else {\n\t\t\t\tcurrentHaltTimer.cancel();\n\t\t\t\tdroneSafetyState.setSafetyModeToNormal();\n\t\t\t\tdroneState.setModeToFlying();\n\t\t\t\tcurrentHaltTimer = null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \n\t *\n\t * return current flight mode state\n\t *\n\t * @return droneState\n\t */\n\tpublic DroneFlightStateManager getFlightModeState() {\n\t\treturn droneState;\n\t}\n\n\tpublic LlaCoordinate getBaseCoordinates() {\n\t\treturn drone.getBaseCoordinates();\n\t}\n\n\tpublic void sendCommand(AbstractDroneCommand command) throws DroneException {\n\t\tdrone.sendCommand(command);\n\n\t}\n\n\tpublic void stop() {\n\t\tif (!droneState.isOnGround()) {\n\t\t\tLOGGER.warn(\"Removing UAV '\" + drone.getDroneName() + \"' while in state \" + droneState.getStatus());\n\t\t} else {\n\t\t\tLOGGER.info(\"Removing UAV '\" + drone.getDroneName() + \"'\");\n\t\t}\n\t\tcont.set(false);\n\t\thaltTimer.cancel();\n\t}\n\n\tpublic void emergencyStop() throws DroneException {\n\t\tLOGGER.warn(\"Emergency stop for UAV '\" + drone.getDroneName() + \"' requested\");\n\t\tsendCommand(new EmergencyStopCommand(drone.getDroneName()));\n\n\t}\n\n\tpublic void resendCommand() throws DroneException {\n\t\tdrone.resendCommand();\n\n\t}\n\n\tpublic DroneSnapshot getSnapshot() {\n\t\tDroneSnapshotInternal snapshot = drone.getLatestDroneSnapshot();\n\t\tif (snapshot == null) {\n\t\t\tLOGGER.debug(\"The backend drone didn't provide a snapshot\");\n\t\t\treturn null;\n\t\t}\n\t\tsnapshot.setName(drone.getDroneName());\n\t\tsnapshot.getCommands().clear();\n\t\tfor (Command cmd : commandQueue) {\n\t\t\tsnapshot.getCommands().add(cmd);\n\t\t}\n\n\t\tsnapshot.setState(droneState.getStatus());\n\n\t\tHashSet<IGoalSnapshot> activeGoalSnapshots = new HashSet<>();\n\t\t// need a thread safe way to copy the set of active goals\n\t\tfor (AbstractGoal goal : activeGoals) {\n\t\t\tactiveGoalSnapshots.add(goal.buildSnapshot());\n\t\t}\n\t\tsnapshot.setGoals(activeGoalSnapshots);\n\n\t\treturn snapshot;\n\t}\n\n\t@Override\n\tpublic void update(Observable observable, Object o) {\n\t\tif (observable instanceof AbstractGoal) {\n\t\t\tthis.messenger.updateGoal((AbstractGoal) observable);\n\t\t}\n\t}\n\t\n\tprivate void updateGoals(AbstractGoal goal) {\n\t\tGoalState state = goal.getState();\n\t\tif (state == GoalState.ACTIVE) {\n\t\t\tactiveGoals.add(goal);\n\t\t} else {\n\t\t\tactiveGoals.remove(goal);\n\t\t}\n\t}\n\t// endregion\n\n\t// region private methods\n\n\tprivate void processAllMessages() {\n\t\ttry {\n\t\t\tAbstractMessage msg = this.mailbox.poll(0, TimeUnit.NANOSECONDS);\n\t\t\twhile (msg != null) {\n\t\t\t\tprocessesMessage(msg);\n\t\t\t\tmsg = this.mailbox.poll(0, TimeUnit.NANOSECONDS);\n\t\t\t}\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\n\tprivate void processesMessage(AbstractMessage msg) {\n\t\tif (msg instanceof GetSnapshotMessage) {\n\t\t\tprocessGetSnapshotMessage((GetSnapshotMessage) msg);\n\t\t} else if (msg instanceof UpdateGuidanceMessage) {\n\t\t\tprocessUpdateGuidanceMessage((UpdateGuidanceMessage) msg);\n\t\t} else if (msg instanceof AssignFlightMessage) {\n\t\t\tprocessAssignFlightMessage((AssignFlightMessage) msg);\n\t\t} else if (msg instanceof UnassignFlightMessage) {\n\t\t\tprocessUnassignFlightMessage((UnassignFlightMessage) msg);\n\t\t} else if (msg instanceof GoalUpdateMessage) {\n\t\t\tprocessGoalUpdateMessage((GoalUpdateMessage) msg);\n\t\t}\n\t}\n\n\tprivate void processGetSnapshotMessage(GetSnapshotMessage msg) {\n\t\ttry {\n\t\t\tmsg.returnBox.put(new DroneSnapshotOption(this.getSnapshot(), this.getDroneName()));\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\n\tprivate void processUpdateGuidanceMessage(UpdateGuidanceMessage msg) {\n\t\tthis.updateGuidance(msg.commands);\n\t}\n\n\tprivate void processAssignFlightMessage(AssignFlightMessage msg) {\n\t\tassignFlight(msg.flightDirective);\n\t}\n\n\tprivate void processUnassignFlightMessage(UnassignFlightMessage msg) {\n\t\tunassignFlight();\n\t}\n\n\tprivate void processGoalUpdateMessage(GoalUpdateMessage msg) {\n\t\tupdateGoals(msg.goal);\n\t}\n\n\tprivate void notifyStateChange() {\n\t\tdrone.getDroneStatus().setStatus(droneState.getStatus());\n\t}\n\n\t\t/**\n\t * Assigns a flight directive to the managed drone\n\t *\n\t * @param flightDirective\n\t */\n\tprivate void assignFlight(IFlightDirector flightDirective) {\n\t\tLOGGER.debug(\"Assigning flight director\");\n\t\tclearGoals();\n\t\tthis.flightDirector = flightDirective;\n\n\t\tLOGGER.trace(\"The flight has \" + flightDirector.getWayPoints().size() + \" waypoints\");\n\t\t// Create waypoint goals for each waypoint in the flight director.\n\t\tfor (Waypoint wp : flightDirector.getWayPoints()) {\n\t\t\tWaypointGoal wpg = new WaypointGoal(wp);\n\n\t\t\t// Add an observer that will update the GUI when this waypoint is reached.\n\t\t\twpg.addObserver((observable, o) -> {\n\t\t\t\tGoalState state = ((AbstractGoal) observable).getState();\n\n\t\t\t\tif (state == GoalState.COMPLETE) {\n\t\t\t\t\twp.reached(true);\n\t\t\t\t\tDronologyMonitoringManager.getInstance().publish( \n\t\t\t\t\t\tMessageMarshaller.createMessage(MessageType.WAYPOINT_REACHED, drone.getDroneName(), wp.getCoordinate()));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\taddGoal(wpg);\n\t\t}\n\n\t\tcompletedCommands.clear();\n\t\tcommandQueue.clear();\n\n\t\tif (!goals.isEmpty()) {\n\t\t\tThread tmpThread = new Thread(new Runnable(){\n\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tgoals.get(0).setActive();\n\t\t\t\t}\n\t\t\t});\n\t\t\ttmpThread.start();\n\t\t\tint lastIndex = goals.size() - 1;\n\t\t\tgoals.get(lastIndex).addObserver((observable, o) -> {\n\t\t\t\tGoalState state = ((AbstractGoal) observable).getState();\n\n\t\t\t\tif (state == GoalState.COMPLETE) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdroneState.setModeToInAir();\n\t\t\t\t\t} catch (FlightZoneException e) {\n\t\t\t\t\t\tLOGGER.warn(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Removes an assigned flight\n\t */\n\tprivate void unassignFlight() {\n\t\tflightDirector = null; // DANGER. NEEDS FIXING. CANNOT UNASSIGN FLIGHT\n\t\t// WITHOUT RETURNING TO BASE!!!\n\t\tLOGGER.warn(\"Unassigned DRONE: \" + getDroneName());\n\t\tclearGoals();\n\t}\n\n\t// Check for end of flight. Land if conditions are satisfied\n\tprivate boolean checkForEndOfFlight() {\n\t\tif (flightDirector != null && flightDirector.readyToLand())\n\t\t\treturn false; // it should have returned here.\n\t\tif (droneState.isLanding())\n\t\t\treturn false;\n\t\tif (droneState.isOnGround())\n\t\t\treturn false;\n\t\tif (droneState.isInAir())\n\t\t\treturn false;\n\n\t\t// Otherwise\n\t\ttry {\n\t\t\tland();\n\t\t} catch (FlightZoneException e) {\n\t\t\tLOGGER.error(getDroneName() + \" is not able to land!\", e);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t *\n\t * @return current safety mode state\n\t */\n\tpublic DroneSafetyStateManager getFlightSafetyModeState() {\n\t\treturn droneSafetyState;\n\t}\n\n\tprivate void flyDrone() {\n\t\t// check to see if we are flying the right command\n\t\tif (commandQueue.size() < 1) {\n\t\t\tcommandQueue.add(new StopCommand(0.0));\n\t\t}\n\t\tif (commandQueue.get(0) != currentCommand) {\n\t\t\tcurrentCommand = commandQueue.get(0);\n\t\t\tcurrentExecutor = executorFactory.makeExecutor(currentCommand);\n\t\t}\n\n\t\tcurrentExecutor.process();\n\n\t\tif (currentExecutor.isFinished()) {\n\t\t\tCommand current = commandQueue.remove(0);\n\t\t\tcompletedCommands.add(current);\n\t\t\tLOGGER.missionInfo(drone.getDroneName() + \" command completed: \" + current.toString());\n\t\t}\n\t}\n\n\tprivate boolean isCompleted(Command ref) {\n\t\tNullUtil.checkNull(ref);\n\t\tint index = 0;\n\t\twhile (index < completedCommands.size()) {\n\t\t\tif (completedCommands.get(index) == ref) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t++index;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void updateGuidance(List<Command> commands) {\n\t\tLOGGER.debug(\"New guidance from CA: \" + commands.stream().map(Object::toString).collect(Collectors.joining(\", \", \"[\", \"]\")));\n\t\tNullUtil.checkNull(commands);\n\t\t// find the first item in commands that is not completed\n\t\t// what if the first command is new and a later command is completed?\n\t\tint index = 0;\n\n\t\twhile (index < commands.size() && isCompleted(commands.get(index))) {\n\t\t\t++index;\n\t\t}\n\n\t\tcommandQueue.clear();\n\t\tif (index >= commands.size()) {\n\t\t\tcommandQueue.add(new StopCommand(0.0));\n\t\t} else {\n\t\t\tList<Command> remaining = commands.subList(index, commands.size());\n\t\t\tfor (Command cmd : remaining) {\n\t\t\t\tcommandQueue.add(cmd);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void clearGoals() {\n\t\tgoals.clear();\n\t\tactiveGoals.clear();\n\t}\n\n\tprivate void addGoal(AbstractGoal goal) {\n\t\tNullUtil.checkNull(goal);\n\n\t\t// ManagedDrone should observe each goal.\n\t\t// When the goal changes state, ManagedDrone needs to update its active goals.\n\t\tgoal.addObserver(this);\n\t\t((AbstractDrone) drone).addObserver(goal);\n\n\t\t// If the new goal is a WaypointGoal, it needs to observe the previous\n\t\t// WaypointGoal (if one exists).\n\t\tif (goal instanceof WaypointGoal) {\n\t\t\tint lastWaypointIdx = -1;\n\n\t\t\t// Find the index of the previous waypoint goal.\n\t\t\tfor (int i = 0; i < goals.size(); i++) {\n\t\t\t\tif (goals.get(i) instanceof WaypointGoal) {\n\t\t\t\t\tlastWaypointIdx = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is a previous waypoint goal, make the new goal an observe of it.\n\t\t\t// When the previous waypoint is completed, the new goal will become active.\n\t\t\tif (lastWaypointIdx >= 0) {\n\t\t\t\tgoals.get(lastWaypointIdx).addObserver(goal);\n\t\t\t}\n\n\t\t}\n\n\t\tgoals.add(goal);\n\t}\n\t// endregion\n}\n"}, {"id": "AreaMappingServiceRemoteFacade.java", "body": "package edu.nd.dronology.services.extensions.areamapping.facade;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.areamapping.GeneratedMappedArea;\nimport edu.nd.dronology.services.core.info.AreaMappingCategoryInfo;\nimport edu.nd.dronology.services.core.info.AreaMappingInfo;\nimport edu.nd.dronology.services.core.listener.IItemChangeListener;\nimport edu.nd.dronology.services.core.remote.IAreaMappingRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.extensions.areamapping.instances.AreaMappingService;\nimport edu.nd.dronology.services.instances.flightmanager.FlightManagerService;\nimport edu.nd.dronology.services.remote.AbstractRemoteFacade;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider; \n\n/**\n * \n * \n * \n * @author Michael Vierhauser\n *\n */\npublic class AreaMappingServiceRemoteFacade extends AbstractRemoteFacade implements IAreaMappingRemoteService {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -4580658378477037955L;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(AreaMappingServiceRemoteFacade.class);\n\tprivate static volatile AreaMappingServiceRemoteFacade INSTANCE;\n\n\tprotected AreaMappingServiceRemoteFacade() throws RemoteException {\n\t\tsuper(FlightManagerService.getInstance());\n\t}\n\n\tpublic static IAreaMappingRemoteService getInstance() throws RemoteException {\n\t\tif (INSTANCE == null) {\n\t\t\ttry {\n\t\t\t\tsynchronized (AreaMappingServiceRemoteFacade.class) {\n\t\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\t\tINSTANCE = new AreaMappingServiceRemoteFacade();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} catch (RemoteException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tpublic byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException {\n\t\treturn AreaMappingService.getInstance().requestFromServer(id);\n\t}\n\n\t@Override\n\tpublic void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException {\n\t\tAreaMappingService.getInstance().transmitToServer(id, content);\n\t}\n\n\t@Override\n\tpublic boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException {\n\t\treturn AreaMappingService.getInstance().addItemChangeListener(listener);\n\t}\n\n\t@Override\n\tpublic boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException {\n\t\treturn AreaMappingService.getInstance().removeItemChangeListener(listener);\n\n\t}\n\n\t@Override\n\tpublic Collection<AreaMappingInfo> getItems() throws RemoteException {\n\t\treturn AreaMappingService.getInstance().getItems();\n\n\t}\n\n\t@Override\n\tpublic AreaMappingInfo createItem() throws RemoteException, DronologyServiceException {\n\t\treturn AreaMappingService.getInstance().createItem();\n\n\t}\n\n\t@Override\n\tpublic void deleteItem(String itemid) throws RemoteException, DronologyServiceException {\n\t\tAreaMappingService.getInstance().deleteItem(itemid);\n\n\t}\n\n\t@Override\n\tpublic Collection<AreaMappingCategoryInfo> getMappingPathCategories() throws RemoteException {\n\t\treturn AreaMappingService.getInstance().getMappingPathCategories();\n\t}\n\n\t@Override\n\tpublic GeneratedMappedArea generateAreaMapping(AreaMappingInfo info)\n\t\t\tthrows DronologyServiceException, RemoteException {\n\t\treturn AreaMappingService.getInstance().generateAreaMapping(info);\n\t}\n\t\n\t@Override\n\tpublic GeneratedMappedArea generateAreaMapping(AreaMappingInfo info, Collection<IUAVProxy> selectedUAVs)\n\t\t\tthrows DronologyServiceException, RemoteException {\n\t\treturn AreaMappingService.getInstance().generateAreaMapping(info,selectedUAVs);\n\t}\n\n\t@Override\n\tpublic void executeAreaMapping(GeneratedMappedArea area) throws DronologyServiceException, RemoteException {\n\t\tAreaMappingService.getInstance().executeAreaMapping(area);\n\n\t}\n\n\n\n}"}, {"id": "AreaMappingServiceInstance.java", "body": "package edu.nd.dronology.services.extensions.areamapping.instances;\n\nimport java.io.File;\nimport java.net.MalformedURLException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.api.IFileChangeNotifyable;\nimport edu.nd.dronology.services.core.areamapping.EdgeLla;\nimport edu.nd.dronology.services.core.areamapping.ExportDrone;\nimport edu.nd.dronology.services.core.areamapping.GeneratedMappedArea;\nimport edu.nd.dronology.services.core.base.AbstractFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.info.AreaMappingCategoryInfo;\nimport edu.nd.dronology.services.core.info.AreaMappingInfo;\nimport edu.nd.dronology.services.core.items.IAreaMapping;\nimport edu.nd.dronology.services.core.items.IFlightRoute;\nimport edu.nd.dronology.services.core.persistence.AreaMappingPersistenceProvider;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport edu.nd.dronology.services.core.util.DronologyConstants;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.core.util.ServiceIds;\nimport edu.nd.dronology.services.extensions.areamapping.AreaMappingGenerator;\nimport edu.nd.dronology.services.instances.dronesetup.DroneSetupService;\nimport edu.nd.dronology.services.instances.flightmanager.FlightManagerService;\nimport edu.nd.dronology.services.supervisor.SupervisorService;\nimport edu.nd.dronology.util.FileUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class AreaMappingServiceInstance extends AbstractFileTransmitServiceInstance<AreaMappingInfo>\n\t\timplements IFileChangeNotifyable, IAreaMappingServiceInstance {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(AreaMappingServiceInstance.class);\n\n\tpublic static final String EXTENSION = DronologyConstants.EXTENSION_AREA;\n\n\tprivate Collection<AreaMappingCategoryInfo> categories = new ArrayList<>();\n\n\tpublic AreaMappingServiceInstance() {\n\t\tsuper(ServiceIds.SERVICE_AREAMAPPING, \"Area Mapping\", EXTENSION);\n\t}\n\n\t@Override\n\tprotected Class<?> getServiceClass() {\n\t\treturn AreaMappingService.class;\n\t}\n\n\t@Override\n\tprotected int getOrder() {\n\t\treturn 2;\n\t}\n\n\t@Override\n\tprotected String getPropertyPath() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void doStartService() throws Exception {\n\t\treloadItems();\n\t}\n\n\t@Override\n\tprotected void doStopService() throws Exception {\n\t\tfileManager.tearDown();\n\t}\n\n\t@Override\n\tpublic AreaMappingInfo createItem() throws DronologyServiceException {\n\t\tAreaMappingPersistenceProvider persistor = AreaMappingPersistenceProvider.getInstance();\n\t\tIAreaMapping areaMapping = DronologyElementFactory.createNewAreaMapping();\n\t\tareaMapping.setName(\"New-AreaMapping\");\n\t\tString savePath = FileUtil.concat(storagePath, areaMapping.getId(), EXTENSION);\n\n\t\ttry {\n\t\t\tpersistor.saveItem(areaMapping, savePath);\n\t\t} catch (PersistenceException e) {\n\t\t\tthrow new DronologyServiceException(\"Error when creating area mapping: \" + e.getMessage());\n\t\t}\n\t\treturn new AreaMappingInfo(areaMapping.getName(), areaMapping.getId());\n\t}\n\n\t@Override\n\tprotected String getPath() {\n\t\tString path = SupervisorService.getInstance().getAreaMappingLocation();\n\t\treturn path;\n\t}\n\n\t@Override\n\tprotected AreaMappingInfo fromFile(String id, File file) throws Throwable {\n\t\tIAreaMapping atm = AreaMappingPersistenceProvider.getInstance().loadItem(file.toURI().toURL());\n\t\tAreaMappingInfo info = new AreaMappingInfo(atm.getName(), id);\n\t\tfor (int i = 0; i <= 1; i++)\n\t\t\tfor (EdgeLla coordinate : atm.getMappedPoints(i)) {\n\t\t\t\tinfo.addCoordinate(i, coordinate);\n\t\t\t}\n\n\t\tBasicFileAttributes attr = Files.readAttributes(Paths.get(file.toURI()), BasicFileAttributes.class);\n\t\tinfo.setDateCreated(attr.creationTime().toMillis());\n\t\tinfo.setDateModified(attr.lastModifiedTime().toMillis());\n\t\tinfo.setDescription(atm.getDescription());\n\t\treturn info;\n\t}\n\n\t@Override\n\tpublic Collection<AreaMappingCategoryInfo> getMappingPathCategories() {\n\t\treturn Collections.unmodifiableCollection(categories);\n\t}\n\n\t@Override\n\tpublic AreaMappingInfo getItem(String name) throws DronologyServiceException {\n\t\tfor (AreaMappingInfo item : itemmap.values()) {\n\t\t\tif (item.getId().equals(name)) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\t\tthrow new DronologyServiceException(\"Area mapping '\" + name + \"' not found\");\n\t}\n\n\t@Override\n\tpublic AreaMappingInfo getMappingByName(String mappingName) throws DronologyServiceException {\n\t\tfor (AreaMappingInfo item : itemmap.values()) {\n\t\t\tif (item.getName().equals(mappingName)) {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t}\n\t\tthrow new DronologyServiceException(\"Area mapping '\" + mappingName + \"' not found\");\n\t}\n\n\t@Override\n\tpublic GeneratedMappedArea generateAreaMapping(AreaMappingInfo info) throws DronologyServiceException {\n\n\t\tCollection<IUAVProxy> allUAVs = DroneSetupService.getInstance().getActiveUAVs();\n\t\treturn generateAreaMapping(info, allUAVs);\n\n\t}\n\n\t@Override\n\tpublic GeneratedMappedArea generateAreaMapping(AreaMappingInfo info, Collection<IUAVProxy> selectedUAVs)\n\t\t\tthrows DronologyServiceException {\n\t\ttry {\n\t\t\tFile file = fileManager.getFile(info.getId());\n\t\t\tIAreaMapping mapping;\n\t\t\tmapping = AreaMappingPersistenceProvider.getInstance().loadItem(file.toURI().toURL());\n\t\t\tAreaMappingGenerator generator = new AreaMappingGenerator(mapping, selectedUAVs);\n\n\t\t\treturn generator.generateMapping();\n\t\t} catch (MalformedURLException | PersistenceException e) {\n\t\t\tthrow new DronologyServiceException(e.getMessage());\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void executeAreaMapping(GeneratedMappedArea area) throws DronologyServiceException {\n\n\t\tfor (ExportDrone ex : area.getUAVAssignments()) {\n\t\t\tString uavid = ex.getUAVId();\n\t\t\tint i = 0;\n\t\t\tList<IFlightRoute> assignments = ex.getDroneRouteAssignment();\n\t\t\tif (assignments.size() > 0) {\n\n\t\t\t\ttry {\n\t\t\t\t\tFlightManagerService.getInstance().takeoff(uavid,\n\t\t\t\t\t\t\tassignments.get(0).getWaypoints().get(0).getCoordinate().getAltitude());\n\t\t\t\t} catch (DronologyServiceException e) {\n\t\t\t\t\tLOGGER.error(e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new DronologyServiceException(\"Error when creating route assignments - no assignments available\");\n\t\t\t}\n\t\t\tfor (IFlightRoute assignment : assignments) {\n\t\t\t\tList<Waypoint> waypoints = assignment.getWaypoints();\n\t\t\t\ttry {\n\t\t\t\t\tFlightManagerService.getInstance().planFlight(uavid, \"Generated-RouteAssignment-\" + i, waypoints);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLOGGER.error(e);\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// try {\n\t\t\t// FlightManagerService.getInstance().planFlight(uavid,\n\t\t\t// \"Generated-RouteAssignment\" + i, waypoints);\n\t\t\t// } catch (Exception e) {\n\t\t\t// LOGGER.error(e);\n\t\t\t// }\n\n\t\t}\n\n\t}\n\n\tprivate List<Waypoint> convertToWaypoints(List<LlaCoordinate> droneFullRoute) {\n\t\tList<Waypoint> wp = new ArrayList<>();\n\n\t\tdroneFullRoute.forEach(coord -> {\n\t\t\twp.add(new Waypoint(coord));\n\t\t});\n\t\treturn wp;\n\t}\n\n}\n"}, {"id": "MissionUtil.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.plan;\n\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.IMissionTask;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.RouteTask;\nimport edu.nd.dronology.services.instances.dronesetup.DroneSetupService;\nimport edu.nd.dronology.services.instances.flightmanager.FlightManagerService;\nimport edu.nd.dronology.services.instances.flightroute.FlightRouteplanningService;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class MissionUtil {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(MissionUtil.class);\n\n\tpublic static void activateRoute(IMissionTask activeTask) throws MissionExecutionException {\n\t\tFlightRouteInfo route = null;\n\t\tCollection<FlightRouteInfo> routes;\n\t\ttry {\n\t\t\troutes = FlightRouteplanningService.getInstance().getItems();\n\t\t} catch (RemoteException e) {\n\t\t\tthrow new MissionExecutionException(\"Error when fetching routes\");\n\t\t}\n\t\tfor (FlightRouteInfo s : routes) {\n\t\t\tif (s.getName().equals(activeTask.getTaskName())) {\n\t\t\t\troute = s;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (route == null) {\n\t\t\tthrow new MissionExecutionException(\"Route '\" + activeTask.getTaskName() + \"' not found\");\n\t\t}\n\t\ttry {\n\n\t\t\tArrayList<Waypoint> wp = new ArrayList<>(route.getWaypoints());\n\t\t\tFlightManagerService.getInstance().planFlight(activeTask.getUAVId(), activeTask.getTaskName(), wp);\n\t\t} catch (Exception e) {\n\t\t\tthrow new MissionExecutionException(\"Error when activating flight plan: \" + e.getMessage());\n\t\t}\n\t}\n\n\tpublic static void activateWaypoint(IMissionTask activeTask) throws MissionExecutionException {\n\t\tWaypoint wp = new Waypoint(activeTask.getWaypoint());\n\t\ttry {\n\t\t\tFlightManagerService.getInstance().planFlight(activeTask.getUAVId(), activeTask.getTaskName(),\n\t\t\t\t\tCollections.singletonList(wp));\n\t\t} catch (Exception e) {\n\t\t\tthrow new MissionExecutionException(\"Error when activating flight plan: \" + e.getMessage());\n\t\t}\n\t}\n\n\tpublic static LlaCoordinate getFinalWaypoint(List<IMissionTask> allTasks) throws MissionExecutionException {\n\t\tIMissionTask task = allTasks.get(allTasks.size() - 1);\n\t\tif (task instanceof RouteTask) {\n\t\t\tLlaCoordinate finalWP = getLastWaypoint(task.getTaskName());\n\t\t\treturn finalWP;\n\t\t}\n\t\tthrow new MissionExecutionException(\"Last task is not a route!\");\n\t}\n\n\tprivate static LlaCoordinate getLastWaypoint(String routeName) throws MissionExecutionException {\n\t\tFlightRouteInfo route = null;\n\t\ttry {\n\t\t\t// route = FlightRouteplanningService.getInstance().getItem(routeName);\n\n\t\t\tCollection<FlightRouteInfo> items = FlightRouteplanningService.getInstance().getItems();\n\t\t\tfor (FlightRouteInfo i : items) {\n\t\t\t\tif (i.getName().equals(routeName)) {\n\t\t\t\t\troute = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (route == null) {\n\t\t\t\tthrow new MissionExecutionException(\"Route '\" + routeName + \"' not found!\");\n\t\t\t}\n\n\t\t\tWaypoint firstWaypoint = new LinkedList<>(route.getWaypoints()).getLast();\n\n\t\t\treturn firstWaypoint.getCoordinate();\n\t\t} catch (RemoteException e) {\n\t\t\tthrow new MissionExecutionException(e.getMessage());\n\t\t}\n\n\t}\n\n\t/**\n\t * Given a routename extract the first way point\n\t * \n\t * @param routeName\n\t * @return\n\t */\n\tpublic static LlaCoordinate getFirstWayPoint(String routeName) throws MissionExecutionException {\n\n\t\tFlightRouteInfo route = null;\n\t\ttry {\n\t\t\t// route = FlightRouteplanningService.getInstance().getItem(routeName);\n\n\t\t\tCollection<FlightRouteInfo> items = FlightRouteplanningService.getInstance().getItems();\n\t\t\tfor (FlightRouteInfo i : items) {\n\t\t\t\tif (i.getName().equals(routeName)) {\n\t\t\t\t\troute = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (route == null) {\n\t\t\t\tthrow new MissionExecutionException(\"Route '\" + routeName + \"' not found!\");\n\t\t\t}\n\n\t\t\tWaypoint firstWaypoint = route.getWaypoints().get(0);\n\n\t\t\treturn firstWaypoint.getCoordinate();\n\n\t\t} catch (RemoteException e) {\n\t\t\tthrow new MissionExecutionException(e.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * Get the home coordinates of *this* UAV i.e., uavID (class variable)\n\t * \n\t * @param routeName\n\t * @return\n\t * @throws MissionExecutionException\n\t */\n\tpublic static LlaCoordinate getHome(String uavid) throws MissionExecutionException {\n\t\tCollection<IUAVProxy> uavList = DroneSetupService.getInstance().getActiveUAVs();\n\n\t\tfor (IUAVProxy uav : uavList) {\n\t\t\tif (uav.getID().equals(uavid)) {\n\n\t\t\t\treturn uav.getHomeLocation();\n\t\t\t}\n\t\t}\n\t\tthrow new MissionExecutionException(\"UAV '\" + uavid + \"' not found!\");\n\n\t}\n\n\tpublic static void stopUAV(String uavid) {\n\t\ttry {\n\t\t\tFlightManagerService.getInstance().emergencyStop(uavid);\n\t\t} catch (DronologyServiceException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\n\t}\n\n}\n"}, {"id": "PersistableUAVMissionTask.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.persistence;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport edu.nd.dronology.services.core.items.IUAVMissionTask;\n\npublic class PersistableUAVMissionTask implements Serializable, IUAVMissionTask {\n\t\n\tpublic static final String DELAY_DURATION =\"duration\";\n\t\n\n\tprivate static final long serialVersionUID = 2287087726638295092L;\n\tprivate String id;\n\tprivate Map<String, Serializable> attributes = new HashMap<>();\n\tprivate String type;\n\n\tpublic PersistableUAVMissionTask(String id, String type) {\n\t\tthis.id = id;\n\t\tthis.setType(type);\n\t}\n\n\tpublic void addAttribute(String key, Serializable value) {\n\t\tattributes.put(key, value);\n\t}\n\n\t@Override\n\tpublic Serializable getAttribute(String key) {\n\t\treturn attributes.get(key);\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic String getType() {\n\t\treturn type;\n\t}\n\n\tpublic void setType(String type) {\n\t\tthis.type = type;\n\t}\n\n\t@Override\n\tpublic Map<String,Serializable> getParameters() {\n\t\treturn Collections.unmodifiableMap(attributes);\n\t}\n\n}\n"}, {"id": "CollisionAvoidanceMessenger.java", "body": "package edu.nd.dronology.core.collisionavoidance;\n\nimport edu.nd.dronology.core.collisionavoidance.backendmessage.*;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;\nimport edu.nd.dronology.core.goal.IGoalSnapshot;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.ArrayBlockingQueue;\n\n/**\n * The CollisionAvoidanceMessenger class facilitates sending messages to instances of CollisionAvoidanceBackend. Use\n * instances of this class when you need to send a message to CollisionAvoidanceBackend.\n */\npublic class CollisionAvoidanceMessenger {\n    private static final ILogger LOGGER = LoggerProvider.getLogger(CollisionAvoidanceMessenger.class);\n    private final ArrayBlockingQueue<AbstractMessage> mailbox;\n\n    // This constructor intentionally has no access modifier. Instances of this class should be created by\n    // CollisionAvoidanceBackend.\n    CollisionAvoidanceMessenger(ArrayBlockingQueue<AbstractMessage> mailbox) {\n        this.mailbox = mailbox;\n    }\n\n    private void offerMessage(AbstractMessage msg) {\n        if(!mailbox.offer(msg)) {\n            LOGGER.warn(\"Could not add message to mailbox \" + msg);\n        }\n    }\n\n    /**\n     * Send a message to the CollisionAvoidanceBackend telling it to run CollisionAvoider.avoid() and disperse guidance\n     * to the managed drones.\n     */\n    //TODO rename this method\n    public void sendCheckTask() {\n        offerMessage(new CheckerTaskMessage());\n    }\n\n    /**\n     * Send an update message with state from a physical drone. This message contains data sensed by a drones\n     * (its position, velocity, etc.). Messages of this type should be sent when new data is received from the\n     * drone.\n     * @param snapshot a snapshot of the data received from the drone\n     */\n    public void sendPhysicalDroneUpdate(DroneSnapshotInternal snapshot) {\n        offerMessage(new PhysicalDroneUpdateMessage(snapshot.getName(),\n                snapshot.getPosition(), snapshot.getVelocity(), snapshot.getAttitude()));\n    }\n\n    /**\n     * Sends an update message with state from a managed drone. This message contains a snapshot of the active goals as\n     * well as the queue of commands currently being executed. Messages of this type should be sent when the set of\n     * active goals changes or when the queue of commands changes.\n     *\n     * @param name the name of the drone\n     * @param commandQueue the current queue of commands the managed drone is executing (this should not be the same\n     *                     object use by managed drone, but a copy of that list)\n     * @param goals a snapshot of the goals for this drone\n     * @param state the state of the drone (FLYING, ON_GROUND, etc.)\n     * @param managedDrone a reference to the managed drone this data came from (used to pass guidance back to the\n     *                     managed drone after the next call of CollisionAvoider.avoid()).\n     */\n    public void sendManagedDroneUpdate(String name, List<Command> commandQueue, Set<IGoalSnapshot> goals, String state, ManagedDrone managedDrone) {\n        offerMessage(new ManagedDroneUpdateMessage(name, commandQueue, goals, state, managedDrone));\n    }\n\n    /**\n     * Send a stop message. This message should be sent when the program is shutting down. This message causes the\n     * CollisionAvoidanceBackend thread to stop gracefully.\n     */\n    public void sendStopMessage() {\n        try {\n            mailbox.put(new StopMessage());\n        } catch (InterruptedException e) {\n            LOGGER.error(\"Could not send stop command to CollisionAvoidanceBackend\");\n            LOGGER.trace(e);\n            throw new RuntimeException(e);\n        }\n\n    }\n }\n"}, {"id": "FlightPlan.java", "body": "package edu.nd.dronology.core.flight.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport edu.nd.dronology.core.Discuss;\nimport edu.nd.dronology.core.DronologyConstants;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.exceptions.FlightZoneException;\nimport edu.nd.dronology.core.flight.IFlightPlan;\nimport edu.nd.dronology.core.monitoring.DronologyMonitoringManager;\nimport edu.nd.dronology.core.monitoring.MessageMarshaller;\nimport edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;\nimport edu.nd.dronology.core.util.FormatUtil;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * Stores flight information including its waypoints and current status.\n * \n * @author Jane Cleland-Huang\n * @version 0.1\n *\n */\npublic class FlightPlan implements IFlightPlan {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -390109273842862492L;\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(FlightPlan.class);\n\n\tprivate static int flightNumber = 0;\n\tprivate String flightID;\n\n\tprivate List<Waypoint> wayPoints;\n\tprivate LlaCoordinate startLocation;\n\tprivate LlaCoordinate endLocation;\n\tprivate Status status;\n\tprivate transient ManagedDrone drone = null;\n\n\tprivate long startTime = -1;\n\tprivate long endTime = -1;\n\tprivate String uavid;\n\n\tprivate enum Status {\n\t\tPLANNED, FLYING, COMPLETED, ON_HOLD;\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn name().charAt(0) + name().substring(1).toLowerCase();\n\t\t}\n\n\t}\n\n\tpublic FlightPlan(String planName, List<Waypoint> wayPoints) {\n\t\tthis(null, planName, wayPoints);\n\n\t}\n\n\tpublic FlightPlan(String uavid, String planName, List<Waypoint> wayPointsToAdd) {\n\t\tthis.wayPoints = new ArrayList<>();\n\t\tfor (Waypoint oldWP : wayPointsToAdd) {\n\t\t\tWaypoint newWP = new Waypoint(oldWP.getCoordinate());\n\t\t\tnewWP.setApproachingspeed(oldWP.getApproachingspeed());\n\t\t\tthis.wayPoints.add(newWP);\n\t\t}\n\n\t\tthis.uavid = uavid;\n\t\tthis.startLocation = wayPoints.get(0).getCoordinate();\n\t\tif (this.wayPoints.size() > 0) {\n\t\t\tthis.endLocation = this.wayPoints.get(this.wayPoints.size() - 1).getCoordinate();\n\t\t} else {\n\t\t\tendLocation = startLocation;\n\t\t}\n\t\tthis.flightID = \"DF-\" + Integer.toString(++flightNumber) + \" - \" + planName;\n\t\tstatus = Status.PLANNED;\n\n\t}\n\n\t/**\n\t * \n\t * @return flight ID\n\t */\n\t@Override\n\tpublic String getFlightID() {\n\t\treturn flightID;\n\t}\n\n\t/**\n\t * \n\t * @return Starting Coordinates\n\t */\n\t@Override\n\tpublic LlaCoordinate getStartLocation() {\n\t\treturn startLocation;\n\t}\n\n\t/**\n\t * \n\t * @return Ending Coordinates\n\t */\n\t@Override\n\tpublic LlaCoordinate getEndLocation() {\n\t\treturn endLocation;\n\t}\n\n\t/**\n\t * Returns the drone assigned to the flight plan. Will return null if no drone\n\t * is yet assigned.\n\t * \n\t * @return iDrone\n\t */\n\t@Override\n\tpublic ManagedDrone getAssignedDrone() {\n\t\treturn drone;\n\t}\n\n\t@Override\n\tpublic void clearAssignedDrone() {\n\t\tdrone = null;\n\t}\n\n\t/**\n\t * \n\t * @param drone\n\t * @return true if drone is currently flying, false otherwise.\n\t * @throws FlightZoneException\n\t */\n\t@Override\n\tpublic boolean setStatusToFlying(ManagedDrone drone) throws FlightZoneException {\n\t\tif (status == Status.PLANNED) {\n\t\t\tstatus = Status.FLYING;\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t\tthis.drone = drone; \n\t\t\tLOGGER.missionInfo(\"Flight Plan '\" + getFlightID() + \"'\" + drone.getDroneName() + \"' started \");\n\t\t\treturn true; \n\t\t} else\n\t\t\tthrow new FlightZoneException(\"Only currently planned flights can have their status changed to flying\");\n\t}\n\n\t/**\n\t * Sets flightplan status to completed when called.\n\t * \n\t * @return true\n\t * @throws FlightZoneException\n\t */\n\t@Override\n\tpublic boolean setStatusToCompleted() throws FlightZoneException {\n\t\tif (status == Status.FLYING) {\n\t\t\tstatus = Status.COMPLETED;\n\t\t\tendTime = System.currentTimeMillis();\n\t\t\tLOGGER.missionInfo(\"Flight Plan '\" + getFlightID() + \"'\" + drone.getDroneName() + \"' completed \"\n\t\t\t\t\t+ FormatUtil.formatTimestamp(startTime) + \"-\" + FormatUtil.formatTimestamp(endTime));\n\n\t\t\treturn true; // success (may add real check here later)\n\t\t} else\n\t\t\tthrow new FlightZoneException(\"Only currently flying flights can have their status changed to completed\");\n\t}\n\n\t/**\n\t * Returns current flightplan status (Planned, Flying, Completed)\n\t * \n\t * @return status\n\t */\n\tpublic String getStatus() {\n\n\t\treturn status.toString();\n\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn flightID + \"\\n\" + getStartLocation() + \" - \" + getEndLocation() + \"\\n\" + getStatus();\n\t}\n\n\t/**\n\t * Returns way points\n\t * \n\t * @return List<Waypoint>\n\t */\n\t@Override\n\tpublic List<Waypoint> getWayPoints() {\n\t\treturn Collections.unmodifiableList(wayPoints);\n\t}\n\n\t/**\n\t * Returns start time of flight.\n\t * \n\t * @return date object\n\t */\n\t@Override\n\tpublic long getStartTime() {\n\t\treturn startTime;\n\t}\n\n\t/**\n\t * REturns end time of flight.\n\t * \n\t * @return date object\n\t */\n\t@Override\n\tpublic long getEndTime() {\n\t\treturn endTime;\n\t}\n\n\t@Override\n\tpublic String getDesignatedDroneId() {\n\t\treturn uavid;\n\t}\n\n\t@Override\n\t@Discuss(discuss = \"unessecary double check of plan complete.. needs to be fixed\")\n\tpublic boolean isCompleted() {\n\t\treturn status == Status.COMPLETED || waypointsReached();\n\t}\n\n\t@Override\n\tpublic double getTakeoffAltitude() {\n\t\treturn DronologyConstants.TAKE_OFF_ALTITUDE;\n\t}\n\n\tprivate boolean waypointsReached() {\n\t\tfor (Waypoint wp : wayPoints) {\n\t\t\tif (!wp.isReached()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} \n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void setDesignatedDroneId(String uavid) {\n\t\tthis.uavid=uavid;\n\t\t\n\t}\n}\n"}, {"id": "CollisionInfo.java", "body": "package edu.nd.dronology.monitoring.simplechecker.checker;\n\nimport java.io.Serializable;\n\npublic class CollisionInfo implements Serializable {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -2177691764314219425L;\n\tprivate final String uavid1;\n\tprivate final String uavid2;\n\tprivate final double distance;\n\n\tpublic CollisionInfo(String uavid1, String uavid2, double distance) {\n\t\tthis.uavid1 = uavid1;\n\t\tthis.uavid2 = uavid2;\n\t\tthis.distance = distance;\n\t}\n\n}\n"}, {"id": "AMMapMarkerUtilities.java", "body": "package edu.nd.dronology.ui.vaadin.areamapping;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.Vector;\n\nimport org.vaadin.addon.leaflet.LMap;\nimport org.vaadin.addon.leaflet.LMarker;\nimport org.vaadin.addon.leaflet.LPolygon;\nimport org.vaadin.addon.leaflet.LPolyline;\nimport org.vaadin.addon.leaflet.LeafletMouseOutEvent;\nimport org.vaadin.addon.leaflet.LeafletMouseOutListener;\nimport org.vaadin.addon.leaflet.LeafletMouseOverEvent;\nimport org.vaadin.addon.leaflet.LeafletMouseOverListener;\nimport org.vaadin.addon.leaflet.shared.Point;\n\nimport com.vaadin.server.FileResource;\nimport com.vaadin.server.VaadinService;\nimport com.vaadin.ui.Component;\nimport com.vaadin.ui.Notification;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.services.core.items.IAreaMapping;\nimport edu.nd.dronology.services.core.items.PriorityArea;\nimport edu.nd.dronology.services.core.items.PrioritySide;\nimport edu.nd.dronology.services.core.persistence.AreaMappingPersistenceProvider;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport edu.nd.dronology.services.core.remote.IAreaMappingRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMMapAddMarkerListener;\nimport edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMMarkerDragEndListener;\nimport edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMMarkerMouseOutListener;\nimport edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMMarkerMouseOverListener;\nimport edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMPolylineClickListener;\nimport edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMPriorityAreaMouseOverListener;\nimport edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMPriorityDragEndListener;\nimport edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMPriorityMouseOutListener;\nimport edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMPrioritySideMouseOverListener;\nimport edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMRightClickListener;\nimport edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMUpstreamClickListener;\nimport edu.nd.dronology.ui.vaadin.areamapping.windows.AMPriorityInfoWindow;\nimport edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;\nimport edu.nd.dronology.ui.vaadin.start.MyUI;\n\n/**\n * Adapted from the MapMarkerUtilities class in the utils folder, this class has listeners that allow the user to interact with the map.\n * Also includes many functions for manipulating and updating a current mapping\n * @author Andrew Slavin\n *\n */\n\npublic class AMMapMarkerUtilities {\t\n\tprivate LMap map;\n\tprivate AMMapComponent mapComponent;\n\t \n\tprivate AMMapAddMarkerListener mapAddMarkerListener;\n\tprivate AMMarkerMouseOverListener markerMouseOverListener;\n\tprivate AMMarkerMouseOutListener markerMouseOutListener;\n\tprivate AMMarkerDragEndListener markerDragEndListener;\n\tprivate AMPolylineClickListener polylineClickListener;\n\tprivate AMRightClickListener rightClickListener;\n\t\n\tprivate AMPriorityInfoWindow priorityInfoWindow;\n\t\n\tprivate LinkedList<Point> polygonVertices = new LinkedList<>();\n\tprivate Vector<PriorityArea> allPriorityAreas = new Vector<>();\n\tprivate Vector<List<UIEdgePoint>> sides;\n\tprivate LPolyline mousedOverLine;\n\tprivate PriorityArea mousedOverArea;\n\tprivate PrioritySide mousedOverSide;\n\tprivate PriorityArea areaToAdd;\n\tprivate LinkedList<LMarker> newPolygonPins = new LinkedList<>();\n\tprivate LinkedList<LMarker> allPolygonPins = new LinkedList<>();\n\tprivate LinkedList<Point> allPolygonPinsCopy = new LinkedList<>();\n\tprivate LinkedList<LPolyline> newPolygonLines = new LinkedList<>();\n\tprivate LinkedList<LPolyline> newPrioritySideLines = new LinkedList<>();\n\tprivate LinkedList<LPolyline> allPriorityLines = new LinkedList<>(); // all red lines on the map\n\tprivate LinkedList<PrioritySide> allPrioritySides = new LinkedList<>();\n\tprivate LinkedList<LPolyline> removedPriorityLines = new LinkedList<>();\n\tprivate LinkedList<LPolyline> allPolylines = new LinkedList<>();\n\tprivate LinkedList<UIEdgePoint> allSideWaypoints = new LinkedList<>();\n\t\n\tprivate Boolean upstream; // true means that upstream is the direction the points are drawn; false is opposite\n\tprivate boolean sidesAreEditable = false;\n\tprivate boolean prioritiesAreEditable = false;\n\t\n\tpublic AMMapMarkerUtilities(AMMapComponent mapComponent) {\n\t\tthis.mapComponent = mapComponent;\n\t\tthis.map = mapComponent.getMap();\n\n\t\t// add listeners\n\t\tthis.mapAddMarkerListener = new AMMapAddMarkerListener(this);\n\t\tthis.markerMouseOverListener = new AMMarkerMouseOverListener(this);\n\t\tthis.markerMouseOutListener = new AMMarkerMouseOutListener(this);\n\t\tthis.markerDragEndListener = new AMMarkerDragEndListener(this);\n\t\tthis.polylineClickListener = new AMPolylineClickListener(this);\t\n\t\tthis.rightClickListener = new AMRightClickListener(this);\n\t\t\n\t\tmap.addClickListener(mapAddMarkerListener);\n\t\t// rightClickListener only knows that the map is being clicked, but uses info about which polyline is moused over\n\t\tmap.addContextClickListener(rightClickListener);\n\t}\n\t\n\tpublic AMMapMarkerUtilities(LMap map) {\n\t\tthis.map = map;\n\t}\n\t\n\t// adds a new pin at a specified point and at a certain index in the list of waypoints (index is relevant when adding a waypoint between two other waypoints)\n\t// -1 signals that a waypoint was added to the end\n\tpublic LMarker addNewPin(Point point, int index) { \n\t\tif (getPins().size() == 0 && mapComponent.getEditSidesController().getSideA()) {\n\t\t\tNotification.show(\"Starting with Side A\", Notification.Type.ERROR_MESSAGE);\n\t\t\tmapComponent.getEditSidesController().setSideA();\n\t\t}\n\t\tif (index > this.getPins().size())\n\t\t\tindex = this.getPins().size();\n\t\t// Creates a waypoint at the given point, and assigns it a random id.\n\t\tUIEdgePoint p = new UIEdgePoint(point, false);\n\t\t// set side\n\t\tif (mapComponent.getEditSidesController().getSideA())\n\t\t\tp.setSide(1);\n\t\telse\n\t\t\tp.setSide(0);\n\t\treturn addNewPin(p, index);\n\t}\n\t\n\tpublic LMarker addNewPin(UIEdgePoint p, int index) {\n\t\tif (index > this.getPins().size()) {\n\t\t\tindex = this.getPins().size();\n\t\t}\n\t\t\n\t\t// Assign the order\n\t\tif (index == -1) {\n\t\t\tp.setOrder(this.getPins().size());\n\t\t} else {\n\t\t\tp.setOrder(index);\n\t\t\tList<LMarker> pins = this.getPins();\n\t\t\tfor (int i = 0; i < pins.size(); i++) {\n\t\t\t\tUIEdgePoint pInMap = (UIEdgePoint)pins.get(i).getData();\n\t\t\t\tif (pInMap.getOrder() >= index) {\n\t\t\t\t\tpInMap.setOrder(pInMap.getOrder() + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tLMarker newPin = null;\n\t\t// if sideA is selected, draw it green; otherwise, draw it blue\n\t\tnewPin = addPinForWayPoint(p);\n\t\tString basepath = VaadinService.getCurrent().getBaseDirectory().getAbsolutePath();\n\t\tFileResource greenIcon = new FileResource(new File(basepath+\"/VAADIN/img/green-dot.png\"));\n\t\tFileResource blueIcon = new FileResource(new File(basepath+\"/VAADIN/img/blue-dot.png\"));\n\t\tif (p.getSide() == 0) // side A is 0 is red\n\t\t\tnewPin.setIcon(greenIcon);\n\t\telse if (p.getSide() == 1) // side B is 1 is blue\n\t\t\tnewPin.setIcon(blueIcon);\n\t\tnewPin.setIconSize(new Point(15, 15));\n\t\tnewPin.setIconAnchor(new Point(7, 10));\n\t\t\n\t\t\n\t\tmapComponent.updateLinesAndGrid();\t\n\t\tallSideWaypoints.add(p);\n\t\treturn newPin;\n\t}\n\t\n\t// adds a vertex to a polygon as it's being drawn\n\tpublic void addPolygonVertex(Point point) {\n\n\t\tUIEdgePoint p = new UIEdgePoint(point, false);\n\t\tLMarker newPin = new LMarker(p.toPoint());\n\t\tnewPin.setData((p));\n\t\tnewPin.setId(p.getId());\n\t\tnewPin.setHeight(\"2px\");\n\t\tnewPin.addDragEndListener(new AMPriorityDragEndListener(this, newPin));\n\t\tnewPolygonPins.add(newPin);\n\t\tmap.addComponent(newPin);\n\t\tsetAllPolygonPins();\n\t\tpolygonVertices.add(point);\n\t\t\n\t\t// add polyline between each additional point that is drawn\n\t\tif (polygonVertices.size() > 1) {\n\t\t\tLPolyline polyline = new LPolyline(point, polygonVertices.get(polygonVertices.size()-2));\n\t\t\tpolyline.setId(UUID.randomUUID().toString());\n\t\t\tpolyline.setColor(\"#ff5050\");\n\t\t\tpolyline.setDashArray(\"5 10\");\n\t\t\tpolyline.setHeight(\"2\");\n\t\t\tpolyline.setWeight(1);\n\t\t\tmap.addComponent(polyline);\n\t\t\tnewPolygonLines.add(polyline);\n\t\t}\n\t\tString basepath = VaadinService.getCurrent().getBaseDirectory().getAbsolutePath();\n\t\tFileResource redIcon = new FileResource(new File(basepath+\"/VAADIN/img/red-dot.png\"));\n\t\tnewPin.setIcon(redIcon);\n\t\tnewPin.setIconSize(new Point(10, 10));\n\t\tnewPin.setIconAnchor(new Point(5, 7));\n\t}\n\t\n\t// adds a pin in a location designated by the wayPoints\n\tprivate LMarker addPinForWayPoint(UIEdgePoint wayPoint) {\n\t\tLMarker leafletMarker = new LMarker(wayPoint.toPoint());\n\t\tleafletMarker.setData(wayPoint);\n\t\tleafletMarker.setId(wayPoint.getId());\n\t\t\n\t\tif (markerMouseOverListener != null) leafletMarker.addMouseOverListener(markerMouseOverListener);\n\t\tif (markerMouseOutListener != null) leafletMarker.addMouseOutListener(markerMouseOutListener);\n\t\tif (markerDragEndListener != null) leafletMarker.addDragEndListener(markerDragEndListener);\n\n\t\tleafletMarker.addClickListener(new AMUpstreamClickListener(this));\n\t\t\n\t\tmap.addComponent(leafletMarker);\n\t\treturn leafletMarker;\n\t}\n\t\n\t// removes a pin when given its ID\n\tpublic void removePinById (String id) {\n\t\tLMarker p = this.getPinById(id);\n\t\tremovePin(p);\n\t}\n\t\n\t// remove a pin from the map\n\tpublic void removePin (LMarker p) {\n\t\tif (p == null)\n\t\t\treturn;\n\t\t\n\t\tUIEdgePoint w = (UIEdgePoint)p.getData();\n\t\t\n\t\tList<LMarker> pins = this.getPins();\n\t\tfor (int i = 0; i < pins.size(); i++) {\n\t\t\tUIEdgePoint pInMap = (UIEdgePoint)pins.get(i).getData();\n\t\t\tif (pInMap.getOrder() >= w.getOrder())\n\t\t\t\tpInMap.setOrder(pInMap.getOrder() - 1);\n\t\t}\n\t\tmap.removeComponent(p);\n\t\t\n\t\t// if pin was in a priority side, remove it from the list and redraw the priority sides\n\t\tfor (PrioritySide side : allPrioritySides) {\n\t\t\tList<LlaCoordinate> tempCoords = new LinkedList<LlaCoordinate>();\n\t\t\tremovedPriorityLines.clear();\n\t\t\tfor (int i = 0; i < side.getCoordinates().size(); i ++) {\n\t\t\t\tif (new LlaCoordinate(p.getPoint().getLat(), p.getPoint().getLon(), 0).equals(side.getCoordinates().get(i))) {\n\t\t\t\t\t// remove lines from allPriorityLines\n\t\t\t\t\tfor (LPolyline line : getAllPriorityLines()) {\n\t\t\t\t\t\tif (((double)Math.round(line.getPoints()[0].getLat() * 1000000d) / 1000000d == (double)Math.round(p.getPoint().getLat() * 1000000d) / 1000000d)\n\t\t\t\t\t\t&& ((double)Math.round(line.getPoints()[0].getLon() * 1000000d) / 1000000d == (double)Math.round(p.getPoint().getLon() * 1000000d) / 1000000d)\n\t\t\t\t\t\t|| (((double)Math.round(line.getPoints()[1].getLat() * 1000000d) / 1000000d == (double)Math.round(p.getPoint().getLat() * 1000000d) / 1000000d)\n\t\t\t\t\t\t&& ((double)Math.round(line.getPoints()[1].getLon() * 1000000d) / 1000000d == (double)Math.round(p.getPoint().getLon() * 1000000d) / 1000000d)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tremovedPriorityLines.add(line);\n\t\t\t\t\t\t\tallPriorityLines.remove(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttempCoords.add(side.getCoordinates().get(i)); // if the deleted pin isn't in allPrioritySides, add it to the temp list\n\t\t\t\t}\n\t\t\t}\n\t\t\tside.setCoordinates(tempCoords);\n\t\t}\n\t\tmapComponent.updateLinesAndGrid();\n\t}\n\t\n\t//removes all of the pins from the map\n\tpublic void removeAllPins() {\n\t\tallSideWaypoints.clear();\n\t\tList<LMarker> pins = getPins();\n\t\tfor (int i = pins.size() - 1; i >= 0; i--) {\n\t\t\tmap.removeComponent(pins.get(i));\n\t\t}\n\t}\n\t\n\t/**\n\t * \n\t * @param wayPoints\n\t * @param fromActive\n\t * \t\t\tshould be true if drawLines is being called from the active flights UI. This\n\t * \t\t\tdetermines if the first line segment should be green (which it shouldn't\n\t * \t\t\tbe in the flight routes UI). \n\t * @return list of polylines drawn on the map\n\t */\n\tpublic Vector<List<LPolyline>> drawLinesForWayPoints(Vector<List<UIEdgePoint>> wayPoints, boolean fromActive) {\n\t\t// Draws polylines based on a list of waypoints, then outputs the newly formed arraylist of polylines.\n\t\tsides = wayPoints;\n\t\tVector<List<LPolyline>> polylines = new Vector<>();\n\t\t\n\t\t\n\t\tfor (int j = 0; j <= 1; j++) {\n\t\t\tpolylines.add(j, new ArrayList<>());\n\t\t\tfor (int i = 0; i < wayPoints.get(j).size() - 1; i++) {\n\t\t\t\tUIEdgePoint current = wayPoints.get(j).get(i);\n\t\t\t\tLPolyline polyline = new LPolyline(current.toPoint(), wayPoints.get(j).get(i + 1).toPoint());\n\t\t\t\tpolyline.setId(UUID.randomUUID().toString());\n\t\t\t\t\n\t\t\t\t// if priority lines were recently deleted, update allPriorityLines accordingly\n\t\t\t\tif (removedPriorityLines.size() == 2) {\n\t\t\t\t\tif ((((double)Math.round(polyline.getPoints()[0].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[0].getLat() * 1000000d) / 1000000d)\n\t\t\t\t\t&& ((double)Math.round(polyline.getPoints()[0].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[0].getLon() * 1000000d) / 1000000d)\n\t\t\t\t\t&& ((double)Math.round(polyline.getPoints()[1].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[0].getLat() * 1000000d) / 1000000d)\n\t\t\t\t\t&& ((double)Math.round(polyline.getPoints()[1].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[0].getLon() * 1000000d) / 1000000d))\n\t\t\t\t\t|| (((double)Math.round(polyline.getPoints()[0].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[0].getLat() * 1000000d) / 1000000d)\n\t\t\t\t\t&& ((double)Math.round(polyline.getPoints()[0].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[0].getLon() * 1000000d) / 1000000d)\n\t\t\t\t\t&& ((double)Math.round(polyline.getPoints()[1].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[1].getLat() * 1000000d) / 1000000d)\n\t\t\t\t\t&& ((double)Math.round(polyline.getPoints()[1].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[1].getLon() * 1000000d) / 1000000d))\n\t\t\t\t\t|| (((double)Math.round(polyline.getPoints()[0].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[1].getLat() * 1000000d) / 1000000d)\n\t\t\t\t\t&& ((double)Math.round(polyline.getPoints()[0].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[1].getLon() * 1000000d) / 1000000d)\n\t\t\t\t\t&& ((double)Math.round(polyline.getPoints()[1].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[1].getLat() * 1000000d) / 1000000d)\n\t\t\t\t\t&& ((double)Math.round(polyline.getPoints()[1].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[1].getLon() * 1000000d) / 1000000d))\n\t\t\t\t\t|| (((double)Math.round(polyline.getPoints()[0].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[1].getLat() * 1000000d) / 1000000d)\n\t\t\t\t\t&& ((double)Math.round(polyline.getPoints()[0].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[1].getLon() * 1000000d) / 1000000d)\n\t\t\t\t\t&& ((double)Math.round(polyline.getPoints()[1].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[0].getLat() * 1000000d) / 1000000d)\n\t\t\t\t\t&& ((double)Math.round(polyline.getPoints()[1].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[0].getLon() * 1000000d) / 1000000d)))\n\t\t\t\t\t{\n\t\t\t\t\t\tallPriorityLines.add(polyline);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// if it's a priority line, draw it red; otherwise, grey\n\t\t\t\tpolyline.setColor(\"#444\");\n\n\t\t\t\tfor (LPolyline line : allPriorityLines) {\n\t\t\t\t\tif ((((double)Math.round(line.getPoints()[0].getLat() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[0].getLat() * 10000d) / 10000d)\n\t\t\t\t\t&& ((double)Math.round(line.getPoints()[0].getLon() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[0].getLon() * 10000d) / 10000d)\n\t\t\t\t\t&& ((double)Math.round(line.getPoints()[1].getLat() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[1].getLat() * 10000d) / 10000d)\n\t\t\t\t\t&& ((double)Math.round(line.getPoints()[1].getLon() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[1].getLon() * 10000d) / 10000d))\n\t\t\t\t\t|| (((double)Math.round(line.getPoints()[0].getLat() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[1].getLat() * 10000d) / 10000d)\n\t\t\t\t\t&& ((double)Math.round(line.getPoints()[0].getLon() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[1].getLon() * 10000d) / 10000d)\n\t\t\t\t\t&& ((double)Math.round(line.getPoints()[1].getLat() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[0].getLat() * 10000d) / 10000d)\n\t\t\t\t\t&& ((double)Math.round(line.getPoints()[1].getLon() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[0].getLon() * 10000d) / 10000d)))\n\t\t\t\t\t{\n\t\t\t\t\t\t// if a priority line endpoint was dragged, change that information in allPrioritySides\n\t\t\t\t\t\tif (markerDragEndListener.getDraggedPriorityLine()) {\n\t\t\t\t\t\t\tfor (int p = 0; p < allPrioritySides.size(); p++) {\n\t\t\t\t\t\t\t\tfor (int q = 0; q < allPrioritySides.get(p).getCoordinates().size(); q++) {\n\t\t\t\t\t\t\t\t\tif ((double)Math.round(allPrioritySides.get(p).getCoordinates().get(q).getLatitude() * 10000d) / 10000d == (double)Math.round(line.getPoints()[0].getLat() * 10000d) / 10000d \n\t\t\t\t\t\t\t\t\t&& (double)Math.round(allPrioritySides.get(p).getCoordinates().get(q).getLongitude() * 10000d) / 10000d == (double)Math.round(line.getPoints()[0].getLon() * 10000d) / 10000d ) {\n\t\t\t\t\t\t\t\t\t\tList<LlaCoordinate> tempCoords = new LinkedList<>(allPrioritySides.get(p).getCoordinates());\n\t\t\t\t\t\t\t\t\t\ttempCoords.set(q, new LlaCoordinate(polyline.getPoints()[0].getLat(), polyline.getPoints()[0].getLon(), 0));\n\t\t\t\t\t\t\t\t\t\tallPrioritySides.get(p).setCoordinates(tempCoords);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif ((double)Math.round(allPrioritySides.get(p).getCoordinates().get(q).getLatitude() * 10000d) / 10000d == (double)Math.round(line.getPoints()[1].getLat() * 10000d) / 10000d \n\t\t\t\t\t\t\t\t\t&& (double)Math.round(allPrioritySides.get(p).getCoordinates().get(q).getLongitude() * 10000d) / 10000d == (double)Math.round(line.getPoints()[1].getLon() * 10000d) / 10000d ) {\n\t\t\t\t\t\t\t\t\t\tList<LlaCoordinate> tempCoords = new LinkedList<>(allPrioritySides.get(p).getCoordinates());\n\t\t\t\t\t\t\t\t\t\ttempCoords.set(q, new LlaCoordinate(polyline.getPoints()[1].getLat(), polyline.getPoints()[1].getLon(), 0));\n\t\t\t\t\t\t\t\t\t\tallPrioritySides.get(p).setCoordinates(tempCoords);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tline.setPoints(polyline.getPoints());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// highlight as priority line\n\t\t\t\t\t\tpolyline.setColor(\"#ff5050\");\n\t\t\t\t\t\tpolyline.addMouseOverListener(new AMPrioritySideMouseOverListener(mapComponent, polyline));\n\t\t\t\t\t\tpolyline.addMouseOutListener(new AMPriorityMouseOutListener(this));\n\t\t\t\t\t\tpolyline.setOpacity(0.7);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmap.addComponent(polyline);\n\t\t\t\tallPolylines.add(polyline);\n\t\t\t\t\n\n\t\t\t\t// assigns the line that is moused over\n\t\t\t\tpolyline.addMouseOverListener(new LeafletMouseOverListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onMouseOver(LeafletMouseOverEvent event) {\n\t\t\t\t\t\tmousedOverLine = (LPolyline)event.getSource();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// if the mouse is removed from the line, set mousedOverLine to null\n\t\t\t\tpolyline.addMouseOutListener(new LeafletMouseOutListener() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onMouseOut(LeafletMouseOutEvent event) {\n\t\t\t\t\t\tmousedOverLine = null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tif (polylineClickListener != null) polyline.addClickListener(polylineClickListener);\n\t\t\t\t\n\t\t\t\tpolylines.get(j).add(polyline);\n\t\t\t}\n\t\t}\n\t\thighlightUpstream();\n\t\treturn polylines;\n\t}\n\t\n\t// Removes all lines from the map and the polylines arraylist unless drawing a polygon\n\tpublic void removeAllLines() {\n\t\tif (mapComponent.getEditPrioritiesController().getDrawingArea())\n\t\t\treturn;\n\t\tIterator<Component> it = map.iterator();\n\t\tLinkedList<LPolyline> linesToRemove = new LinkedList<>();\n\t\twhile(it.hasNext()) {\n\t\t\tComponent c = it.next();\n\t\t\tif (c.getClass() == LPolyline.class) {\n\t\t\t\tlinesToRemove.add((LPolyline)c);\n\t\t\t}\n\t\t}\n\t\tfor (LPolyline polyline : linesToRemove) {\n\t\t\tmap.removeComponent(polyline);\n\t\t}\n\t\tallPolylines.clear();\n\t}\n\t\n\t// Removes all lines and points from the polygon that's currently being drawn\n\tpublic void deleteNewPolygon() {\n\t\tfor (int i = 0; i < newPolygonPins.size(); i++) {\n\t\t\tmap.removeComponent(newPolygonPins.get(i));\n\t\t}\n\t\tfor (int i = 0; i < newPolygonLines.size(); i++) {\n\t\t\tmap.removeComponent(newPolygonLines.get(i));\n\t\t}\n\t\tpolygonVertices.clear();\n\t\tclearPolygonVertices();\n\t}\n\t\n\t// removes a polygon from the existing list\n\tpublic void deleteOldPolygon(PriorityArea areaToDelete) {\n\t\tfor (int i = 0; i < allPriorityAreas.size(); i++) {\n\t\t\tif (allPriorityAreas.get(i).getId().equals(areaToDelete.getId())) {\n\t\t\t\tallPriorityAreas.remove(i);\n\t\t\t}\n\t\t}\n\t\t// redraw polygons to map (without the one that was deleted)\n\t\tLinkedList<PriorityArea> tempPolygonList = new LinkedList<>(allPriorityAreas);\n\t\tremoveAllPriorityAreas();\n\t\tfor (int i = 0; i < tempPolygonList.size(); i++) {\n\t\t\tfor (int j = 0; j < tempPolygonList.get(i).getCoordinates().size(); j++) {\n\t\t\t\t\taddPolygonVertex(new Point(tempPolygonList.get(i).getCoordinates().get(j).getLatitude(), tempPolygonList.get(i).getCoordinates().get(j).getLongitude()));\n\t\t\t}\n\t\t\t\tdrawPolygon();\t\n\t\t\t\taddPriorityArea(tempPolygonList.get(i).getType(), tempPolygonList.get(i).getDescription(), tempPolygonList.get(i).getImportance());\n\t\t}\n\t}\n\t\n\t// redraws all the lines to the map\n\tpublic Vector<List<LPolyline>> redrawAllLines(boolean fromActive) {\n\t\tremoveAllLines();\n\t\tVector<List<UIEdgePoint>> mapPoints = getOrderedWayPoints();\n\t\treturn drawLinesForWayPoints(mapPoints, fromActive);\n\t}\n\t\n\t// highlights the points that are upstream based on upstream variable\n\tpublic void highlightUpstream() {\n\t\tif (upstream == null || this.getOrderedWayPoints().get(0).size() == 0 || this.getOrderedWayPoints().get(1).size() == 0)\n\t\t\treturn;\n\t\tString basepath = VaadinService.getCurrent().getBaseDirectory().getAbsolutePath();\n\t\tFileResource waterfallIcon = new FileResource(new File(basepath+\"/VAADIN/img/waterfall.png\"));\n\t\tFileResource greenIcon = new FileResource(new File(basepath+\"/VAADIN/img/green-dot.png\"));\n\t\tFileResource blueIcon = new FileResource(new File(basepath+\"/VAADIN/img/blue-dot.png\"));\n\t\tfor (int i = 0; i < this.getPins().size(); i++) {\n\t\t\t// if upstream is false, make the last waypoints on both sides into the waterfall icon\n\t\t\tif ((((double)Math.round(getPins().get(i).getPoint().getLat() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(0).get(getOrderedWayPoints().get(0).size()-1).getLatitude()) * 10000d) / 10000d) \n\t\t\t&& ((double)Math.round(getPins().get(i).getPoint().getLon() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(0).get(getOrderedWayPoints().get(0).size()-1).getLongitude())* 10000d) / 10000d)\t\n\t\t\t&& upstream == false)\n\t\t\t|| (((double)Math.round(getPins().get(i).getPoint().getLat() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(1).get(getOrderedWayPoints().get(1).size()-1).getLatitude()) * 10000d) / 10000d) \n\t\t\t&& ((double)Math.round(getPins().get(i).getPoint().getLon() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(1).get(getOrderedWayPoints().get(1).size()-1).getLongitude())* 10000d) / 10000d)\t\n\t\t\t&& upstream == false)) {\n\t\t\t\tLMarker leafletMarker = this.getPins().get(i);\n\t\t\t\tleafletMarker.setIcon(waterfallIcon);\n\t\t\t\tleafletMarker.setIconSize(new Point(30, 30));\n\t\t\t\tleafletMarker.setIconAnchor(new Point(16, 10));\n\t\t\t}\n\t\t\t\n\t\t\t// if upstream is true, make the first waypoints on both sides into the waterfall icon\n\t\t\telse if ((((double)Math.round(getPins().get(i).getPoint().getLat() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(0).get(0).getLatitude())* 10000d) / 10000d)\n\t\t\t&& ((double)Math.round(getPins().get(i).getPoint().getLon() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(0).get(0).getLongitude()) * 10000d) / 10000d)\n\t\t\t&& upstream == true)\n\t\t\t|| (((double)Math.round(getPins().get(i).getPoint().getLat() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(1).get(0).getLatitude())* 10000d) / 10000d)\n\t\t\t&& ((double)Math.round(getPins().get(i).getPoint().getLon() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(1).get(0).getLongitude()) * 10000d) / 10000d)\n\t\t\t&& upstream == true)) {\n\t\t\t\tLMarker leafletMarker = this.getPins().get(i);\n\t\t\t\tleafletMarker.setIcon(waterfallIcon);\n\t\t\t\tleafletMarker.setIconSize(new Point(30, 30));\n\t\t\t\tleafletMarker.setIconAnchor(new Point(16, 10));\n\t\t\t}\n\t\t\t// color all other points normally\n\t\t\telse {\n\t\t\t\tLMarker leafletMarker = this.getPins().get(i);\n\t\t\t\tleafletMarker.setIcon(blueIcon);\n\t\t\t\tleafletMarker.setIconSize(new Point(15, 15));\n\t\t\t\tleafletMarker.setIconAnchor(new Point(7, 10));\n\t\t\t\tfor (UIEdgePoint point : getOrderedWayPoints().get(0)) {\n\t\t\t\t\tif ((double)Math.round(Double.parseDouble(point.getLatitude()) * 10000d) / 10000d == (double)Math.round(this.getPins().get(i).getPoint().getLat() * 10000d) / 10000d\n\t\t\t\t\t&& (double)Math.round(Double.parseDouble(point.getLongitude()) * 10000d) / 10000d == (double)Math.round(this.getPins().get(i).getPoint().getLon()* 10000d) / 10000d) {\n\t\t\t\t\t\tleafletMarker.setIcon(greenIcon);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// get ordered waypoints that belong to each side of the mapping\n\tpublic Vector<List<UIEdgePoint>> getOrderedWayPoints() {\n\t\tVector<List<UIEdgePoint>> wayPoints = new Vector<>();\n\t\twayPoints.add(0, new LinkedList<UIEdgePoint>());\n\t\twayPoints.add(1, new LinkedList<UIEdgePoint>());\n\t\tfor (LMarker p : getPins()) {\n\t\t\twayPoints.get(((UIEdgePoint)p.getData()).getSide()).add((UIEdgePoint)p.getData());\n\t\t}\n\t\twayPoints.get(0).sort(new Comparator<UIEdgePoint>() {\n\t        @Override\n\t        public int compare(UIEdgePoint w1, UIEdgePoint w2) {\n\t        \t\treturn  w1.getOrder() - w2.getOrder();\n\t        }\n\t    });\n\t\twayPoints.get(1).sort(new Comparator<UIEdgePoint>() {\n\t        @Override\n\t        public int compare(UIEdgePoint w1, UIEdgePoint w2) {\n\t        \t\treturn  w1.getOrder() - w2.getOrder();\n\t        }\n\t    }); \n\t\treturn wayPoints;\n\t}\n\t\n\t// Gets all of the pins that are on the map, excluding polygon pins\n\tpublic List<LMarker> getPins() {\n\t\tList<LMarker> pins = new ArrayList<>();\n\t\tIterator<Component> it = map.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tComponent c = it.next();\n\t\t\tif (c.getClass() == LMarker.class) {\n\t\t\t\tif (c.getHeight() != 2.0) // height of polygon pin\n\t\t\t\t\tpins.add((LMarker)c);\n\t\t\t}\n\t\t}\n\t\treturn pins;\n\t}\n\t\n\t// gets pin by its ID\n\tpublic LMarker getPinById(String id) {\n\t\tList<LMarker> pins = getPins();\n\t\tfor (LMarker pin : pins) {\n\t\t\tif (pin.getId().equals(id))\n\t\t\t\treturn pin;\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t// draw a polygon using the points that have been plotted on the map\n\tpublic void drawPolygon() {\n\t\t\n\t\t// convert each point to create an area to add\n\t\tareaToAdd= new PriorityArea(UUID.randomUUID().toString());\n\t\tfor (int i = 0; i < polygonVertices.size(); i++) {\n\t\t\tareaToAdd.addCoordinate(new LlaCoordinate(polygonVertices.get(i).getLat(), polygonVertices.get(i).getLon(), 0));\n\t\t}\n\t\t\n\t\t// if polygon already in list, remove it so that copies don't exist\n\t\tfor (int i = 0; i < allPriorityAreas.size(); i ++) {\n\t\t\tif (areaToAdd.getCoordinates().equals(allPriorityAreas.get(i).getCoordinates()))\n\t\t\t\tallPriorityAreas.remove(i);\n\t\t}\n\t\t\n\t\t// convert from list to array to create Polygon\n\t\tLPolygon newPolygon = new LPolygon();\n\t\tnewPolygon.setColor(\"#ff5050\");\n\t\tPoint pointArray[] = new Point[polygonVertices.size()];\n\t    pointArray = polygonVertices.toArray(pointArray);\n\t\tnewPolygon.setPoints(pointArray);\n\t\tmap.addComponent(newPolygon);\n\t\tAMPriorityAreaMouseOverListener mouseOverListener = new AMPriorityAreaMouseOverListener(mapComponent, areaToAdd.getId());\n\t\tnewPolygon.addMouseOverListener(mouseOverListener);\n\t\tnewPolygon.addMouseOutListener(new AMPriorityMouseOutListener(this)); // closes the window from the mouseOverListener\n\t\tnewPolygonPins.clear();\n\t\tnewPolygonLines.clear();\n\t}\n\t\n\t// uses the polygonVertices to finish and create a new priority area\n\tpublic void addPriorityArea(String type, String description, Integer importance) {\n\t\tareaToAdd.setType(type);\n\t\tareaToAdd.setDescription(description);\n\t\tareaToAdd.setImportance(importance);\n\t\tallPriorityAreas.add(areaToAdd);\n\t\tpolygonVertices.clear();\n\t}\n\t\n\t// iterate through map to find all polygons and polygon pins and delete them\n\tpublic void removeAllPriorityAreas() {\n\t\tList<LPolygon> polygons = new ArrayList<>();\n\t\tList<LMarker> pins = new ArrayList<>();\n\t\tList<LPolyline> lines = new ArrayList<>();\n\t\tIterator<Component> it = map.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tComponent c = it.next();\n\t\t\tif (c.getClass() == LPolygon.class) {\n\t\t\t\t\tpolygons.add((LPolygon)c);\n\t\t\t}\n\t\t\tif (c.getClass() == LMarker.class) {\n\t\t\t\tif (c.getHeight() == 2.0) // height of polygon pin\n\t\t\t\t\tpins.add((LMarker)c);\n\t\t\t}\n\t\t\tif (c.getClass() == LPolyline.class) {\n\t\t\t\tif (c.getHeight() == 2.0) // height of polygon line\n\t\t\t\t\tlines.add((LPolyline)c);\n\t\t\t}\n\t\t}\n\n\t\t// delete all polygons and pins\n\t\tfor (int i = polygons.size() - 1; i >= 0; i--) {\n\t\t\tmap.removeComponent(polygons.get(i));\n\t\t}\n\t\tfor (int i = pins.size() -1; i >= 0; i--) {\n\t\t\tmap.removeComponent(pins.get(i));\n\t\t}\n\t\tfor (int i = lines.size() -1; i >= 0; i--) {\n\t\t\tmap.removeComponent(lines.get(i));\n\t\t}\n\t\t\n\t\tpolygons.clear();\n\t\tpins.clear();\n\t\tallPriorityAreas.clear();\n\t\tpolygonVertices.clear();\n\t}\n\t\n\t// updates allPolygonPins based on the pins on the map\n\tpublic void setAllPolygonPins() {\n\t\tallPolygonPins.clear();\n\t\tIterator<Component> it = map.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tComponent c = it.next();\n\t\t\tif (c.getClass() == LMarker.class) {\n\t\t\t\tif (c.getHeight() == 2.0) // height of polygon pin\n\t\t\t\t\tallPolygonPins.add((LMarker)c);\n\t\t\t}\n\t\t}\n\t\tallPolygonPinsCopy.clear();\n\t\tfor (LMarker marker : allPolygonPins) {\n\t\t\tallPolygonPinsCopy.add(marker.getPoint());\n\t\t}\n\t}\n\t\n\t// draw the priorities using the mapping from dronology\n\tpublic void drawPriorities() {\n\t\t\n\t\t// if drawing a polygon, don't refresh all the others because this will interrupt the process\n\t\tif (this.getMapComponent().getMapUtilities().getPrioritiesAreEditable() || this.getMapComponent().getMapUtilities().getSidesAreEditable())\n\t\t\treturn;\n\n\t\tremoveAllPriorityAreas();\n\t\t\n\t\t// get area mapping from dronology\n\t\tIAreaMapping amapping = null;\n\t\tBaseServiceProvider provider = MyUI.getProvider();\n\t\tAreaMappingPersistenceProvider mappingPersistor = AreaMappingPersistenceProvider.getInstance();\n\t\ttry {\n\t\t\tIAreaMappingRemoteService service = (IAreaMappingRemoteService) provider.getRemoteManager().getService(IAreaMappingRemoteService.class);\n\t\t\tByteArrayInputStream inStream;\n\t\t\tString id = mapComponent.getMainLayout().getControls().getInfoPanel().getHighlightedAMInfoBox().getId();\n\t\t\tbyte[] information = service.requestFromServer(id);\n\t\t\tinStream = new ByteArrayInputStream(information);\n\t\t\tamapping = mappingPersistor.loadItem(inStream);\n\t\t} catch (DronologyServiceException | RemoteException e1) {\n\t\te1.printStackTrace();\n\t\tMyUI.setConnected(false);\n\t\t} catch (PersistenceException e1) {\n\t\te1.printStackTrace();\n\t\t}\n\t\t// get and add priority areas/sides from area mapping \n\t\tfor (int i = 0; i < amapping.getLocationMappings().size(); i++) {\n\t\t\tif (amapping.getLocationMappings().get(i).getClass() == PriorityArea.class) {\n\t\t\t\tfor (int j = 0; j < amapping.getLocationMappings().get(i).getCoordinates().size(); j++) {\n\t\t\t\t\taddPolygonVertex(new Point(amapping.getLocationMappings().get(i).getCoordinates().get(j).getLatitude(), amapping.getLocationMappings().get(i).getCoordinates().get(j).getLongitude()));\n\t\t\t\t}\n\t\t\t\tdrawPolygon();\t\n\t\t\t\taddPriorityArea(amapping.getLocationMappings().get(i).getType(), amapping.getLocationMappings().get(i).getDescription(), amapping.getLocationMappings().get(i).getImportance());\n\t\t\t}\n\t\t\telse { // priority side\n\n\t\t\t\tfor (int j = 0; j < amapping.getLocationMappings().get(i).getCoordinates().size() - 1; j++) {\n\t\t\t\t\t// find line that connects two coordinates\n\t\t\t\t\tfor (LPolyline line : this.getPolylines()) {\n\t\t\t\t\t\tdouble latPolylinePoint1 = (double)Math.round(line.getPoints()[0].getLat() * 1000000d) / 1000000d;\n\t\t\t\t\t\tdouble lonPolylinePoint1 = (double)Math.round(line.getPoints()[0].getLon() * 1000000d) / 1000000d;\n\t\t\t\t\t\tdouble latPolylinePoint2 = (double)Math.round(line.getPoints()[1].getLat() * 1000000d) / 1000000d;\n\t\t\t\t\t\tdouble lonPolylinePoint2 = (double)Math.round(line.getPoints()[1].getLon() * 1000000d) / 1000000d;\n\t\t\t\t\t\tdouble latPriorityPoint1 = (double)Math.round(amapping.getLocationMappings().get(i).getCoordinates().get(j).getLatitude() * 1000000d) / 1000000d;\n\t\t\t\t\t\tdouble lonPriorityPoint1 = (double)Math.round(amapping.getLocationMappings().get(i).getCoordinates().get(j).getLongitude() * 1000000d) / 1000000d;\n\t\t\t\t\t\tdouble latPriorityPoint2 = (double)Math.round(amapping.getLocationMappings().get(i).getCoordinates().get(j+1).getLatitude() * 1000000d) / 1000000d;\n\t\t\t\t\t\tdouble lonPriorityPoint2 = (double)Math.round(amapping.getLocationMappings().get(i).getCoordinates().get(j+1).getLongitude() * 1000000d) / 1000000d;\n\t\t\t\t\t\tif ((latPolylinePoint1 == latPriorityPoint1 && lonPolylinePoint1 == lonPriorityPoint1 && latPolylinePoint2 == latPriorityPoint2 && lonPolylinePoint2 == lonPriorityPoint2)\n\t\t\t\t\t\t\t|| (latPolylinePoint2 == latPriorityPoint1 && lonPolylinePoint2 == lonPriorityPoint1 && latPolylinePoint1 == latPriorityPoint2 && lonPolylinePoint1 == lonPriorityPoint2)) {\n\t\t\t\t\t\t\taddPriorityLine(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddPrioritySide(amapping.getLocationMappings().get(i).getId(), amapping.getLocationMappings().get(i).getType(), amapping.getLocationMappings().get(i).getDescription(), amapping.getLocationMappings().get(i).getImportance());\n\t\t\t}\n\t\t}\n\t\t\n\t\t// also, mark upstream so that the waterfall icon is correctly drawn\n\t\tif (amapping != null) {\n\t\t\tupstream = amapping.getUpstream();\n\t\t}\n\t}\n\t\n\t// switch out one of the areas in allPriorityAreas with one that was edited\n\tpublic void editPriorityArea(PriorityArea changedArea) {\n\t\tfor (int i = 0; i < allPriorityAreas.size(); i++) {\n\t\t\tif (allPriorityAreas.get(i).getId().equals(changedArea.getId())) {\n\t\t\t\tallPriorityAreas.set(i, changedArea);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// switch out one of the sides in allPrioritySides with one that was edited\n\tpublic void editPrioritySide(PrioritySide changedSide) {\n\t\tfor (int i = 0; i < allPrioritySides.size(); i++) {\n\t\t\tif (allPrioritySides.get(i).getId().equals(changedSide.getId())) {\n\t\t\t\tallPrioritySides.set(i, changedSide);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// adds a new priority line\n\tpublic void addPriorityLine(LPolyline lineToAdd) {\n\n\t\tBoolean foundInAllPriorityLines = false;\n\t\t\n\t\t// iterate through existing priority lines to make sure that it doesn't already exist\n\t\tfor (LPolyline polyline : allPriorityLines) \n\t\t\tif ((((double)Math.round(lineToAdd.getPoints()[0].getLat() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[0].getLat() * 1000000d) / 1000000d)\n\t\t\t&& ((double)Math.round(lineToAdd.getPoints()[0].getLon() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[0].getLon() * 1000000d) / 1000000d)\n\t\t\t&& ((double)Math.round(lineToAdd.getPoints()[1].getLat() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[1].getLat() * 1000000d) / 1000000d)\n\t\t\t&& ((double)Math.round(lineToAdd.getPoints()[1].getLon() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[1].getLon() * 1000000d) / 1000000d)) \n\t\t\t|| (((double)Math.round(lineToAdd.getPoints()[0].getLat() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[1].getLat() * 1000000d) / 1000000d)\n\t\t\t&& ((double)Math.round(lineToAdd.getPoints()[0].getLon() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[1].getLon() * 1000000d) / 1000000d)\n\t\t\t&& ((double)Math.round(lineToAdd.getPoints()[1].getLat() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[0].getLat() * 1000000d) / 1000000d)\n\t\t\t&& ((double)Math.round(lineToAdd.getPoints()[1].getLon() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[0].getLon() * 1000000d) / 1000000d))) {\n\t\t\t\tfoundInAllPriorityLines = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t// if not found, add the new line\n\t\tif (!foundInAllPriorityLines) {\n\t\t\tlineToAdd.setColor(\"#ff5050\");\n\t\t\tlineToAdd.setOpacity(0.7);\n\t\t\tnewPrioritySideLines.add(lineToAdd);\n\t\t\tallPriorityLines.add(lineToAdd);\n\t\t\tmap.addComponent(lineToAdd);\n\t\t\tlineToAdd.addMouseOverListener(new AMPrioritySideMouseOverListener(mapComponent, lineToAdd));\n\t\t\tlineToAdd.addMouseOutListener(new AMPriorityMouseOutListener(this));\n\t\t}\n\t\tpolylineClickListener.resetPolylineIsClickedInThisEvent();\n\t}\n\t\n\t// adds the current priority side to allPrioritySides\n\tpublic void addPrioritySide(String id, String type, String description, int importance) {\n\t\t// return if no newPrioritySideLines or if the side already exists in allPrioritySides\n\t\tif (newPrioritySideLines.size() == 0) {\n\t\t\treturn;\n\t\t}\n\t\tfor (PrioritySide side : allPrioritySides) {\n\t\t\tif (side.getId().equals(id)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tPrioritySide newPrioritySide = new PrioritySide(id);\n\t\tnewPrioritySide.setType(type);\n\t\tnewPrioritySide.setDescription(description);\n\t\tnewPrioritySide.setImportance(importance);\n\t\t// add all coords belonging the lines to the list of coords\n\t\tfor (LPolyline line : newPrioritySideLines) {\n\t\t\tfor (int i = 0; i <= 1; i++) {\n\t\t\t\tLlaCoordinate currCoord = new LlaCoordinate(line.getPoints()[i].getLat(), line.getPoints()[i].getLon(), 0);\n\t\t\t\tnewPrioritySide.addCoordinate(currCoord);\n\t\t\t}\n\t\t}\n\n\t\tallPrioritySides.add(newPrioritySide);\n\t\tnewPrioritySideLines.clear();\n\t}\n\t\n\t// used to add a full side when creating a sub-map\n\tpublic void addPrioritySide(PrioritySide side) {\n\t\tfor (int j = 0; j < side.getCoordinates().size() - 1; j++) {\n\t\t\t// find line that connects two coordinates\n\t\t\tfor (LPolyline line : this.getPolylines()) {\n\t\t\t\tdouble latPolylinePoint1 = (double)Math.round(line.getPoints()[0].getLat() * 1000000d) / 1000000d;\n\t\t\t\tdouble lonPolylinePoint1 = (double)Math.round(line.getPoints()[0].getLon() * 1000000d) / 1000000d;\n\t\t\t\tdouble latPolylinePoint2 = (double)Math.round(line.getPoints()[1].getLat() * 1000000d) / 1000000d;\n\t\t\t\tdouble lonPolylinePoint2 = (double)Math.round(line.getPoints()[1].getLon() * 1000000d) / 1000000d;\n\t\t\t\tdouble latPriorityPoint1 = (double)Math.round(side.getCoordinates().get(j).getLatitude() * 1000000d) / 1000000d;\n\t\t\t\tdouble lonPriorityPoint1 = (double)Math.round(side.getCoordinates().get(j).getLongitude() * 1000000d) / 1000000d;\n\t\t\t\tdouble latPriorityPoint2 = (double)Math.round(side.getCoordinates().get(j+1).getLatitude() * 1000000d) / 1000000d;\n\t\t\t\tdouble lonPriorityPoint2 = (double)Math.round(side.getCoordinates().get(j+1).getLongitude() * 1000000d) / 1000000d;\n\t\t\t\tif ((latPolylinePoint1 == latPriorityPoint1 && lonPolylinePoint1 == lonPriorityPoint1 && latPolylinePoint2 == latPriorityPoint2 && lonPolylinePoint2 == lonPriorityPoint2)\n\t\t\t\t\t|| (latPolylinePoint2 == latPriorityPoint1 && lonPolylinePoint2 == lonPriorityPoint1 && latPolylinePoint1 == latPriorityPoint2 && lonPolylinePoint1 == lonPriorityPoint2)) {\n\t\t\t\t\taddPriorityLine(line);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\taddPrioritySide(side.getId(), side.getType(), side.getDescription(), side.getImportance());\n\t}\n\t\n\t// Enables/disable sides editing.\n\tpublic void setSidesAreEditable (boolean isEditable) {\n\t\tsidesAreEditable = isEditable;\n\t}\n\n\t// Returns whether or not edit mode has been enabled.\n\tpublic boolean getSidesAreEditable() {\n\t\treturn sidesAreEditable;\n\t}\n\t\n\tpublic List<Point> getAllPolygonPins() {\n\t\treturn allPolygonPinsCopy;\n\t}\n\t\n\t// Enables/disable sides editing.\n\tpublic void setPrioritiesAreEditable (boolean isEditable) {\n\t\tprioritiesAreEditable = isEditable;\n\t}\n\t\n\t// Returns whether or not edit mode has been enabled.\n\tpublic boolean getPrioritiesAreEditable() {\n\t\treturn prioritiesAreEditable;\n\t}\n\t\n\t// Gets all of the side polylines that are on the map\n\tpublic List<LPolyline> getPolylines() {\n\t\treturn allPolylines;\n\t}\n\t\n\t// Returns the map.\n\tpublic LMap getMap() {\n\t\treturn map;\n\t}\n\t\n\t// Returns the mapComponent (use if the functions in AMMapComponent are needed).\n\tpublic AMMapComponent getMapComponent() {\n\t\treturn mapComponent;\n\t}\n\t\n\tpublic AMMapAddMarkerListener getMapAddMarkerListener() {\n\t\treturn mapAddMarkerListener;\n\t}\n\tpublic AMMarkerMouseOverListener getMarkerMouseOverListener() {\n\t\treturn markerMouseOverListener;\n\t}\n\tpublic AMPolylineClickListener getPolylineClickListener() {\n\t\treturn polylineClickListener;\n\t}\n\t\n\tpublic LinkedList<Point> getPolygonVertices() {\n\t\treturn polygonVertices;\n\t}\n\t\n\t// returns the two sides\n\tpublic Vector<List<UIEdgePoint>> getSides() {\n\t\treturn sides;\n\t}\n\t\n\t// returns the polyline that's moused over\n\tpublic LPolyline getMousedOverLine() {\n\t\treturn mousedOverLine;\n\t}\n\t\n\t// sets the priority area that's moused over\n\tpublic void setMousedOverArea(PriorityArea mousedOverArea) {\n\t\tthis.mousedOverArea = mousedOverArea;\n\t}\n\t\n\t// sets the priority side that's moused over\n\tpublic void setMousedOverSide(PrioritySide mousedOverSide) {\n\t\tthis.mousedOverSide = mousedOverSide;\n\t}\n\t\n\t// gets the priority area that's moused over\n\tpublic PriorityArea getMousedOverArea() {\n\t\treturn mousedOverArea;\n\t}\n\t\n\t// gets the priority side that's moused over\n\tpublic PrioritySide getMousedOverSide() {\n\t\treturn mousedOverSide;\n\t}\n\t\n\t// returns vector that contains a separate list of points for each polygon\n\tpublic Vector<PriorityArea> getAllPriorityAreas() {\n\t\treturn allPriorityAreas;\n\t}\n\t\n\tpublic void setAllPriorityAreas(Vector<PriorityArea> allPriorityAreas) {\n\t\tthis.allPriorityAreas = allPriorityAreas;\n\t}\n\t\n\tpublic void clearPolygonVertices() {\n\t\tpolygonVertices.clear();\n\t\tnewPolygonPins.clear();\n\t\tnewPolygonLines.clear();\n\t}\n\t\n\tpublic void setPriorityInfoWindow(AMPriorityInfoWindow priorityInfoWindow) {\n\t\tthis.priorityInfoWindow = priorityInfoWindow;\n\t}\n\tpublic AMPriorityInfoWindow getPriorityInfoWindow() {\n\t\treturn priorityInfoWindow;\n\t}\n\t\n\tpublic List<LMarker> getNewPolygonPins() {\n\t\treturn newPolygonPins;\n\t}\n\t\n\tpublic List<LPolyline> getNewPrioritySideLines() {\n\t\treturn newPrioritySideLines;\n\t}\n\t\n\tpublic List<PrioritySide> getAllPrioritySides() {\n\t\treturn allPrioritySides;\n\t}\n\t\n\tpublic List<LPolyline> getAllPriorityLines() {\n\t\treturn allPriorityLines;\n\t}\n\t\n\tpublic List<UIEdgePoint> getAllSideWaypoints() {\n\t\treturn new LinkedList<>(allSideWaypoints);\n\t}\n\t\n\tpublic Boolean getUpstream() {\n\t\treturn upstream;\n\t}\n\t\n\tpublic void setUpstream(Boolean upstream) {\n\t\tthis.upstream = upstream;\n\t}\n} "}, {"id": "IBaseServiceProvider.java", "body": "package edu.nd.dronology.services.core.api;\n\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic interface IBaseServiceProvider {\n\n\tvoid init(String serverHost, int serverPort);\n \n\tIRemoteManager getRemoteManager() throws DronologyServiceException;\n\n}\n"}, {"id": "CollisionAvoidanceCheckTask.java", "body": "package edu.nd.dronology.core.collisionavoidance;\n\nimport edu.nd.dronology.core.fleet.DroneFleetManager;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\nimport java.util.*;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\n\npublic class CollisionAvoidanceCheckTask extends TimerTask {\n    private static final ILogger LOGGER = LoggerProvider.getLogger(CollisionAvoidanceCheckTask.class);\n    private final CollisionAvoider avoiderStrategy;\n    private DroneCollector droneCollector;\n    private final HashMap<String, DroneSnapshot> tmp = new HashMap<>();\n\n    public CollisionAvoidanceCheckTask(CollisionAvoider avoiderStrategy) {\n        this.avoiderStrategy = avoiderStrategy;\n        this.droneCollector = new DroneCollector() {\n            @Override\n            public List<ManagedDrone> getManagedDrones() {\n                return DroneFleetManager.getInstance().getRegisteredDrones();\n//                return Collections.<ManagedDrone>emptyList();\n            }\n        };\n    }\n\n    @Override\n    public void run() {\n        LOGGER.debug(\"CA timer task started\");\n        List<ManagedDrone> allDrones = droneCollector.getManagedDrones().stream().filter(uav -> {\n            // return uav.getFlightModeState().isInAir() || uav.getFlightModeState().isFlying();\n            return uav.isStarted();\n        }).collect(Collectors.toList());\n        if (allDrones.size() < 1) {\n            return;\n        }\n        ArrayBlockingQueue<DroneSnapshotOption> returnQueue = new ArrayBlockingQueue<>(allDrones.size());\n        ArrayList<DroneSnapshot> input = new ArrayList<>();\n        tmp.clear();\n        for (ManagedDrone managedDrone : allDrones) {\n            managedDrone.getMessenger().getSnapshot(returnQueue);\n        }\n        for (ManagedDrone managedDrone: allDrones) {\n            try {\n                DroneSnapshotOption snapshotOption = returnQueue.take();\n                DroneSnapshot snapshot = snapshotOption.snapshot;\n                if (Objects.nonNull(snapshot)) {\n                    input.add(snapshot);\n                    tmp.put(snapshot.getName(), snapshot);\n                } else {\n                    LOGGER.debug(snapshotOption.droneName + \" didn't provide a snapshot.\");\n                }\n            } catch (Exception e) {\n                LOGGER.error(e);\n                return;\n            }\n        }\n\n        LOGGER.debug(\"Running avoid on \" + input.size() + \" drones\");\n        avoiderStrategy.avoid(input);\n\n        for (ManagedDrone managedDrone : allDrones) {\n            if (tmp.containsKey(managedDrone.getDroneName())) {\n                managedDrone.getMessenger().updateGuidance(tmp.get(managedDrone.getDroneName()).getCommands());\n            }\n        }\n    }\n\n}\n"}, {"id": "AbstractServerService.java", "body": "package edu.nd.dronology.services.core.base;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport edu.nd.dronology.services.core.api.IServiceInstance;\nimport edu.nd.dronology.services.core.api.ServiceInfo;\nimport edu.nd.dronology.services.core.listener.IServiceListener;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.util.NullUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic abstract class AbstractServerService<S extends IServiceInstance> {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(AbstractServerService.class);\n\n\tprotected S serviceInstance;\n\tprotected AtomicBoolean isStarted = new AtomicBoolean(false);\n\tprivate static List<AbstractServerService> services = new ArrayList<>();\n\tprivate static String customWorkspace;\n\n\n\n\tpublic AbstractServerService() {\n\t\tservices.add(this);\n\t\tserviceInstance = initServiceInstance();\n\t}\n\n\tpublic S getServer() {\n\t\treturn serviceInstance;\n\t}\n\n\tpublic void startService() throws DronologyServiceException {\n\t\tif (isStarted.compareAndSet(false, true)) {\n\t\t\t// LOGGER.info(\"Service '\" + this.getClass().getSimpleName() + \"' started\");\n\t\t\tserviceInstance.startService();\n\t\t\t// ServiceOrchestrator.registerService(this);\n\t\t}\n\t}\n\n\tpublic void stopService() throws DronologyServiceException {\n\t\tif (isStarted.compareAndSet(true, false)) {\n\t\t\t// LOGGER.info(\"Service '\" + this.getClass().getSimpleName() + \"' stopped\");\n\t\t\tserviceInstance.stopService();\n\t\t\t// ServiceOrchestrator.unregisterService(this);\n\t\t}\n\t}\n\n\tpublic void restartService() throws DronologyServiceException {\n\t\tLOGGER.info(\"Restarting \" + getClass().getSimpleName());\n\t\tif (!isStarted.get()) {\n\t\t\tstartService();\n\t\t} else {\n\t\t\tstopService();\n\t\t\ttry {\n\t\t\t\tThread.sleep(300);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t\tstartService();\n\t\t}\n\t}\n\n\tpublic boolean addServiceListener(IServiceListener processListener) {\n\t\treturn serviceInstance.addServiceListener(processListener);\n\n\t}\n\n\tpublic boolean removeServiceListener(IServiceListener processListener) {\n\t\treturn serviceInstance.remoteServiceListener(processListener);\n\t}\n\n\tpublic ServiceInfo getServerInfo() {\n\t\treturn serviceInstance.getServiceInfo();\n\t}\n\n\tpublic static void addUniversialServiceListener(IServiceListener processListener) {\n\t\tsynchronized (services) {\n\t\t\tfor (AbstractServerService service : services) {\n\t\t\t\tservice.serviceInstance.addServiceListener(processListener);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void setWorkspace(String customWorkspace) {\n\t\tNullUtil.checkNull(customWorkspace);\n\t\tAbstractServerService.customWorkspace = customWorkspace;\n\t}\n\t\n\n\tpublic static String getWorkspace() {\n\t\treturn customWorkspace;\n\t}\n\n\tpublic static void removeUniversialServiceListener(IServiceListener processListener) {\n\t\tsynchronized (services) {\n\t\t\tfor (AbstractServerService service : services) {\n\t\t\t\tservice.serviceInstance.addServiceListener(processListener);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected abstract S initServiceInstance();\n\n\tpublic static List<ServiceInfo> getServiceInfos() throws DronologyServiceException {\n\t\tList<ServiceInfo> sInfos = new ArrayList<>();\n\t\tsynchronized (services) {\n\t\t\tfor (AbstractServerService service : services) {\n\t\t\t\tServiceInfo sInfo = service.getServerInfo();\n\t\t\t\tif (sInfo == null) {\n\t\t\t\t\tthrow new DronologyServiceException(\"Error retrieving service information from '\"\n\t\t\t\t\t\t\t+ service.getClass().getSimpleName() + \"'\");\n\t\t\t\t}\n\t\t\t\tsInfos.add(sInfo);\n\t\t\t}\n\t\t}\n\t\treturn Collections.unmodifiableList(sInfos);\n\t}\n\n\tpublic static List<ServiceInfo> getFileServiceInfos() throws DronologyServiceException {\n\t\tList<ServiceInfo> sInfos = new ArrayList<>();\n\t\tsynchronized (services) {\n\t\t\tfor (AbstractServerService service : services) {\n\t\t\t\tServiceInfo sInfo = service.getServerInfo();\n\t\t\t\tif (sInfo == null) {\n\t\t\t\t\tthrow new DronologyServiceException(\"Error retrieving service information from '\"\n\t\t\t\t\t\t\t+ service.getClass().getSimpleName() + \"'\");\n\t\t\t\t}\n\t\t\t\tif (service instanceof AbstractFileTransmitServerService<?, ?>) {\n\t\t\t\t\tsInfos.add(sInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Collections.unmodifiableList(sInfos);\n\t}\n\n\tpublic static void stopAll() {\n\t\tfor (AbstractServerService service : services) {\n\t\t\ttry {\n\t\t\t\tservice.stopService();\n\t\t\t} catch (DronologyServiceException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void restartAll() {\n\t\tfor (AbstractServerService service : services) {\n\t\t\ttry {\n\t\t\t\tservice.restartService();\n\t\t\t} catch (DronologyServiceException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected AbstractServerService getService(String serviceClass) throws DronologyServiceException {\n\t\tfor (AbstractServerService service : services) {\n\t\t\tif (service.getClass().getCanonicalName().equals(serviceClass)) {\n\t\t\t\treturn service;\n\t\t\t}\n\t\t}\n\t\tthrow new DronologyServiceException(\"Service '\" + serviceClass + \"' not found!\");\n\t}\n\n\tpublic static List<ServiceInfo> getCoreServices() throws DronologyServiceException {\n\t\tList<ServiceInfo> sInfos = new ArrayList<>();\n\t\tsynchronized (services) {\n\t\t\tfor (AbstractServerService service : services) {\n\t\t\t\tServiceInfo sInfo = service.getServerInfo();\n\t\t\t\tif (sInfo == null) {\n\t\t\t\t\tthrow new DronologyServiceException(\"Error retrieving service information from '\"\n\t\t\t\t\t\t\t+ service.getClass().getSimpleName() + \"'\");\n\t\t\t\t}\n\t\t\t\tif (!(service instanceof AbstractFileTransmitServerService<?, ?>)) {\n\t\t\t\t\tsInfos.add(sInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Collections.unmodifiableList(sInfos);\n\t}\n\n\n\n}\n"}, {"id": "MissionPlanningService.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.service.internal;\n\nimport edu.nd.dronology.services.core.base.AbstractFileTransmitServerService;\nimport edu.nd.dronology.services.core.info.MissionInfo;\nimport edu.nd.dronology.services.core.info.UAVMappingInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n/**\n * \n * Services for planning and executing missions for multiple UAVs .<br>\n * Initial implementation of mission planning capabilities. <br>\n * Allows retrieving sending a mission plan as JSON String to Dronology.\n * \n * \n * @author Michael Vierhauser\n *\n */\npublic class MissionPlanningService\n\t\textends AbstractFileTransmitServerService<IMissionPlanningServiceInstance, MissionInfo> {\n\n\tprivate static volatile MissionPlanningService INSTANCE;\n\n\tprotected MissionPlanningService() {\n\t}\n\n\t/**\n\t * @return The singleton ConfigurationService instance\n\t */\n\tpublic static MissionPlanningService getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (MissionPlanningService.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new MissionPlanningService();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tprotected IMissionPlanningServiceInstance initServiceInstance() {\n\t\treturn new MissionPlanningServiceInstance();\n\t}\n\n\tpublic void executeMissionPlan(String mission) throws DronologyServiceException {\n\t\tserviceInstance.executeMissionPlan(mission);\n\n\t}\n\n\tpublic void cancelMission() throws DronologyServiceException {\n\t\tserviceInstance.cancelMission();\n\n\t}\n\n\tpublic void removeUAV(String uavid) throws DronologyServiceException {\n\t\tserviceInstance.removeUAV(uavid);\n\n\t}\n\n\tpublic void executeMissionPlan(MissionInfo mission) throws DronologyServiceException {\n\t\tserviceInstance.executeMissionPlan(mission);\n\n\t}\n\n\tpublic void executeMissionPlan(MissionInfo mission, UAVMappingInfo mapping) throws DronologyServiceException {\n\t\tserviceInstance.executeMissionPlan(mission, mapping);\n\n\t}\n\n}\n"}, {"id": "IFlightSimulator.java", "body": "package edu.nd.dronology.core.simulator;\n\nimport edu.nd.dronology.core.vehicle.internal.VirtualDrone;\n\n/**\n * \n * Interface for the internal simulator used with {@link VirtualDrone}.<br>\n * The simulator consists of a {@link IBatterySimulator} and a {@link IMovementSimulator} approximating the behavior of a UAV.\n * \n * @author Michael Vierhauser\n *\n */\npublic interface IFlightSimulator extends IBatterySimulator, IMovementSimulator {\n\n}\n"}, {"id": "StopEveryone.java", "body": "package edu.nd.dronology.core.collisionavoidance.strategy;\n\nimport edu.nd.dronology.core.collisionavoidance.CollisionAvoider;\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand;\nimport edu.nd.dronology.core.goal.AbstractGoal;\nimport edu.nd.dronology.core.goal.IGoalSnapshot;\nimport edu.nd.dronology.core.goal.WaypointGoalSnapshot;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * The StopEveryone CollisionAvoider is a failsafe that only triggers if it detects two drones are intruding into each\n * others space because something has gone wrong. Use this with mission plans that carefully navigate the drones to\n * avoid crashing into one another. StopEveryone assumes the drones will follow a mission plan that takes into account\n * where all the drones will be in space and time. When the StopEveryone CollisionAvoider is triggered the mission is\n * aborted, and humans need to land the drones manually.\n */\npublic class StopEveryone implements CollisionAvoider {\n    private static final ILogger LOGGER = LoggerProvider.getLogger(StopEveryone.class);\n    private final double threshold;\n\n    /**\n     * Initializes a newly created StopEveryone object that triggers all drones to stop whatever they're doing and hover\n     * in place, if any two drones move closer than the threshold distance to one another.\n     *\n     * @param threshold distance in meters. If any two drones move close enough to be within the threshold distance,\n     *                  then StopEveryone will command all drones to stop whatever they're doing and hover in place.\n     */\n    public  StopEveryone(double threshold) {\n        this.threshold = threshold;\n    }\n\n    @Override\n    public void avoid(ArrayList<DroneSnapshot> drones) {\n        ArrayList<DroneSnapshot> flyingDrones = findFlyingDrones(drones);\n        if (isSafe(flyingDrones)) {\n            // fly to the goal\n            for (DroneSnapshot drone : flyingDrones) {\n                WaypointGoalSnapshot waypointGoal = findActiveWaypointGoal(drone.getGoals());\n                if (waypointGoal != null) {\n                    LOGGER.debug(drone.getName() + \" had a waypoint goal: \" + waypointGoal.getPosition().toLlaCoordinate());\n                    flyToGoalIfNotAlready(drone, waypointGoal);\n                } else {\n                    LOGGER.debug(drone.getName() + \" had no waypoint goal\");\n                }\n            }\n        }\n        else {\n            // stop everyone\n            for (DroneSnapshot drone : flyingDrones) {\n                LOGGER.fatal(\"WARNING ALL DRONES STOPPED\");\n                onStopTrigger(drone);\n            }\n        }\n    }\n\n    protected void onStopTrigger(DroneSnapshot drone) {\n        stopDroneIfNotStopped(drone);\n    }\n\n    /**\n     * @param flyingDrones the drones that are flying (not all drones)\n     * @return true if every drone is at least threshold distance apart\n     */\n    private boolean isSafe(ArrayList<DroneSnapshot> flyingDrones) {\n        for (int i = 0; i < flyingDrones.size() - 1; ++i) {\n            for (int j = i + 1; j < flyingDrones.size(); ++j) {\n                if (isTooClose(flyingDrones.get(i), flyingDrones.get(j))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n\n    /**\n     * Check if two drones are too close\n     * @param a the first drone\n     * @param b the second drone\n     * @return true if the distance between the drones is less than the threshold distance\n     */\n    private boolean isTooClose(DroneSnapshot a, DroneSnapshot b) {\n        double distance = a.getPosition().distance(b.getPosition());\n        boolean result = distance < this.threshold;\n        if (result) {\n            LOGGER.warn(\"DRONES TOO CLOSE \" + a.getName() + \", \" + b.getName() + \" distance: \" + distance);\n        }\n        return result;\n    }\n\n    /**\n     * given the drone snapshots, filter out the drones that are not flying\n     * @param drones all the drone snapshots\n     * @return a list with all the flying drones\n     */\n    public static ArrayList<DroneSnapshot> findFlyingDrones(ArrayList<DroneSnapshot> drones) {\n        return drones.stream()\n                .filter(drone -> \"FLYING\".equals(drone.getState()))\n                .collect(Collectors.toCollection(ArrayList::new));\n    }\n\n    // if no active waypoint goal exists return null, otherwise return the first one it finds. Note if more than one\n    // active waypoint goal exists in the set of active goals, the active goal that is returned is up to the set's\n    // iterator\n    public static WaypointGoalSnapshot findActiveWaypointGoal(Set<IGoalSnapshot> goals) {\n        for (IGoalSnapshot goal: goals) {\n            if (goal instanceof WaypointGoalSnapshot && goal.getState() == AbstractGoal.GoalState.ACTIVE) {\n                return (WaypointGoalSnapshot) goal;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Make sure the drone's command queue has a stop command, overwriting the current command queue if needed.\n     * @param drone to stop\n     */\n    public static void stopDroneIfNotStopped(DroneSnapshot drone) {\n        // we don't need to do anything if the first command in the command queue is a stop command\n        if (!drone.getCommands().isEmpty()) {\n            if (drone.getCommands().get(0) instanceof StopCommand) {\n                return;\n            }\n        }\n        drone.getCommands().clear();\n        drone.getCommands().add(new StopCommand(-1.0));\n    }\n\n    /*\n    if this method is called, we want the drone to fly to the current goal, so we will wipe out command queue and put a\n    waypoint command in there unless the drone is already doing the right thing.\n     */\n    public static void flyToGoalIfNotAlready(DroneSnapshot drone, WaypointGoalSnapshot goal) {\n        // check if we are doing the right thing: that we have one cmd in the command queue and that cmd matches the\n        // current waypoint goal\n        if (drone.getCommands().size() == 1) {\n            if (drone.getCommands().get(0) instanceof WaypointCommand) {\n                WaypointCommand wp = (WaypointCommand) drone.getCommands().get(0);\n                boolean sameDest = wp.getDestination().toLlaCoordinate().equals(goal.getPosition().toLlaCoordinate());\n                boolean sameSpeed = wp.getSpeed() == goal.getSpeed();\n                if (sameDest && sameSpeed) {\n                    return;\n                }\n            }\n        }\n        // we have now filtered out the case where we don't have to do anything. If this code runs, we need to replace\n        // what's in the command queue\n        drone.getCommands().clear();\n        WaypointCommand cmd = new WaypointCommand(goal.getPosition().toLlaCoordinate(), goal.getSpeed());\n        drone.getCommands().add(cmd);\n    }\n}\n"}, {"id": "UAVTypeRegistrationPersistenceProvider.java", "body": "package edu.nd.dronology.services.core.persistence;\n\nimport edu.nd.dronology.services.core.items.IUAVRegistration;\nimport edu.nd.dronology.services.core.items.IUAVTypeRegistration;\nimport edu.nd.dronology.services.core.persistence.internal.UAVTypeRegistrationXStreamPersistor;\n\n\n/**\n * Provider implementation for {@link IUAVRegistration}.<br>\n * Details see {@link AbstractItemPersistenceProvider}\n * \n * @author Michael Vierhauser\n * \n */\npublic class UAVTypeRegistrationPersistenceProvider extends AbstractItemPersistenceProvider<IUAVTypeRegistration> {\n\n\tpublic UAVTypeRegistrationPersistenceProvider() {\n\t\tsuper();\n\t}\n\n\t@Override\n\tprotected void initPersistor() {\n\t\tPERSISTOR = new UAVTypeRegistrationXStreamPersistor();\n\n\t}\n\n\t@Override\n\tprotected void initPersistor(String type) {\n\t\tinitPersistor();\n\t}\n\n\tpublic static UAVTypeRegistrationPersistenceProvider getInstance() {\n\t\treturn new UAVTypeRegistrationPersistenceProvider();\n\t}\n\n}\n"}, {"id": "RemoteManagerFactory.java", "body": "package edu.nd.dronology.services.remote.rmi;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport edu.nd.dronology.services.core.remote.IRemoteManager;\n\npublic class RemoteManagerFactory {\n\n\n\n\tpublic static List<IRemoteManager> createRMIObjects(Integer port) {\n\t\tList<IRemoteManager> manager = new ArrayList<>();\n\t\tmanager.add(RemoteRMIRemoteObject.getInstance(port));\n\t\treturn manager;\n\t\t\n\t}\n\n\n\n}\n"}, {"id": "AreaMappingGenerator.java", "body": "package edu.nd.dronology.services.extensions.areamapping;\n\nimport java.util.Collection;\nimport java.util.List;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.areamapping.ExportAllocationInformation;\nimport edu.nd.dronology.services.core.areamapping.ExportDrone;\nimport edu.nd.dronology.services.core.areamapping.GeneratedMappedArea;\nimport edu.nd.dronology.services.core.items.IAreaMapping;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.extensions.areamapping.creation.MapRiver;\nimport edu.nd.dronology.services.extensions.areamapping.selection.GeneratedRoutesInfo;\nimport edu.nd.dronology.services.extensions.areamapping.selection.IRouteSelectionStrategy;\nimport edu.nd.dronology.services.extensions.areamapping.selection.RouteSelectionResult;\nimport edu.nd.dronology.services.extensions.areamapping.selection.StrategyFactory;\nimport edu.nd.dronology.services.extensions.areamapping.util.SelectionWriter;\n\npublic class AreaMappingGenerator {\n\n\tprivate IAreaMapping mapping;\n\tprivate Collection<IUAVProxy> selectedUAVs;\n\tprivate MapRiver riverMapper;\n\n\tpublic AreaMappingGenerator(IAreaMapping mapping, Collection<IUAVProxy> selectedUAVs) {\n\t\tthis.mapping = mapping;\n\t\tthis.selectedUAVs = selectedUAVs;\n\n\t}\n\n\tpublic GeneratedMappedArea generateMapping() throws DronologyServiceException {\n\n\t\ttry {\n\n\t\t\triverMapper = new MapRiver(mapping);\n\n\t\t\tIRouteSelectionStrategy selector = StrategyFactory.getSelectionStrategy();\n\n\t\t\tlong startGenerate = System.currentTimeMillis();\n\t\t\tGeneratedRoutesInfo gInfo = new GeneratedRoutesInfo(riverMapper.generateRoutePrimitives(),\n\t\t\t\t\triverMapper.getAverageLatitude(), riverMapper.getTotalRiverSegment(), riverMapper.getBankList());\n\t\t\tlong endGenerate = System.currentTimeMillis();\n\n\t\t\tselector.initialize(gInfo, selectedUAVs, mapping);\n\n\t\t\tlong startSelect = System.currentTimeMillis();\n\t\t\tRouteSelectionResult result = selector.generateAssignments();\n\t\t\tlong endSelect = System.currentTimeMillis();\n\n\t\t\tSystem.out.println(\"ROUTE Generation: \" + (endGenerate - startGenerate) / 1000);\n\t\t\tSystem.out.println(\"ROUTE Selection: \" + (endSelect - startSelect) / 1000);\n\t\t\tSystem.out.println(\"Specs: \");\n\t\t\tExportAllocationInformation flight = result.getEportAllocationInformation().get(0);\n\t\t\tSystem.out.println(\"Mission Score: \" + flight.getMetricStatistics().getAllocationScore());\n\t\t\tSystem.out.println(\"Coverage: \" + flight.getMetricStatistics().getAllocationCoverage());\n\t\t\tSystem.out.println(\"Equality of Tasks: \" + flight.getMetricStatistics().getEqualityOfTasks());\n\t\t\tSystem.out.println(\"Collisions: \" + flight.getMetricStatistics().getCollisions());\n\n\t\t\tList<ExportDrone> allocations = result.getEportAllocationInformation().get(0).getDroneAllocations();\n\n\t\t\tGeneratedMappedArea area = new GeneratedMappedArea();\n\n\t\t\tallocations.forEach(ed -> {\n\t\t\t\tarea.addUAVRouteAssignment(ed);\n\t\t\t});\n\n\t\t\tnew SelectionWriter().writeRouteSelection(result);\n\n\t\t\treturn area;\n\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t\tthrow new DronologyServiceException(t.getMessage());\n\t\t}\n\t}\n}\n"}, {"id": "IRemoteMonitoringMessageHandler.java", "body": "package edu.nd.dronology.monitoring;\n\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\n\nimport edu.nd.dronology.core.monitoring.IMonitorableMessage;\n \npublic interface IRemoteMonitoringMessageHandler extends Remote {\n\n\tvoid notifyMonitoringMessage(IMonitorableMessage message) throws RemoteException;\n\n}\n"}, {"id": "NvecInterpolator.java", "body": "package edu.nd.dronology.core.simulator.nvecsimulator;\n\nimport edu.nd.dronology.core.coordinate.NVector;\n\n/**\n * \n * @author Michael Murphy\n *\n */\npublic class NvecInterpolator {\n\tpublic static final double TOLERANCE = 0.001; // 1 Millimeter\n\n\tprivate static NVector mid(NVector a, NVector b) {\n\t\tdouble x = average(a.getX(), b.getX());\n\t\tdouble y = average(a.getY(), b.getY());\n\t\tdouble z = average(a.getZ(), b.getZ());\n\t\tdouble alt = average(a.getAltitude(), b.getAltitude());\n\t\treturn new NVector(x, y, z, alt);\n\t}\n \n\tprivate static double average(double a, double b) {\n\t\treturn (a + b) / 2.0;\n\t}\n\n\t/**\n\t * Uses the bisection method to iteratively hone in on the nvector that is\n\t * metersToTravel distance away from the current n-vector along the path\n\t * that goes from current to target. A path can be thought of as the set of\n\t * NVectors you can create by interpolating between current and target. This\n\t * code takes advantage of this to find the NVector on this path that is the\n\t * right distance away from the current distance.\n\t * \n\t * @param current\n\t *            drone current position\n\t * @param target\n\t *            drone target position\n\t * @param metersToTravel\n\t *            the distance the drone should travel along the path from\n\t *            current to target\n\t * @return the nvector taht is meters distance away from current along the\n\t *         path that goes from current to target\n\t */\n\tpublic static NVector move(NVector current, NVector target, double metersToTravel) {\n\t\t// a negative value for metersToTravel causes an infinite loop\n\t\tif (metersToTravel < 0.0) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t\tif (current.distance(target) < metersToTravel) {\n\t\t\treturn target;\n\t\t}\n\t\tNVector lowBall = current;\n\t\tNVector highBall = target;\n\t\tNVector nextGuess = mid(lowBall, highBall);\n\t\tdouble guessDistance = current.distance(nextGuess);\n\t\twhile (Math.abs(guessDistance - metersToTravel) > TOLERANCE) {\n\t\t\tif (guessDistance > metersToTravel) {\n\t\t\t\thighBall = nextGuess;\n\t\t\t} else {\n\t\t\t\tlowBall = nextGuess;\n\t\t\t}\n\t\t\tnextGuess = mid(lowBall, highBall);\n\t\t\tguessDistance = current.distance(nextGuess);\n\t\t}\n\t\treturn nextGuess;\n\t}\n\n}\n"}, {"id": "IDroneStatusChangeListener.java", "body": "package edu.nd.dronology.services.core.listener;\n\nimport java.rmi.RemoteException;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.api.IRemotable;\n\npublic interface IDroneStatusChangeListener extends IRemotable{\n\n\tvoid droneStatusChanged(IUAVProxy status) throws RemoteException;\n\t\n}\n"}, {"id": "UnitState.java", "body": "package edu.nd.dronology.services.core.util;\n\n/**\n * Enum that reflects the current state of a Probe.\n * \n * @author Michael Vierhauser\n * \n */\npublic enum UnitState {\n\n\t/**\n\t * The unit is running and able to send data.\n\t */\n\tRUNNING,\n\n\t/**\n\t * The unit is paused and no data is sent to the server.\n\t */\n\tPAUSED,\n\t/**\n\t * The unit has been terminated. No further data will be processed until restarted.\n\t */\n\tTERMINATED,\n\n\t/**\n\t * Current status is unknown.\n\t */\n\tUNKNOWN,\n\n\t/**\n\t * The unit is registered at the server.\n\t */\n\tREGISTERED,\n\n\t/**\n\t * The unit has been unregistered from the server.\n\t */\n\tUNREGISTERED, \n\t\n\t\n\tERROR\n\n}\n"}, {"id": "RemoteMessageHandler.java", "body": "package edu.nd.dronology.monitoring.simplechecker.monitor;\n\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\n\nimport edu.nd.dronology.core.monitoring.IMonitorableMessage;\nimport edu.nd.dronology.monitoring.IRemoteMonitoringMessageHandler;\n\npublic class RemoteMessageHandler extends UnicastRemoteObject implements IRemoteMonitoringMessageHandler {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -5811464159361618772L;\n\tprivate transient MonitorDialog display;\n\n\n\n\tpublic RemoteMessageHandler(MonitorDialog display) throws RemoteException {\n\t\tsuper();\n\t\tthis.display =display;\n\t}\n\n\n\n\t@Override\n\tpublic void notifyMonitoringMessage(IMonitorableMessage message) throws RemoteException {\n\n\t\tdisplay.addLine(message.toString());\n\t\t\n\t\t\n\t}\n\n\n}\n"}, {"id": "AbstractFileTransmitServiceInstance.java", "body": "package edu.nd.dronology.services.core.base;\n\nimport java.io.File;\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nimport edu.nd.dronology.services.core.api.IFileChangeNotifyable;\nimport edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.info.RemoteInfoObject;\nimport edu.nd.dronology.services.core.listener.IItemChangeListener;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.core.util.FileManager;\nimport edu.nd.dronology.util.FileUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Abstract base class for all services that allow transferring files as a byte\n * array\n * \n * @author Michael Vierhauser\n *\n * \n */\npublic abstract class AbstractFileTransmitServiceInstance<ITEM_TYPE extends RemoteInfoObject>\n\t\textends AbstractServiceInstance implements IFileTransmitServiceInstance<ITEM_TYPE>, IFileChangeNotifyable {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(AbstractFileTransmitServiceInstance.class);\n\n\tprotected String extension;\n\tprotected FileManager fileManager;\n\tprotected List<IItemChangeListener> listeners = new ArrayList<>();\n\tprotected Map<String, ITEM_TYPE> itemmap = new Hashtable<>();\n\tprotected String storagePath;\n\n\tpublic AbstractFileTransmitServiceInstance(String ID, String description, String extension) {\n\t\tsuper(ID, description);\n\t\tthis.extension = extension;\n\t\tstoragePath = getPath();\n\t\tfileManager = new FileManager(this, storagePath, extension);\n\t}\n\n\t@Override\n\tpublic Collection<ITEM_TYPE> getItems() {\n\t\tList<ITEM_TYPE> charts;\n\t\tsynchronized (itemmap) {\n\t\t\tcharts = new ArrayList<>(itemmap.values());\n\t\t}\n\t\treturn Collections.unmodifiableList(charts);\n\t}\n\n\t@Override\n\tpublic ITEM_TYPE getItem(String id) throws DronologyServiceException {\n\t\tsynchronized (itemmap) {\n\t\t\tif (itemmap.containsKey(id)) {\n\t\t\t\treturn itemmap.get(id);\n\t\t\t}\n\t\t}\n\t\tthrow new DronologyServiceException(\"Item '\" + id + \"' not found\");\n\t}\n\n\t@Override\n\tpublic byte[] requestFromServer(String id) throws DronologyServiceException {\n\t\treturn fileManager.getFileAsByteArray(id);\n\t}\n\n\t@Override\n\tpublic void transmitToServer(String id, byte[] content) throws DronologyServiceException {\n\t\tfileManager.saveByteArrayToFile(id, content);\n\t}\n\n\t@Override\n\tpublic void notifyFileChange(Set<String> changed) {\n\t\treloadItems();\n\t\tSet<String> info = new TreeSet<>();\n\t\tfor (String s : changed) {\n\t\t\tString id = s.replace(\".\" + extension, \"\");\n\t\t\tif (itemmap.containsKey(id)) {\n\t\t\t\tinfo.add(\"ADDED/UPDATED: \" + itemmap.get(id).getName() + \"[\" + id + \"]\");\n\t\t\t} else {\n\t\t\t\tinfo.add(\"REMOVED: [\" + id + \"]\");\n\t\t\t}\n\t\t}\n\n\t\tList<IItemChangeListener> notifyList;\n\t\tsynchronized (listeners) {\n\t\t\tnotifyList = new ArrayList<>(listeners);\n\t\t}\n\t\tfor (IItemChangeListener listener : notifyList) {\n\t\t\ttry {\n\t\t\t\tlistener.itemChanged(info);\n\t\t\t} catch (RemoteException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t\tlisteners.remove(listener);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprotected void reloadItems() {\n\t\ttry {\n\t\t\titemmap.clear();\n\t\t\tFile[] files = fileManager.loadFiles();\n\t\t\tfor (File file : files) {\n\t\t\t\tString id = file.getName().replace(\".\" + extension, \"\");\n\t\t\t\tITEM_TYPE item = null;\n\t\t\t\ttry {\n\t\t\t\t\titem = fromFile(id, file);\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\tLOGGER.error(\"Error loading file with id:\" + id + \"file: \" + file.getAbsolutePath(), e);\n\t\t\t\t}\n\t\t\t\tif (item != null) {\n\t\t\t\t\titemmap.put(id, item);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void deleteItem(String itemid) throws DronologyServiceException {\n\t\tString savelocation = FileUtil.concat(storagePath, itemid, extension);\n\t\tFile f = new File(savelocation);\n\t\tif (f.exists()) {\n\t\t\tboolean success = f.delete();\n\t\t\tLOGGER.info((success ? \"Done\" : \"Failed\") + \" deleting Item: \" + savelocation);\n\t\t\treloadItems();\n\t\t} else {\n\t\t\tthrow new DronologyServiceException(\"Item '\" + itemid + \"' does not exist on server\");\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic boolean addItemChangeListener(IItemChangeListener listener) {\n\t\tsynchronized (listeners) {\n\t\t\tif (!listeners.contains(listener)) {\n\t\t\t\tLOGGER.info(\"Adding new Item Change Listener\");\n\t\t\t\treturn listeners.add(listener);\n\t\t\t}\n\t\t\tLOGGER.info(\"Listener instance already registered\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean removeItemChangeListener(IItemChangeListener listener) {\n\t\tboolean success;\n\t\tsynchronized (listener) {\n\t\t\tsuccess = listeners.remove(listener);\n\t\t}\n\t\tif (success) {\n\t\t\tLOGGER.info(\"Removed Item Change Listener\");\n\t\t} else {\n\t\t\tLOGGER.info(\"Failed removing Item Change Listener\");\n\t\t}\n\t\treturn success;\n\t}\n\n\tprotected abstract String getPath();\n\n\tprotected abstract ITEM_TYPE fromFile(String id, File file) throws Throwable;\n\n}\n"}, {"id": "NedExecutor.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal;\n\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.NedCommand;\nimport edu.nd.dronology.core.vehicle.IDrone;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\n\npublic class NedExecutor implements CommandExecutor {\n\n    enum NedExecutionState {\n        RADIOING,\n        WATCHING_THE_CLOCK,\n        FINISHED;\n    }\n\n    private IDrone drone;\n    NedExecutionState state = NedExecutionState.RADIOING;\n    NedCommand data;\n    long startTime;\n\n    public NedExecutor(IDrone drone, NedCommand data) {\n        this.drone = drone;\n        this.data = data;\n    }\n\n    @Override\n    public void process() {\n        switch (state) {\n            case RADIOING:\n                radioDrone();\n                break;\n            case WATCHING_THE_CLOCK:\n                checkClock();\n                break;\n            case FINISHED:\n            default:\n                // Do nothing.\n                break;\n        }\n    }\n\n    @Override\n    public boolean isFinished() {\n        return state == NedExecutionState.FINISHED;\n    }\n\n    private void radioDrone() {\n        drone.setVelocity(data.getNorth(), data.getEast(), data.getDown());\n        startTime = System.nanoTime();\n        state = NedExecutionState.WATCHING_THE_CLOCK;\n    }\n\n    private void checkClock() {\n        double waitDuration = data.getTime();\n        long deltaNano = System.nanoTime()- startTime;\n        double deltaT = deltaNano * 1.0e-9;\n        if (deltaT > waitDuration) {\n            state = NedExecutionState.FINISHED;\n        }\n    }\n}\n"}, {"id": "PatternFactory.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.patterns;\n\n/**\n * Factory class for predefined {@link IFlightPattern}.\n * \n * @author Michael Vierhauser\n *\n */\npublic class PatternFactory {\n\n\tpublic enum PatternType {\n\t\tCOORDINATED_TAKEOFF, COORDINATED_LANDING\n\t}\n\n\t/**\n\t * \n\t * @param type\n\t *          The {@link PatternType} of the flight pattern to create.\n\t * @return A flight pattern for the given pattern type.\n\t * @throws An\n\t * @{@link IllegalArgumentException} in case the pattern is not supported.\n\t */\n\tpublic static IFlightPattern getPattern(PatternType type) {\n\t\tswitch (type) {\n\t\t\tcase COORDINATED_TAKEOFF:\n\t\t\t\treturn new CoordinatedTakeoffPattern();\n\n\t\t\tcase COORDINATED_LANDING:\n\t\t\t\treturn new CoordinatedLandingPattern();\n\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"Type \" + type + \" not supported\");\n\t\t}\n\t}\n\n}\n"}, {"id": "DroneInitializationInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.util.NullUtil;\n\npublic class DroneInitializationInfo extends RemoteInfoObject {\n\n\t\n\tpublic enum DroneMode {\n\t\tMODE_VIRTUAL, MODE_PHYSICAL; \n\n\t}\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 3002533064742692033L;\n\tprivate String type;\n\tprivate LlaCoordinate initialLocation;\n\tprivate DroneMode mode;\n\tprivate String safetyInformation;\n\n\n\n\tpublic DroneInitializationInfo(String id, DroneMode mode, String type, LlaCoordinate initialLocation) {\n\t\tsuper(id, id);\n\t\tNullUtil.checkNull(type, initialLocation,mode);\n\t\tthis.type = type;\n\t\tthis.mode= mode;\n\t\tthis.initialLocation = initialLocation;\n\n\t}\n\n\tpublic DroneMode getMode() {\n\t\treturn mode;\n\t}\n\n\tpublic String getType() {\n\t\treturn type;\n\t}\n\n\tpublic LlaCoordinate getInitialLocation() {\n\t\treturn initialLocation;\n\t}\n\t\n\tpublic String getSafetyInformation() {\n\t\treturn safetyInformation;\n\t}\n\n\tpublic void setSafetyInformation(String safetyInformation) {\n\t\tthis.safetyInformation = safetyInformation;\n\t}\n\n}\n"}, {"id": "AFMainLayout.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport java.util.List;\n\nimport com.vaadin.ui.CssLayout;\nimport com.vaadin.ui.CustomComponent;\n\n/**\n * This is the main layout for the Active Flights UI\n * \n * @author Jinghui Cheng\n */\npublic class AFMainLayout extends CustomComponent {\n\tprivate static final long serialVersionUID = 1L;\n\tprivate AFControlsComponent controls = new AFControlsComponent();\n\tprivate AFMapComponent map = new AFMapComponent(controls.getPanel());\n \n\tpublic AFMainLayout() {\n\t\taddStyleName(\"main_layout\");\n\n\t\tCssLayout content = new CssLayout();\n\t\tcontent.setSizeFull();\n\n\t\tcontrols.getPanel().getMapView().getViewButton().addClickListener(e -> {\n\t\t\tmap.setFollow(false);\n\t\t\tmap.setAverageCenter();\n\t\t});\n\n\n\n\t\tcontrols.getPanel().getMapView().getFollowButton().addClickListener(e -> {\n\t\t\tmap.setFollow(true);\n\t\t\tmap.setFollowZoom(true);\n\t\t\tList<String> names = controls.getPanel().getChecked();\n\t\t\tmap.followDrones(names);\n\t\t});\n\n\t\tcontent.addComponents(controls, map);\n\t\tsetCompositionRoot(content);\n\t}\n\n\t/**\n\t * determines if the map should continue in follow mode\n\t */\n\tpublic void continueFollowing() {\n\t\tif (map.getFollow()) {\n\t\t\tList<String> names = controls.getPanel().getChecked();\n\t\t\tmap.followDrones(names);\n\t\t}\n\t}\n\n\tpublic AFControlsComponent getControls() {\n\t\treturn controls;\n\t}\n\n\tpublic AFMapComponent getAFMap() {\n\t\treturn map;\n\t}\n}\n"}, {"id": "PlanPoolManager.java", "body": "package edu.nd.dronology.core.flight;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.monitoring.DronologyMonitoringManager;\nimport edu.nd.dronology.core.monitoring.MessageMarshaller;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * Management of pending plans for individual UAVs.<br>\n * Each active UAV has a {@link PlanPool} that keeps track of the assigned (and pending) flight plans.\n * \n * @author Michael Vierhauser\n *\n */\npublic class PlanPoolManager {\n\n\tprivate static volatile PlanPoolManager INSTANCE = null;\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(PlanPoolManager.class);\n\n\tprivate Map<String, PlanPool> planList = new ConcurrentHashMap<>();\n\n\tprivate List<IFlightPlan> pendingPlans = Collections.synchronizedList(new ArrayList<>());\n\n\tprivate List<IPlanStatusChangeListener> planStatusChangeListener = Collections.synchronizedList(new ArrayList<>());\n\n\tpublic static PlanPoolManager getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (PlanPoolManager.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new PlanPoolManager();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\tpublic void addNewPlan(IFlightPlan plan) throws DroneException {\n\t\tString uavId = plan.getDesignatedDroneId();\n\t\tif (uavId == null) {\n\t\t\tassignPlan(plan);\n\t\t} else {\n\t\t\tassignToPool(uavId, plan);\n\t\t}\n\t}\n\n\tprivate void assignPlan(IFlightPlan plan) throws DroneException {\n\t\tpendingPlans.add(plan);\n\n\t}\n\n\tprivate void assignToPool(String uavId, IFlightPlan plan) {\n\t\tPlanPool pp = null;\n\t\tif (planList.get(uavId) == null) {\n\t\t\tpp = new PlanPool(uavId);\n\t\t\tplanList.put(uavId, pp);\n\t\t} else {\n\t\t\tpp = planList.get(uavId);\n\t\t}\n\t\tpp.addPlan(plan);\n\t\tpendingPlans.add(plan);\n\t}\n\n\tpublic boolean hasPendingFlights() {\n\t\treturn pendingPlans.size() > 0;\n\t}\n\n\tpublic IFlightPlan getNextPendingPlan() {\n\t\treturn pendingPlans.get(0);\n\t}\n\n\tpublic void activatePlan(IFlightPlan plan, String uavid) throws DroneException {\n\t\tif (planList.get(uavid) == null) {\n\t\t\tthrow new DroneException(\"Error no plan for '\" + uavid + \"' pending\");\n\n\t\t}\n\t\tpendingPlans.remove(plan);\n\t\tplanList.get(uavid).setNextPlanToCurrent();\n\t\tplan.setDesignatedDroneId(uavid); \n\t\tDronologyMonitoringManager.getInstance().publish(MessageMarshaller.createPlanActive(plan));\n\t}\n\n\tpublic void checkFormCompletedPlans() throws DroneException {\n\t\tfor (PlanPool pp : planList.values()) {\n\t\t\tif (pp.getCurrentPlan() != null && pp.getCurrentPlan().isCompleted()) {\n\t\t\t\tIFlightPlan current = pp.getCurrentPlan();\n\t\t\t\tpp.setCurrentFlightCompleted();\n\t\t\t\tDronologyMonitoringManager.getInstance().publish(MessageMarshaller.createPlanCompleted(current));\n\t\t\t\tnotifyPlanChange(current);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void notifyPlanChange(IFlightPlan changedPlan) {\n\t\tfor (IPlanStatusChangeListener listener : planStatusChangeListener) {\n\t\t\tlistener.notifyPlanChange(changedPlan);\n\t\t}\n\n\t}\n\n\tpublic List<IFlightPlan> getCurrentFlights() {\n\t\tList<IFlightPlan> currentFlights = new ArrayList<>();\n\t\tfor (PlanPool pp : planList.values()) {\n\t\t\tif (pp.getCurrentPlan() != null) {\n\t\t\t\tcurrentFlights.add(pp.getCurrentPlan());\n\t\t\t}\n\t\t}\n\t\treturn currentFlights;\n\t}\n\n\tpublic void assignPlan(IFlightPlan plan, String uavId) {\n\t\tPlanPool pp = null;\n\t\tif (planList.get(uavId) == null) {\n\t\t\tpp = new PlanPool(uavId);\n\t\t\tplanList.put(uavId, pp);\n\t\t} else {\n\t\t\tpp = planList.get(uavId);\n\t\t}\n\t\tpp.addPlan(plan);\n\n\t}\n\n\tpublic void addPlanStatusChangeListener(IPlanStatusChangeListener listener) {\n\t\tplanStatusChangeListener.add(listener);\n\n\t}\n\n\tpublic IFlightPlan getCurrentPlan(String uavId) {\n\t\tif (planList.get(uavId) != null) {\n\t\t\treturn planList.get(uavId).getCurrentPlan();\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic List<IFlightPlan> getPendingPlans(String uavId) {\n\t\tif (planList.get(uavId) != null) {\n\t\t\treturn planList.get(uavId).getPendingPlans();\n\t\t}\n\t\treturn Collections.emptyList();\n\t}\n\n\tpublic List<IFlightPlan> getCompletedPlans(String uavId) {\n\t\tif (planList.get(uavId) != null) {\n\t\t\treturn planList.get(uavId).getCompletedPlans();\n\t\t}\n\t\treturn Collections.emptyList();\n\t}\n\n\tpublic void overridePlan(IFlightPlan homePlane, String uavid) throws DroneException {\n\t\tif (planList.get(uavid) == null) {\n\t\t\tthrow new DroneException(\"Error no plan for '\" + uavid + \"' pending\");\n\n\t\t}\n\t\tplanList.get(uavid).overridePlan(homePlane);\n\n\t}\n\n\tpublic void cancelPendingPlans(String uavid) throws DroneException {\n\t\tif (planList.get(uavid) == null) {\n\t\t\tthrow new DroneException(\"Error no plan for '\" + uavid + \"' pending\");\n\n\t\t} \n\t\tplanList.get(uavid).cancelPendingPlans();\n\t\tsynchronized (pendingPlans) {\n\t\t\tList<IFlightPlan> allPending = new ArrayList<>(pendingPlans);\n\n\t\t\tfor (IFlightPlan p : allPending) {\n\t\t\t\tif (p.getDesignatedDroneId().equals(uavid)) {\n\t\t\t\t\tpendingPlans.remove(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic List<IFlightPlan> getPendingPlans() {\n\t\treturn Collections.unmodifiableList(new ArrayList<>(pendingPlans));\n\t}\n\n}\n"}, {"id": "AllocationInformation.java", "body": "package edu.nd.dronology.services.extensions.areamapping.metrics;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport edu.nd.dronology.services.core.areamapping.MetricsStatistics;\n\npublic class AllocationInformation implements Comparable<AllocationInformation> {\n\tprivate List<Drone> droneAllocations;\n\tprivate MetricsStatistics metricsStatistics;\n\n\tpublic AllocationInformation() {\n\t\tdroneAllocations = new ArrayList<>();\n\t}\n\n\tpublic List<Drone> getDroneAllocations() {\n\t\treturn droneAllocations;\n\t}\n\n\tpublic MetricsStatistics getMetricStatistics() {\n\t\treturn metricsStatistics;\n\t}\n\n\tpublic void setDroneAllocations(List<Drone> droneAllocations) {\n\t\tthis.droneAllocations = droneAllocations;\n\t}\n\n\tpublic void setMetricsStatistics(MetricsStatistics metricsStatistics) {\n\t\tthis.metricsStatistics = metricsStatistics;\n\t}\n\n\t@Override\n\tpublic int compareTo(AllocationInformation otherAllocation) {\n\t\tif (this.getMetricStatistics().getAllocationScore() < otherAllocation.getMetricStatistics().getAllocationScore()) {\n\t\t\treturn 1;\n\t\t} else if (otherAllocation.getMetricStatistics().getAllocationScore() < this.getMetricStatistics()\n\t\t\t\t.getAllocationScore()) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n"}, {"id": "FileManager.java", "body": "package edu.nd.dronology.services.core.util;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.FilenameFilter;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport edu.nd.dronology.services.core.api.IFileChangeNotifyable;\nimport edu.nd.dronology.util.FileUtil;\nimport edu.nd.dronology.util.NamedThreadFactory;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class FileManager {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(FileManager.class);\n\tprivate static final ExecutorService EXECUTOR_SERVICE = Executors.newFixedThreadPool(20,\n\t\t\tnew NamedThreadFactory(\"Directory-WatchServices\"));\n\n\tprivate WatchServiceRunner directoryWatcher;\n\tprivate String extension;\n\tprivate String path;\n\n\tpublic FileManager(final IFileChangeNotifyable instance, String path, String extension) {\n\t\tthis.path = path;\n\t\tthis.extension = extension;\n\t\tinitWorkspace();\n\n\t\tdirectoryWatcher = new WatchServiceRunner(path, false, instance, extension);\n\t\tEXECUTOR_SERVICE.submit(directoryWatcher);\n\n\t}\n\n\tprivate void initWorkspace() {\n\t\tFile f = new File(path);\n\t\tif (!f.exists()) {\n\t\t\tf.mkdirs();\n\t\t}\n\n\t}\n\n\tpublic byte[] getFileAsByteArray(String fileId) throws DronologyServiceException {\n\t\tLOGGER.info(\"File '\" + fileId + \"' requested\");\n\n\t\tString savelocation = path + File.separator + fileId + \".\" + extension;\n\t\tFile f = new File(savelocation);\n\t\tif (!f.exists()) {\n\t\t\tLOGGER.info(\"File not found: \" + savelocation);\n\t\t\tthrow new DronologyServiceException(\"File \" + fileId + \" does not exist on server!\");\n\t\t}\n\t\tbyte[] content = FileUtil.toByteArray(f);\n\t\tif (content.length == 0) {\n\t\t\tthrow new DronologyServiceException(\"Error when reading file \" + fileId);\n\t\t}\n\t\treturn content;\n\n\t}\n\n\tpublic File getFile(String fileId) throws DronologyServiceException {\n\t\tLOGGER.info(\"File '\" + fileId + \"' requested\");\n\n\t\tString savelocation = path + File.separator + fileId + \".\" + extension;\n\t\tFile f = new File(savelocation);\n\t\tif (!f.exists()) {\n\t\t\tLOGGER.info(\"File not found: \" + savelocation);\n\t\t\tthrow new DronologyServiceException(\"File \" + fileId + \" does not exist on server!\");\n\t\t}\n\t\treturn f;\n\t}\n\n\tpublic boolean saveByteArrayToFile(String id, byte[] content) {\n\t\tLOGGER.info(\"File '\" + id + \"' received\");\n\t\tFileOutputStream stream = null;\n\t\tString savelocation = path + File.separator + id + \".\" + extension;\n\t\tFile f = new File(savelocation);\n\t\tif (f.exists()) {\n\t\t\tLOGGER.info(\"Deleting old file\");\n\t\t\tf.delete();\n\t\t}\n\t\treturn FileUtil.saveByteArrayToFile(f, content);\n\n\t}\n\n\tpublic File[] loadFiles() {\n\t\tLOGGER.info(\"Loading Files | extension:'\" + extension + \"' path: [\" + path + \"]\");\n\t\tFile f = new File(path);\n\t\tFile[] files = f.listFiles(new FilenameFilter() {\n\n\t\t\t@Override\n\t\t\tpublic boolean accept(File arg0, String arg1) {\n\t\t\t\treturn arg1.endsWith(extension);\n\t\t\t}\n\t\t});\n\t\treturn files;\n\n\t}\n\n\tpublic void tearDown() {\n\t\tdirectoryWatcher.stop();\n\t}\n\n}\n"}, {"id": "SearchConstants.java", "body": "package edu.nd.dronology.services.extensions.areamapping.output;\n\npublic class SearchConstants {\n\tprivate double OVERLAP_FACTOR;\n\tprivate double APERATURE_WIDTH;\n\tprivate double MAX_RIVER_WIDTH;\n\tprivate int dronesNum;\n\tprivate static SearchConstants instance = null;\n\t\n\tpublic static SearchConstants getInstance() {\n\t\tif(instance == null) {\n\t\t\tinstance = new SearchConstants();\n\t\t}\n\t\treturn instance;\n\t}\n\tpublic void initialize(double overlapFactor, double aperatureWidth, double maxRiverWidth, int drones) {\n\t\tOVERLAP_FACTOR = overlapFactor;\n\t\tAPERATURE_WIDTH = aperatureWidth;\n\t\tMAX_RIVER_WIDTH = maxRiverWidth;\n\t\tdronesNum = drones;\n\t}\n\t\n\tpublic double getOverlapFactor() {\n\t\treturn OVERLAP_FACTOR;\n\t}\n\t\n\tpublic double getAperatureWidth() {\n\t\treturn APERATURE_WIDTH;\n\t}\n\t\n\tpublic double getMaxRiverWidth() {\n\t\treturn MAX_RIVER_WIDTH;\n\t}\n\t\n\tpublic int getDronesNum() {\n\t\treturn dronesNum;\n\t}\n}\n"}, {"id": "StopExecutorViaWaypoint.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal;\n\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.vehicle.IDrone;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\n\npublic class StopExecutorViaWaypoint implements CommandExecutor {\n\n    enum StopExecutionState {\n        RADIOING,\n        WATCHING_THE_CLOCK,\n        WAITING_FOREVER,\n        FINISHED;\n    }\n\n    private class PositionAndSpeed {\n        public LlaCoordinate position;\n        public double speed;\n    }\n\n    private IDrone drone;\n    StopExecutionState state = StopExecutionState.RADIOING;\n    StopCommand data;\n    long startTime;\n\n    public StopExecutorViaWaypoint(IDrone drone, StopCommand data) {\n        this.drone = drone;\n        this.data = data;\n    }\n\n    @Override\n    public void process() {\n        switch (state) {\n            case RADIOING:\n                radioDrone();\n                break;\n\n            case WATCHING_THE_CLOCK:\n                checkClock();\n                break;\n\n            case WAITING_FOREVER:\n            case FINISHED:\n            default:\n                // Do nothing.\n                break;\n        }\n    }\n\n    private void radioDrone() {\n        PositionAndSpeed current = getCurrentPositionAndSpeed();\n        drone.flyTo(current.position, current.speed);\n\n        double waitDuration = data.getTime();\n        if (waitDuration > 0.0) {\n            startTime = System.nanoTime();\n            state = StopExecutionState.WATCHING_THE_CLOCK;\n        }\n        else {\n            state = StopExecutionState.WAITING_FOREVER;\n        }\n    }\n\n    private void checkClock() {\n        double waitDuration = data.getTime();\n        long deltaNano = System.nanoTime()- startTime;\n        double deltaT = deltaNano * 1.0e-9;\n        if (deltaT > waitDuration) {\n            state = StopExecutionState.FINISHED;\n        }\n    }\n\n    @Override\n    public boolean isFinished() {\n        return state == StopExecutionState.FINISHED;\n    }\n\n    private PositionAndSpeed getCurrentPositionAndSpeed() {\n        PositionAndSpeed result = new PositionAndSpeed();\n        DroneSnapshotInternal currentState = drone.getLatestDroneSnapshot();\n        result.position = currentState.getPosition();\n        result.speed = Vector3D.distance(Vector3D.ZERO, currentState.getVelocity());\n        return result;\n    }\n\n}\n"}, {"id": "IFlightDirector.java", "body": "package edu.nd.dronology.core.flight;\n\nimport java.util.List;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.util.Waypoint;\n\npublic interface IFlightDirector {\n\t\n\t//public void returnHome(LlaCoordinate home);\n\t\n\t\t\n\tpublic LlaCoordinate flyToNextPoint();\n\n\n\t/**\n\t * Clear all waypoints\n\t */\n\tvoid clearWayPoints();\n\n\n\t\n\t/** \n\t * Check if more waypoints exist\n\t * @return boolean\n\t */\n\tboolean hasMoreWayPoints();\n\n\t/**\n\t * Specifies if flight is currently under a safety directive.\n\t * @return isUnderSafetyDirectives\n\t */\n\tboolean isUnderSafetyDirectives();\n\n\t/**\n\t * Removes one wayPoint -- typically when a drone reaches a waypoint.\n\t * @param wayPoint\n\t */\n\tvoid clearCurrentWayPoint();\n\n\t/**\n\t * Add a waypoint to the flight directive.\n\t * @param wayPoint\n\t */\n//\tvoid addWayPoint(LlaCoordinate wayPoint);\n\n\tvoid flyHome();\n\n\tboolean readyToLand();\n\n\tboolean readyToTakeOff();\n\n\n\tvoid setWayPoints(List<Waypoint> wayPoints);\n\n\tList<Waypoint> getWayPoints();\n\n\tvoid addWayPoint(Waypoint wayPoint);\n\n\n\tvoid returnHome(Waypoint home);\n\n\n}"}, {"id": "UAVMonitoringMessage.java", "body": "package edu.nd.dronology.gstation.connector.messages;\n\nimport java.io.Serializable;\n\n/**\n * Monitoring message received from the GCS for a specific UAV.\n * \n * @author Michael Vierhauser\n *\n */\npublic class UAVMonitoringMessage extends AbstractUAVMessage<Object> implements Serializable {\n\n\tprivate static final long serialVersionUID = 1502042637906425729L;\n\tpublic static final String MESSAGE_TYPE = \"monitoring\";\n\n\tpublic UAVMonitoringMessage(String messagetype, String groundstationid, String uavid) {\n\t\tsuper(MESSAGE_TYPE, groundstationid, uavid);\n\t}\n\n}\n"}, {"id": "AreaMapping.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.UUID;\n\nimport edu.nd.dronology.core.util.ManagedHashTableList;\nimport edu.nd.dronology.services.core.areamapping.EdgeLla; \nimport edu.nd.dronology.services.core.areamapping.IRegionOfInterest;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n/**\n * \n * @author Michael Vierhauser\n *\n */ \npublic class AreaMapping implements IAreaMapping {\n\n\tprivate String name; \n\tprivate String id;\n\tprivate String description;\n\tprivate ManagedHashTableList<Integer, EdgeLla> areaMappings = new ManagedHashTableList<>();\n\tprivate List<IMappedItem> locationMappings = new ArrayList<>();\n\tprivate Boolean upstream;\n\n\t// MappedArea area;\n\tList<IRegionOfInterest> regions = new ArrayList<>();\n\n\tpublic AreaMapping() {\n\t\tid = UUID.randomUUID().toString();\n\t\tname = id;\n\t}\n\n\t@Override\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\t@Override\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\t@Override\n\tpublic List<EdgeLla> getMappedPoints(Integer part) {\n\t\treturn Collections.unmodifiableList(areaMappings.get(part));\n\t}\n\n\t@Override\n\tpublic void addMappedArea(Integer part, List<EdgeLla> coordinates) {\n\t\tareaMappings.put(part, coordinates);\n\t}\n\n\t@Override\n\tpublic void addMappedArea(Integer part, EdgeLla coordinate) {\n\t\tareaMappings.add(part, coordinate);\n\t}\n\n\t@Override\n\tpublic void removeCoordinate(int part, EdgeLla coordinate) {\n\t\tint index = areaMappings.get(part).indexOf(coordinate);\n\t\tif (index != -1) {\n\t\t\tareaMappings.get(part).remove(coordinate);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void addMappedLocation(IMappedItem item) {\n\t\tlocationMappings.add(item);\n\t}\n\t\n\t@Override\n\tpublic List<IMappedItem> getLocationMappings() {\n\t\treturn locationMappings;\n\t}\n\n\n\t@Override\n\tpublic void removeMappedLocation(String id) throws DronologyServiceException {\n\t\tList<IMappedItem> toCheck = new ArrayList<>(locationMappings);\n\t\tfor (IMappedItem item : toCheck) {\n\t\t\tif (item.getId().equals(id)) {\n\t\t\t\tlocationMappings.remove(item);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthrow new DronologyServiceException(\"Location with id '\" + id + \"' not found!\");\n\t}\n\n\t@Override\n\tpublic void setUpstream(Boolean upstream) {\n\t\tthis.upstream = upstream;\n\t}\n\n\t@Override\n\tpublic Boolean getUpstream() {\n\t\treturn upstream;\n\t}\n\n}\n"}, {"id": "DroneFlightStateManager.java", "body": "package edu.nd.dronology.core.vehicle;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.github.oxo42.stateless4j.StateMachine;\n\nimport edu.nd.dronology.core.exceptions.FlightZoneException;\nimport edu.nd.dronology.core.monitoring.DronologyMonitoringManager;\nimport edu.nd.dronology.core.monitoring.MessageMarshaller;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * Associates a drone state object with a drone. <br>\n * Normal behavior : ON_GROUND -> AWAITING_TAKEOFF_CLEARANCE -> TAKING_OFF -> FLYING -> In IN_AIR -> LANDING <br>\n * Unavailable transitions will result in an exception being thrown.\n *  \n * @author Jane Cleland-Huang\n *\n */\npublic class DroneFlightStateManager {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(DroneFlightStateManager.class);\n\n\tpublic enum FlightMode {\n\t\tON_GROUND, AWAITING_TAKEOFF_CLEARANCE, TAKING_OFF, FLYING, IN_AIR, LANDING, USER_CONTROLLED\n\t}\n\n\tprivate enum FlightModeTransition {\n\t\tTO_ON_GROUND, PLAN_ASSIGNED, TAKEOFF_GRANTED, TARGET_ALTITUED_REACHED, PLAN_COMPLETE, ZERO_ALTITUED_REACHED, LANDING_GRANTED, MANUAL_TAKEOFER;\n\t}\n\n\tprivate volatile StateMachine<FlightMode, FlightModeTransition> uavStateMachine;\n\n\tprivate final String uavid;\n\n\tprivate List<IManagedDroneStateChangeListener> listeners = new ArrayList<>();\n\n\t/**\n\t * Constructor States for both FlightMode and SafetyMode set to initial state\n\t * \n\t * @param uav\n\t *          The UAV the state manager is assigned to.\n\t */\n\tpublic DroneFlightStateManager(ManagedDrone uav) {\n\t\tthis.uavid = uav.getDroneName();\n\t\tbuildStateMachine();\n\t}\n\n\tprivate void buildStateMachine() {\n\t\tuavStateMachine = new StateMachine<>(FlightMode.ON_GROUND);\n\t\tuavStateMachine.configure(FlightMode.ON_GROUND).permit(FlightModeTransition.PLAN_ASSIGNED,\n\t\t\t\tFlightMode.AWAITING_TAKEOFF_CLEARANCE);\n\t\tuavStateMachine.configure(FlightMode.AWAITING_TAKEOFF_CLEARANCE).permit(FlightModeTransition.TAKEOFF_GRANTED,\n\t\t\t\tFlightMode.TAKING_OFF);\n\t\tuavStateMachine.configure(FlightMode.TAKING_OFF).permit(FlightModeTransition.TARGET_ALTITUED_REACHED,\n\t\t\t\tFlightMode.FLYING);\n\t\tuavStateMachine.configure(FlightMode.FLYING).permit(FlightModeTransition.PLAN_COMPLETE, FlightMode.IN_AIR);\n\t\tuavStateMachine.configure(FlightMode.IN_AIR).permit(FlightModeTransition.PLAN_ASSIGNED, FlightMode.FLYING);\n\t\tuavStateMachine.configure(FlightMode.IN_AIR).permit(FlightModeTransition.LANDING_GRANTED, FlightMode.LANDING);\n\t\tuavStateMachine.configure(FlightMode.LANDING).permit(FlightModeTransition.ZERO_ALTITUED_REACHED,\n\t\t\t\tFlightMode.ON_GROUND);\n\n\t\tuavStateMachine.configure(FlightMode.ON_GROUND).permit(FlightModeTransition.MANUAL_TAKEOFER,\n\t\t\t\tFlightMode.USER_CONTROLLED);\n\t\tuavStateMachine.configure(FlightMode.AWAITING_TAKEOFF_CLEARANCE).permit(FlightModeTransition.MANUAL_TAKEOFER,\n\t\t\t\tFlightMode.USER_CONTROLLED);\n\t\tuavStateMachine.configure(FlightMode.TAKING_OFF).permit(FlightModeTransition.MANUAL_TAKEOFER,\n\t\t\t\tFlightMode.USER_CONTROLLED);\n\t\tuavStateMachine.configure(FlightMode.FLYING).permit(FlightModeTransition.MANUAL_TAKEOFER,\n\t\t\t\tFlightMode.USER_CONTROLLED);\n\t\tuavStateMachine.configure(FlightMode.IN_AIR).permit(FlightModeTransition.MANUAL_TAKEOFER,\n\t\t\t\tFlightMode.USER_CONTROLLED);\n\t\tuavStateMachine.configure(FlightMode.LANDING).permit(FlightModeTransition.MANUAL_TAKEOFER,\n\t\t\t\tFlightMode.USER_CONTROLLED);\n\n\t}\n\n\t/**\n\t * Set Flight Mode to OnGround\n\t * \n\t * @throws FlightZoneException\n\t *           if mode change does not follow allowed state transition.\n\t */\n\tpublic void setModeToOnGround() throws FlightZoneException {\n\t\tFlightMode oldState = uavStateMachine.getState();\n\t\tif (uavStateMachine.canFire(FlightModeTransition.ZERO_ALTITUED_REACHED)) {\n\t\t\tuavStateMachine.fire(FlightModeTransition.ZERO_ALTITUED_REACHED);\n\t\t\tnotifyStateChange(oldState, uavStateMachine.getState());\n\n\t\t} else {\n\t\t\tLOGGER.error(\"You may not transition from '\" + uavStateMachine.getState() + \"' with trigger '\"\n\t\t\t\t\t+ FlightModeTransition.ZERO_ALTITUED_REACHED + \"'\");\n\t\t\tthrow new FlightZoneException(\n\t\t\t\t\t\"You may not transition to \" + FlightMode.ON_GROUND + \" directly from \" + uavStateMachine.getState());\n\t\t}\n\t}\n\n\t/**\n\t * Set Flight Mode to UserControlled\n\t * \n\t */ \n\tpublic void setModeToUserControlled() throws FlightZoneException {\n\t\tFlightMode oldState = uavStateMachine.getState();\n\t\tif (uavStateMachine.canFire(FlightModeTransition.MANUAL_TAKEOFER)) {\n\t\t\tuavStateMachine.fire(FlightModeTransition.MANUAL_TAKEOFER);\n\t\t\tnotifyStateChange(oldState, uavStateMachine.getState());\n\n\t\t} else {\n\t\t\tLOGGER.error(\"You may not transition from '\" + uavStateMachine.getState() + \"' with trigger '\"\n\t\t\t\t\t+ FlightModeTransition.MANUAL_TAKEOFER + \"'\");\n\t\t\tthrow new FlightZoneException(\n\t\t\t\t\t\"You may not transition to \" + FlightMode.ON_GROUND + \" directly from \" + uavStateMachine.getState());\n\t\t}\n\n\t}\n\n\t/**\n\t * Set Flight mode to awaiting Takeoff Clearance\n\t * \n\t * @throws FlightZoneException\n\t *           if mode change does not follow allowed state transition.\n\t */\n\tpublic void setModeToAwaitingTakeOffClearance() throws FlightZoneException {\n\t\tFlightMode oldState = uavStateMachine.getState();\n\t\tif (uavStateMachine.canFire(FlightModeTransition.PLAN_ASSIGNED)) {\n\t\t\tuavStateMachine.fire(FlightModeTransition.PLAN_ASSIGNED);\n\t\t\tnotifyStateChange(oldState, uavStateMachine.getState());\n\t\t} else {\n\t\t\tLOGGER.error(\"You may not transition from '\" + uavStateMachine.getState() + \"' with trigger '\"\n\t\t\t\t\t+ FlightModeTransition.PLAN_ASSIGNED + \"'\");\n\t\t\tthrow new FlightZoneException(\"You may not transition to \" + FlightMode.AWAITING_TAKEOFF_CLEARANCE\n\t\t\t\t\t+ \" directly from \" + uavStateMachine.getState());\n\t\t}\n\n\t}\n\n\t/**\n\t * Set flight mode to Taking off\n\t * \n\t * @throws FlightZoneException\n\t *           if mode change does not follow allowed state transition.\n\t */\n\tpublic void setModeToTakingOff() throws FlightZoneException {\n\t\tFlightMode oldState = uavStateMachine.getState();\n\t\tif (uavStateMachine.canFire(FlightModeTransition.TAKEOFF_GRANTED)) {\n\t\t\tuavStateMachine.fire(FlightModeTransition.TAKEOFF_GRANTED);\n\t\t\tnotifyStateChange(oldState, uavStateMachine.getState());\n\t\t} else {\n\t\t\tLOGGER.error(\"You may not transition from '\" + uavStateMachine.getState() + \"' with trigger '\"\n\t\t\t\t\t+ FlightModeTransition.TAKEOFF_GRANTED + \"'\");\n\t\t\tthrow new FlightZoneException(\n\t\t\t\t\t\"You may not transition to \" + FlightMode.TAKING_OFF + \" directly from \" + uavStateMachine.getState());\n\t\t}\n\n\t}\n\n\t/**\n\t * Set flight mode to Flying\n\t * \n\t * @throws FlightZoneException\n\t *           if mode change does not follow allowed state transition.\n\t */\n\tpublic void setModeToFlying() throws FlightZoneException {\n\t\tFlightMode oldState = uavStateMachine.getState();\n\t\tif (uavStateMachine.canFire(FlightModeTransition.TARGET_ALTITUED_REACHED)) {\n\t\t\tuavStateMachine.fire(FlightModeTransition.TARGET_ALTITUED_REACHED);\n\t\t\tnotifyStateChange(oldState, uavStateMachine.getState());\n\t\t} else if (uavStateMachine.canFire(FlightModeTransition.PLAN_ASSIGNED)) {\n\t\t\tuavStateMachine.fire(FlightModeTransition.PLAN_ASSIGNED);\n\t\t\tnotifyStateChange(oldState, uavStateMachine.getState());\n\t\t} else {\n\t\t\tLOGGER.error(\"You may not transition from '\" + uavStateMachine.getState() + \"' with trigger '\"\n\t\t\t\t\t+ FlightModeTransition.TARGET_ALTITUED_REACHED + \"'\");\n\t\t\tthrow new FlightZoneException(\n\t\t\t\t\t\"You may not transition to \" + FlightMode.FLYING + \" directly from \" + uavStateMachine.getState());\n\t\t}\n\n\t}\n\n\t/**\n\t * Set flight mode to Landing\n\t * \n\t * @throws FlightZoneException\n\t *           if mode change does not follow allowed state transition.\n\t */\n\tpublic void setModeToLanding() throws FlightZoneException {\n\t\tFlightMode oldState = uavStateMachine.getState();\n\t\tif (uavStateMachine.canFire(FlightModeTransition.LANDING_GRANTED)) {\n\t\t\tuavStateMachine.fire(FlightModeTransition.LANDING_GRANTED);\n\t\t\tnotifyStateChange(oldState, uavStateMachine.getState());\n\t\t} else {\n\t\t\tLOGGER.error(\"You may not transition from '\" + uavStateMachine.getState() + \"' with trigger '\"\n\t\t\t\t\t+ FlightModeTransition.LANDING_GRANTED + \"'\");\n\t\t\tthrow new FlightZoneException(\n\t\t\t\t\t\"You may not transition to \" + FlightMode.LANDING + \" directly from \" + uavStateMachine.getState());\n\t\t}\n\n\t}\n\n\t/**\n\t * \n\t * @return true if drone is currently on the ground, false otherwise\n\t */\n\tpublic boolean isOnGround() {\n\t\treturn uavStateMachine.getState() == FlightMode.ON_GROUND;\n\n\t}\n\n\t/**\n\t * \n\t * @return true if drone is currently in AwaitingTakeOffClearance mode, false otherwise\n\t */\n\tpublic boolean isAwaitingTakeoffClearance() {\n\t\treturn uavStateMachine.getState() == FlightMode.AWAITING_TAKEOFF_CLEARANCE;\n\n\t}\n\n\t/**\n\t * \n\t * @return true if drone is currently taking off, false otherwise\n\t */\n\tpublic boolean isTakingOff() {\n\t\treturn uavStateMachine.getState() == FlightMode.TAKING_OFF;\n\t}\n\n\t/**\n\t * \n\t * @return true if drone is currently flying, false otherwise\n\t */\n\tpublic boolean isFlying() {\n\t\treturn uavStateMachine.getState() == FlightMode.FLYING;\n\n\t}\n\n\t/**\n\t * \n\t * @return true if drone is currently landing, false otherwise\n\t */\n\tpublic boolean isLanding() {\n\t\treturn uavStateMachine.getState() == FlightMode.LANDING;\n\n\t}\n\n\t/**\n\t * \n\t * @return current status\n\t */\n\tpublic String getStatus() {\n\t\treturn uavStateMachine.getState().toString();\n\t\t// return currentFlightMode.toString();\n\t}\n\n\tprivate synchronized void notifyStateChange(FlightMode oldState, FlightMode newState) {\n\t\tLOGGER.info(\"Drone '\" + uavid + \"' set to: \" + uavStateMachine.getState());\n\t\tDronologyMonitoringManager.getInstance().publish(MessageMarshaller.create(uavid, oldState, newState));\n\t\tfor (IManagedDroneStateChangeListener listener : listeners) {\n\t\t\tlistener.notifyStateChange();\n\t\t}\n\t}\n\n\tpublic boolean isInAir() {\n\t\treturn uavStateMachine.getState() == FlightMode.IN_AIR;\n\t}\n\n\tpublic void setModeToInAir() throws FlightZoneException {\n\t\tFlightMode oldState = uavStateMachine.getState();\n\t\tif (uavStateMachine.canFire(FlightModeTransition.PLAN_COMPLETE)) {\n\t\t\tuavStateMachine.fire(FlightModeTransition.PLAN_COMPLETE);\n\t\t\tnotifyStateChange(oldState, uavStateMachine.getState());\n\t\t} else {\n\t\t\tLOGGER.error(\"You may not transition from '\" + uavStateMachine.getState() + \"' with trigger '\"\n\t\t\t\t\t+ FlightModeTransition.PLAN_COMPLETE + \"'\");\n\t\t\tthrow new FlightZoneException(\n\t\t\t\t\t\"You may not transition to \" + FlightMode.IN_AIR + \" directly from \" + uavStateMachine.getState());\n\t\t}\n\t}\n\n\tpublic void addStateChangeListener(IManagedDroneStateChangeListener listener) {\n\t\tlisteners.add(listener);\n\n\t}\n\n}\n"}, {"id": "JSONSendTester.java", "body": "package edu.nd.dronology.misc.gcs;\n\nimport java.text.DateFormat;\n\nimport com.google.gson.FieldNamingPolicy;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.gstation.connector.messages.UAVHandshakeMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVStateMessage;\n\npublic class JSONSendTester {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tfinal Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()\n\t\t\t\t\t.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)\n\t\t\t\t\t.setVersion(1.0).serializeSpecialFloatingPointValues().create();\n\n\t\t\tUAVMonitoringMessage mm = new UAVMonitoringMessage(\"Drone1\", \"FAKE\", \"Drone1\");\n\n\t\t\tmm.setType(UAVMonitoringMessage.MESSAGE_TYPE);\n\t\t\tmm.setUavid(\"DRONE1\");\n\t\t\tmm.addPropery(\"NR_SATELITES\", 5);\n\t\t\tmm.addPropery(\"GPS_BIAS\", 3.125);\n\t\t\tmm.addPropery(\"CURRENT_SPEED\", 5.25);\n\n\t\t\tString toSend = GSON.toJson(mm);\n\n\t\t\tUAVStateMessage sm = new UAVStateMessage(\"Drone1\", \"FAKE\",\"Drone1\");\n\n\t\t\t// sm.setType(UAVStateMessage.MESSAGE_TYPE);\n\t\t\t// sm.setUavid(\"DRONE1\");\n\t\t\t// sm.setArmable(true);\n\t\t\t// sm.setArmed(true);\n\t\t\t// sm.setAttitude(new LlaCoordinate(1, 2, 3));\n\t\t\t// sm.setGroundspeed(25.3);\n\t\t\t// sm.setLocation(new LlaCoordinate(3, 4, 5));\n\t\t\t// sm.setMode(edu.nd.dronology.gstation.python.connector.messages.UAVStateMessage.DroneMode.CIRCLE);\n\t\t\t// sm.setStatus(DroneStatus.ACTIVE);\n\t\t\t// sm.setVelocity(new LlaCoordinate(5, 6, 7));\n\t\t\t// sm.setBatterystatus(new BatteryStatus());\n\n\t\t\ttoSend = GSON.toJson(sm);\n\n\t\t\tUAVHandshakeMessage hm = new UAVHandshakeMessage(\"FAKE\", \"Drone1\");\n\t\t\thm.setType(UAVHandshakeMessage.MESSAGE_TYPE);\n\t\t\thm.setHome(new LlaCoordinate(3, 5, 8));\n\t\t\thm.addPropery(\"xxx\", \"abc\");\n\t\t\thm.addPropery(\"yyy\", \"more parameters...\");\n\t\t\ttoSend = GSON.toJson(hm);\n\n\t\t\tSystem.out.println(toSend);\n\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n}\n"}, {"id": "FakePassivPythonGroundstation2.java", "body": "package edu.nd.dronology.misc.gcs;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.text.DateFormat;\nimport java.util.Random;\n\nimport com.google.gson.FieldNamingPolicy;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.vehicle.DroneFlightStateManager.FlightMode;\nimport edu.nd.dronology.core.vehicle.commands.ConnectionResponseCommand;\nimport edu.nd.dronology.gstation.connector.messages.ConnectionRequestMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVHandshakeMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVModeChangeMessage;\nimport edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class FakePassivPythonGroundstation2 {\n\n\t// private static Socket socket;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(FakePassivPythonGroundstation2.class);\n\n\tfinal static Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()\n\t\t\t.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)\n\t\t\t.setVersion(1.0).serializeSpecialFloatingPointValues().create();\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tint port = 1234;\n\t\t\t// ServerSocket serverSocket = new ServerSocket(port);\n\t\t\t// Server is running always. This is done using this while(true) loop\n\n\t\t\t// socket = serverSocket.accept();\n\t\t\tString hostAddr = \"localhost\";\n\n\t\t\tLOGGER.info(\"Connecting to Python base \" + hostAddr + \"@\" + port);\n\t\t\tSocket pythonSocket = new Socket();\n\t\t\tpythonSocket.connect(new InetSocketAddress(hostAddr, port), 5000);\n\n\t\t\tSystem.out.println(\"Client has connected!\");\n\t\t\tInputStream is = pythonSocket.getInputStream();\n\t\t\tInputStreamReader isr = new InputStreamReader(is);\n\t\t\tBufferedReader br = new BufferedReader(isr);\n\n\t\t\t// UAVHandshakeMessage handshake = new UAVHandshakeMessage(\"Drone1\", \"Drone1\");\n\t\t\tConnectionRequestMessage connect = new ConnectionRequestMessage(\"FAKE_GROUND_2\");\n\n\t\t\tString handshakeString = GSON.toJson(connect);\n\t\t\tThread.sleep(10000);\n\t\t\tOutputStream os = pythonSocket.getOutputStream();\n\t\t\tOutputStreamWriter osw = new OutputStreamWriter(os);\n\t\t\tBufferedWriter bw = new BufferedWriter(osw);\n\t\t\tbw.write(handshakeString);\n\t\t\tbw.write(\"\\n\");\n\t\t\tSystem.out.println(\"Message sent to the client is \" + handshakeString);\n\t\t\tbw.flush();\n\n\t\t\tString ackMesasge = br.readLine();\n\t\t\tConnectionResponseCommand response = GSON.fromJson(ackMesasge, ConnectionResponseCommand.class);\n\t\t\tSystem.out.println(\"RESPONSE:\" + response.toJsonString());\n\t\t\tThread.sleep(3000);\n\n\t\t\tUAVHandshakeMessage hand = new UAVHandshakeMessage(\"FAKE_GROUND_2\", \"UAV1\");\n\t\t\thand.setHome(new LlaCoordinate(0, 0, 0));\n\t\t\tString uavString = GSON.toJson(hand);\n\t\t\tbw.write(uavString);\n\t\t\tbw.write(\"\\n\");\n\t\t\tSystem.out.println(\"Message sent to the client is \" + uavString);\n\t\t\tbw.flush();\n\n\t\t\tThread.sleep(3000);\n\n\t\t\t// UAVModeChangeMessage mode = new UAVModeChangeMessage(\"FAKE_GROUND_2\", \"UAV1\",\n\t\t\t// FlightMode.USER_CONTROLLED.toString());\n\n\t\t\t// String modeString = GSON.toJson(mode);\n\t\t\t// bw.write(modeString);\n\t\t\t// bw.write(\"\\n\");\n\t\t\t// System.out.println(\"Message sent to the client is \" + modeString);\n\t\t\t// bw.flush();\n\n\t\t\tint i = 2;\n\t\t\twhile (i > 1) {\n\n\t\t\t\tUAVMonitoringMessage mm = new UAVMonitoringMessage(\"Dronexxx\", \"FAKE_GROUND_2\", \"Dronexxx\");\n\t\t\t\tRandom rand = new Random();\n\t\t\t\tmm.setType(UAVMonitoringMessage.MESSAGE_TYPE);\n\t\t\t\t// mm.setuavid(\"DRONE1\");\n\t\t\t\tmm.addPropery(\"NR_SATELITES\", \"5\");\n\t\t\t\tmm.addPropery(\"GPS_BIAS\", \"3.125\");\n\t\t\t\tmm.addPropery(\"CURRENT_SPEED\", \"5.25\");\n\t\t\t\tmm.addPropery(\"BLEVEL_VOLTAGE\", \"3\");\n\t\t\t\tmm.addPropery(\"BATTERY_MAXPOWERX\", \"50\");\n\t\t\t\tmm.addPropery(\"BATTERY_VOLTAGE\", rand.nextInt(10));\n\t\t\t\tmm.addPropery(\"BATTERY_POWER\", rand.nextInt(10));\n\t\t\t\tmm.addPropery(\"BLEVEL_POWER\", rand.nextInt(10));\n\n\t\t\t\t// if flying mission mlevel > 20%\n\t\t\t\t// if retunr home blvel > 10;\n\t\t\t\tUAVModeChangeMessage modeCh = new UAVModeChangeMessage(\"FAKE_GROUND_2\", \"UAV1\", \"LOITER\");\n\t\t\t\tString toSend = GSON.toJson(modeCh);\n\n\t\t\t\t// Reading the message from the client\n\n\t\t\t\t// String number = br.readLine();\n\t\t\t\t// System.out.println(\"Message received from client is \" + number);\n\n\t\t\t\t// Multiplying the number by 2 and forming the return message\n\t\t\t\t// String returnMessage;\n\t\t\t\t// try {\n\t\t\t\t// int numberInIntFormat = Integer.parseInt(number);\n\t\t\t\t// int returnValue = numberInIntFormat * 2;\n\t\t\t\t// returnMessage = String.valueOf(returnValue) + \"\\n\";\n\t\t\t\t// } catch (NumberFormatException e) {\n\t\t\t\t// // Input was not a number. Sending proper message back to client.\n\t\t\t\t// returnMessage = \"Please send a proper number\\n\";\n\t\t\t\t// }\n\n\t\t\t\t// Sending the response back to the client.\n\t\t\t\t// OutputStream os = socket.getOutputStream();\n\t\t\t\t// OutputStreamWriter osw = new OutputStreamWriter(os);\n\t\t\t\t// BufferedWriter bw = new BufferedWriter(osw);\n\t\t\t\tbw.write(toSend);\n\t\t\t\tbw.write(\"\\n\");\n\t\t\t\tSystem.out.println(\"Message sent to the client is \" + toSend);\n\t\t\t\tbw.flush();\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\t\n\t\t\tThread.sleep(10000);\n\t\t\t\n\t\t\tUAVModeChangeMessage modeCh = new UAVModeChangeMessage(\"FAKE_GROUND_2\", \"UAV1\", \"STABILIZE\");\n\t\t\tString toSend = GSON.toJson(modeCh);\n\t\t\tbw.write(toSend);\n\t\t\tbw.write(\"\\n\");\n\t\t\tSystem.out.println(\"Message sent to the client is \" + toSend);\n\t\t\tbw.flush();\n\t\t\t\n\t\t\tThread.sleep(50000);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}"}, {"id": "RiverBankPrimitive.java", "body": "package edu.nd.dronology.services.extensions.areamapping.internal;\n\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive.RouteType;\nimport edu.nd.dronology.services.extensions.areamapping.util.Utilities;\n\npublic class RiverBankPrimitive implements SearchPatternStrategy{\n\tprivate List<SourcePoints> sourcePointsList;\n\tprivate RoutePrimitive.RouteType routeType;\n\t\n\tpublic RiverBankPrimitive() {\n\t\tsourcePointsList = new ArrayList<>();\n\t}\n\t\n\t@Override\n\tpublic void setSourcePoints(List<SourcePoints> points) {\n\t\tsourcePointsList = points;\n\t}\n\t\n\t@Override\n\tpublic void setRouteType(RoutePrimitive.RouteType routeType) {\n\t\tthis.routeType = routeType;\n\t}\n\t\n\tprivate RoutePrimitive transformSourcePoints(SourcePoints sourcePoints, double APERATURE_HEIGHT, double OVERLAP_FACTOR) {\n\t\tRoutePrimitive newRoute = new RoutePrimitive(routeType, sourcePoints.getWeight());\n\t\tfor(Point2D.Double entry : sourcePoints.getSourcePoints()) {\n\t\t\tnewRoute.addRouteWaypoint(entry);\n\t\t}\n\t\tUtilities.generateImageWaypoints(newRoute, APERATURE_HEIGHT, OVERLAP_FACTOR);\n\t\treturn newRoute;\n\t}\n\t\n\t@Override\n\tpublic List<RoutePrimitive> generateRoutePrimitive(double APERATURE_HEIGHT, double OVERLAP_FACTOR){\n\n\t\tList<RoutePrimitive> routes = new ArrayList<>();\n\t\tfor(SourcePoints source : sourcePointsList) {\n\t\t\troutes.add(transformSourcePoints(source, APERATURE_HEIGHT, OVERLAP_FACTOR));\n\t\t}\n\t\treturn routes;\n\t}\n}\n"}, {"id": "IDroneCommand.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n\nimport java.io.Serializable;\n/**\n * Interface for all UAV commands.\n * \n * @author Michael Vierhauser\n *\n */\npublic interface IDroneCommand extends Serializable {\n\n\tpublic static final String ATTRIBUTE_FREQUENCY = \"frequency\";\n\tpublic static final String ATTRIBUTE_ALTITUDE = \"altitude\";\n\tpublic static final String ATTRIBUTE_SPEED = \"speed\";\n\tpublic static final String ATTRIBUTE_MODE = \"mode\";\n\n\tpublic static final String ATTRIBUTE_X = \"x\";\n\tpublic static final String ATTRIBUTE_Y = \"y\";\n\tpublic static final String ATTRIBUTE_Z = \"z\";\n\n\tpublic static final String ATTRIBUTE_SUCCESS = \"success\";\n\n\tString toJsonString();\n\n\tString getUAVId();\n\n\tvoid timestamp();\n\n}\n"}, {"id": "RouteSelectionResult.java", "body": "package edu.nd.dronology.services.extensions.areamapping.selection;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport edu.nd.dronology.services.core.areamapping.ExportAllocationInformation;\n\npublic class RouteSelectionResult {\n\tprivate List<ExportAllocationInformation> allocationInfo;\n\tprivate long selectionTime; // in milliseconds\n\n\tpublic RouteSelectionResult() {\n\t\tallocationInfo = new ArrayList<>();\n\t}\n\n\tpublic List<ExportAllocationInformation> getEportAllocationInformation() {\n\t\treturn allocationInfo;\n\t}\n\n\tpublic double getSelectionTime() {\n\t\treturn selectionTime;\n\t}\n\n\t// public void setExportAllocationInformation(List<ExportAllocationInformation> info) {\n\t// allocationInfo = info;\n\t// }\n\n\tpublic void setSelectionTime(long time) {\n\t\tselectionTime = time;\n\t}\n\n\tpublic void add(ExportAllocationInformation ass) {\n\t\tallocationInfo.add(ass);\n\n\t}\n}\n"}, {"id": "AbstractPosition.java", "body": "package edu.nd.dronology.core.coordinate;\n\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\n/**\n * A terrestrial position in WGS-84. this class implements utility methods for\n * subclasses.\n * \n * @author Michael Murphy\n *\n */ \npublic abstract class AbstractPosition {\n\n\t/**\n\t * Convert this position if necessary to an NVector.\n\t * \n\t * @return a terrestrial position defined an NVector and an altitude.\n\t */\n\tpublic abstract NVector toNVector();\n\n\t/**\n\t * Convert this position if necessary to a PVector.\n\t * \n\t * @return a terrestrial position defined an X, Y and Z coordinate.\n\t */\n\tpublic abstract PVector toPVector();\n\n\t/**\n\t * Convert this position if necessary to an LlaCoordinate.\n\t * \n\t * @return a terrestrial position defined by a latitude, longitude, and\n\t *         altitude.\n\t */\n\tpublic abstract LlaCoordinate toLlaCoordinate();\n\n\t/**\n\t * Calculates the distance from this position to other position. This is the\n\t * distance a laser bean would travel to reach the other point.\n\t * \n\t * @param other\n\t *            the position of the point to calculate the distance to.\n\t * @return the distance to the other position in meters\n\t */\n\tpublic double distance(AbstractPosition other) {\n\t\treturn NVector.laserDistance(this.toNVector(), other.toNVector());\n\t}\n\n\t/**\n\t * Calculates the distance a drone would realistically travel to get from\n\t * this position to the other position.\n\t * \n\t * Warning! this code is slow. The time it takes to run is proportional to the\n\t * distance from this to other.\n\t * \n\t * @param other\n\t *            the position of the point to calculate the distance to.\n\t * @return the distance a drone would need to travel to get to the other\n\t *         position in meters\n\t */\n\tpublic double travelDistance(AbstractPosition other) {\n\t\treturn NVector.travelDistance(this.toNVector(), other.toNVector());\n\t}\n\n\t/**\n\t * Calculate the rotation matrix representation of this position. This\n\t * rotation matrix can take displacement vectors in ECEF coordinates and\n\t * rotate them into NED coordinates at this position.\n\t * \n\t * This position cannot be at the poles as north and east directions don't\n\t * make sense there.\n\t * \n\t * This is the matrix inverse of equation 11 in <a href=\n\t * \"http://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf\">this\n\t * paper.</a>\n\t * \n\t * \n\t * @return a 3x3 rotation matrix where the rows can be interpreted as\n\t *         unit vectors pointing in the north, east and down directions\n\t *         respectively.\n\t */\n\tpublic RealMatrix toRotMatrix() {\n\t\tNVector n = this.toNVector();\n\t\tVector3D nvec = new Vector3D(n.getX(), n.getY(), n.getZ());\n\t\tVector3D z = new Vector3D(0, 0, 1);\n\t\tVector3D east = z.crossProduct(nvec).normalize();\n\t\tVector3D north = nvec.crossProduct(east).normalize();\n\t\tVector3D down = nvec.negate();\n\t\tdouble[][] data = { north.toArray(), east.toArray(), down.toArray() };\n\t\treturn new Array2DRowRealMatrix(data);\n\t}\n\n\t/**\n\t * Calculates the number of meters North, East and down (NED coordinates)\n\t * from this position to another global position.\n\t * \n\t * @param other\n\t *            the terrestrial position to transform into NED coordinates\n\t *            using this position as the origin\n\t * @return the NED coordinates as a vector with 3 elements where the first\n\t *         (0th) element is the number of meters north, the second element\n\t *         is the number of meters east and the third element is the number\n\t *         of meters down.\n\t */\n\tpublic Vector3D findNed(AbstractPosition other) {\n\t\tVector3D self = makeVector3D(this);\n\t\tVector3D otherVec = makeVector3D(other);\n\t\tVector3D displacement = otherVec.subtract(self);\n\t\tRealMatrix tmp = new Array2DRowRealMatrix(displacement.toArray());\n\t\treturn new Vector3D(this.toRotMatrix().multiply(tmp).getColumn(0));\n\t}\n\n\t/**\n\t * Calculates the latitude, longitude and altitude of a relative position\n\t * given as the number of meters North, East, and down from this position.\n\t * \n\t * @param ned\n\t *            a vector with three elements where the first is the number of\n\t *            meters north, the second is the number of meters east, and the\n\t *            third is the number of meters down.\n\t * @return the latitude longitude and altitude of the other position\n\t */\n\tpublic LlaCoordinate findLla(Vector3D ned) {\n\t\tVector3D self = makeVector3D(this);\n\t\tRealMatrix tmp = new Array2DRowRealMatrix(ned.toArray());\n\t\tVector3D d = new Vector3D(this.toRotMatrix().transpose().multiply(tmp).getColumn(0));\n\t\tVector3D p = self.add(d);\n\t\treturn new PVector(p.getX(), p.getY(), p.getZ()).toLlaCoordinate();\n\t}\n\n\tprivate static Vector3D makeVector3D(AbstractPosition pos) {\n\t\tPVector p = pos.toPVector();\n\t\treturn new Vector3D(p.getX(), p.getY(), p.getZ());\n\t}\n\n}\n"}, {"id": "FormatUtil.java", "body": "package edu.nd.dronology.core.util;\n\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.concurrent.TimeUnit;\n\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class FormatUtil {\n\tstatic ILogger LOGGER = LoggerProvider.getLogger(FormatUtil.class);\n\n\tpublic static final String FORMAT_YEAR_FIRST = \"yyyy-MM-dd HH:mm:ss\";\n\tpublic static final String FORMAT_YEAR_FIRST_MILLIS = \"yyyy-MM-dd HH:mm:ss.SSS\";\n\tpublic static final String FORMAT_FILE = \"yyyy_MM_dd_HH_mm_ss\";\n\tpublic static final String FORMAT_HOUR_FIRST_MILLIS = \"HH:mm:ss.SSS\";\n\n\t// public static final String FORMAT_YEAR_FIRST = \"yyyy-MM-dd HH:mm:ss\";\n\tpublic static final String FORMAT_DATE_STD = \"E M yy\";\n\n\tpublic static String formatTimestamp(long timestamp) {\n\t\treturn formatTimestamp(timestamp, FORMAT_YEAR_FIRST);\n\t}\n\n\tpublic static String formatTimeElapsed(long l) {\n\t\tfinal long hr = TimeUnit.MILLISECONDS.toHours(l);\n\t\tfinal long min = TimeUnit.MILLISECONDS.toMinutes(l - TimeUnit.HOURS.toMillis(hr));\n\t\tfinal long sec = TimeUnit.MILLISECONDS.toSeconds(l - TimeUnit.HOURS.toMillis(hr) - TimeUnit.MINUTES.toMillis(min));\n\t\treturn String.format(\"%02d:%02d:%02d\", hr, min, sec);\n\t}\n\n\tpublic static String formatTimestamp(long timestamp, String format) {\n\t\tDateFormat formatter = new SimpleDateFormat(format);\n\t\tCalendar c = new GregorianCalendar();\n\t\tc.setTimeInMillis(timestamp);\n\t\treturn formatter.format(c.getTime());\n\t}\n\n\tpublic static String formatTimestamp(PreciseTimestamp timestamp, String format) {\n\t\treturn formatTimestamp(timestamp.getTimestamp(), format);\n\t}\n\tpublic static String formatTimestamp(PreciseTimestamp timestamp){\n\t\treturn formatTimestamp(timestamp.getTimestamp());\n\t\t}\n\n\tpublic static long unformatTimestamp(String timestamp, String type) {\n\t\tDateFormat formatter = new SimpleDateFormat(type);\n\t\tDate date;\n\t\tlong dateInLong = -1;\n\t\ttry {\n\t\t\tdate = formatter.parse(timestamp);\n\t\t\tdateInLong = date.getTime();\n\t\t\treturn dateInLong;\n\t\t} catch (ParseException ex) {\n\t\t\tLOGGER.error(ex);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static boolean canParse(String timestamp, String type) {\n\t\tDateFormat formatter = new SimpleDateFormat(type);\n\t\ttry {\n\t\t\tformatter.parse(timestamp);\n\t\t\treturn true;\n\t\t} catch (ParseException ex) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n}\n"}, {"id": "IRemoteableService.java", "body": "package edu.nd.dronology.services.core.remote;\n\nimport java.io.Serializable;\nimport java.rmi.RemoteException;\n\nimport edu.nd.dronology.services.core.api.IRemotable;\nimport edu.nd.dronology.services.core.api.ServiceInfo;\nimport edu.nd.dronology.services.core.listener.IServiceListener;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic interface IRemoteableService extends IRemotable, Serializable {\n\n\tServiceInfo getServiceInfo() throws RemoteException;\n\n\tvoid startService() throws RemoteException, DronologyServiceException;\n\n\tvoid stopService() throws RemoteException, DronologyServiceException;\n\n\tboolean removeServiceListener(IServiceListener servicelistener) throws RemoteException;\n\n\tboolean addServiceListener(IServiceListener servicelistener) throws RemoteException;\n\n\tvoid restartService() throws RemoteException, DronologyServiceException;\n\n}\n"}, {"id": "IFlightPlan.java", "body": "package edu.nd.dronology.core.flight;\n\nimport java.io.Serializable;\nimport java.util.List;\n\nimport edu.nd.dronology.core.Discuss;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.exceptions.FlightZoneException;\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\n\n@Discuss(discuss = \"this interface is currently exposed - i.e. managed drone is exposed \")\npublic interface IFlightPlan extends Serializable {\n\n\tManagedDrone getAssignedDrone();\n\n\tboolean setStatusToCompleted() throws FlightZoneException;\n\n\tLlaCoordinate getStartLocation();\n\n\tLlaCoordinate getEndLocation();\n\n\tvoid clearAssignedDrone();\n\n\tString getFlightID();\n\n\tboolean setStatusToFlying(ManagedDrone drone) throws FlightZoneException;\n\n\tList<Waypoint> getWayPoints();\n\n\tlong getStartTime();\n\n\tlong getEndTime();\n\n\tString getDesignatedDroneId();\n\n\tboolean isCompleted();\n\n\tdouble getTakeoffAltitude();\n\n\tvoid setDesignatedDroneId(String uavid);\n\n}\n"}, {"id": "IFlightManagerRemoteService.java", "body": "package edu.nd.dronology.services.core.remote;\n\nimport java.rmi.RemoteException;\nimport java.util.Collection;\nimport java.util.List;\n\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.services.core.info.FlightInfo;\nimport edu.nd.dronology.services.core.info.FlightPlanInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n/**\n * \n * @author Michael Vierhauser\n * \n */\npublic interface IFlightManagerRemoteService extends IRemoteableService {\n\n\tvoid planFlight(String planName, List<Waypoint> wayPoints) throws RemoteException, Exception;\n\n\tvoid planFlight(String uavid, String planName, List<Waypoint> wayPoints) throws RemoteException, Exception;\n\n\tvoid returnToHome(String uavid) throws RemoteException, Exception;\n\n\tvoid takeoff(String uavid, double altitude) throws RemoteException, DronologyServiceException;\n\n\tvoid pauseFlight(String iavid) throws RemoteException, Exception;\n\n\tFlightInfo getFlightInfo(String uavId) throws RemoteException, Exception;\n\n\tCollection<FlightPlanInfo> getCurrentFlights() throws RemoteException;\n\n\tvoid cancelPendingFlights(String uavid) throws RemoteException, Exception;\n\n}\n"}, {"id": "MapDrawingUtil.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.vaadin.addon.leaflet.LMap;\nimport org.vaadin.addon.leaflet.LMarker;\nimport org.vaadin.addon.leaflet.LPolyline;\nimport org.vaadin.addon.leaflet.shared.Point;\n\nimport com.vaadin.server.Resource;\nimport com.vaadin.ui.Notification;\n\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.info.FlightPlanInfo;\nimport edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;\nimport edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;\nimport edu.nd.dronology.ui.vaadin.start.MyUI;\nimport edu.nd.dronology.ui.vaadin.utils.ImageProvider;\nimport edu.nd.dronology.ui.vaadin.utils.MapMarkerUtilities;\nimport edu.nd.dronology.ui.vaadin.utils.UIWayPoint;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * Utility class for drawing marker and UAV icons on the map <br>\n * <b>NEEDS ADDITIONAL CLEANUP & REFACTORING!<b>\n * \n * @author Michael Vierhauser\n *\n */\npublic class MapDrawingUtil {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(MapDrawingUtil.class);\n\n\tprivate LMap leafletMap;\n\tprivate MapMarkerUtilities utilities;\n\n\tprivate List<List<LMarker>> wayPointMarkers = new ArrayList<>();\n\tprivate List<List<LPolyline>> flightRoutes = new ArrayList<>();\n\tprivate ArrayList<LMarker> markers = new ArrayList<>();\n\n\tprivate Resource droneIconFocused = ImageProvider.getFocusUAVResource();\n\tprivate Resource droneIcon = ImageProvider.getDefaultUAVResource(); \n\tprivate Resource droneIconSelected = ImageProvider.getSelectedUAVResource();\n\n\tprivate Resource dotIcon = ImageProvider.getDotIconResource();\n\n\tprivate AFMapComponent mapComponent;\n\n\tBaseServiceProvider provider;\n\tprivate IFlightManagerRemoteService flightManagerService;\n\tprivate IDroneSetupRemoteService droneSetupService;\n\n\tprivate double ACHN_X = 11;\n\n\tprivate double ANCH_Y = 23;\n\n\tpublic MapDrawingUtil(LMap leafletMap, AFMapComponent mapComponent) {\n\t\tthis.leafletMap = leafletMap;\n\t\tthis.mapComponent = mapComponent;\n\t\tutilities = new MapMarkerUtilities(leafletMap);\n\t\tinitConnection();\n\n\t}\n\n\tprivate void initConnection() {\n\t\ttry {\n\t\t\tprovider = MyUI.getProvider();\n\t\t\tflightManagerService = (IFlightManagerRemoteService) provider.getRemoteManager()\n\t\t\t\t\t.getService(IFlightManagerRemoteService.class);\n\t\t\tdroneSetupService = (IDroneSetupRemoteService) provider.getRemoteManager()\n\t\t\t\t\t.getService(IDroneSetupRemoteService.class);\n\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\tMyUI.setConnected(false);// reconnect to dronology if connection is lost\n\t\t\ttry {\n\t\t\t\tNotification.show(\"Reconnecting...\");\n\t\t\t\tdroneSetupService = (IDroneSetupRemoteService) provider.getRemoteManager()\n\t\t\t\t\t\t.getService(IDroneSetupRemoteService.class);\n\t\t\t\tflightManagerService = (IFlightManagerRemoteService) provider.getRemoteManager()\n\t\t\t\t\t\t.getService(IFlightManagerRemoteService.class);\n\t\t\t} catch (RemoteException | DronologyServiceException e1) {\n\t\t\t\tNotification.show(\"Reconnecting...\");\n\t\t\t}\n\t\t\tNotification.show(\"Reconnecting...\");\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This function gets the flight routes from dronology core and draws them on the map.\n\t * \n\t * @param focused\n\t *          this is the drone that is focused in the AFInfoPanel. It's flight route will be orange\n\t * @param checked\n\t *          this is a list of drones that have their checkbox checked in the AFInfoPanel. Their routes will be black.\n\t */\n\tpublic void addActiveFlightRoutes(String focused, List<String> checked) {\n\t\ttry {\n\t\t\tCollection<FlightPlanInfo> currentFlights = flightManagerService.getCurrentFlights();\n\t\t\tfor (FlightPlanInfo e : currentFlights) { // goes through each route\n\t\t\t\tList<Waypoint> coordinates = e.getWaypoints();\n\t\t\t\tList<UIWayPoint> wayPoints = new ArrayList<>();\n\t\t\t\tList<LMarker> wayPointMarker = new ArrayList<>();\n\t\t\t\tint i = 0;\n\t\t\t\tfor (Waypoint coord : coordinates) { // goes through all the coordinates in each route\n\t\t\t\t\tPoint point = new Point(coord.getCoordinate().getLatitude(), coord.getCoordinate().getLongitude());\n\t\t\t\t\tUIWayPoint wayPoint = new UIWayPoint(point, nextReached(coordinates, i + 1));\n\t\t\t\t\twayPoints.add(wayPoint);\n\t\t\t\t\tif (wayPointMarkers.size() != currentFlights.size()) { // adds the waypoints to the map first\n\t\t\t\t\t\tLMarker marker = new LMarker(point);\n\t\t\t\t\t\tmarker.setIcon(dotIcon);\n\t\t\t\t\t\tmarker.setIconSize(new Point(10, 10));\n\t\t\t\t\t\tmarker.addMouseOverListener(mapComponent.getWaypointListener());\n\t\t\t\t\t\twayPointMarker.add(marker);\n\t\t\t\t\t\tleafletMap.addComponent(marker);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tList<LPolyline> polyLines = new ArrayList<>(); // draws the lines and loads them into a list\n\t\t\t\tif (e.getDroneId().equals(focused)) {\n\t\t\t\t\tutilities.removeAllLines();\n\t\t\t\t\tpolyLines = utilities.drawLinesForWayPoints(wayPoints, 2, true);\n\t\t\t\t} else {\n\t\t\t\t\tboolean drawn = false;\n\t\t\t\t\tfor (String name : checked) {\n\t\t\t\t\t\tif (e.getDroneId().equals(name)) { \n\t\t\t\t\t\t\tutilities.removeAllLines();\n\t\t\t\t\t\t\tpolyLines = utilities.drawLinesForWayPoints(wayPoints, 1, true);\n\t\t\t\t\t\t\tdrawn = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!drawn) {\n\t\t\t\t\t\t// utilities.removeAllLines();\n\t\t\t\t\t\tpolyLines = utilities.drawLinesForWayPoints(wayPoints, 0, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tflightRoutes.add(polyLines); // keep a list of all lines and markers\n\t\t\t\tif (wayPointMarkers.size() != currentFlights.size())\n\t\t\t\t\twayPointMarkers.add(wayPointMarker);\n\t\t\t}\n\t\t} catch (RemoteException e) { // reconnect to dronology if connection is lost\n\t\t\tinitConnection();\n\t\t}\n\t}\n\n\t/**\n\t * updates the flight routes. Deletes old ones, adds new ones, and redraws the lines to different colors as each waypoint is reached\n\t * \n\t * @param focused\n\t *          this is the drone that is focused in the AFInfoPanel. It's flight route will be orange\n\t * @param checked\n\t *          this is a list of drones that have their checkbox checked in the AFInfoPanel. Their routes will be black.\n\t */\n\tpublic void updateActiveFlightRoutes(String focused, List<String> checked) {\n\t\ttry {\n\t\t\tCollection<FlightPlanInfo> currentFlights = flightManagerService.getCurrentFlights();\n\t\t\tif (currentFlights.size() != flightRoutes.size() || true) {\n\t\t\t\tutilities.removeAllLines();\n\t\t\t\tboolean exists = true; // determines if flight route is still active\n\t\t\t\tfor (List<LMarker> e : wayPointMarkers) {\n\t\t\t\t\tboolean individualExist = false; // helper variable to determine if each flight route is still active\n\t\t\t\t\tfor (FlightPlanInfo q : currentFlights) {\n\t\t\t\t\t\tif (e.get(0).getPoint().getLat() == q.getWaypoints().get(0).getCoordinate().getLatitude()\n\t\t\t\t\t\t\t\t&& e.get(0).getPoint().getLon() == q.getWaypoints().get(0).getCoordinate().getLongitude()) {\n\t\t\t\t\t\t\tindividualExist = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (individualExist == false)\n\t\t\t\t\t\texists = false;\n\t\t\t\t}\n\t\t\t\tif (!exists || wayPointMarkers.size() != currentFlights.size()) { // if flight doesn't exist, remove it's waypoint markers\n\t\t\t\t\tfor (List<LMarker> lmarkers : wayPointMarkers) {\n\t\t\t\t\t\tfor (LMarker m : lmarkers) {\n\t\t\t\t\t\t\tutilities.getMap().removeComponent(m);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twayPointMarkers.clear();\n\t\t\t\t\tif (!mapComponent.getFollow() && flightRoutes.size() < currentFlights.size()) // only reset the center when a flight route is added\n\t\t\t\t\t\tmapComponent.setAverageCenter();\n\t\t\t\t}\n\t\t\t}\n\t\t\tflightRoutes.clear();\n\t\t\t/*\n\t\t\t * if (wayPointMarkers.size() != flightRoutes.size()){ for (ArrayList<LMarker> e:wayPointMarkers){ utilities.removeAllMarkers(e); } wayPointMarkers.clear(); } flightRoutes.clear();\n\t\t\t */\n\t\t\tthis.addActiveFlightRoutes(focused, checked); // redraw the flight routes\n\t\t\t// }\n\n\t\t} catch (RemoteException e) { // reconnect to dronology\n\t\t\tinitConnection();\n\t\t}\n\t}\n\n\t/**\n\t * This function updates the position of the drone icons on the map\n\t * \n\t * @param focused\n\t *          this is the drone that is focused in the AFInfoPanel. It's flight route will be orange\n\t * @param checked\n\t *          this is a list of drones that have their checkbox checked in the AFInfoPanel. Their routes will be black.\n\t */\n\tpublic void updateDroneMarkers(String focused, List<String> checked) {\n\t\ttry {\n\t\t\tCollection<IUAVProxy> drones = droneSetupService.getActiveUAVs();\n\t\t\tArrayList<LMarker> remove = new ArrayList<>();\n\t\t\tif (markers.size() == drones.size()) {\n\t\t\t\tfor (LMarker marker : markers) {\n\t\t\t\t\tboolean exists = false;\n\t\t\t\t\tfor (IUAVProxy e : drones) {\n\t\t\t\t\t\tif (marker.getId().equals(e.getID())) { // if the marker correlates to the drone\n\t\t\t\t\t\t\tPoint temp = new Point();\n\t\t\t\t\t\t\ttemp.setLat(e.getLatitude()); // update location\n\t\t\t\t\t\t\ttemp.setLon(e.getLongitude());\n\t\t\t\t\t\t\tmarker.setPoint(temp);\n\t\t\t\t\t\t\tif (marker.getId().equals(focused))\n\t\t\t\t\t\t\t\tmarker.setIcon(droneIconFocused);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tboolean chosen = false;\n\t\t\t\t\t\t\t\tfor (String name : checked) {\n\t\t\t\t\t\t\t\t\tif (marker.getId().equals(name)) {\n\t\t\t\t\t\t\t\t\t\tmarker.setIcon(droneIconSelected);\n\t\t\t\t\t\t\t\t\t\tchosen = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!chosen)\n\t\t\t\t\t\t\t\t\tmarker.setIcon(droneIcon);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\texists = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!exists) { // if the drone that is represented by the marker is no longer active or if the drone is new\n\t\t\t\t\t\tremove.add(marker);\n\t\t\t\t\t\tfor (IUAVProxy e1 : drones) {\n\t\t\t\t\t\t\tboolean old = false;\n\t\t\t\t\t\t\tfor (LMarker marker1 : markers) {\n\t\t\t\t\t\t\t\tif (e1.getID().equals(marker1.getId()))\n\t\t\t\t\t\t\t\t\told = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!old) { // the drone does not have a marker represented by it\n\t\t\t\t\t\t\t\tLMarker newMarker = new LMarker(e1.getLatitude(), e1.getLongitude());\n\t\t\t\t\t\t\t\tnewMarker.setId(e1.getID());\n\t\t\t\t\t\t\t\tif (marker.getId().equals(focused))\n\t\t\t\t\t\t\t\t\tmarker.setIcon(droneIconFocused);\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tboolean chosen = false;\n\t\t\t\t\t\t\t\t\tfor (String name : checked) {\n\t\t\t\t\t\t\t\t\t\tif (marker.getId().equals(name)) {\n\t\t\t\t\t\t\t\t\t\t\tmarker.setIcon(droneIconSelected);\n\t\t\t\t\t\t\t\t\t\t\tchosen = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!chosen)\n\t\t\t\t\t\t\t\t\t\tmarker.setIcon(droneIcon);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnewMarker.setIconSize(new Point(33, 33));\n\t\t\t\t\t\t\t\tnewMarker.setIconAnchor(new Point(ACHN_X, ANCH_Y));\n\t\t\t\t\t\t\t\tnewMarker.addMouseOverListener(mapComponent.getDroneListener());\n\t\t\t\t\t\t\t\tmarkers.add(newMarker);\n\t\t\t\t\t\t\t\tleafletMap.addComponent(newMarker);\n\t\t\t\t\t\t\t\tif (!mapComponent.getFollow())\n\t\t\t\t\t\t\t\t\tmapComponent.setAverageCenter();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (markers.size() < drones.size()) {\n\t\t\t\tfor (IUAVProxy e : drones) {\n\t\t\t\t\tboolean exists = false;\n\t\t\t\t\tfor (LMarker marker : markers) {\n\t\t\t\t\t\tif (e.getID().equals(marker.getId()))\n\t\t\t\t\t\t\texists = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!exists) {\n\t\t\t\t\t\tLMarker marker = new LMarker(e.getLatitude(), e.getLongitude()); // create new marker for the drone\n\t\t\t\t\t\tmarker.setId(e.getID());\n\t\t\t\t\t\tif (marker.getId().equals(focused))\n\t\t\t\t\t\t\tmarker.setIcon(droneIconFocused);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tboolean chosen = false;\n\t\t\t\t\t\t\tfor (String name : checked) {\n\t\t\t\t\t\t\t\tif (marker.getId().equals(name)) {\n\t\t\t\t\t\t\t\t\tmarker.setIcon(droneIconSelected);\n\t\t\t\t\t\t\t\t\tchosen = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!chosen)\n\t\t\t\t\t\t\t\tmarker.setIcon(droneIcon);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmarker.setIconSize(new Point(33, 33));\n\t\t\t\t\t\tmarker.addMouseOverListener(mapComponent.getDroneListener());\n\t\t\t\t\t\tmarker.setIconAnchor(new Point(ACHN_X, ANCH_Y));\n\t\t\t\t\t\tmarkers.add(marker);\n\t\t\t\t\t\tleafletMap.addComponent(marker);\n\t\t\t\t\t\tif (!mapComponent.getFollow())\n\t\t\t\t\t\t\tmapComponent.setAverageCenter();\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (markers.size() > drones.size()) {\n\t\t\t\tfor (LMarker marker : markers) {\n\t\t\t\t\tboolean exists = false;\n\t\t\t\t\tfor (IUAVProxy e : drones) {\n\t\t\t\t\t\tif (e.getID().equals(marker.getId()))\n\t\t\t\t\t\t\texists = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!exists) // remove marker that represents a deactivated drone\n\t\t\t\t\t\tremove.add(marker);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (remove.size() > 0) {\n\t\t\t\tfor (LMarker e : remove) {\n\t\t\t\t\tmarkers.remove(e);\n\t\t\t\t\tleafletMap.removeComponent(e);\n\t\t\t\t\tif (!mapComponent.getFollow())\n\t\t\t\t\t\tmapComponent.setAverageCenter();\n\t\t\t\t}\n\t\t\t\tremove.clear();\n\t\t\t}\n\t\t} catch (RemoteException e) { // reconnect to dronology\n\t\t\tinitConnection();\n\t\t}\n\t}\n\n\t/**\n\t * This function adds icons on the map that represent each drone's position.\n\t * \n\t * @param focused\n\t *          this is the drone that is focused in the AFInfoPanel. It's flight route will be orange\n\t * @param checked\n\t *          this is a list of drones that have their checkbox checked in the AFInfoPanel. Their routes will be black.\n\t */\n\tpublic void addDroneMarkers(String focused, List<String> checked) {\n\t\tCollection<IUAVProxy> drones = Collections.emptyList();\n\t\ttry {\n\t\t\tdrones = droneSetupService.getActiveUAVs();\n\t\t} catch (RemoteException e1) {\n\t\t\tinitConnection();\n\t\t}\n\t\tfor (\n\n\t\tIUAVProxy e : drones) {\n\t\t\tLMarker marker = new LMarker(e.getLatitude(), e.getLongitude());\n\t\t\tmarker.setId(e.getID());\n\t\t\tif (marker.getId().equals(focused))\n\t\t\t\tmarker.setIcon(droneIconFocused);\n\t\t\telse {\n\t\t\t\tboolean chosen = false;\n\t\t\t\tfor (String name : checked) {\n\t\t\t\t\tif (marker.getId().equals(name)) {\n\t\t\t\t\t\tmarker.setIcon(droneIconSelected);\n\t\t\t\t\t\tchosen = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!chosen)\n\t\t\t\t\tmarker.setIcon(droneIcon);\n\t\t\t}\n\t\t\tmarker.setIconSize(new Point(30, 30));\n\t\t\tmarker.setIconAnchor(new Point(ACHN_X, ANCH_Y));\n\t\t\tmarker.addMouseOverListener(mapComponent.getDroneListener());\n\t\t\tmarkers.add(marker);\n\t\t\tleafletMap.addComponent(marker);\n\t\t\tif (!mapComponent.getFollow())\n\t\t\t\tmapComponent.setAverageCenter();\n\t\t}\n\t}\n\n\t/**\n\t * assists in the logic of updating flight routes\n\t * \n\t * @param coordinates\n\t * @param i\n\t * @return\n\t */\n\tprivate boolean nextReached(List<Waypoint> coordinates, int i) {\n\t\tif (coordinates.size() <= i) {\n\t\t\treturn false;\n\t\t}\n\t\tWaypoint next = coordinates.get(i);\n\t\treturn next.isReached();\n\t}\n\n}\n"}, {"id": "AbstractServiceInstance.java", "body": "package edu.nd.dronology.services.core.base;\n\nimport java.util.ArrayList;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport org.apache.commons.lang.StringUtils;\n\nimport edu.nd.dronology.services.core.api.IServiceInstance;\nimport edu.nd.dronology.services.core.api.ServiceInfo;\nimport edu.nd.dronology.services.core.api.ServiceStatus;\nimport edu.nd.dronology.services.core.listener.IServiceListener;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.util.NamedThreadFactory;\nimport edu.nd.dronology.util.NullUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Base class for all service instance implementations.\n * \n * @author Michael Vierhauser\n * \n */\npublic abstract class AbstractServiceInstance implements IServiceInstance {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(AbstractServiceInstance.class);\n\tprivate static final Properties EMPTY_PROPERTIES = new Properties();\n\tprotected static final ExecutorService servicesExecutor = Executors.newFixedThreadPool(25,\n\t\t\tnew NamedThreadFactory(\"Service-Threads\"));\n\n\tprivate final String ID;\n\tprivate String description;\n\tprivate ServiceStatus status = ServiceStatus.STOPPED;\n\tprivate List<IServiceListener> serviceListener = new ArrayList<>();\n\n\tprivate Properties properties;\n\tprotected String PORT_PROPERTY = \"\";\n\n\t/**\n\t * \n\t * @param ID\n\t *            The id of the service.\n\t */\n\tpublic AbstractServiceInstance(String ID) {\n\t\tthis(ID, \"\");\n\t}\n\n\t/**\n\t * \n\t * @param ID\n\t *            The id of the service.\n\t * @param description\n\t *            A description for the service.\n\t */\n\tpublic AbstractServiceInstance(String ID, String description) {\n\t\tNullUtil.checkNull(ID, description);\n\t\tthis.ID = ID;\n\t\tthis.description = description;\n\t\tPORT_PROPERTY = \"port-\" + ID;\n\t}\n\n\t@Override\n\tpublic String getServiceID() {\n\t\treturn ID;\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\t@Override\n\tpublic ServiceStatus getStatus() {\n\t\treturn status;\n\t}\n\n\t@Override\n\tpublic final boolean addServiceListener(IServiceListener listener) {\n\t\treturn serviceListener.add(listener);\n\t}\n\n\t@Override\n\tpublic final boolean remoteServiceListener(IServiceListener listener) {\n\t\treturn serviceListener.remove(listener);\n\t}\n\n\t@Override\n\tpublic final void startService() throws DronologyServiceException {\n\t\tif (getStatus() != ServiceStatus.RUNNING) {\n\t\t\ttry {\n\t\t\t\tdoStartService();\n\t\t\t\tsetStatus(ServiceStatus.RUNNING);\n\t\t\t\treturn;\n\t\t\t} catch (Exception e) {\n\t\t\t\tsetStatus(ServiceStatus.ERROR);\n\t\t\t\tthrow new DronologyServiceException(\"Error when starting service \" + this.getClass().getSimpleName(),\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t}\n\t\tthrow new DronologyServiceException(\"Service already running\");\n\t}\n\n\t@Override\n\tpublic final void stopService() throws DronologyServiceException {\n\t\tif (getStatus() == ServiceStatus.RUNNING) {\n\t\t\ttry {\n\t\t\t\tdoStopService();\n\t\t\t\tsetStatus(ServiceStatus.STOPPED);\n\t\t\t\treturn;\n\t\t\t} catch (Exception e) {\n\t\t\t\tsetStatus(ServiceStatus.ERROR);\n\t\t\t\tthrow new DronologyServiceException(\"Error when stopping service\", e);\n\t\t\t}\n\t\t}\n\t\tthrow new DronologyServiceException(\"Service not running\");\n\t}\n\n\t@Override\n\tpublic Properties getConfigurationProperties() {\n\t\tif (!hasProperties()) {\n\t\t\treturn EMPTY_PROPERTIES;\n\t\t}\n\t\tif (properties == null) {\n\t\t\tproperties = new Properties();\n\t\t\t// addGlobalProperties();\n\t\t\tif (getPropertyPath() == null || StringUtils.isEmpty(getPropertyPath())) {\n\t\t\t\tLOGGER.warn(\"No property path defined for \" + this.getClass().getSimpleName());\n\t\t\t\treturn properties;\n\t\t\t}\n\n\t\t}\n\t\treturn properties;\n\t}\n\n\t/**\n\t * Sets the status of the service. <br>\n\t * May be called from a subsequent server-thread or delegate.<br>\n\t * Not an interface method and therefore not intended to be called from\n\t * outside!\n\t * \n\t * @param status\n\t */\n\tpublic final void setStatus(ServiceStatus status) {\n\t\tNullUtil.checkNull(status);\n\t\t// LOGGER.trace(this.getClass().getSimpleName() + \" status set to: \" +\n\t\t// status);\n\t\tthis.status = status;\n\t\tfor (IServiceListener listener : serviceListener) {\n\t\t\tlistener.statusChanged(status);\n\t\t}\n\t}\n\n\t@Override\n\tpublic ServiceInfo getServiceInfo() {\n\t\tMap<String, String> attributes = new HashMap<>();\n\t\tMap<String, String> properties = new HashMap<>();\n\n\t\tfor (Entry<Object, Object> e : getConfigurationProperties().entrySet()) {\n\t\t\tproperties.put(e.getKey().toString(), e.getValue().toString());\n\t\t}\n\t\tServiceInfo sInfo = new ServiceInfo(this.getServiceID(), this.getStatus(), this.getDescription(), attributes,\n\t\t\t\tproperties, getOrder());\n\t\tsInfo.setServiceClass(getServiceClass().getCanonicalName());\n\t\treturn sInfo;\n\n\t}\n\n\tprotected void submitServiceThread(Runnable serverThread) {\n\t\tservicesExecutor.submit(serverThread);\n\t}\n\n\tprotected void checkRunning() throws DronologyServiceException {\n\t\tif (getStatus() != ServiceStatus.RUNNING)\n\t\t\tthrow new DronologyServiceException(\"Service not running!\");\n\t}\n\n\tprotected boolean hasProperties() {\n\t\treturn true;\n\t}\n\n\tprotected abstract Class<?> getServiceClass();\n\n\tprotected abstract int getOrder();\n\n\tprotected abstract String getPropertyPath();\n\n\tprotected abstract void doStartService() throws Exception;\n\n\tprotected abstract void doStopService() throws Exception;\n\n}\n"}, {"id": "DronologyServiceRunner.java", "body": "package edu.nd.dronology.services.launch;\n\nimport edu.nd.dronology.core.fleet.RuntimeDroneTypes;\nimport edu.nd.dronology.gstation.connector.service.connector.DroneConnectorService;\nimport edu.nd.dronology.monitoring.service.DroneMonitoringServiceRemoteFacade;\nimport edu.nd.dronology.monitoring.service.IDroneMonitoringRemoteService;\nimport edu.nd.dronology.services.core.remote.IAreaMappingRemoteService;\nimport edu.nd.dronology.services.core.remote.IMissionPlanningRemoteService;\nimport edu.nd.dronology.services.extensions.areamapping.facade.AreaMappingServiceRemoteFacade;\nimport edu.nd.dronology.services.extensions.areamapping.instances.AreaMappingService;\nimport edu.nd.dronology.services.extensions.missionplanning.service.MissionPlanningServiceRemoteFacade;\nimport edu.nd.dronology.services.extensions.missionplanning.service.internal.MissionPlanningService;\nimport edu.nd.dronology.services.instances.dronesetup.DroneSetupService;\nimport edu.nd.dronology.services.instances.dronesimulator.DroneSimulatorService;\nimport edu.nd.dronology.services.instances.flightmanager.FlightManagerService;\nimport edu.nd.dronology.services.instances.flightroute.FlightRouteplanningService;\nimport edu.nd.dronology.services.instances.registration.types.UAVTypeRegistrationService;\nimport edu.nd.dronology.services.instances.registration.uavs.UAVRegistrationService;\nimport edu.nd.dronology.services.remote.RemoteManager;\nimport edu.nd.dronology.services.remote.RemoteService;\nimport edu.nd.dronology.services.supervisor.SupervisorService;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class DronologyServiceRunner {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(DronologyServiceRunner.class);\n\tprivate static final boolean USE_SAFETY_CASES = true;\n\n\tpublic static void main(String[] args) {\n\n\t\ttry {\n\n\t\t\tRemoteService.getInstance().startService();\n\t\t\tSupervisorService.getInstance().startService();\n\t\t\tFlightRouteplanningService.getInstance().startService();\n\t\t\tFlightManagerService.getInstance().startService();\n\t\t\tDroneSetupService.getInstance().startService();\n\t\t\tUAVRegistrationService.getInstance().startService();\n\t\t\tDroneSimulatorService.getInstance().startService();\n\t\t\t\n\t\t\t\n\t\t\tUAVRegistrationService.getInstance().startService();\n\t\t\tUAVTypeRegistrationService.getInstance().startService();\n\t\t\t\n\n\t\t\tDroneConnectorService.getInstance().startService();\n\t\t\tRuntimeDroneTypes runtimeMode = RuntimeDroneTypes.getInstance();\n\n\t\t\truntimeMode.setPhysicalEnvironment();\n\n\t\t\t// Extension services....\n\t\t\tMissionPlanningService.getInstance().startService();\n\t\t\tAreaMappingService.getInstance().startService();\n\n\t\t\tRemoteManager.getInstance().contributeService(IMissionPlanningRemoteService.class,\n\t\t\t\t\tMissionPlanningServiceRemoteFacade.getInstance());\n\n\t\t\tRemoteManager.getInstance().contributeService(IDroneMonitoringRemoteService.class,\n\t\t\t\t\tDroneMonitoringServiceRemoteFacade.getInstance());\n\t\t\t\n\t\t\tRemoteManager.getInstance().contributeService(IAreaMappingRemoteService.class,\n\t\t\t\t\tAreaMappingServiceRemoteFacade.getInstance());\n\n\t\t\t// DronologyMonitoringManager.getInstance().registerHandler(new\n\t\t\t// MonitoringDataHandler3());\n\n\t\t\t// new SimpleMonitor().main(null);\n\t\t\t// SimpleChecker.getInstance().init();\n\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n}\n"}, {"id": "IItemChangeListener.java", "body": "package edu.nd.dronology.services.core.listener;\n\nimport java.rmi.RemoteException;\nimport java.util.Set;\n\nimport edu.nd.dronology.services.core.api.IRemotable;\n\npublic interface IItemChangeListener extends IRemotable{\n\n\tvoid itemChanged(Set<String> info) throws RemoteException;\n\t\n}\n"}, {"id": "SupervisorService.java", "body": "package edu.nd.dronology.services.supervisor;\n\nimport java.util.Map;\n\n\nimport edu.nd.dronology.services.core.base.AbstractServerService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic class SupervisorService extends AbstractServerService<ISupervisorServiceInstance> {\n\n\tprivate static volatile SupervisorService INSTANCE;\n\n\tprotected SupervisorService() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @return The singleton SupervisorService instance\n\t */\n\tpublic static SupervisorService getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (SupervisorService.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new SupervisorService();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tprotected ISupervisorServiceInstance initServiceInstance() {\n\t\treturn new SupervisorServiceInstance();\n\t}\n\n\tpublic void shutdownServer() {\n\t\tserviceInstance.shutdownServer();\n\t}\n\n\tpublic void restartAllServices() {\n\t\tserviceInstance.restartAllServices();\n\t}\n\n\tpublic String getFlightPathLocation() {\n\t\treturn serviceInstance.getFlightPathLocation();\n\t}\n\n\tpublic String getSimScenarioLocation() {\n\t\treturn serviceInstance.getSimScenarioLocation();\n\t}\n\n\tpublic String getDroneSpecificationLocation() {\n\t\treturn serviceInstance.getDroneSpecificationLocation();\n\t}\n\t\n\tpublic String getAreaMappingLocation() {\n\t\treturn serviceInstance.getAreaMappingLocation();\n\t}\n\tpublic String getMissionPlanningLocation() {\n\t\treturn serviceInstance.getMissionPlanningLocation();\n\t}\n\n\tpublic String getWorkspaceLocation() {\n\t\treturn serviceInstance.getWorkspaceLocation();\n\n\t}\n\n\tpublic Map<String, String> getGlobalProperties() {\n\t\treturn serviceInstance.getGlobalProperties();\n\t}\n\n\tpublic boolean importItem(String fileName, byte[] byteArray, boolean overwrite) throws DronologyServiceException {\n\t\treturn serviceInstance.importItem(fileName, byteArray, overwrite);\n\t}\n\n\tpublic void restart(String serviceClass) throws DronologyServiceException {\n\t\tgetService(serviceClass).restartService();\n\n\t}\n\n}\n"}, {"id": "WaypointGoalSnapshot.java", "body": "package edu.nd.dronology.core.goal;\n\nimport edu.nd.dronology.core.coordinate.AbstractPosition;\n\npublic class WaypointGoalSnapshot implements IGoalSnapshot {\n    private final AbstractPosition position;\n    private final double speed;\n    private final AbstractGoal.GoalState state;\n\n    public WaypointGoalSnapshot(AbstractPosition position, double speed, AbstractGoal.GoalState state) {\n        this.position = position;\n        this.speed = speed;\n        this.state = state;\n    }\n\n    @Override\n    public AbstractGoal.GoalState getState() {\n        return state;\n    }\n\n    public AbstractPosition getPosition() {\n        return position;\n    }\n\n    public double getSpeed() {\n        return speed;\n    }\n}\n"}, {"id": "UAVPlanChangeMessage.java", "body": "//package edu.nd.dronology.core.monitoring.messages;\n//\n//import edu.nd.dronology.core.monitoring.ArtifactIdentifier;\n//import edu.nd.dronology.core.monitoring.IMonitorableMessage;\n//import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;\n//import edu.nd.dronology.core.util.PreciseTimestamp;\n//\n//public class UAVPlanChangeMessage implements IMonitorableMessage {\n//\n//\tprivate String uavid;\n//\tprivate long startTime;\n//\tprivate String type;\n//\tprivate String flightid;\n//\tprivate long endTime;\n//\tprivate final PreciseTimestamp timestamp;\n//\n//\tpublic UAVPlanChangeMessage(String uavid, String type, String flightid, long startTime, long endTime) {\n//\t\tthis.timestamp = PreciseTimestamp.create();\n//\t\tthis.uavid = uavid;\n//\t\tthis.type = type;\n//\t\tthis.flightid = flightid;\n//\t\tthis.startTime = startTime;\n//\t\tthis.endTime = endTime;\n//\t}\n//\n//\t@Override\n//\tpublic ArtifactIdentifier<?> getIdentifier() {\n//\t\treturn new ArtifactIdentifier(ArtifactIdentifier.ROOT, \"INTERNAL\", MessageType.PLAN_CHANGE.toString(), uavid);\n//\t}\n//\n//\tpublic String getUavid() {\n//\t\treturn uavid;\n//\t}\n//\n//\t@Override\n//\tpublic String getData() {\n//\t\t// TODO Auto-generated method stub\n//\t\treturn null;\n//\t}\n//\n//\t@Override\n//\tpublic PreciseTimestamp getTimestamp() {\n//\t\treturn timestamp;\n//\t}\n//\n//\t@Override\n//\tpublic MessageType getType() {\n//\t\treturn MessageType.PLAN_CHANGE;\n//\t}\n//\n//}\n"}, {"id": "FlightPlanFactory.java", "body": "package edu.nd.dronology.core.flight;\n\nimport java.util.List;\n\nimport edu.nd.dronology.core.flight.internal.FlightPlan;\nimport edu.nd.dronology.core.util.Waypoint;\n\npublic class FlightPlanFactory {\n\n\tpublic static IFlightPlan create(String uavid, String planName, List<Waypoint> waypoints) {\n\t\treturn new FlightPlan(uavid, planName, waypoints);\n\t}\n\n\tpublic static IFlightPlan create(String planName, List<Waypoint> waypoints) {\n\t\treturn new FlightPlan(planName, waypoints);\n\n\t}\n\n}\n"}, {"id": "DroneFleetListener.java", "body": "package edu.nd.dronology.core.fleet;\n\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\n\npublic interface DroneFleetListener {\n    void droneAdded(ManagedDrone managedDrone);\n    void droneRemoved(ManagedDrone managedDrone);\n}"}, {"id": "MissionInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nimport edu.nd.dronology.services.core.items.TagList;\n\npublic class MissionInfo extends RemoteInfoObject {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 6569277297683551416L;\n\tprivate TagList tags = new TagList();\n\tprivate long dateCreated;\n\tprivate long dateModified;\n\tprivate List<String> uavids;\n\tprivate String description;\n\n\tpublic MissionInfo(String name, String id) {\n\t\tsuper(name, id);\n\t\tuavids = new ArrayList<>();\n\t}\n\n\tpublic void setDateModified(long dateModified) {\n\t\tthis.dateModified = dateModified;\n\t}\n\n\tpublic void setDateCreated(long dateCreated) {\n\t\tthis.dateCreated = dateCreated;\n\t}\n\n\tpublic long getDateCreated() {\n\t\treturn dateCreated;\n\t}\n\n\tpublic long getDateModified() {\n\t\treturn dateModified;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\tpublic void addUavId(String uavid) {\n\t\tuavids.add(uavid);\n\t}\n\t\n\tpublic void removeUavId(String uavid) {\n\t\tuavids.remove(uavid);\n\t}\n\n\tpublic Collection<String> getUAVIds() {\n\t\treturn Collections.unmodifiableCollection(uavids);\n\t}\n\n\tpublic TagList getTags() {\n\t\treturn tags;\n\t}\n\n\tpublic void addTag(String tag) {\n\t\ttags.add(tag);\n\t}\n \n}\n"}, {"id": "SynchronizationManager.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.sync;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport edu.nd.dronology.core.DronologyConstants;\nimport edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * The {@link SynchronizationManager} holds a list of {@link SynchronizationPoint} and ensures that a point is fully synced<br>\n * before allowing UAVs to proceed with the next task.\n * \n * @author Jane Cleland-Huang \n * \n * \n *\n */\npublic class SynchronizationManager {\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(SynchronizationManager.class);\n\n\tprivate Map<String, SynchronizationPoint> synchPoints;\n\tprivate int availableAltitude = DronologyConstants.MISSION_TAKEOFF_MIN_ALTITUDE;\n\n\tprivate static transient SynchronizationManager INSTANCE;\n\n\tprivate SynchronizationManager() {\n\t\tsynchPoints = new HashMap<>();\n\t}\n\n\tpublic static SynchronizationManager getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (SynchronizationManager.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new SynchronizationManager();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\tpublic int getNextAltitude() throws MissionExecutionException {\n\t\tavailableAltitude += DronologyConstants.MISSION_TAKEOFF_ALTITUDE_INCREMENT;\n\t\tif (availableAltitude > DronologyConstants.MISSION_MAX_TAKEOFF_DISTANCE) {\n\t\t\tthrow new MissionExecutionException(\"Max altitude reached - No safe altitude available\");\n\t\t}\n\n\t\treturn availableAltitude;\n\t}\n\n\t// Create named synchronization point\n\tpublic SynchronizationPoint createSynchronizationPoint(String synchName) {\n\t\tif (!synchPoints.containsKey(synchName)) {\n\t\t\tSynchronizationPoint synchPoint = new SynchronizationPoint(synchName);\n\t\t\tsynchPoints.put(synchName, synchPoint);\n\t\t\treturn synchPoint;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic boolean synchPointExists(String synchName) {\n\t\treturn synchPoints.containsKey(synchName);\n\t}\n\n\t// Register a UAV for a synchPoint\n\tpublic boolean addSynchItem(String uavid, String synchName) {\n\t\tSynchronizationPoint synchPoint = synchPoints.get(synchName);\n\t\tif (synchPoint != null) {\n\t\t\tsynchPoint.registerCollaborator(uavid);\n\t\t\tLOGGER.missionInfo(\"Adding '\" + uavid + \"' to SYNC-Point\" + synchName);\n\t\t\treturn true;\n\t\t}\n\t\tLOGGER.missionError(\"Sync point '\" + synchName + \"' not available!\");\n\t\treturn false;\n\t}\n\n\t// Activate all synchronization points (we may not always want to do this -- but\n\t// it works for our current coordinated takeoff/landing\n\tpublic void activateAllSynchPoints() {\n\t\tsynchPoints.forEach((k, point) -> {\n\t\t\tpoint.activateSynchronizationPoint();\n\t\t});\n\t}\n\n\t// Remove UAV from the synch point it has visited\n\tpublic void uavVisitedSynchPoint(String uavid, String synchName) {\n\t\tSynchronizationPoint synchPoint = synchPoints.get(synchName);\n\t\tif (synchPoint != null) {\n\t\t\tsynchPoint.removeCollaborator(uavid);\n\t\t} else {\n\t\t\tLOGGER.missionError(\"Sync point '\" + synchName + \"' not found\");\n\t\t}\n\t}\n\n\t// Count number of UAVs who are yet to visit the synch point\n\tpublic int getCountOfUnsynchedUAVs(String synchName) {\n\t\tSynchronizationPoint synchPoint = synchPoints.get(synchName);\n\t\treturn synchPoint.countUnsynched();\n\t}\n\n\t// Check if all expected UAVs have visited\n\tpublic boolean isFullySynched(String synchName) {\n\t\tSynchronizationPoint synchPoint = synchPoints.get(synchName);\n\t\treturn synchPoint.isSynched();\n\t}\n\n\t// Remove UAV after it has visited\n\tpublic void removeUAV(String uavID) {\n\t\tfor (SynchronizationPoint sp : synchPoints.values()) {\n\t\t\tsp.removeCollaborator(uavID);\n\t\t}\n\t}\n\n\tpublic void resetAltitudes() {\n\t\tavailableAltitude = DronologyConstants.MISSION_TAKEOFF_MIN_ALTITUDE;\n\t}\n\n}"}, {"id": "CoordinateChange.java", "body": "package edu.nd.dronology.core;\n\n\npublic @interface CoordinateChange {\n\t\n\n\t \n\n}\n"}, {"id": "SearchPatternStrategy.java", "body": "package edu.nd.dronology.services.extensions.areamapping.internal;\n\nimport java.util.List;\n\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\n\npublic interface SearchPatternStrategy {\n\tpublic List<RoutePrimitive> generateRoutePrimitive(double APERATURE_HEIGHT, double OVERLAP_FACTOR);\n\n\tpublic void setSourcePoints(List<SourcePoints> points);\n\t\n\tpublic void setRouteType(RoutePrimitive.RouteType routeType);\n}\n"}, {"id": "IDroneMonitoringRemoteService.java", "body": "package edu.nd.dronology.monitoring.service;\n\nimport java.rmi.RemoteException;\n\nimport edu.nd.dronology.core.monitoring.ArtifactIdentifier;\nimport edu.nd.dronology.monitoring.IRemoteMonitoringMessageHandler;\nimport edu.nd.dronology.services.core.remote.IRemoteableService;\n\n/**\n *\n * \n * @author Michael Vierhauser\n * \n *  \n * \n */\npublic interface IDroneMonitoringRemoteService extends IRemoteableService {\n\n\tpublic void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler) throws RemoteException;\n\n\tpublic void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler, ArtifactIdentifier identifier)\n\t\t\tthrows RemoteException;\n\n\tvoid setMonitoringFrequency(String uavid, Double frequency) throws RemoteException;\n\n}\n"}, {"id": "DroneSimulatorServiceInstance.java", "body": "package edu.nd.dronology.services.instances.dronesimulator;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport edu.nd.dronology.core.util.Waypoint;\nimport edu.nd.dronology.services.core.api.IFileChangeNotifyable;\nimport edu.nd.dronology.services.core.api.ServiceInfo;\nimport edu.nd.dronology.services.core.base.AbstractFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo;\nimport edu.nd.dronology.services.core.info.DroneInitializationInfo.DroneMode;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.info.SimulatorScenarioCategoryInfo;\nimport edu.nd.dronology.services.core.info.SimulatorScenarioInfo;\nimport edu.nd.dronology.services.core.items.AssignedDrone;\nimport edu.nd.dronology.services.core.items.ISimulatorScenario;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport edu.nd.dronology.services.core.persistence.SimulatorScenarioPersistenceProvider;\nimport edu.nd.dronology.services.core.util.DronologyConstants;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.core.util.ServiceIds;\nimport edu.nd.dronology.services.instances.DronologyElementFactory;\nimport edu.nd.dronology.services.instances.dronesetup.DroneSetupService;\nimport edu.nd.dronology.services.instances.flightmanager.FlightManagerService;\nimport edu.nd.dronology.services.instances.flightroute.FlightRouteplanningService;\nimport edu.nd.dronology.services.supervisor.SupervisorService;\nimport edu.nd.dronology.util.FileUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class DroneSimulatorServiceInstance extends AbstractFileTransmitServiceInstance<SimulatorScenarioInfo>\n\t\timplements IFileChangeNotifyable, IDroneSimulatorServiceInstance {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(DroneSimulatorServiceInstance.class);\n\n\tprivate static final int ORDER = 5;\n\n\tpublic static final String EXTENSION = DronologyConstants.EXTENSION_SIM_SCENARIO;\n\n\tprivate Collection<SimulatorScenarioCategoryInfo> categories = new ArrayList<>();\n\n\tprivate Map<String, ISimulatorScenario> scenarios = new HashMap<>();\n\n\tpublic DroneSimulatorServiceInstance() {\n\t\tsuper(ServiceIds.SERVICE_SIMULATOR, \"DroneSimulator Management\", EXTENSION);\n\n\t\tcategories.add(new SimulatorScenarioCategoryInfo(\"Default\", \"Default\"));\n\n\t}\n\n\t@Override\n\tprotected Class<?> getServiceClass() {\n\t\treturn FlightRouteplanningService.class;\n\t}\n\n\t@Override\n\tprotected int getOrder() {\n\t\treturn ORDER;\n\t}\n\n\t@Override\n\tprotected String getPropertyPath() {\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void doStartService() throws Exception {\n\t\treloadItems();\n\t}\n\n\t@Override\n\tprotected void doStopService() throws Exception {\n\t\tfileManager.tearDown();\n\t}\n\n\t@Override\n\tpublic ServiceInfo getServiceInfo() {\n\t\tServiceInfo sInfo = super.getServiceInfo();\n\t\tsInfo.addAttribute(ServiceInfo.ATTRIBUTE_TYPE, ServiceInfo.ATTRIBUTE_FILE);\n\t\treturn sInfo;\n\t}\n\n\t@Override\n\tpublic SimulatorScenarioInfo createItem() throws DronologyServiceException {\n\t\tSimulatorScenarioPersistenceProvider persistor = SimulatorScenarioPersistenceProvider.getInstance();\n\t\tISimulatorScenario simulatorScenario = DronologyElementFactory.createNewSimulatorScenario();\n\t\tsimulatorScenario.setName(\"New-SimulatorScenario\");\n\t\tString savePath = FileUtil.concat(storagePath, simulatorScenario.getId(), EXTENSION);\n\n\t\ttry {\n\t\t\tpersistor.saveItem(simulatorScenario, savePath);\n\t\t} catch (PersistenceException e) {\n\t\t\tthrow new DronologyServiceException(\"Error when creating flightpath: \" + e.getMessage());\n\t\t}\n\t\treturn new SimulatorScenarioInfo(simulatorScenario.getName(), simulatorScenario.getId());\n\t}\n\n\t@Override\n\tprotected String getPath() {\n\t\tString path = SupervisorService.getInstance().getSimScenarioLocation();\n\t\treturn path;\n\t}\n\n\t@Override\n\tprotected SimulatorScenarioInfo fromFile(String id, File file) throws Throwable {\n\t\tISimulatorScenario atm = SimulatorScenarioPersistenceProvider.getInstance().loadItem(file.toURI().toURL());\n\t\tscenarios.put(id, atm);\n\t\tSimulatorScenarioInfo info = new SimulatorScenarioInfo(atm.getName(), id);\n\n\t\treturn info;\n\t}\n\n\t@Override\n\tprotected boolean hasProperties() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void notifyFileChange(Set<String> changed) {\n\t\tsuper.notifyFileChange(changed);\n\t\tfor (String s : changed) {\n\t\t\tString id = s.replace(\".\" + extension, \"\");\n\t\t\tif (!itemmap.containsKey(id)) {\n\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void activateScenario(SimulatorScenarioInfo scenario) throws DronologyServiceException {\n\t\tISimulatorScenario item = scenarios.get(scenario.getId());\n\t\tif (item == null) {\n\t\t\tthrow new DronologyServiceException(\"Scenario '\" + scenario.getId() + \"' not found\");\n\t\t}\n\t\tfor (AssignedDrone drone : item.getAssignedDrones()) {\n\t\t\tDroneSetupService.getInstance().initializeDrones(new DroneInitializationInfo(drone.getName(),\n\t\t\t\t\tDroneMode.MODE_VIRTUAL, drone.getName(), drone.getStartCoordinate()));\n\t\t}\n\n\t\tfor (String path : item.getAssignedFlightPaths()) {\n\n\t\t\tFlightRouteInfo info = FlightRouteplanningService.getInstance().getItem(path);\n\n\t\t\tList<Waypoint> coordds = new ArrayList<>(info.getWaypoints());\n\t\t\tList<Waypoint> waypoints = new ArrayList<>();\n\t\t\tfor (Waypoint c : coordds) {\n\t\t\t\twaypoints.add(c);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tFlightManagerService.getInstance().planFlight(info.getName(), waypoints);\n\t\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic Collection<SimulatorScenarioCategoryInfo> getCategories() {\n\t\treturn Collections.unmodifiableCollection(categories);\n\t}\n}\n"}, {"id": "IPersistenceManager.java", "body": "\npackage edu.nd.dronology.services.core.persistence;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic interface IPersistenceManager<T> {\n\t\n\tpublic T open(InputStream fin) throws PersistenceException;\n\n\tpublic boolean save(T o, OutputStream fout) throws PersistenceException;\n}\n"}, {"id": "ReturnHomeMessage.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal.message;\n\npublic class ReturnHomeMessage extends AbstractMessage {\n}\n"}, {"id": "TakeoffTask.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.tasks;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\npublic class TakeoffTask extends AbstractMissionTask {\n\n\tprivate final LlaCoordinate coordinate;\n\n\tprotected TakeoffTask(String uavID, LlaCoordinate coordinate) {\n\t\tsuper(uavID, coordinate.toString());\n\t\tthis.coordinate = coordinate;\n\t}\n\n\t@Override\n\tpublic LlaCoordinate getWaypoint() {\n\t\treturn coordinate;\n\t}\n}"}, {"id": "IUAVMissionDescription.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.io.Serializable;\nimport java.util.List;\n\npublic interface IUAVMissionDescription {\n\n\tString getName();\n\n\tList<IUAVMissionTask> getTasks();\n\n\tString getDescription();\n\n\tvoid setDescription(String description);\n\n\tvoid setName(String name);\n\n\tvoid addAttribute(String key, Serializable value);\n\n\tSerializable getAttributes(String key);\n\n\tvoid addTask(IUAVMissionTask task);\n\n\tvoid addTask(IUAVMissionTask task, int index);\n\n\tboolean removeTask(int index);\n\n\tboolean removeTask(IUAVMissionTask task);\n\n}\n"}, {"id": "RoutePrimitive.java", "body": "package edu.nd.dronology.services.extensions.areamapping.model;\n\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Point2D.Double;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Vector;\n\nimport edu.nd.dronology.services.extensions.areamapping.internal.Geometry;\nimport edu.nd.dronology.services.extensions.areamapping.internal.ImageWaypoints;\n\npublic class RoutePrimitive{\n\n\tprivate List<Point2D.Double> routePrimitive;\n\tprivate ImageWaypoints imageWaypoints;\n\tprivate boolean downstreamDirection;\n\tpublic enum RouteType {\n\t\tCRISSCROSS,\n\t\tINNER_CRISSCROSS,\n\t\tRIVERBANK,\n\t\tPRIORITYAREA,\n\t\tHOME\n\t}\n\tprivate final RouteType type;\n\tprivate int routeWeight;\n\t\n\tpublic RoutePrimitive(RouteType type, int routeWeight) {\n\t\tthis.type = type;\n\t\tthis.routeWeight = routeWeight;\n\t\troutePrimitive = new Vector<Point2D.Double>();\n\t\timageWaypoints = new ImageWaypoints();\n\t\tdownstreamDirection = true;\n\t}\n\t\n\tpublic void addRouteWaypoint(Point2D.Double routeWaypoint) {\n\t\troutePrimitive.add(routeWaypoint);\n\t}\n\t\n\tpublic void reverseRoute() {\n\t\tCollections.reverse(routePrimitive);\n\t\tif(downstreamDirection) {\n\t\t\tdownstreamDirection = false;\n\t\t} else {\n\t\t\tdownstreamDirection = true;\n\t\t}\n\t}\n\t\n\tpublic boolean getDownstreamDirection() {\n\t\treturn downstreamDirection;\n\t}\n\t\n\tpublic List<Point2D.Double> getRoute(){\n\t\treturn Collections.unmodifiableList(routePrimitive);\n\t}\n\t\n\tpublic Point2D.Double getRouteStartPoint(){\n\t\treturn routePrimitive.get(0);\n\t}\n\t\n\tpublic Point2D.Double getRouteEndPoint(){\n\t\treturn routePrimitive.get(size()-1);\n\t}\n\t\n\tpublic double getRouteDistance() {\n\t\treturn Geometry.routePrimitiveDistance(routePrimitive);\n\t}\n\t\n\tpublic Point2D.Double getRouteWaypoint(int entry){\n\t\treturn routePrimitive.get(entry);\n\t}\n\t\n\tpublic void insertRouteWaypoint(int index, Point2D.Double waypoint) {\n\t\troutePrimitive.add(index, waypoint);\n\t}\n\t\n\tpublic void setRouteWaypoint(int index, Point2D.Double entry) {\n\t\troutePrimitive.set(index, entry);\n\t}\n\t\n\tpublic int size() {\n\t\treturn routePrimitive.size();\n\t}\n\t\n\tpublic ImageWaypoints getIWP() {\n\t\treturn imageWaypoints;\n\t}\n\t\n\tpublic RouteType getRouteType() {\n\t\treturn type;\n\t}\n\t\n\tpublic int getRouteWeight() {\n\t\treturn routeWeight;\n\t}\n}\n"}, {"id": "NedCommand.java", "body": "package edu.nd.dronology.core.collisionavoidance.guidancecommands;\n\n/**\n * A command that tells a UAV to fly in a direction for a specified amount of time.\n */\npublic class NedCommand extends Command {\n    private final double north, east, down, time;\n\n    /**\n     * <p>\n     * Creates a command that tells a UAV to fly in the direction given as a NED vector for the given amount of time.\n     * </p>\n     *\n     * <p>\n     * Each component of the NED vector is given in meters per second. The time parameter is given in seconds.\n     * </p>\n     *\n     * <p>\n     *     For example, to create a NedCommand that tells the UAV to fly north at 5 meters per second for 10 seconds.\n     *     <pre>\n     *         {@code\n     *         NedCommand north = new NedCommand(5, 0, 0, 10);\n     *         }\n     *     </pre>\n     * </p>\n     *\n     * @param north the north component of the velocity vector given in meters per second\n     * @param east the east component of the velocity vector given in meters per second\n     * @param down the down component of the velocity vector given in meters per second\n     * @param time the amount of time to fly at the given velocity in seconds\n     */\n    public NedCommand(double north, double east, double down, double time) {\n        this.north = north;\n        this.east = east;\n        this.down = down;\n        this.time = time;\n    }\n\n    /**\n     *\n     * @return the north component of the velocity vector in meters per second\n     */\n    public double getNorth() {\n        return north;\n    }\n\n    /**\n     *\n     * @return the east component of the velocity vector in meters per second\n     */\n    public double getEast() {\n        return east;\n    }\n\n    /**\n     *\n     * @return the down component of the velocity vector in meters per second\n     */\n    public double getDown() {\n        return down;\n    }\n\n    /**\n     *\n     * @return the amount of time to fly at the given velocity in seconds\n     */\n    public double getTime() {\n        return time;\n    }\n\n    @Override\n    public String toString() {\n        return \"NedCommand(\" + north + \" N, \" + east + \" E, \" + down +\" D, \" + time + \" seconds)\";\n    }\n}\n"}, {"id": "AFInfoPanel.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport com.vaadin.ui.Button;\nimport com.vaadin.ui.Component;\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.HorizontalLayout;\nimport com.vaadin.ui.Label;\nimport com.vaadin.ui.Notification;\nimport com.vaadin.ui.Panel;\nimport com.vaadin.ui.UI;\nimport com.vaadin.ui.VerticalLayout;\nimport com.vaadin.ui.Window;\nimport com.vaadin.ui.themes.ValoTheme;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\nimport edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;\nimport edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;\nimport edu.nd.dronology.ui.vaadin.start.MyUI;\nimport edu.nd.dronology.ui.vaadin.utils.StyleConstants;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * This is the side panel that contains the AFInfoBoxes with the UAV information\n * \n * @author Patrick Falvey\n *\n */\n\npublic class AFInfoPanel extends CustomComponent {\n\tprivate static final long serialVersionUID = -3663049148276256302L;\n\tprivate Panel panel = new Panel();\n\tprivate Button selectButton = new Button(\"Select all\");\n\tprivate Button visibleButton = new Button(\"Expand all\");\n\tprivate VerticalLayout content = new VerticalLayout();\n\tprivate int numUAVs = 0;\n\tprivate boolean selectAll = true;\n\tprivate boolean visible = false;\n\tprivate String focused = \"\";\n\tprivate AFMapViewOperations mapView = new AFMapViewOperations();\n\tprivate Collection<IUAVProxy> drones;\n\tprivate IDroneSetupRemoteService service;\n\tprivate BaseServiceProvider provider = MyUI.getProvider();\n\tprivate AFMissionOperations missionView = new AFMissionOperations(this);\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(AFInfoPanel.class);\n\n\tpublic AFInfoPanel() { \n\n\t\tpanel.setCaption(Integer.toString(numUAVs) + \" Active UAVs\");\n\t\tpanel.setContent(content);\n\t\tpanel.addStyleName(StyleConstants.AF_INFO_PANEL);\n\t\tpanel.addStyleName(StyleConstants.CONTROL_PANEL);\n\n\t\tHorizontalLayout buttons = new HorizontalLayout();\n\t\tVerticalLayout sideBar = new VerticalLayout();\n\n\t\tAFEmergencyComponent emergency = new AFEmergencyComponent();\n\n\t\temergency.getHome().addClickListener(e -> { // sends all UAVs (or all checked UAVs) to their homes\n\t\t\tList<String> checked = this.getChecked();\n\t\t\tString message = \"\";\n\t\t\tboolean sendHome = true;\n\t\t\tif (checked.size() > 0) {\n\t\t\t\tif (checked.size() == 1) {\n\t\t\t\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\t\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(i);\n\t\t\t\t\t\tif (box.getName().equals(checked.get(0))) {\n\t\t\t\t\t\t\tif (box.getStatus().equals(\"ON_GROUND\")) {\n\t\t\t\t\t\t\t\tNotification.show(checked.get(0) + \" is already home.\");\n\t\t\t\t\t\t\t\tsendHome = false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmessage = \"Are you sure you want to send \" + checked.get(0) + \" to its home?\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tString drones = \"\";\n\t\t\t\t\tfor (int i = 0; i < checked.size() - 1; i++) {\n\t\t\t\t\t\tdrones += checked.get(i) + \", \";\n\t\t\t\t\t}\n\t\t\t\t\tmessage = \"Are you sure you want to send \" + drones + \"and \" + checked.get(checked.size() - 1)\n\t\t\t\t\t\t\t+ \" to their homes?\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmessage = \"Are you sure to send all UAVs to their homes?\";\n\t\t\t}\n\t\t\tWindow confirm = new Window(\"Confirm\");\n\t\t\tconfirm.addStyleName(\"confirm_window\");\n\t\t\tVerticalLayout subContent = new VerticalLayout();\n\t\t\tHorizontalLayout subButtons = new HorizontalLayout();\n\t\t\tsubButtons.addStyleName(\"confirm_button_area\");\n\t\t\tLabel label = new Label(message);\n\t\t\tButton yes = new Button(\"Yes\");\n\t\t\tyes.addStyleName(\"btn-danger\");\n\t\t\tButton no = new Button(\"No\");\n\n\t\t\tyes.addClickListener(subEvent -> {\n\t\t\t\tUI.getCurrent().removeWindow(confirm);\n\t\t\t\tIFlightManagerRemoteService service;\n\t\t\t\ttry {\n\t\t\t\t\tservice = (IFlightManagerRemoteService) provider.getRemoteManager()\n\t\t\t\t\t\t\t.getService(IFlightManagerRemoteService.class);\n\t\t\t\t\tif (checked.size() > 0) {\n\t\t\t\t\t\tfor (int i = 0; i < checked.size(); i++) {\n\t\t\t\t\t\t\tfor (int j = 1; j < numUAVs + 1; j++) {\n\t\t\t\t\t\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(j);\n\t\t\t\t\t\t\t\tif (box.getName().equals(checked.get(i))) {\n\t\t\t\t\t\t\t\t\tif (!box.getStatus().equals(\"ON_GROUND\")) {\n\t\t\t\t\t\t\t\t\t\tservice.returnToHome(checked.get(i));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\t\t\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(i);\n\t\t\t\t\t\t\tif (!box.getStatus().equals(\"ON_GROUND\"))\n\t\t\t\t\t\t\t\tservice.returnToHome(box.getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception exc) {\n\t\t\t\t\texc.printStackTrace();\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\tno.addClickListener(subEvent -> {\n\t\t\t\tUI.getCurrent().removeWindow(confirm);\n\t\t\t});\n\n\t\t\tsubButtons.addComponents(yes, no);\n\t\t\tsubContent.addComponents(label, subButtons);\n\t\t\tconfirm.setContent(subContent);\n\t\t\tconfirm.setModal(true);\n\t\t\tconfirm.setResizable(false);\n\t\t\tconfirm.center();\n\t\t\tif (sendHome)\n\t\t\t\tUI.getCurrent().addWindow(confirm);\n\n\t\t});\n\n\t\tcontent.addLayoutClickListener(e -> { // determines if a box should be in focus\n\t\t\tComponent testChild = e.getChildComponent();\n\t\t\tif (testChild.getClass() == AFInfoBox.class) {\n\t\t\t\tAFInfoBox child = (AFInfoBox) e.getChildComponent();\n\t\t\t\tif (!child.getCheckClick()) { // if the box was clicked but not the checkbox\n\t\t\t\t\tchild.addStyleName(\"info_box_focus\");\n\t\t\t\t\tchild.setIsChecked(true);\n\t\t\t\t\tfocused = child.getName();\n\t\t\t\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\t\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(i);\n\t\t\t\t\t\tif (!box.getName().equals(child.getName())) {\n\t\t\t\t\t\t\tbox.removeStyleName(\"info_box_focus\");\n\t\t\t\t\t\t\tbox.setIsChecked(false);\n\t\t\t\t\t\t\tbox.setCheckClick(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tchild.removeStyleName(\"info_box_focus\");\n\t\t\t\t\tif (focused.equals(child.getName()))\n\t\t\t\t\t\tfocused = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tsideBar.addComponents(panel, mapView, missionView, emergency);\n\t\tsetCompositionRoot(sideBar);\n\n\t\tselectButton.addStyleName(ValoTheme.BUTTON_LINK);\n\t\tselectButton.addStyleName(StyleConstants.SMALL_BUTTON_LINK);\n\t\tvisibleButton.addStyleName(ValoTheme.BUTTON_LINK);\n\t\tvisibleButton.addStyleName(StyleConstants.SMALL_BUTTON_LINK);\n\n\t\tbuttons.addComponents(selectButton, visibleButton);\n\t\tbuttons.addStyleName(\"af_uav_list_controls\");\n\n\t\tselectButton.addClickListener(e -> {\n\t\t\tif (selectAll) {\n\t\t\t\tselectAll(true);\n\t\t\t\tselectButton.setCaption(\"Deselect all\");\n\t\t\t\tselectAll = false;\n\t\t\t} else {\n\t\t\t\tselectAll(false);\n\t\t\t\tselectButton.setCaption(\"Select all\");\n\t\t\t\tselectAll = true;\n\t\t\t}\n\t\t});\n\n\t\tvisibleButton.addClickListener(e -> {\n\t\t\tif (visible) {\n\t\t\t\tvisible = false;\n\t\t\t\tsetVisibility(true);\n\t\t\t\tvisibleButton.setCaption(\"Expand all\");\n\t\t\t} else {\n\t\t\t\tvisible = true;\n\t\t\t\tsetVisibility(false);\n\t\t\t\tvisibleButton.setCaption(\"Collapse all\");\n\t\t\t}\n\t\t});\n\n\t\tcontent.addComponent(buttons);\n\t\tnumUAVs = content.getComponentCount() - 1;\n\n\t\ttry {\n\t\t\tservice = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);\n\t\t\tCollection<IUAVProxy> activeDrones = service.getActiveUAVs();\n\t\t\tdrones = new ArrayList<>(activeDrones);\n\t\t\t// Collections.sort(drones);\n\t\t\tfor (IUAVProxy e : drones) {\n\t\t\t\taddBox(false, new UAVStatusWrapper(e), false);\n\t\t\t}\n\t\t} catch (DronologyServiceException | RemoteException e1) {\n\t\t\tMyUI.setConnected(false);\n\t\t\tLOGGER.error(e1);\n\t\t}\n\n\t}\n\n\tpublic AFMapViewOperations getMapView() {\n\t\treturn mapView;\n\t}\n\n\tpublic String getFocusedName() {\n\t\treturn focused;\n\t}\n\n\t/**\n\t * Adds a box to the panel\n\t * \n\t * @param isChecked\n\t * @param name\n\t * @param status\n\t * @param batteryLife\n\t * @param healthColor\n\t * @param lat\n\t * @param lon\n\t * @param alt\n\t * @param speed\n\t * @param hoverInPlace\n\t */\n\tpublic void addBox(boolean isChecked, UAVStatusWrapper uavStatus, boolean hoverInPlace) {\n\t\tAFInfoBox box = new AFInfoBox(isChecked, uavStatus, hoverInPlace);\n\t\tbox.createContents();\n\t\tcontent.addComponent(box);\n\t\tnumUAVs = content.getComponentCount() - 1;\n\t\tpanel.setCaption(Integer.toString(numUAVs) + \" Active UAVs\");\n\t}\n\n\tpublic void addBox() {\n\t\tAFInfoBox box = new AFInfoBox();\n\t\tcontent.addComponent(box);\n\t\tnumUAVs = content.getComponentCount() - 1;\n\t\tpanel.setCaption(Integer.toString(numUAVs) + \" Active UAVs\");\n\t}\n\n\t/**\n\t * Removes a box from the panel\n\t * \n\t * @param name\n\t *          the name/ID of the drone\n\t * @return returns true if successful. returns false if failed\n\t */\n\tpublic boolean removeBox(String name) {\n\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(i);\n\t\t\tif (box.getName().equals(name)) {\n\t\t\t\tcontent.removeComponent(box);\n\t\t\t\tnumUAVs = content.getComponentCount() - 1;\n\t\t\t\tpanel.setCaption(Integer.toString(numUAVs) + \" Active UAVs\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic void selectAll(boolean select) {\n\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(i);\n\t\t\tbox.setIsChecked(select);\n\t\t\tif (!select && focused.equals(box.getName())) {\n\t\t\t\tbox.removeStyleName(\"info_box_focus\");\n\t\t\t\tbox.setCheckClick(false);\n\t\t\t\tfocused = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @return a list of all drones that have their checkbox checked\n\t */\n\tpublic List<String> getChecked() {\n\t\tList<String> names = new ArrayList<>();\n\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(i);\n\t\t\tif (box.getIsChecked())\n\t\t\t\tnames.add(box.getName());\n\t\t}\n\t\treturn names;\n\t}\n\n\t/**\n\t * \n\t * @return true if all the drones are checked\n\t */\n\tprivate boolean getAllChecked() {\n\t\tboolean checked = true;\n\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(i);\n\t\t\tif (!box.getIsChecked())\n\t\t\t\tchecked = false;\n\t\t}\n\t\treturn checked;\n\t}\n\n\t/**\n\t * \n\t * @return true if all drones are not checked\n\t */\n\tprivate boolean getAllNotChecked() {\n\t\tboolean notChecked = true;\n\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(i);\n\t\t\tif (box.getIsChecked())\n\t\t\t\tnotChecked = false;\n\t\t}\n\t\treturn notChecked;\n\t}\n\n\t/**\n\t * Expands or collapses all the boxes\n\t * \n\t * @param visible\n\t */\n\tpublic void setVisibility(boolean visible) {\n\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(i);\n\t\t\tbox.setBoxVisible(visible);\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @return true if all boxes are expanded\n\t */\n\tprivate boolean getAllVisible() {\n\t\tboolean visible = true;\n\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(i);\n\t\t\tif (!box.getBoxVisible())\n\t\t\t\tvisible = false;\n\t\t}\n\t\treturn visible;\n\t}\n\n\t/**\n\t * \n\t * @return true if all boxes are collapsed\n\t */\n\tprivate boolean getAllNotVisible() {\n\t\tboolean notVisible = true;\n\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(i);\n\t\t\tif (box.getBoxVisible())\n\t\t\t\tnotVisible = false;\n\t\t}\n\t\treturn notVisible;\n\t}\n\n\tpublic void setAllToHover() {\n\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(i);\n\t\t\tbox.setHoverInPlace(true);\n\t\t}\n\t}\n\n\tpublic VerticalLayout getBoxes() {\n\t\treturn content;\n\t}\n\n\tpublic int getNumUAVS() {\n\t\treturn numUAVs;\n\t}\n\n\t/**\n\t * gets updated information from dronology about the UAV's location information and status. adds any new drones to the panel and removes any drones that were deactivated\n\t */\n\t@SuppressWarnings(\"deprecation\") \n\tpublic void refreshDrones() {\n\t\t// update select/deselect all button\n\t\tif (this.getAllChecked() && selectButton.getCaption().equals(\"Select all\") && numUAVs != 0) {\n\t\t\tselectButton.setCaption(\"Deselect all\");\n\t\t\tselectAll = false;\n\t\t} else if (this.getAllNotChecked() && selectButton.getCaption().equals(\"Deselect all\") && numUAVs != 0) {\n\t\t\tselectButton.setCaption(\"Select all\");\n\t\t\tselectAll = true;\n\t\t}\n\t\t// update expand/collapse all button\n\t\tif (this.getAllVisible() && visibleButton.getCaption().equals(\"Expand all\") && numUAVs != 0) {\n\t\t\tvisibleButton.setCaption(\"Collapse all\");\n\t\t\tvisible = true;\n\t\t} else if (this.getAllNotVisible() && visibleButton.getCaption().equals(\"Collapse all\") && numUAVs != 0) {\n\t\t\tvisibleButton.setCaption(\"Expand all\");\n\t\t\tvisible = false;\n\t\t}\n\t\ttry {\n\n\t\t\tCollection<IUAVProxy> newDrones = service.getActiveUAVs();\n\t\t\t/**\n\t\t\t * add new drones to the panel\n\t\t\t */\n\t\t\tif (newDrones.size() > drones.size()) {\n\t\t\t\tfor (IUAVProxy e1 : newDrones) {\n\t\t\t\t\tboolean nameMatch = false;\n\t\t\t\t\tfor (IUAVProxy e2 : drones) {\n\t\t\t\t\t\tif (e1.getID().equals(e2.getID())) {\n\t\t\t\t\t\t\tnameMatch = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!nameMatch) {\n\t\t\t\t\t\tthis.addBox(false, new UAVStatusWrapper(e1), false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**\n\t\t\t * delete old drones from the panel\n\t\t\t */\n\t\t\tif (newDrones.size() < drones.size()) {\n\t\t\t\tfor (IUAVProxy old : drones) {\n\t\t\t\t\tboolean exists = false;\n\t\t\t\t\tfor (IUAVProxy current : newDrones) {\n\t\t\t\t\t\tif (old.getID().equals(current.getID()))\n\t\t\t\t\t\t\texists = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!exists) {\n\t\t\t\t\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\t\t\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(i);\n\t\t\t\t\t\t\tif (old.getID().equals(box.getName()))\n\t\t\t\t\t\t\t\tthis.removeBox(box.getName());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (RemoteException e1) {\n\t\t\ttry {\n\t\t\t\tNotification.show(\"Reconnecting...\");\n\t\t\t\tservice = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);\n\t\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\t\tMyUI.setConnected(false);\n\t\t\t\tNotification.show(\"Reconnecting...\");\n\t\t\t}\n\t\t\tNotification.show(\"Reconnecting...\");\n\t\t\tcontent.removeAllComponents();\n\t\t\tnumUAVs = 0;\n\t\t}\n\t\t/**\n\t\t * update current drones' status\n\t\t */\n\t\ttry {\n\t\t\tdrones = service.getActiveUAVs();\n\t\t\tfor (IUAVProxy e : drones) {\n\t\t\t\tfor (int i = 1; i < numUAVs + 1; i++) {\n\t\t\t\t\tAFInfoBox box = (AFInfoBox) content.getComponent(i);\n\t\t\t\t\tif (e.getID().equals(box.getName())) {\n\t\t\t\t\t\tbox.update(new UAVStatusWrapper(e));\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (RemoteException e1) {\n\t\t\ttry {\n\t\t\t\tNotification.show(\"Reconnecting...\");\n\t\t\t\tservice = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);\n\t\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\t\tNotification.show(\"Reconnecting...\");\n\t\t\t}\n\t\t\tNotification.show(\"Reconnecting...\");\n\t\t\tcontent.removeAllComponents();\n\t\t\tnumUAVs = 0;\n\t\t}\n\t}\n\n\tpublic void createContents() {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}\n"}, {"id": "GetBaseCoordinatesMessage.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal.message;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\nimport java.util.concurrent.SynchronousQueue;\n\npublic class GetBaseCoordinatesMessage extends AbstractMessage {\n    public final SynchronousQueue<LlaCoordinate> returnBox = new SynchronousQueue<>();\n}\n"}, {"id": "MonitoringDataHandler3.java", "body": "package edu.nd.dronology.monitoring;\n\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport edu.nd.dronology.core.monitoring.ArtifactIdentifier;\nimport edu.nd.dronology.core.monitoring.IMonitorableMessage;\nimport edu.nd.dronology.core.monitoring.IMonitoringDataHandler;\nimport edu.nd.dronology.monitoring.service.DroneMonitoringService;\nimport edu.nd.dronology.util.NamedThreadFactory;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class MonitoringDataHandler3 implements Runnable, IMonitoringDataHandler {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(MonitoringDataHandler3.class);\n\tprivate static final int NUM_THREADS = 10;\n\tprivate BlockingQueue<IMonitorableMessage> queue;\n\tprivate AtomicBoolean cont = new AtomicBoolean(true);\n\n\tprivate static final ExecutorService SERVICE_EXECUTOR = Executors.newFixedThreadPool(NUM_THREADS,\n\t\t\tnew NamedThreadFactory(\"SubscriberDistributionThreads\"));\n\n\tpublic MonitoringDataHandler3() {\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\twhile (cont.get()) {\n\n\t\t\ttry {\n\t\t\t\tIMonitorableMessage message = queue.take();\n\n\t\t\t\tArtifactIdentifier<?> identifier = message.getIdentifier();\n\n\t\t\t\tSet<IRemoteMonitoringMessageHandler> handler = DroneMonitoringService.getInstance()\n\t\t\t\t\t\t.getSubscribedHandler(identifier);\n\t\t\t\tfor (IRemoteMonitoringMessageHandler h : handler) {\n\t\t\t\t\tSERVICE_EXECUTOR.submit(new SendToSubscriberCallable(h, message));\n\t\t\t\t}\n\n\t\t\t} catch (Throwable e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setQueue(BlockingQueue<IMonitorableMessage> queue) {\n\t\tthis.queue = queue;\n\n\t}\n}\n"}, {"id": "UAVEquipmentTypeRegistrationXStreamPersistor.java", "body": "package edu.nd.dronology.services.core.persistence.internal;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.nio.charset.Charset;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport com.thoughtworks.xstream.XStream;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\n\nimport edu.nd.dronology.services.core.items.IUAVEquipmentTypeRegistration;\nimport edu.nd.dronology.services.core.persistence.DronologyPersistenceUtil;\nimport edu.nd.dronology.services.core.persistence.IPersistenceManager;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class UAVEquipmentTypeRegistrationXStreamPersistor implements IPersistenceManager<IUAVEquipmentTypeRegistration> {\n\n\tprivate static final XStream xstream = new XStream(new XppDriver());\n\tprivate static ILogger LOGGER = LoggerProvider.getLogger(UAVEquipmentTypeRegistrationXStreamPersistor.class);\n\n\tstatic final boolean useCompression = false;\n\n\t@Override\n\tpublic IUAVEquipmentTypeRegistration open(InputStream fin) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t//\t xstream.setMode(XStream.);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\t\t\n\t\tif (useCompression) {\n\t\t\treturn loadedCompressedStream(fin);\n\t\t} else {\n\t\t\treturn loadUncompressedStream(fin);\n\t\t}\n\t}\n\n\tprivate IUAVEquipmentTypeRegistration loadUncompressedStream(InputStream fin) throws PersistenceException {\n\t\ttry {\n\t\t\tInputStreamReader reader = new InputStreamReader(new BufferedInputStream(fin), Charset.forName(\"UTF-8\"));\n\t\t\tObject model = xstream.fromXML(reader);\n\t\t\treturn (IUAVEquipmentTypeRegistration) model;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (fin != null) {\n\t\t\t\t\tfin.close();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate IUAVEquipmentTypeRegistration loadedCompressedStream(InputStream fin) throws PersistenceException {\n\t\tInputStream zIn = null;\n\t\ttry {\n\t\t\tzIn = new GZIPInputStream(fin);\n\t\t\tObject model = xstream.fromXML(new BufferedReader(new InputStreamReader(zIn, \"UTF-8\")));\n\n\t\t\treturn (IUAVEquipmentTypeRegistration) model;\n\t\t} catch (IOException e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (zIn != null) {\n\t\t\t\t\tzIn.close();\n\t\t\t\t}\n\t\t\t\tif (fin != null) {\n\t\t\t\t\tfin.close();\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\n\t\t}\n\t}\n \n\t@Override\n\tpublic boolean save(IUAVEquipmentTypeRegistration o, OutputStream fout) throws PersistenceException {\n\t\tDronologyPersistenceUtil.preprocessStream(xstream);\n\t\t// xstream.setMode(XStream.ID_REFERENCES);\n\t\t// xstream.addImplicitCollection(ImplMMEArtifactType.class, \"children\");\n\t\t// xstream.addImplicitMap(ImplMEEvent.class, \"relatedEvents\", ImplMEEvent.class, \"relatedEvents\");\n\n\t\tif (useCompression) {\n\t\t\treturn saveCompressedStream(o, fout);\n\t\t} else {\n\t\t\treturn saveUncompressedStream(o, fout);\n\t\t}\n\n\t}\n\n\tprivate boolean saveUncompressedStream(IUAVEquipmentTypeRegistration o, OutputStream fout) throws PersistenceException {\n\t\tOutputStreamWriter writer = null;\n\t\ttry {\n\t\t\twriter = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(\"UTF-8\"));\n\t\t\txstream.toXML(o, writer);\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (writer != null) {\n\t\t\t\t\twriter.close();\n\t\t\t\t}\n\t\t\t\tif (fout != null) {\n\t\t\t\t\tfout.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean saveCompressedStream(IUAVEquipmentTypeRegistration o, OutputStream fout) throws PersistenceException {\n\t\ttry {\n\t\t\tGZIPOutputStream zOut = new GZIPOutputStream(fout);\n\t\t\txstream.toXML(o, new BufferedWriter(new OutputStreamWriter(zOut, \"UTF-8\")));\n\n\t\t\tzOut.close();\n\t\t\tfout.close();\n\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t}\n\t}\n\n}\n"}, {"id": "SyncConstants.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.sync;\n\n/**\n * Synchronization IDs for predefined, built-in {@link SynchronizationPoint} .\n * \n * @author Michael Vierhauser \n * \n * \n *\n */\npublic class SyncConstants {\n \n\tpublic static final String LANDING_ASC_REACHED = \"SP-Landing-AscentTargetReached\";\n\tpublic static final String LANDING_LONLAT_REACHED = \"SP-Landing-LonLatReached\";\n\tpublic static final String LANDING_HOME_REACHED = \"SP-Landing-HomeReached\";\n\n\tpublic static final String TAKEOFF_ASC_REACHED = \"SP-TakeOff-AscentTargetReached\";\n\tpublic static final String TAKEOFF_LATLON_REACHED = \"SP-TakeOff-LonLatReached\";\n\tpublic static final String TAKEOFF_WP_REACHED = \"SP-TakeOff-FirstWayPointReached\";\n\n}\n"}, {"id": "IDroneCommandHandler.java", "body": "package edu.nd.dronology.core.vehicle;\n\nimport edu.nd.dronology.core.IUAVPropertyUpdateNotifier;\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.vehicle.commands.IDroneCommand;\n\npublic interface IDroneCommandHandler {\n\t\n\t\n\tpublic void sendCommand(IDroneCommand command) throws DroneException;\n\n\tvoid setStatusCallbackNotifier(String id, IUAVPropertyUpdateNotifier listener) throws DroneException;\n\t\n\tpublic String getHandlerId();\n\n}\n"}, {"id": "SimulatorFactory.java", "body": "package edu.nd.dronology.core.simulator;\n\nimport edu.nd.dronology.core.simulator.nvecsimulator.NVECSimulator;\nimport edu.nd.dronology.core.simulator.simplesimulator.SimpleSimulator;\nimport edu.nd.dronology.core.vehicle.internal.VirtualDrone;\n\npublic class SimulatorFactory {\n\n\tprivate static final boolean USE_SIMPLE_SIMULATOR = true;\n\n\tpublic static IFlightSimulator getSimulator(VirtualDrone drone) {\n\t\tif (USE_SIMPLE_SIMULATOR) {\n\t\t\treturn new SimpleSimulator(drone);\n\t\t} else {\n\t\t\treturn new NVECSimulator(drone);\n\t\t}\n\t}\n\n}\n"}, {"id": "UAVStateChangeMessage.java", "body": "//package edu.nd.dronology.core.monitoring.messages;\n//\n//import edu.nd.dronology.core.monitoring.ArtifactIdentifier;\n//import edu.nd.dronology.core.monitoring.IMonitorableMessage;\n//import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;\n//import edu.nd.dronology.core.util.PreciseTimestamp;\n//\n//public class UAVStateChangeMessage implements IMonitorableMessage {\n//\n//\tprivate String uavid;\n//\tprivate String oldstate;\n//\tprivate String newstate;\n//\tprivate final PreciseTimestamp timestamp;\n//\n//\tpublic UAVStateChangeMessage(String uavid, String oldstate, String newstate) {\n//\t\tthis.uavid = uavid;\n//\t\ttimestamp = PreciseTimestamp.create();\n//\t\tthis.oldstate = oldstate;\n//\t\tthis.newstate = newstate;\n//\t}\n//\n//\t@Override\n//\tpublic ArtifactIdentifier<?> getIdentifier() {\n//\t\treturn new ArtifactIdentifier(ArtifactIdentifier.ROOT, \"INTERNAL\",MessageType.STATE_CHANGE.toString(), uavid);\n//\n//\t}\n//\n//\tpublic String getUavid() {\n//\t\treturn uavid;\n//\t}\n//\n//\t@Override\n//\tpublic String getData() {\n//\t\treturn null;\n//\t}\n//\n//\t@Override\n//\tpublic PreciseTimestamp getTimestamp() {\n//\t\treturn timestamp;\n//\t}\n//\n//\t@Override\n//\tpublic MessageType getType() {\n//\t\treturn MessageType.STATE_CHANGE;\n//\t}\n//\n//}\n"}, {"id": "IMissionPlanningRemoteService.java", "body": "package edu.nd.dronology.services.core.remote;\n\nimport java.rmi.RemoteException;\n\nimport edu.nd.dronology.services.core.info.MissionInfo;\nimport edu.nd.dronology.services.core.info.UAVMappingInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\n/**\n * \n * @author Michael Vierhauser\n * \n */\npublic interface IMissionPlanningRemoteService extends IRemoteableService, IFileTransmitRemoteService<MissionInfo>  {\n\n\t@Deprecated\n\tvoid executeMissionPlan(String mission) throws RemoteException, Exception;\n\n\tvoid cancelMission() throws RemoteException, DronologyServiceException;\n\n\tvoid executeMissionPlan(MissionInfo info) throws RemoteException, DronologyServiceException;\n\t\n\tvoid executeMissionPlan(MissionInfo info, UAVMappingInfo mapping) throws RemoteException, DronologyServiceException;\n\n}\n"}, {"id": "MessageMarshaller.java", "body": "package edu.nd.dronology.core.monitoring;\n\nimport java.io.Serializable;\n\nimport edu.nd.dronology.core.flight.IFlightPlan;\nimport edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage;\nimport edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;\nimport edu.nd.dronology.core.vehicle.DroneFlightStateManager.FlightMode;\nimport edu.nd.dronology.core.vehicle.commands.IDroneCommand;\n\npublic class MessageMarshaller {\n\n\tpublic static class StateWrapper implements Serializable {\n\n\t\t/**\n\t\t * \n\t\t */\n\t\tprivate static final long serialVersionUID = -6332164623939457896L;\n\t\tprivate String oldstate;\n\t\tprivate String newstate;\n\t\tprivate String uavid;\n\n\t\tpublic StateWrapper(String uavid, FlightMode oldState, FlightMode newState) {\n\t\t\tthis.uavid = uavid;\n\t\t\tthis.oldstate = oldState.toString();\n\t\t\tthis.newstate = newState.toString();\n\t\t}\n\n\t}\n\n\tpublic static IMonitorableMessage create(String droneId, FlightMode oldState, FlightMode newState) {\n\t\t// return new UAVStateChangeMessage(droneId, oldState.toString(),\n\t\t// newState.toString());\n\t\treturn new UAVMonitorableMessage(MessageType.STATE_CHANGE, droneId,\n\t\t\t\tnew StateWrapper(droneId, oldState, newState));\n\t}\n\n\tpublic static IMonitorableMessage createPlanActive(IFlightPlan plan) {\n\t\t// return new UAVPlanChangeMessage(plan.getDesignatedDroneId(), \"ACTIVATE\",\n\t\t// plan.getFlightID(),\n\t\t// plan.getStartTime(), plan.getEndTime());\n\t\treturn new UAVMonitorableMessage(MessageType.PLAN_ACTIVATED, plan.getDesignatedDroneId(), plan);\n\t}\n\n\tpublic static IMonitorableMessage createPlanCompleted(IFlightPlan plan) {\n\t\t// return new UAVPlanChangeMessage(plan.getDesignatedDroneId(), \"COMPLETE\",\n\t\t// plan.getFlightID(),\n\t\t// plan.getStartTime(), plan.getEndTime());\n\n\t\treturn new UAVMonitorableMessage(MessageType.PLAN_COMPLETE, plan.getDesignatedDroneId(), plan);\n\n\t}\n\n\tpublic static IMonitorableMessage createMessage(IDroneCommand cmd) {\n\t\treturn new UAVMonitorableMessage(MessageType.COMMAND, cmd.getUAVId(), cmd);\n\t}\n\n\tpublic static IMonitorableMessage createMessage(MessageType type, String uavid, Serializable data) {\n\t\treturn new UAVMonitorableMessage(type, uavid, data);\n\t}\n\n\tpublic static IMonitorableMessage createMessage(MessageType type, String uavid) {\n\t\treturn createMessage(type, uavid, null);\n\t}\n\n}\n"}, {"id": "DronologyServiceException.java", "body": "package edu.nd.dronology.services.core.util;\n\n\n/**\n * \n * Default exception that is thrown when any kind of exception occurs server-side Wraps technology specific exceptions such as JMS or RMI exceptions.\n * \n * @author Michael Vierhauser\n * \n */\npublic class DronologyServiceException extends Exception {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -4309389079690729311L;\n\n\t/**\n\t * @param e\n\t */\n\tpublic DronologyServiceException(Throwable e) {\n\t\tsuper(e);\n\t}\n\n\t/**\n\t * @param message\n\t */\n\tpublic DronologyServiceException(String message) {\n\t\tsuper(message);\n\t}\n\t\n\t/**\n\t * @param message\n\t * @param e\n\t */\n\tpublic DronologyServiceException(String message, Exception e) {\n\t\tsuper(message,e);\n\t}\n\n}\n"}, {"id": "AMInfoBox.java", "body": "package edu.nd.dronology.ui.vaadin.areamapping;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport com.vaadin.server.FileResource;\nimport com.vaadin.server.VaadinService;\nimport com.vaadin.ui.Button;\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.HorizontalLayout;\nimport com.vaadin.ui.Label;\nimport com.vaadin.ui.VerticalLayout;\nimport com.vaadin.ui.themes.ValoTheme;\n\nimport edu.nd.dronology.services.core.info.AreaMappingInfo;\nimport edu.nd.dronology.ui.vaadin.areamapping.windows.AMUnsavedChangesConfirmation.ChangeType;\n\n/**\n * Each Mapping has a different info box. It contains information about date creation. It also has buttons for editing or trashing a mapping.\n * \n * @author Andrew Slavin\n *\n */\n\n\npublic class AMInfoBox extends CustomComponent {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 763381012380912332L;\n\n\tprivate AreaMappingInfo areaMappingInfo;\n\n\tprivate HorizontalLayout titleBar = new HorizontalLayout();\n\n\t// Create AMInfoBox in Area Mapping view -- with edit and delete buttons\n\tpublic AMInfoBox(AMInfoPanel infoPanel, AreaMappingInfo areaMappingInfo) {\n\t\tthis(areaMappingInfo);\n\n\t\t// Imports images for buttons.\n\t\tString basepath = VaadinService.getCurrent().getBaseDirectory().getAbsolutePath();\n\t\tFileResource editIcon = new FileResource(new File(basepath + \"/VAADIN/img/edit.png\"));\n\t\tFileResource trashIcon = new FileResource(new File(basepath + \"/VAADIN/img/trashcan.png\"));\n\n\t\tButton editButton = new Button();\n\t\tButton trashButton = new Button();\n\n\t\teditButton.setIcon(editIcon);\n\t\ttrashButton.setIcon(trashIcon);\n\t\teditButton.addStyleName(ValoTheme.BUTTON_ICON_ONLY);\n\t\ttrashButton.addStyleName(ValoTheme.BUTTON_ICON_ONLY);\n\t\t\n\t\t// Adds listener to the delete button on the mapping box /\n\t\ttrashButton.addListener(e -> {\n\t\t\tif (infoPanel.getControls().getMainLayout().getMapComponent().getMapUtilities().getSidesAreEditable() || infoPanel.getControls().getMainLayout().getMapComponent().getMapUtilities().getPrioritiesAreEditable()) {\n\t\t\t\t// Checks if the mapping is in edit mode.\n\t\t\t\tinfoPanel.getControls().getMainLayout().getUnsavedChangesConfirmation().showWindow(\n\t\t\t\t\t\tinfoPanel.getHighlightedAMInfoBox().getAreaMappingInfo().getName(), ChangeType.DELETE_MAPPING, e);\n\t\t\t} else {\n\t\t\t\tinfoPanel.getControls().getMainLayout().getDeleteMappingConfirmation().showWindow(getAreaMappingInfo(),\n\t\t\t\t\t\te);\n\t\t\t}\n\t\t});\n\t\t// A click on the edit button enables editing, unless edit mode is already\n\t\t// enabled, in which case the user is prompted about losing changes.\n\t\teditButton.addClickListener(e -> {\n\t\t\tif (!infoPanel.getControls().getMainLayout().getMapComponent().getMapUtilities().getSidesAreEditable() && !infoPanel.getControls().getMainLayout().getMapComponent().getMapUtilities().getPrioritiesAreEditable()) {\n\t\t\t\t// open edit mode choices window\n\t\t\t\tinfoPanel.getControls().getMainLayout().switchMapping(this);\n\t\t\t\tinfoPanel.getControls().getMainLayout().getMapComponent().getEditSidesController().enterEditMode();\n\t\t\t} else {\n\t\t\t\tif (infoPanel.getHighlightedAMInfoBox() != null\n\t\t\t\t\t\t&& areaMappingInfo.getId().equals(infoPanel.getHighlightedAMInfoBox().getId()))\n\t\t\t\t\treturn;\n\t\t\t\tinfoPanel.getControls().getMainLayout().getUnsavedChangesConfirmation().showWindow(\n\t\t\t\t\t\tinfoPanel.getHighlightedAMInfoBox().getAreaMappingInfo().getName(), ChangeType.EDIT_ANOTHER, e, this, infoPanel);\n\t\t\t}\n\t\t});\n\n\t\ttitleBar.addComponents(trashButton, editButton);\n\t}\n\n\t// set the creation and modification time\n\tpublic AMInfoBox(AreaMappingInfo areaMappingInfo) {\n\t\tthis.areaMappingInfo = areaMappingInfo;\n\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"MMM d, yyyy, hh:mm aaa\");\n\t\tlong creationTime = areaMappingInfo.getDateCreated();\n\t\tString creationFormatted = sdf.format(new Date(creationTime));\n\t\tlong modifiedTime = areaMappingInfo.getDateModified();\n\t\tString modifiedFormatted = sdf.format(new Date(modifiedTime));\n\n\t\tthis.addStyleName(\"info_box\");\n\t\tthis.addStyleName(\"fr_info_box\");\n\n\t\tVerticalLayout mappingDescription = new VerticalLayout();\n\t\tmappingDescription.addStyleName(\"detailed_info_well\");\n\n\t\tVerticalLayout allContent = new VerticalLayout();\n\n\t\t// Create name id label.\n\t\tLabel nameIdLabel = new Label(areaMappingInfo.getName());\n\t\tnameIdLabel.addStyleName(\"info_box_name\");\n\n\t\t// Creates 4 different labels\n\t\tLabel createdLabel = new Label(\"Created:  \" + creationFormatted);\n\t\tLabel modifiedLabel = new Label(\"Last Modified:  \" + modifiedFormatted);\n\t\tLabel sideALabel = new Label(areaMappingInfo.getCoordinates(0).size() + \" side A coordinates\");\n\t\tLabel sideBLabel = new Label(areaMappingInfo.getCoordinates(1).size() + \" side B coordinates\");\n\t\t\n\t\tmappingDescription.addComponents(createdLabel, modifiedLabel, sideALabel, sideBLabel);\n\n\t\ttitleBar.addComponents(nameIdLabel);\n\n\t\t// Adds all content together and aligns the buttons on the right.\n\t\tallContent.addComponents(titleBar, mappingDescription);\n\n\t\tsetCompositionRoot(allContent);\n\t}\n\n\tpublic AreaMappingInfo getAreaMappingInfo() {\n\t\treturn areaMappingInfo;\n\t}\n\n\t// Gets the name of the route.\n\tpublic String getName() {\n\t\treturn areaMappingInfo.getName();\n\t}\n\n\t// Gets the route id.\n\t@Override\n\tpublic String getId() {\n\t\treturn areaMappingInfo.getId();\n\t}\n}\n"}, {"id": "AbstractDroneCommand.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n\nimport java.text.DateFormat;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport com.google.gson.FieldNamingPolicy;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\n\n/**\n * \n * Abstract base class for all commands sent to the GCS.<br>\n * Contains the id of the UAV and a unique command id.\n * \n * @author Michael Vierhauser\n *\n */\n@SuppressWarnings(\"unused\")\npublic class AbstractDroneCommand implements IDroneCommand {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 4401634183653180024L;\n\n\tstatic final transient Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()\n\t\t\t.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).setVersion(1.0)\n\t\t\t.serializeSpecialFloatingPointValues().create();\n\n\tprotected final Map<String, Object> data = new HashMap<>();\n\n\tprivate final String uavid;\n\n\tprivate final String command;\n\tprivate long sendtimestamp;\n\tprivate final String commandid;\n\n\tprotected AbstractDroneCommand(String uavid, String command) {\n\t\tthis.uavid = uavid;\n\t\tthis.command = command;\n\t\tthis.commandid = UUID.randomUUID().toString();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.getClass().getSimpleName() + \" [\" + GSON.toJson(this) + \"]\";\n\t}\n\n\t@Override\n\tpublic String toJsonString() {\n\t\treturn GSON.toJson(this);\n\t}\n\n\t@Override\n\tpublic void timestamp() {\n\t\tsendtimestamp = System.currentTimeMillis();\n\t}\n\n\t@Override\n\tpublic String getUAVId() {\n\t\treturn uavid;\n\t}\n\n}\n"}, {"id": "FlightZoneException.java", "body": "package edu.nd.dronology.core.exceptions;\n\n/**\n * Supports customized flight zone exceptions\n * \n * @author Jane Cleland-Huang\n * @version 0.1\n *\n */\npublic class FlightZoneException extends Throwable {\n\t/**\n\t* \n\t*/\n\tprivate static final long serialVersionUID = 8522577350228262490L;\n\n\tpublic FlightZoneException(String msg) {\n\t\tsuper(msg);\n\t}\n\n\tpublic FlightZoneException(Throwable t) {\n\t\tsuper(t);\n\t}\n}\n"}, {"id": "IMissionPlanningServiceInstance.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.service.internal;\n\nimport edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.info.MissionInfo;\nimport edu.nd.dronology.services.core.info.UAVMappingInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic interface IMissionPlanningServiceInstance extends IFileTransmitServiceInstance<MissionInfo> {\n\n\tvoid executeMissionPlan(String mission) throws DronologyServiceException;\n\n\tvoid cancelMission() throws DronologyServiceException;\n\n\tvoid removeUAV(String uavid) throws DronologyServiceException;\n\n\tvoid executeMissionPlan(MissionInfo info) throws DronologyServiceException;\n\n\tvoid executeMissionPlan(MissionInfo mission, UAVMappingInfo mapping) throws DronologyServiceException;\n\n}\n"}, {"id": "DummyLockObject.java", "body": "package edu.nd.dronology.core.util;\n\n/**\n * Use as dummy object handy for \"synchronized(dummy)\" blocks.\n * \n * @author Michael Vierhauser\n * \n */\npublic class DummyLockObject {\n\n}\n"}, {"id": "ManagedDroneMessenger.java", "body": "package edu.nd.dronology.core.vehicle.manageddroneinternal;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshotOption;\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.flight.IFlightDirector;\nimport edu.nd.dronology.core.goal.AbstractGoal;\nimport edu.nd.dronology.core.vehicle.manageddroneinternal.message.*;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\nimport java.util.List;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.SynchronousQueue;\n\npublic class ManagedDroneMessenger {\n\n    private static final ILogger LOGGER = LoggerProvider.getLogger(ManagedDroneMessenger.class);\n    private final ArrayBlockingQueue<AbstractMessage> mailbox;\n\n    public ManagedDroneMessenger(ArrayBlockingQueue<AbstractMessage> mailbox) {\n        this.mailbox = mailbox;\n    }\n\n    private void offerMessage(AbstractMessage msg) {\n        if(!mailbox.offer(msg)) {\n            LOGGER.warn(\"Could not add message to mailbox \" + msg);\n        }\n    }\n\n    private <T> T returnService(AbstractMessage msg, SynchronousQueue<T> returnBox) {\n        try {\n            mailbox.put(msg);\n            return returnBox.take();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        throw new RuntimeException();\n    }\n\n    /**\n     * <p>\n     *  Gets the current position of the drone.\n     * </p>\n     *\n     * <p>\n     *     Note this sends a message and blocks while it waits to receive a return message from the managed drone with\n     *     the coordinates. The time it takes for this method to run is indeterminate.\n     * </p>\n     * @return\n     */\n    public LlaCoordinate getCoordinates() {\n        GetCoordinatesMessage msg = new GetCoordinatesMessage();\n        return returnService(msg, msg.returnBox);\n    }\n\n    /**\n     * Assigns a flight directive to the managed drone\n     *\n     * @param flightDirective\n     */\n    public void assignFlight(IFlightDirector flightDirective) {\n        AssignFlightMessage msg = new AssignFlightMessage(flightDirective);\n        offerMessage(msg);\n    }\n\n    /**\n     * Removes an assigned flight\n     */\n    public void unassignFlight() {\n        UnassignFlightMessage msg = new UnassignFlightMessage();\n        offerMessage(msg);\n    }\n\n    /**\n     * Tell the drone to fly home\n     */\n    public void returnHome() {\n        ReturnHomeMessage msg = new ReturnHomeMessage();\n        offerMessage(msg);\n    }\n\n    /**\n     *\n     * @param targetAltitude\n     *          Sets target altitude for takeoff\n     */\n    public void setTargetAltitude(double targetAltitude) {\n        SetTargetAltitudeMessage msg = new SetTargetAltitudeMessage(targetAltitude);\n        offerMessage(msg);\n    }\n\n    /**\n     * Tell the drone to takeoff\n     */\n    public void takeOff() {\n        TakeOffMessage msg = new TakeOffMessage();\n        offerMessage(msg);\n    }\n\n//    /**\n//     *\n//     * Get the drone's unique ID.\n//     *  <p>\n//     *     Note this sends a message and blocks while it waits to receive a return message from the managed drone with\n//     *     the return value. The time it takes for this method to run is indeterminate.\n//     * </p>\n//     * @return unique drone ID\n//     */\n//    public String getDroneName() {\n//        GetNameMessage msg = new GetNameMessage();\n//        return returnService(msg, msg.returnBox);\n//    }\n\n    /**\n     * Tell the drone to land. The drone will touch down on the ground.\n     *\n     */\n    public void land() {\n        LandMessage msg = new LandMessage();\n        offerMessage(msg);\n    }\n\n    /**\n     * Get the drone's base coordinates (its home location).\n     *  <p>\n     *     Note this sends a message and blocks while it waits to receive a return message from the managed drone with\n     *     the return value. The time it takes for this method to run is indeterminate.\n     * </p>\n     * @return the managed drone's base coordinates\n     */\n    public LlaCoordinate getBaseCoordinates() {\n        GetCoordinatesMessage msg = new GetCoordinatesMessage();\n        return returnService(msg, msg.returnBox);\n    }\n\n    /**\n     * Update the ManagedDrones list of commands.\n     * @param commands The commands this drone should carry out\n     */\n    public void updateGuidance(List<Command> commands) {\n        UpdateGuidanceMessage msg = new UpdateGuidanceMessage(commands);\n        offerMessage(msg);\n    }\n\n    public void getSnapshot(ArrayBlockingQueue<DroneSnapshotOption> returnQueue) {\n        GetSnapshotMessage msg = new GetSnapshotMessage(returnQueue);\n        offerMessage(msg);\n    }\n\n    public void updateGoal(AbstractGoal goal) {\n        GoalUpdateMessage msg = new GoalUpdateMessage(goal);\n        offerMessage(msg);\n    }\n}\n"}, {"id": "MissionPlanningServiceInstance.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.service.internal;\n\nimport java.io.File;\nimport java.net.MalformedURLException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.BasicFileAttributes;\n\nimport edu.nd.dronology.core.status.DronologyListenerManager;\nimport edu.nd.dronology.services.core.api.IFileChangeNotifyable;\nimport edu.nd.dronology.services.core.base.AbstractFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.info.MissionInfo;\nimport edu.nd.dronology.services.core.info.UAVMappingInfo;\nimport edu.nd.dronology.services.core.items.IMissionPlan;\nimport edu.nd.dronology.services.core.persistence.MissionPlanningPersistenceProvider;\nimport edu.nd.dronology.services.core.persistence.PersistenceException;\nimport edu.nd.dronology.services.core.util.DronologyConstants;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.services.core.util.ServiceIds;\nimport edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;\nimport edu.nd.dronology.services.extensions.missionplanning.plan.MissionController;\nimport edu.nd.dronology.services.extensions.missionplanning.sync.SynchronizationManager;\nimport edu.nd.dronology.services.instances.DronologyElementFactory;\nimport edu.nd.dronology.services.supervisor.SupervisorService;\nimport edu.nd.dronology.util.FileUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\npublic class MissionPlanningServiceInstance extends AbstractFileTransmitServiceInstance<MissionInfo>\n\t\timplements IFileChangeNotifyable, IMissionPlanningServiceInstance {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(MissionPlanningServiceInstance.class);\n\n\tpublic static final String EXTENSION = DronologyConstants.EXTENSION_MISSION;\n\n\tprivate DronologySeriviceListener listener;\n\n\tpublic MissionPlanningServiceInstance() {\n\t\tsuper(ServiceIds.SERVICE_MISSIONPLANNING, \"Mission Planning\", EXTENSION);\n\t}\n\n\t@Override\n\tprotected Class<?> getServiceClass() {\n\t\treturn MissionPlanningService.class;\n\t}\n\n\t@Override\n\tprotected int getOrder() {\n\t\t// TODO Auto-generated method stub\n\t\treturn 2;\n\t}\n\n\t@Override\n\tprotected String getPropertyPath() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void doStartService() throws Exception {\n\t\treloadItems();\n\t\tregisterListener();\n\t}\n\n\tprivate void registerListener() {\n\t\tlistener = new DronologySeriviceListener();\n\t\tDronologyListenerManager.getInstance().addListener(listener);\n\t\t\n\t}\n\n\t@Override\n\tprotected void doStopService() throws Exception {\n\t\tunregisterListener();\n\n\t}\n\n\tprivate void unregisterListener() {\n\t\tDronologyListenerManager.getInstance().removeListener(listener);\n\t\t\n\t}\n\n\t@Override\n\tpublic void executeMissionPlan(String mission) throws DronologyServiceException {\n\t\ttry {\n\t\t\tMissionController.getInstance().executeMission(mission);\n\t\t} catch (MissionExecutionException e) {\n\t\t\tLOGGER.error(e);\n\t\t\tnew DronologyServiceException(e.getMessage());\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void cancelMission() throws DronologyServiceException {\n\t\ttry {\n\t\t\tMissionController.getInstance().cancelMission();\n\t\t} catch (MissionExecutionException e) {\n\t\t\tLOGGER.error(e);\n\t\t\tnew DronologyServiceException(e.getMessage());\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void removeUAV(String uavid) throws DronologyServiceException {\n\t\tSynchronizationManager.getInstance().removeUAV(uavid);\n\n\t}\n\n\t@Override\n\tpublic MissionInfo createItem() throws DronologyServiceException {\n\t\tMissionPlanningPersistenceProvider persistor = MissionPlanningPersistenceProvider.getInstance();\n\t\tIMissionPlan missionPlan = MissionElementFactory.createNewMissionPlan();\n\t\tmissionPlan.setName(\"New-MissionPlan\");\n\t\tString savePath = FileUtil.concat(storagePath, missionPlan.getId(), EXTENSION);\n\n\t\ttry {\n\t\t\tpersistor.saveItem(missionPlan, savePath);\n\t\t} catch (PersistenceException e) {\n\t\t\tthrow new DronologyServiceException(\"Error when creating mission plan: \" + e.getMessage());\n\t\t}\n\t\treturn new MissionInfo(missionPlan.getName(), missionPlan.getId());\n\t}\n\n\t@Override\n\tprotected String getPath() {\n\t\tString path = SupervisorService.getInstance().getMissionPlanningLocation();\n\t\treturn path;\n\t}\n\n\t@Override\n\tprotected MissionInfo fromFile(String id, File file) throws Throwable {\n\t\tIMissionPlan atm = MissionPlanningPersistenceProvider.getInstance().loadItem(file.toURI().toURL());\n\t\tMissionInfo info = new MissionInfo(atm.getName(), id);\n\n\t\tBasicFileAttributes attr = Files.readAttributes(Paths.get(file.toURI()), BasicFileAttributes.class);\n\t\tinfo.setDateCreated(attr.creationTime().toMillis());\n\t\tinfo.setDateModified(attr.lastModifiedTime().toMillis());\n\t\tinfo.setDescription(atm.getDescription());\n\t\treturn info;\n\t}\n\n\t@Override\n\tpublic void executeMissionPlan(MissionInfo info) throws DronologyServiceException {\n\t\texecuteMissionPlan(info, new UAVMappingInfo());\n\t}\n\n\t@Override\n\tpublic void executeMissionPlan(MissionInfo info, UAVMappingInfo mapping) throws DronologyServiceException {\n\t\ttry {\n\t\t\tFile file = fileManager.getFile(info.getId());\n\t\t\tIMissionPlan mission = MissionPlanningPersistenceProvider.getInstance().loadItem(file.toURI().toURL());\n\n\t\t\tMissionController.getInstance().executeMission(mission,mapping);\n\t\t} catch (MissionExecutionException | MalformedURLException | PersistenceException e) {\n\t\t\tLOGGER.error(e);\n\t\t\tnew DronologyServiceException(e.getMessage());\n\t\t}\n\n\t}\n\n}\n"}, {"id": "IAreaMapping.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.util.List;\nimport edu.nd.dronology.services.core.areamapping.EdgeLla;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic interface IAreaMapping extends IPersistableItem {\n\n\tString getDescription();\n\n\tvoid setDescription(String description);\n\n\tList<EdgeLla> getMappedPoints(Integer part);\n\n\tvoid addMappedArea(Integer part, List<EdgeLla> coordinates);\n\n\tvoid addMappedArea(Integer part, EdgeLla coordinate);\n\n\tvoid removeCoordinate(int part, EdgeLla coordinate);\n\n\tvoid addMappedLocation(IMappedItem item);\n\t\n\tList<IMappedItem> getLocationMappings();\n\n\tvoid removeMappedLocation(String id) throws DronologyServiceException;\n\t\n\tvoid setUpstream(Boolean upstream);\n\t\n\tBoolean getUpstream();\n}\n"}, {"id": "DronePair.java", "body": "package edu.nd.dronology.core.collisionavoidance;\n\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\n\npublic class DronePair {\n    public final DroneSnapshot a;\n    public final DroneSnapshot b;\n\n    public DronePair(DroneSnapshot a, DroneSnapshot b) {\n        this.a = a;\n        this.b = b;\n    }\n\n    public double findDistance() {\n        return a.getPosition().distance(b.getPosition());\n    }\n}"}, {"id": "DroneMonitoringServiceRemoteFacade.java", "body": "package edu.nd.dronology.monitoring.service;\n\nimport java.rmi.RemoteException;\n\nimport edu.nd.dronology.core.monitoring.ArtifactIdentifier;\nimport edu.nd.dronology.monitoring.IRemoteMonitoringMessageHandler;\nimport edu.nd.dronology.services.remote.AbstractRemoteFacade;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * \n * Remote facade for monitoring UAVs<br>\n * Allows registering {@link IRemoteMonitoringMessageHandler} to subscribe to certain message types or topics<br>\n * \n * \n * @author Michael Vierhauser\n *\n */\n\npublic class DroneMonitoringServiceRemoteFacade extends AbstractRemoteFacade implements IDroneMonitoringRemoteService {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -4580658378477037955L;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(DroneMonitoringServiceRemoteFacade.class);\n\tprivate static volatile DroneMonitoringServiceRemoteFacade INSTANCE;\n\n\tprotected DroneMonitoringServiceRemoteFacade() throws RemoteException {\n\t\tsuper(DroneMonitoringService.getInstance());\n\t}\n\n\tpublic static IDroneMonitoringRemoteService getInstance() throws RemoteException {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (DroneMonitoringServiceRemoteFacade.class) {\n\t\t\t\ttry {\n\t\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\t\tINSTANCE = new DroneMonitoringServiceRemoteFacade();\n\t\t\t\t\t}\n\t\t\t\t} catch (RemoteException e) {\n\t\t\t\t\tLOGGER.error(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\n\t}\n\n\t@Override\n\tpublic void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler) throws RemoteException {\n\t\tDroneMonitoringService.getInstance().registerMonitoringMessageHandler(handler);\n\n\t}\n\n\t@Override\n\tpublic void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler, ArtifactIdentifier identifier)\n\t\t\tthrows RemoteException {\n\t\tDroneMonitoringService.getInstance().registerMonitoringMessageHandler(handler, identifier);\n\n\t}\n\n\t@Override\n\tpublic void setMonitoringFrequency(String uavid, Double frequency) throws RemoteException {\n\t\tDroneMonitoringService.getInstance().setMonitoringFrequency(uavid, frequency);\n\n\t}\n\n}"}, {"id": "AFDragLayout.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport com.vaadin.event.Transferable;\nimport com.vaadin.event.dd.DragAndDropEvent;\nimport com.vaadin.event.dd.DropHandler;\nimport com.vaadin.event.dd.DropTarget;\nimport com.vaadin.event.dd.TargetDetails;\nimport com.vaadin.event.dd.acceptcriteria.AcceptCriterion;\nimport com.vaadin.event.dd.acceptcriteria.Not;\nimport com.vaadin.event.dd.acceptcriteria.SourceIsTarget;\nimport com.vaadin.shared.ui.dd.HorizontalDropLocation;\nimport com.vaadin.ui.AbstractOrderedLayout;\nimport com.vaadin.ui.Component;\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.DragAndDropWrapper;\nimport com.vaadin.ui.VerticalLayout;\n\nimport edu.nd.dronology.services.core.info.FlightInfo;\nimport edu.nd.dronology.services.core.info.FlightPlanInfo;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;\nimport edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;\nimport edu.nd.dronology.ui.vaadin.flightroutes.FRInfoBox;\nimport edu.nd.dronology.ui.vaadin.start.MyUI;\n\n/**\n * This is the drag and drop vertical layout in which the FRInfoBoxes are stored \n * in the assign routes UI.  \n * \n * @author Patrick Falvey \n *\n */\n\npublic class AFDragLayout extends VerticalLayout {\n\n\t/**\n\t* \n\t*/\n\tprivate static final long serialVersionUID = -978484208144577037L;\n\tprivate SortableLayout layout = new SortableLayout();\n\tprivate IFlightManagerRemoteService flightRouteService;\n\tprivate IFlightRouteplanningRemoteService flightInfoService;\n\tprivate BaseServiceProvider provider = MyUI.getProvider();\n\tprivate String UAVid;\n\tprivate int boxID = 88888; //arbitrary value so the component ID does not overlap boxIDs from AFAssignRouteComponent\n\n\tpublic AFDragLayout(String UAVid) {\t\n\t\tthis.UAVid = UAVid;\n\t\tlayout.setSizeUndefined();\n\t\tfor (Component component : createComponents()) {\n\t\t\tlayout.addNewComponent(component);\n\t\t}\n\n\t\taddComponent(layout);\n\t}\n\n\t/**\n\t * \n\t * @return list of pending plans for the UAV\n\t */\n\tprivate List<Component> createComponents() {\n\t\tFlightInfo flightRouteInfo = null;\n\t\tCollection<FlightRouteInfo> items = null;\n\t\ttry {\n\t\t\tflightRouteService = (IFlightManagerRemoteService) provider.getRemoteManager()\n\t\t\t\t\t.getService(IFlightManagerRemoteService.class);\n\t\t\tflightInfoService = (IFlightRouteplanningRemoteService) provider.getRemoteManager()\n\t\t\t\t\t.getService(IFlightRouteplanningRemoteService.class);\n\t\t\tflightRouteInfo = flightRouteService.getFlightInfo(UAVid);\n\t\t\titems = flightInfoService.getItems();\n\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\tList<Component> components = new ArrayList<>();\n\t\t\n\t\tfor (FlightPlanInfo flight : flightRouteInfo.getPendingFlights()){ //convert plans into the FRInfoBoxes\n\t\t\tfor (FlightRouteInfo info : items){\n\t\t\t\tString flightName = flight.getName().length() < info.getName().length() ? flight.getName() : \n\t\t\t\t\tflight.getName().substring(flight.getName().length() - info.getName().length());\n\t\t\t\tif(flightName.equals(info.getName())){\n\t\t\t\t\tFRInfoBox box = new FRInfoBox(info);\n\t\t\t\t\tbox.setId(Integer.toString(this.boxID));\n\t\t\t\t\tthis.boxID++;\n\t\t\t\t\tcomponents.add(box);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn components;\n\t}\n\t\n\tpublic SortableLayout getSortableLayout(){\n\t\treturn this.layout;\n\t}\n\t\n\tpublic void addNewComponent(Component component){\n\t\tlayout.addNewComponent(component);\n\t}\n\t\n\t@Override\n\tpublic void removeComponent(Component component){\n\t\tlayout.removeComponent(component);\n\t}\n\t\n\t@Override\n\tpublic Component getComponent(int index){\n\t\treturn layout.getComponent(index);\n\t}\n\t\n\t@Override\n\tpublic int getComponentCount(){\n\t\treturn layout.getComponentCount();\n\t}\n\t\n\t@Override\n\tpublic int getComponentIndex(Component component){\n\t\treturn layout.getComponentIndex(component);\n\t}\n\tpublic static class SortableLayout extends CustomComponent {\n\t\t/**\n\t\t* \n\t\t*/\n\t\tprivate static final long serialVersionUID = 2763521051649448355L;\n\t\tprivate final AbstractOrderedLayout layout;\n\t\tprivate final DropHandler dropHandler;\n\n\t\tpublic SortableLayout() {\n\t\t\tlayout = new VerticalLayout();\n\t\t\tdropHandler = new ReorderLayoutDropHandler(layout);\n\n\t\t\tDragAndDropWrapper pane = new DragAndDropWrapper(layout);\n\t\t\tsetCompositionRoot(pane);\n\t\t}\n\t\t\n\t\tpublic VerticalLayout getVerticalLayout(){\n\t\t\treturn (VerticalLayout) layout;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int getComponentCount(){\n\t\t\treturn layout.getComponentCount();\n\t\t}\n\t\t\n\t\tpublic int getComponentIndex(Component component) {\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tIterator<Component> componentIterator = layout.getComponentIterator();\n\t\t\tWrappedComponent next = null;\n\t\t\tint index = 0;\n\t\t\twhile (componentIterator.hasNext()) { //important to compare with route name and component ID because some routes have the same name\n\t\t\t\tnext = (WrappedComponent) componentIterator.next();\n\t\t\t\tif (((FRInfoBox) next.getContent()).getName().equals(((FRInfoBox) component).getName()) && component.getId().equals(next.getContent().getId())){\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tpublic Component getComponent(int index) {\n\t\t\tWrappedComponent wrapper = (WrappedComponent) layout.getComponent(index);\n\t\t\treturn wrapper.getContent();\n\t\t}\n\t\t\n\t\tpublic void addNewComponent(Component component) {\n\t\t\tWrappedComponent wrapper = new WrappedComponent(component, dropHandler);\n\t\t\twrapper.setSizeUndefined();\n\t\t\tcomponent.setWidth(\"100%\");\n\t\t\twrapper.setWidth(\"100%\");\n\t\t\tlayout.addComponent(wrapper);\n\t\t}\n\t\t\n\t\tpublic void removeComponent(Component component) {\n\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\tIterator<Component> componentIterator = layout.getComponentIterator();\n\t\t\tWrappedComponent next = null;\n\t\t\tboolean cont = true;\n\t\t\twhile (cont && componentIterator.hasNext()) {\n\t\t\t\tnext = (WrappedComponent) componentIterator.next();\n\t\t\t\tif (((FRInfoBox) next.getContent()).getName().equals(((FRInfoBox) component).getName()) && component.getId().equals(next.getContent().getId())){\n\t\t\t\t\tlayout.removeComponent(next);\n\t\t\t\t\tcont = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static class WrappedComponent extends DragAndDropWrapper {\n\n\t\t/**\n\t\t* \n\t\t*/\n\t\tprivate static final long serialVersionUID = -6051699334166210253L;\n\t\tprivate final DropHandler dropHandler;\n\t\tprivate Component content;\n\n\t\tpublic WrappedComponent(Component content, DropHandler dropHandler) {\n\t\t\tsuper(content);\n\t\t\tthis.content = content;\n\t\t\tthis.dropHandler = dropHandler;\n\t\t\tsetDragStartMode(DragStartMode.WRAPPER);\n\t\t}\n\n\t\t@Override\n\t\tpublic DropHandler getDropHandler() {\n\t\t\treturn dropHandler;\n\t\t}\n\t\t\n\t\tpublic Component getContent(){\n\t\t\treturn this.content;\n\t\t}\n\n\t}\n\n\tprivate static class ReorderLayoutDropHandler implements DropHandler {\n\n\t\t/**\n\t\t* \n\t\t*/\n\t\tprivate static final long serialVersionUID = 8500739235515201928L;\n\t\tprivate AbstractOrderedLayout layout;\n\n\t\tpublic ReorderLayoutDropHandler(AbstractOrderedLayout layout) {\n\t\t\tthis.layout = layout;\n\t\t}\n\n\t\t@Override\n\t\tpublic AcceptCriterion getAcceptCriterion() {\n\t\t\treturn new Not(SourceIsTarget.get());\n\t\t}\n\n\t\t@Override\n\t\tpublic void drop(DragAndDropEvent dropEvent) {  //logic to determine the position of the drag and dropped object\n\t\t\tTransferable transferable = dropEvent.getTransferable();\n\t\t\tComponent sourceComponent = transferable.getSourceComponent();\n\t\t\tif (sourceComponent instanceof WrappedComponent) {\n\t\t\t\tTargetDetails dropTargetData = dropEvent.getTargetDetails();\n\t\t\t\tDropTarget target = dropTargetData.getTarget();\n\n\t\t\t\tboolean sourceWasAfterTarget = true;\n\t\t\t\tint index = 0;\n\t\t\t\t@SuppressWarnings(\"deprecation\")\n\t\t\t\tIterator<Component> componentIterator = layout.getComponentIterator();\n\t\t\t\tComponent next = null;\n\t\t\t\twhile (next != target && componentIterator.hasNext()) {\n\t\t\t\t\tnext = componentIterator.next();\n\t\t\t\t\tif (next != sourceComponent) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsourceWasAfterTarget = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (next == null || next != target) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (dropTargetData.getData(\"horizontalLocation\").equals(HorizontalDropLocation.CENTER.toString())) {\n\t\t\t\t\tif (sourceWasAfterTarget) {\n\t\t\t\t\t\tindex--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\telse if (dropTargetData.getData(\"horizontalLocation\").equals(HorizontalDropLocation.LEFT.toString())) {\n\t\t\t\t\tindex--;\n\t\t\t\t\tif (index < 0) {\n\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlayout.removeComponent(sourceComponent);\n\t\t\t\tlayout.addComponent(sourceComponent, index);\n\t\t\t}\n\t\t}\n\t}\n\n}"}, {"id": "DroneException.java", "body": "package edu.nd.dronology.core.exceptions;\n\n/**\n * @author Michael\n *\n */\npublic class DroneException extends Exception {\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -6599291683788888263L;\n\n\t/**\n\t* \n\t*/\n\n\tpublic DroneException(String msg) {\n\t\tsuper(msg);\n\t}\n}\n"}, {"id": "SimulatorScenarioCategoryInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\npublic class SimulatorScenarioCategoryInfo extends RemoteInfoObject {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -7327376857430499641L;\n\n\tpublic SimulatorScenarioCategoryInfo(String name, String id) {\n\t\tsuper(name, id);\n\t}\n\n}\n"}, {"id": "AbstractRegisterableUnit.java", "body": "package edu.nd.dronology.services.core.base;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport edu.nd.dronology.services.core.info.UAVRegistrationInfo;\nimport edu.nd.dronology.services.core.util.UnitState;\n\n/**\n * Abstract class for registerable units that register at the server.<br>\n * \n * @author Michael Vierhauser\n * \n */\n\npublic abstract class AbstractRegisterableUnit implements Serializable {\n\n\tprivate static final long serialVersionUID = 2983958174901066192L;\n\t/** The timestamp when the unit was created **/\n\tpublic static final String TIMESTAMP = \"timestamp\";\n\t/** The IP address of the sender **/\n\tpublic static String IP_ADDRESS = \"ipaddress\";\n\t/** The designated command port of the unit **/\n\tpublic static final String COMMAND_PORT = \"commandport\";\n\t/** Unregister flag **/\n\tpublic static final String UNREGISTER = \"unregister\";\n\t/** The current state of the unit **/\n\tpublic static String STATE = \"state\";\n\tprotected final String ID;\n\t\n\n\t\n\tpublic static final  String HAS_REMOTEOBJECT = \"hasRemoteObject\";\n\tpublic static final String IS_MANAGED = \"isManaged\";\n\t\n\tprotected final String hostname;\n\tprivate Map<String, String> attributes = new HashMap<>();\n\n\tprotected AbstractRegisterableUnit(String ID, String hostname) {\n\t\tsuper();\n\t\tthis.ID = ID;\n\t\tthis.hostname = hostname;\n\t\taddAttribute(STATE, UnitState.UNKNOWN.name());\n\t}\n\n\t/**\n\t * \n\t * @return The id of the unit.\n\t */\n\tpublic String getID() {\n\t\treturn ID;\n\t}\n\n\t/**\n\t * \n\t * @return The hostname of the unit.\n\t */\n\tpublic String getHost() {\n\t\treturn hostname;\n\t}\n\n\t/**\n\t * \n\t * @return A map of key-values of attributes.\n\t */\n\tpublic Map<String, String> getAttributes() {\n\t\treturn Collections.unmodifiableMap(attributes);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = (prime * result) + ID.hashCode();\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object thatObject) {\n\t\tif (this == thatObject) {\n\t\t\treturn true;\n\t\t}\n\t\tif (thatObject == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (getClass() != thatObject.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tAbstractRegisterableUnit other = (AbstractRegisterableUnit) thatObject;\n\t\tif (!other.ID.equals(this.ID)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Adds a new attribute to the unit.\n\t * \n\t * @param key\n\t * @param value\n\t */\n\tpublic void addAttribute(String key, String value) {\n\t\tattributes.put(key, value);\n\t}\n\n\t/**\n\t * \n\t * @param key\n\t * @return The attribute associated with the key.<br>\n\t *         Retunrs {@code null} if no attribute exists for the give key.\n\t */\n\tpublic String getAttribute(String key) {\n\t\tif (attributes.containsKey(key)) {\n\t\t\treturn attributes.get(key);\n\t\t}\n\t\treturn null;\n\t}\n/**\n * \n * @return The type of the unit as human readable string representation.\n */\n\tpublic abstract String getUnitType();\n\n}\n"}, {"id": "UAVAcknowledgeMessage.java", "body": "package edu.nd.dronology.gstation.connector.messages;\n\nimport java.io.Serializable;\n\npublic class UAVAcknowledgeMessage extends AbstractUAVMessage<Object> implements Serializable {\n\n\tprivate static final long serialVersionUID = 1502042637906425729L;\n\tpublic static final String MESSAGE_TYPE = \"ack\";\n\n\tpublic UAVAcknowledgeMessage(String messagetype, String groundstationid, String uavid) {\n\t\tsuper(MESSAGE_TYPE, groundstationid, uavid);\n\t}\n\n}\n"}, {"id": "AbstractFlightPattern.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.patterns;\n\nimport edu.nd.dronology.services.extensions.missionplanning.sync.SynchronizationManager;\nimport edu.nd.dronology.services.extensions.missionplanning.tasks.IMissionTask;\n\n/**\n * Base class for all predefined flight patterns that can be exanded\n * \n * @author Michael Vierhauser\n *\n */\npublic abstract class AbstractFlightPattern implements IFlightPattern {\n\n\tprotected SynchronizationManager synchPointMgr;\n\tprivate TaskList taskList = new TaskList();\n\n\t@Override\n\tpublic void initialize(SynchronizationManager synchPointMgr) {\n\t\tthis.synchPointMgr = synchPointMgr;\n\t\tdoCreateSyncPoints();\n\t}\n\n\tprotected abstract void doCreateSyncPoints();\n\n\tprotected void addSyncPoint(String pointname) {\n\t\tsynchPointMgr.createSynchronizationPoint(pointname);\n\n\t}\n\n\tprotected void addTask(IMissionTask task) {\n\t\ttaskList.addTask(task);\n\n\t}\n\n\t@Override\n\tpublic TaskList getTaskList() {\n\t\treturn taskList;\n\t}\n\n}\n"}, {"id": "RiverBank.java", "body": "package edu.nd.dronology.services.extensions.areamapping.internal;\n\nimport java.awt.geom.Point2D;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Vector;\n\n\npublic class RiverBank {\n\tprivate List<Point2D.Double> riverBank;\n\t\n\tpublic RiverBank() {\n\t\triverBank = new Vector<Point2D.Double>();\n\t}\n\t\n\tpublic void add(Point2D.Double bankNode) {\n\t\triverBank.add(bankNode);\n\t}\n\t\n\tpublic void add(int entry, Point2D.Double bankNode) {\n\t\triverBank.add(entry,bankNode);\n\t}\n\t\n\tpublic void reverse() {\n\t\tCollections.reverse(riverBank);\n\t}\n\t\n\tpublic List<Point2D.Double> get(){\n\t\treturn Collections.unmodifiableList(riverBank);\n\t}\n\t\n\tpublic Point2D.Double get(int entry){\n\t\treturn riverBank.get(entry);\n\t}\n\t\n\tpublic int size() {\n\t\treturn riverBank.size();\n\t}\n}\n"}, {"id": "ConnectionRequestMessage.java", "body": "package edu.nd.dronology.gstation.connector.messages;\n\nimport java.io.Serializable;\n/**\n * When a new GCS connects to Dronology it sends a {@link ConnectionRequestMessage}.\n * \n * @author Michael Vierhauser\n *\n */\npublic class ConnectionRequestMessage extends AbstractUAVMessage<Object> implements Serializable {\n\n\tprivate static final long serialVersionUID = 1502042637906425729L;\n\tpublic static final String MESSAGE_TYPE = \"connect\";\n\n\tpublic ConnectionRequestMessage(String groundstationId) {\n\t\tsuper(MESSAGE_TYPE, groundstationId, groundstationId);\n\t}\n\n\t@Override \n\tpublic void setType(String type) {\n\t\tthis.type = type;\n\n\t}\n\n}\n"}, {"id": "UAVModeChangeMessage.java", "body": "package edu.nd.dronology.gstation.connector.messages;\n\nimport java.io.Serializable;\n\n/**\n * Monitoring message received from the GCS for a specific UAV.\n * \n * @author Michael Vierhauser\n *\n */\npublic class UAVModeChangeMessage extends AbstractUAVMessage<Object> implements Serializable {\n\n\tprivate static final long serialVersionUID = 1502042637906425729L;\n\tpublic static final String MESSAGE_TYPE = \"modechange\";\n\tpublic static final String DATA = \"data\";\n\tpublic static final transient String MODE = \"mode\";\n\tpublic static final transient String GS_ID = \"groundstationid\";\n\tpublic static final transient String UAV_ID = \"uavid\";\n\n\tpublic UAVModeChangeMessage(String groundstationid, String uavid, String mode) {\n\t\tsuper(MESSAGE_TYPE, groundstationid, uavid);\n\t\tdata.put(MODE, mode);\n\t}\n\n\t@Override\n\tpublic void setType(String type) {\n\t\tthis.type = type;\n\n\t}\n\n\tpublic String getMode() {\n\t\treturn data.get(MODE).toString();\n\t}\n\n}\n"}, {"id": "DroneType.java", "body": "package edu.nd.dronology.core.fleet;\n\npublic enum DroneType {LEAD_DRONE, PLATOON_FOLLOWER}\n"}, {"id": "ArtifactIdentifier.java", "body": "package edu.nd.dronology.core.monitoring;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport edu.nd.dronology.util.NullUtil;\n\n/**\n * A structured Identifier. Each object holds an id part and refers to child IDs\n * which in turn<br/> \n * hold again one id part, etc, which altogether form the whole identifier.\n * <p/>\n * \n * @author Michael Vierhauser\n * \n */\npublic class ArtifactIdentifier<TYPE> implements Serializable {\n\n\tprivate static final long serialVersionUID = 9173775383058285758L;\n\tprivate static final String SEPARATOR = \"::\";\n\tpublic static final String ROOT = \"DRONOLOGY\";\n\n\t// Never null\n\tprivate final String id;\n\t// May be null, when this is the last part of an identifier.\n\tpublic static AtomicInteger COUNTER = new AtomicInteger(0);\n \n\tprivate final ArtifactIdentifier child;\n\tprivate Set<TYPE> attacheditems = new HashSet<>();\n\n\t/**\n\t * \n\t * @param ids\n\t *            The ids that will be mapped to root and child ArtifactIdentifier\n\t */\n\tpublic ArtifactIdentifier(String... ids) {\n\t\tif (ids.length < 1) {\n\t\t\tthrow new IllegalArgumentException(\"At least 1 id is required\");\n\t\t}\n\t\tCOUNTER.addAndGet(1);\n\t\tthis.id = ids[0];\n\t\tNullUtil.checkNull(id);\n\t\tif (ids.length > 1) {\n\t\t\tchild = new ArtifactIdentifier(Arrays.copyOfRange(ids, 1, ids.length));\n\t\t} else {\n\t\t\tchild = null;\n\t\t}\n\t}\n\n\t/**\n\t * \n\t * @return The id of the parent ArtifactIdentifier\n\t */\n\tpublic synchronized String getId() {\n\t\treturn id;\n\t}\n\n\t/**\n\t * \n\t * @return The child ArtifactIdentifier\n\t */\n\tpublic synchronized ArtifactIdentifier getChild() {\n\t\treturn child;\n\t}\n\n\t/**\n\t * Returns all artifact identifier concatenated (separated by ::)\n\t */\n\t@Override\n\tpublic synchronized String toString() {\n\t\tif (child == null) {\n\t\t\treturn id;\n\t\t}\n\t\treturn String.format(\"%s\" + SEPARATOR + \"%s\", id, child.toString());\n\t}\n\n\t@Override\n\tpublic synchronized int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((child == null) ? 0 : child.hashCode());\n\t\tresult = prime * result + ((id == null) ? 0 : id.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic synchronized boolean equals(Object obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (obj == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (getClass() != obj.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tArtifactIdentifier other = (ArtifactIdentifier) obj;\n\t\tif (child == null) {\n\t\t\tif (other.child != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (!child.equals(other.child)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (id == null) {\n\t\t\tif (other.id != null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (!id.equals(other.id)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tprotected void finalize() throws Throwable {\n\t\ttry {\n\t\t\tCOUNTER.addAndGet(-1);\n\t\t} finally {\n\t\t\tsuper.finalize();\n\t\t}\n\t}\n\n\tpublic Collection<TYPE> getAttachedItems() {\n\t\treturn Collections.unmodifiableCollection(attacheditems);\n\t}\n\n\tpublic void attachItem(TYPE item) {\n\t\tattacheditems.add(item);\n\n\t}\n\n\tpublic void removeAttachedItem(TYPE handler) {\n\t\tattacheditems.remove(handler);\n\n\t}\n\n\tpublic void attachItems(Collection<TYPE> toAdd) {\n\t\tattacheditems.addAll(toAdd);\n\n\t}\n}\n"}, {"id": "PrioritySide.java", "body": "package edu.nd.dronology.services.core.items;\n\npublic class PrioritySide extends MappedItem {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -3286441007471288294L;\n\n\tpublic PrioritySide(String id) {\n\t\tsuper(id);\n\t}\n\n}\n"}, {"id": "IRegionOfInterest.java", "body": "package edu.nd.dronology.services.core.areamapping;\n\nimport java.util.List;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\npublic interface IRegionOfInterest {\n\n\tString getName();\n\n\tString getDescription();\n\n\tdouble getWeight();\n\n\tList<LlaCoordinate> getArea();\n\t\n\tString getAreaAttribute(String attributeName);\n\n}"}, {"id": "TagList.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class TagList implements Serializable {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 3805379647109731039L;\n\tprivate List<String> tags = new ArrayList<>();\n\n\tpublic void add(String tag) {\n\t\ttags .add(tag);\n\n\t}\n\n}\n"}, {"id": "AreaMappingInfo.java", "body": "\npackage edu.nd.dronology.services.core.info;\n\nimport java.util.LinkedList;\nimport java.util.Vector;\n\nimport edu.nd.dronology.services.core.areamapping.EdgeLla;\n\npublic class AreaMappingInfo extends RemoteInfoObject {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -8659534015844582331L;\n\tprivate Vector<LinkedList<EdgeLla>> coordinates = new Vector<>();\n\tprivate long dateCreated;\n\tprivate long dateModified;\n\tprivate double length;\n\tprivate String description;\n\t\n\tpublic AreaMappingInfo(String name, String id) {\n\t\tsuper(name, id);\n\t\tcoordinates.add(0, new LinkedList<>());\n\t\tcoordinates.add(1, new LinkedList<>());\n\t}\n\t\n\tpublic double getMappingLength() {\n\t\treturn length;\n\t}\n\t\n\tpublic void addCoordinate(int part, EdgeLla coordinate) {\n\t\tcoordinates.get(part).add(coordinate);\n\t}\n\t\n\tpublic void removeCoordinate(int part, EdgeLla coordinate) {\n\t\tcoordinates.get(part).remove(coordinate);\n\t}\n\t\n\tpublic LinkedList<EdgeLla> getCoordinates(int part) {\n\t\treturn coordinates.get(part);\n\t}\n\n\tpublic void setDateModified(long dateModified) {\n\t\tthis.dateModified = dateModified;\n\t}\n\n\tpublic void setDateCreated(long dateCreated) {\n\t\tthis.dateCreated = dateCreated;\n\t}\n\n\tpublic long getDateCreated() {\n\t\treturn dateCreated;\n\t}\n\n\tpublic long getDateModified() {\n\t\treturn dateModified;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n}\n"}, {"id": "ArtifactIdentifierTree.java", "body": "package edu.nd.dronology.monitoring.tree;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport edu.nd.dronology.core.monitoring.ArtifactIdentifier;\nimport edu.nd.dronology.util.NullUtil;\n\n/**\n * Based on the structure of {@link ArtifactIdentifier} builds up a tree of the \"id parts\".\n * \n * @author Michael Vierhauser\n * \n */\n\npublic class ArtifactIdentifierTree {\n\n\tprivate final TreeNode root;\n\n\tpublic ArtifactIdentifierTree(final ArtifactIdentifier root) {\n\t\tif (root == null) {\n\t\t\tthrow new IllegalArgumentException(\"Parameter root can't be null!\");\n\t\t}\n\t\tthis.root = new TreeNode(root);\n\t}\n\n\tpublic void clear() {\n\t\troot.clear();\n\t}\n\n\t/**\n\t * Will add id to the tree by creating appropriate child elements, enabling {@link #getAllRelatedIdentifier(ArtifactIdentifier)}.\n\t * \n\t * @param id\n\t */\n\tpublic void add(final ArtifactIdentifier id) {\n\t\tNullUtil.checkNull(id);\n\t\tadd(root, id, id);\n\t}\n\n\t/**\n\t * Will step-wise create child elements based on the part-ids of \"current\".\n\t * \n\t * @param parent\n\t *          Node has to exist already.\n\t * @param source\n\t *          The original full identifier.\n\t * @param current\n\t *          The currently remaining id parts to be mapped into the tree.\n\t * @return The next-step child node to the id.\n\t */\n\tprivate TreeNode add(TreeNode parent, ArtifactIdentifier source, ArtifactIdentifier current) {\n\t\tNullUtil.checkNull(parent, current);\n\t\t// Construct an ident only from the first id part.\n\t\tArtifactIdentifier art = new ArtifactIdentifier(current.getId());\n\t\t// Get an existing or create a new child node for this identifier.\n\t\tTreeNode child = parent.getChild(art);\n\t\tif (current.getChild() != null) {\n\t\t\t// If the id has more child parts.\n\t\t\treturn add(child, source, current.getChild());\n\t\t}\n\t\tchild.addElement(source);\n\t\treturn child;\n\t}\n\n\t/**\n\t * \n\t * @param id\n\t * @return All {@link ArtifactIdentifier} currently in the tree and children of the given id.\n\t */\n\tpublic Set<ArtifactIdentifier> getAllRelatedIdentifier(ArtifactIdentifier id) {\n\t\tNullUtil.checkNull(id);\n\t\tadd(id);\n\t\tTreeNode matching = findMatchingNode(root.getChildren().get(new ArtifactIdentifier(id.getId())), id);\n\t\treturn getChildren(matching);\n\t}\n\n\t/**\n\t * \n\t * @param id\n\t * @return All {@link ArtifactIdentifier} currently in the tree and children of the given id.\n\t */\n\tpublic Set<ArtifactIdentifier> getParents(ArtifactIdentifier id) {\n\t\tNullUtil.checkNull(id);\n\t\tadd(id);\n\t\tTreeNode matching = findMatchingNode(root.getChildren().get(new ArtifactIdentifier(id.getId())), id);\n\t\treturn getParent(matching);\n\t}\n\n\tprivate Set<ArtifactIdentifier> getParent(TreeNode matching) {\n\t\tSet<ArtifactIdentifier> matches = new HashSet<>();\n\t\tif (matching == root) {\n\t\t\treturn matches;\n\t\t}\n\t\tgetParent(matching, matches);\n\t\treturn matches;\n\n\t}\n\n\tprivate void getParent(TreeNode node, Set<ArtifactIdentifier> matches) {\n\t\tif (node == root) {\n\t\t\treturn;\n\t\t}\n\t\tmatches.addAll(node.getElements());\n\t\tgetParent(node.getParent(), matches);\n\t}\n\n\t/**\n\t * \n\t * @param matching\n\t * @return Unmodifiable set-copy of all identifiers of all {@link TreeNode#getElements()} of all child treenodes of matching.\n\t */\n\tprivate Set<ArtifactIdentifier> getChildren(TreeNode matching) {\n\t\tNullUtil.checkNull(matching);\n\t\tSet<ArtifactIdentifier> matches = new HashSet<>();\n\t\t// Add all elements from this node.\n\t\tmatches.addAll(matching.getElements());\n\t\t// Recursively add all elements from child treenodes.\n\t\tfor (Entry<ArtifactIdentifier, TreeNode> n : matching.getChildren().entrySet()) {\n\t\t\tmatches.addAll(getChildren(n.getValue()));\n\t\t}\n\t\treturn Collections.unmodifiableSet(matches);\n\t}\n\n\t/**\n\t * Multi-step lookup to find a child/grandchild/etc that exactly matches the id.\n\t * \n\t * @param parent\n\t * @param id\n\t * @return The node corresponding to the id.\n\t */\n\tprivate TreeNode findMatchingNode(TreeNode parent, ArtifactIdentifier id) {\n\t\tif (id.getChild() == null) {\n\t\t\treturn parent;\n\t\t}\n\t\tArtifactIdentifier newArt = new ArtifactIdentifier(id.getChild().getId());\n\t\treturn findMatchingNode(parent.getChildren().get(newArt), id.getChild());\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"ArtifactIdentifierTree [root=\" + root + \"]\";\n\t}\n\n\t/**\n\t * Log some diagnostic output.\n\t */\n\t@SuppressWarnings(\"unused\")\n\tprivate void toLog() {\n\t\troot.toLog();\n\t}\n\n\n\tpublic void remove(ArtifactIdentifier id) {\n\t\tTreeNode node = findMatchingNode(root, id);\n\t\tif (node != null && node.getChildren().size() == 0 && node.getParent() != null) {\n\t\t\tnode.getParent().remove(node);\n\t\t}\n\n\t}\n\n\tpublic int size() {\n\t\tint size = 0;\n\t\tsize += count(root.getChildren().values());\n\t\treturn size;\n\t}\n\n\tprivate int count(Collection<TreeNode> values) {\n\t\tint count = 0;\n\t\tfor (TreeNode n : values) {\n\t\t\tcount += n.getChildren().size();\n\t\t\tcount += count(n.getChildren().values());\n\t\t}\n\t\treturn count;\n\t}\n}\n"}, {"id": "StrategyFactory.java", "body": "package edu.nd.dronology.services.extensions.areamapping.selection;\n\nimport edu.nd.dronology.services.extensions.areamapping.selection.random.RandomRouteSelector;\n\npublic class StrategyFactory {\n\n\tpublic static IRouteSelectionStrategy getSelectionStrategy() {\n\t\treturn new RandomRouteSelector();\n\t}\n\n}\n"}, {"id": "CoverageStatistics.java", "body": "package edu.nd.dronology.services.extensions.areamapping.unused;\n//package edu.nd.dronology.extensions.dynamicareacoverage.out;\n//\n//import java.nio.DoubleBuffer;\n//\n//public class CoverageStatistics {\n//\tprivate double coverage;\n//\tprivate double wastedEffort;\n//\t\n//\tpublic CoverageStatistics() {\n//\t\tcoverage = 0;\n//\t\twastedEffort = 0;\n//\t}\n//\t\n//\tpublic double getCoverage() {\n//\t\treturn coverage;\n//\t}\n//\t\n//\tpublic double getWastedEffort() {\n//\t\treturn wastedEffort;\n//\t}\n//\t\n//\tpublic void setCoverage(double coverageFraction) {\n//\t\tcoverage = coverageFraction;\n//\t}\n//\t\n//\tpublic void setWastedEffort(double wastedEffortFraction) {\n//\t\twastedEffort = wastedEffortFraction;\n//\t}\n//}\n"}, {"id": "DroneConnectorService.java", "body": "package edu.nd.dronology.gstation.connector.service.connector;\n\nimport edu.nd.dronology.gstation.connector.GroundStationException;\nimport edu.nd.dronology.gstation.connector.GroundstationConnector;\nimport edu.nd.dronology.gstation.connector.messages.ConnectionRequestMessage;\nimport edu.nd.dronology.services.core.base.AbstractServerService;\n\npublic class DroneConnectorService extends AbstractServerService<IDroneConnectorServiceInstance> {\n\n\tprivate static volatile DroneConnectorService INSTANCE;\n\n\tprotected DroneConnectorService() {\n\t}\n\n\t/**\n\t * @return The singleton ConfigurationService instance\n\t */\n\tpublic static DroneConnectorService getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (DroneConnectorService.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new DroneConnectorService();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tprotected IDroneConnectorServiceInstance initServiceInstance() {\n\t\treturn new DroneConnectorServiceInstance();\n\t}\n\n\tpublic void handleConnection(GroundstationConnector connector) {\n\t\tserviceInstance.handleConnection(connector);\n\n\t}\n\n\tpublic void registerConnection(GroundstationConnector connector, ConnectionRequestMessage msg)\n\t\t\tthrows GroundStationException {\n\t\tserviceInstance.registerConnection(connector, msg);\n\n\t}\n\n\tpublic void unregisterConnection(String groundstationid) throws GroundStationException {\n\t\tserviceInstance.unregisterConnection(groundstationid); \n\n\t}\n\n}\n"}, {"id": "AFMissionOperations.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport java.rmi.RemoteException;\nimport java.util.Map;\n\nimport com.vaadin.event.ContextClickEvent;\nimport com.vaadin.event.ContextClickEvent.ContextClickListener;\nimport com.vaadin.event.LayoutEvents.LayoutClickListener;\nimport com.vaadin.shared.MouseEventDetails;\nimport com.vaadin.ui.Button;\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.HorizontalLayout;\nimport com.vaadin.ui.Label;\nimport com.vaadin.ui.NativeButton;\nimport com.vaadin.ui.UI;\nimport com.vaadin.ui.Upload;\nimport com.vaadin.ui.VerticalLayout;\nimport com.vaadin.ui.Window;\n\nimport edu.nd.dronology.services.core.info.MissionInfo;\nimport edu.nd.dronology.services.core.remote.IMissionPlanningRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.ui.vaadin.missionplanning.MPEditMissionHelpWindow;\nimport edu.nd.dronology.ui.vaadin.missionplanning.MPEditMissionWindow;\nimport edu.nd.dronology.ui.vaadin.missionplanning.MPInfoPanel;\nimport edu.nd.dronology.ui.vaadin.missionplanning.MPMapComponent;\nimport edu.nd.dronology.ui.vaadin.start.MyUI;\n\n/**\n * This is the set of map operation buttons in the AFInfoPanel\n * \n * @author Patrick Falvey\n *\n */\n\npublic class AFMissionOperations extends CustomComponent {\n\n\tprivate static final long serialVersionUID = -2249802562670339842L;\n\tprivate HorizontalLayout buttons = new HorizontalLayout();\n\tprivate Upload upload;\n\tprivate Button cancelMission = new Button(\"Cancel Mission\");\n\tprivate Button executeMission=new Button(\"Execute Mission\");\n\t//private AFChooseMissionWindow chooseMissionWindow;\n\n\tpublic AFMissionOperations(AFInfoPanel infoPanel) {\n\t\tVerticalLayout layout = new VerticalLayout();\n\t\tlayout.addStyleName(\"af_mission_group\");\n\n\t\tLabel caption = new Label(\"Mission Operations\");\n\n\t//\tMissionHandler handler = new MissionHandler();\n\t//\tupload = new Upload(null, handler.getReceiver());\n\t//\tupload.setVisible(true);\n\t//\tupload.addSucceededListener(handler.getReceiver());\n\t//\tupload.setImmediateMode(true);\n\t//\tupload.setButtonCaption(\"Execute Mission\");\n\t\tcancelMission.addClickListener(e -> {\n\t\t\tcancelMisison();\n\n\t\t});\n\t\texecuteMission.addClickListener( e ->{\n\t\t\tUI.getCurrent().addWindow(new AFChooseMissionWindow(infoPanel));\n\t\t});\n\t\t\n\t\n\t\t\n\t//\tContextClickListener myListener = new MyListener();\n\t//\tupload.addContextClickListener(myListener);\n\n\t\tbuttons.addComponents(executeMission, cancelMission);   //upload\n\t\tlayout.addComponents(caption, buttons);\n\n\t\tsetCompositionRoot(layout);\n\t}\n\n\tprivate void cancelMisison() {\n\t\ttry {\n\t\t\tIMissionPlanningRemoteService service = (IMissionPlanningRemoteService) MyUI.getProvider()\n\t\t\t\t\t.getRemoteManager().getService(IMissionPlanningRemoteService.class);\n\t\t\tservice.cancelMission();\n\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\tMyUI.setConnected(false);\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n\tpublic void addOnClickListener(LayoutClickListener listener) {\n\t\tbuttons.addLayoutClickListener(listener);\n\t}\n\n\t\n//\tprivate class MyListener implements ContextClickListener {\n\n\t\t/**\n\t\t * \n\t\t */\n\t//\tprivate static final long serialVersionUID = -1892418708777796487L;\n\n\t//\t@Override\n\t//\tpublic void contextClick(ContextClickEvent event) {\n\t\t\t// upload\n\t//\t\tSystem.out.println(\"CLICK!\");\n\t//\t\tupload.submitUpload();\n\t//\t}\n\t//}\n\n}\n"}, {"id": "IUAVTypeRegistrationServiceInstance.java", "body": "package edu.nd.dronology.services.instances.registration.types;\n\nimport edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.info.UAVTypeRegistrationInfo;\n\npublic interface IUAVTypeRegistrationServiceInstance extends IFileTransmitServiceInstance<UAVTypeRegistrationInfo> {\n\n\t\n}\n"}, {"id": "SimpleMonitor.java", "body": "package edu.nd.dronology.monitoring.simplechecker.monitor;\n\nimport edu.nd.dronology.core.monitoring.ArtifactIdentifier;\n\nimport edu.nd.dronology.monitoring.service.IDroneMonitoringRemoteService;\nimport edu.nd.dronology.monitoring.simplechecker.BaseServiceProvider;\n\npublic class SimpleMonitor {\n\n\tpublic static void main(String[] args) {\n\n\t\tMonitorDialog dialog = new MonitorDialog();\n\t\tnew Thread(new Runnable() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tdialog.main(args);\n\t\t\t}\n\t\t}).start();\n\t\ttry {\n\t\t\tThread.sleep(3000);\n\t\t} catch (InterruptedException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tBaseServiceProvider provider = new BaseServiceProvider();\n\n\t\ttry {\n\t\t\tSystem.setProperty(\"java.rmi.server.hostname\", \"localhost\");\n\n\t\t\tIDroneMonitoringRemoteService sevice = (IDroneMonitoringRemoteService) provider.getRemoteManager()\n\t\t\t\t\t.getService(IDroneMonitoringRemoteService.class);\n\n\t\t\tArtifactIdentifier id = new ArtifactIdentifier(ArtifactIdentifier.ROOT, \"INTERNAL\", \"MISSION_WAYPOINT\");\n\t\t\tArtifactIdentifier id2 = new ArtifactIdentifier(ArtifactIdentifier.ROOT, \"INTERNAL\", \"COLLISION\");\n\t\t\tRemoteMessageHandler handler = new RemoteMessageHandler(dialog);\n\t\t\tsevice.registerMonitoringMessageHandler(handler, id);\n\t\t\tsevice.registerMonitoringMessageHandler(handler, id2);\n\t\t} catch (Throwable e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n"}, {"id": "Geometry.java", "body": "package edu.nd.dronology.services.extensions.areamapping.internal;\n\n\n\n\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Path2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Vector;\n\nimport edu.nd.dronology.services.extensions.areamapping.model.RiverSubsegment;\nimport edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;\nimport edu.nd.dronology.services.extensions.areamapping.util.Utilities;\npublic class Geometry {\n\n    static final double RADIUS = 6373000.0;\n    public static final double EPSILON = 0.000001;\n\n    /**\n     * This function calculates the angle between two points.\n     * @param a\n     * @param b\n     * @return angle between two points\n     */\n    public static double getAngle(Point2D.Double a, Point2D.Double b) {\n        double angle = 0;\n        if(!(a.getX() == b.getX() || a.getY() == b.getY()))\n        {\n            angle = Math.atan2(b.getY() - a.getY(), b.getX() - a.getX()) ;\n        }\n        return angle;\n    }\n\n    /**\n     * This function finds the midpoint between two points.\n     * @param a\n     * @param b\n     * @return midpoint between two points.\n     */\n    public static Point2D.Double findMidpoint(Point2D.Double a, Point2D.Double b) {\n        Point2D.Double mid = new Point2D.Double((a.getX()+b.getX())/2, (a.getY()+b.getY())/2);\n        return mid;\n    }\n\n\n    /**\n     * This function takes a point of gps coordinates and translates into cartesian coordinates.\n     * X is latitude, Y is longitude, and centralLatitude is the latitude of a point in the river.\n     * @param gpsPoint\n     * @param centralLatitude\n     * @return Point2D.Double of cartesian coordinates\n     */\n    public static Point2D.Double gpsToCartesian (Point2D.Double gpsPoint, double centralLatitude){\n        Point2D.Double cartesianPoint = new Point2D.Double();\n\n        double lat = Math.toRadians(gpsPoint.getX());\n        double lon = Math.toRadians(gpsPoint.getY());\n        double aspectRatio = Math.cos(Math.toRadians(centralLatitude));\n\n        double xCartesian = RADIUS * lat;\n        double yCartesian = RADIUS * lon * aspectRatio;\n\n        cartesianPoint = new Point2D.Double(xCartesian,yCartesian);\n        return cartesianPoint;\n    }\n\n    /*This function is the inverse of gpsToCartesian. */\n\n    /**\n     * This function performs the reverse operation of gpsToCartesian. It takes a point of cartesian coordinates\n     * and translates them into gps coordinates.\n     * @param cartesianPoint\n     * @param centralLatitude\n     * @return Point2D.Double of gps coordinates\n     */\n    public static Point2D.Double cartesianToGPS (Point2D.Double cartesianPoint, double centralLatitude) {\n        Point2D.Double gpsPoint = new Point2D.Double();\n\n        double xCartesian = cartesianPoint.getX();\n        double yCartesian = cartesianPoint.getY();\n        double aspectRatio = Math.cos(Math.toRadians(centralLatitude));\n\n        double lat = Math.toDegrees(xCartesian / RADIUS);\n        double lon = Math.toDegrees(yCartesian / (RADIUS * aspectRatio));\n\n        gpsPoint = new Point2D.Double(lat, lon);\n        return gpsPoint;\n    }\n\n    /**\n     * This function finds the intersection point of two line segments\n     * @param line1\n     * @param line2\n     * @return intersection point of the two line segments\n     */\n    public static Point2D.Double findLineIntersection(Line2D.Double line1, Line2D.Double line2){\n        double m1, m2, b1, b2, xIntersection, yIntersection;\n        \n        m1 = (line1.getP2().getY() - line1.getP1().getY()) / (line1.getP2().getX() - line1.getP1().getX());\n        m2 = (line2.getP2().getY() - line2.getP1().getY()) / (line2.getP2().getX() - line2.getP1().getX());\n        \n        if (m1 > 1000 || m1 < -1000){\n            xIntersection = line1.getP1().getX();\n            b2 = line2.getP1().getY() - (m2 * line2.getP1().getX());\n            yIntersection = m2 * xIntersection + b2;\n        }\n        else if (m2 > 1000 || m2 < -1000){\n            xIntersection = line2.getP1().getX();\n            b1 = line1.getP1().getY() - (m1 * line1.getP1().getX());\n            yIntersection = m1 * xIntersection + b1;\n        }\n\n        else if (m1 < EPSILON && m1 > -EPSILON) { //horizontal line\n            yIntersection = line1.getP2().getY();\n            b2 = line2.getP1().getY() - (m2 * line2.getP1().getX());\n            xIntersection = (yIntersection - b2) / m2;\n        }\n        \n        else if (m2 < EPSILON && m2 > -EPSILON) { //horizontal line\n            yIntersection = line2.getP2().getY();\n            b1 = line1.getP1().getY() - (m1 * line1.getP1().getX());\n            xIntersection = (yIntersection - b1) / m1;\n        }\n\n        else {\n            b1 = line1.getP1().getY() - (m1 * line1.getP1().getX());\n            b2 = line2.getP1().getY() - (m2 * line2.getP1().getX());\n            xIntersection = (b2-b1) / (m1-m2);\n            yIntersection = m1 * ( (b2 - b1) / (m1 - m2) ) + b1;\n        }\n\n        return new Point2D.Double(xIntersection,yIntersection);\n    }\n    \n    \n    /**\n     * This function finds the cartesian distance between two points\n     * @param pointA\n     * @param pointB\n     * @return cartesian distance\n     */\n    public static double findCartesianDistance(Point2D.Double pointA, Point2D.Double pointB) {\n    \treturn Math.sqrt(Math.pow((pointA.getX() - pointB.getX()), 2) + Math.pow((pointA.getY() - pointB.getY()), 2));\n    }\n    \n    \n    /**\n     * This function uses a distance ratio to calculate a point a given distance along the path from one point to another\n     * @param point1\n     * @param point2\n     * @param distanceRatio - desired distance/distance between the two points\n     * @return\n     */\n    public static Point2D.Double findOffsetPoint(Point2D.Double point1, Point2D.Double point2, double distanceRatio){\n    \tPoint2D.Double newPoint = new Point2D.Double();\n    \tnewPoint.setLocation(((1-distanceRatio)*point1.getX() + distanceRatio*point2.getX()), ((1-distanceRatio)*point1.getY() + distanceRatio*point2.getY()));\n    \treturn newPoint;\n    }\n    \n    \n    /**\n     * This function calculates the total cartesian distance of a RoutePrimitive\n     * @param route\n     * @return cartesian distance\n     */\n    public static double routePrimitiveDistance(List<Point2D.Double> route) {\n    \tdouble totalDistance = 0;\n    \tfor(int i = 0; i < route.size()-1; i++) {\n    \t\ttotalDistance += findCartesianDistance(route.get(i), route.get(i+1));\n    \t}\n    \treturn totalDistance;\n    }\n    \n    \n    /**\n     * This function calculates the total cartesian distance of a RiverBank\n     * @param bank\n     * @return cartesian distance\n     */\n    public static double riverBankDistance(RiverBank bank) {\n    \tdouble totalDistance = 0;\n    \tfor(int i = 0; i < bank.size()-1; i++) {\n    \t\ttotalDistance += findCartesianDistance(bank.get(i), bank.get(i+1));\n    \t}\n    \treturn totalDistance;\n    }\n    \n    \n    /**\n     * This function calculates the area irregular polygon shape of the river segment\n     * @param segment\n     * @return area\n     */\n    public static double calculateRiverSegmentArea(RiverSubsegment segment) {\n    \tdouble area = 0;\n    \tList<Point2D.Double> bank1 = segment.get(0).get();\n    \tfor(int i = 0; i < bank1.size()-1; i++) {\n    \t\tarea += bank1.get(i).getY()*bank1.get(i+1).getX() - bank1.get(i).getX()*bank1.get(i+1).getY();\n    \t}\n    \tRiverBank bank2 = segment.get(1);\n    \tbank2.reverse();\n    \tarea += bank1.get(bank1.size()-1).getY()*bank2.get(0).getX() - bank1.get(bank1.size()-1).getX()*bank2.get(0).getY();\n    \tfor(int i = 0; i < bank2.size()-1; i++) {\n    \t\tarea += bank2.get(i).getY()*bank2.get(i+1).getX() - bank2.get(i).getX()*bank2.get(i+1).getY();\n    \t}\n    \tarea += bank2.get(bank2.size()-1).getY()*bank1.get(0).getX() - bank2.get(bank2.size()-1).getX()*bank1.get(0).getY();\n    \tarea = area / 2;\n    \tbank2.reverse();    \t\n    \treturn Math.abs(area);\n    }\n    \n    \n    /**\n     * This function calculates the maximum and minimum coordinate points of a simpleBoundingRectangle around the \n     * river segment\n     * @param banks\n     * @return vector containing maximum and minimum coordinate points\n     */\n    public static Vector<Point2D.Double> simpleRiverBoundingRectangle(List<RiverBank> banks) {\n    \tVector<Point2D.Double> minMax = new Vector<>();\n    \tList<Point2D.Double> bank1 = banks.get(0).get();\n    \tList<Point2D.Double> bank2 = banks.get(1).get();\n    \tPoint2D.Double minPoint = new Point2D.Double(Double.MAX_VALUE, Double.MAX_VALUE);\n    \tPoint2D.Double maxPoint = new Point2D.Double(-Double.MAX_VALUE, -Double.MAX_VALUE);\n    \tminAndMaxPoints(minPoint, maxPoint, bank1);\n    \tminAndMaxPoints(minPoint, maxPoint, bank2);\n    \tminMax.add(minPoint);\n    \tminMax.add(maxPoint);\n    \t/*System.out.println(\"[\" + minPoint.getX() + \", \" + minPoint.getY() + \"]\");\n    \tSystem.out.println(\"[\" + minPoint.getX() + \", \" + maxPoint.getY() + \"]\");\n    \tSystem.out.println(\"[\" + maxPoint.getX() + \", \" + maxPoint.getY() + \"]\");\n    \tSystem.out.println(\"[\" + maxPoint.getX() + \", \" + minPoint.getY() + \"]\");*/\n    \treturn minMax;\n    }\n    \n    public static Vector<Point2D.Double> simplePriorityPolygonBoundingRectangle(List<Point2D.Double> polygonPoints) {\n    \tVector<Point2D.Double> minMax = new Vector<>();\n    \tPoint2D.Double minPoint = new Point2D.Double(Double.MAX_VALUE, Double.MAX_VALUE);\n    \tPoint2D.Double maxPoint = new Point2D.Double(-Double.MAX_VALUE, -Double.MAX_VALUE);\n    \tminAndMaxPoints(minPoint, maxPoint, polygonPoints);\n    \tminMax.add(minPoint);\n    \tminMax.add(maxPoint);\n    \t/*System.out.println(\"[\" + minPoint.getX() + \", \" + minPoint.getY() + \"]\");\n    \tSystem.out.println(\"[\" + minPoint.getX() + \", \" + maxPoint.getY() + \"]\");\n    \tSystem.out.println(\"[\" + maxPoint.getX() + \", \" + maxPoint.getY() + \"]\");\n    \tSystem.out.println(\"[\" + maxPoint.getX() + \", \" + minPoint.getY() + \"]\");*/\n    \treturn minMax;\n    }\n    \n   \n    /**\n     * This function finds the minimum and maximum points in a RiverBank\n     * @param minPoint\n     * @param maxPoint\n     * @param points\n     */\n    private static void minAndMaxPoints(Point2D.Double minPoint, Point2D.Double maxPoint, List<Point2D.Double> points) {\n    \tfor(int i = 0; i < points.size(); i++) {\n    \t\tif(points.get(i).getX() < minPoint.getX()) {\n    \t\t\tminPoint.setLocation(points.get(i).getX(), minPoint.getY());\n    \t\t}\n    \t\tif(points.get(i).getX() > maxPoint.getX()) {\n    \t\t\tmaxPoint.setLocation(points.get(i).getX(),maxPoint.getY());\n    \t\t}\n    \t\tif(points.get(i).getY() < minPoint.getY()) {\n    \t\t\tminPoint.setLocation(minPoint.getX(), points.get(i).getY());\n    \t\t}\n    \t\tif(points.get(i).getY() > maxPoint.getY()) {\n    \t\t\tmaxPoint.setLocation(maxPoint.getX(), points.get(i).getY());\n    \t\t}\n    \t}\n    }\n    \n    \n    /**\n     * This function finds the closest point in the opposite RoutePrimitive\n     * @param point\n     * @param opposingSide\n     * @return closest opposing point\n     */\n    public static Point2D.Double findClosestOpposingPoint(Point2D.Double point, List<Point2D.Double> opposingSide) {\n    \tPoint2D.Double destination = new Point2D.Double();\n    \tdouble distance = Double.MAX_VALUE;\n    \tdouble newDistance;\n    \tfor(Point2D.Double node : opposingSide) {\n    \t\tnewDistance = findCartesianDistance(point, node);\n    \t\tif(newDistance < distance){\n    \t\t\tdistance = newDistance;\n    \t\t\tdestination = node;\n    \t\t}\n    \t}\n    \treturn destination;\n    } \n    \n    \n    /**\n     * This function inserts additional nodes into each RiverBank so that there is a node every \n     * APERATURE_WIDTH*OVERLAP_FACTOR.\n     * @param bank\n     * @param newPoints\n     * @param APERATURE_WIDTH\n     * @param OVERLAP_FACTOR\n     * @param riverSegment\n     * @return adjusted RiverBank\n     */\n    private static RiverBank findRiverBankOffset(RiverBank bank, List<Point2D.Double> newPoints, double APERATURE_WIDTH, double OVERLAP_FACTOR, Path2D.Double riverSegment){\n\t\tPoint2D.Double newPoint = new Point2D.Double();\n\t\tPoint2D.Double point1;\n\t\tPoint2D.Double point2;\n\t\tRiverBank newBank = new RiverBank();\n\t\tdouble riverBankDistance;\n\t\tdouble traverseDistance = APERATURE_WIDTH*OVERLAP_FACTOR;\n\t\tdouble distanceRatio;\n\t\tdouble newTraverseDistance = 0;\n\t\tfor(int i = 0; i < bank.size()-1; i++) {\n\t\t\tpoint1 = bank.get(i);\n\t\t\tpoint2 = bank.get(i+1);\n\t\t\tnewBank.add(point1);\n\t\t\triverBankDistance = Geometry.findCartesianDistance(point1, point2);\n\t\t\tif(newTraverseDistance != 0 && newTraverseDistance <= riverBankDistance) {\n\t\t\t\tdistanceRatio = newTraverseDistance / riverBankDistance;\n\t\t\t\tnewPoint = Geometry.findOffsetPoint(point1, point2, distanceRatio);\n\t\t\t\tnewBank.add(newPoint);\n\t\t\t\tnewPoints.add(newPoint);\n\t\t\t\tpoint1 = newPoint;\n\t\t\t\triverBankDistance = riverBankDistance - newTraverseDistance;\n\t\t\t\tnewTraverseDistance = 0;\n\t\t\t}\n\t\t\twhile(traverseDistance <= riverBankDistance) {\n\t\t\t\t\tdistanceRatio = traverseDistance / riverBankDistance;\n\t\t\t\t\tnewPoint = Geometry.findOffsetPoint(point1, point2, distanceRatio);\n\t\t\t\t\tnewBank.add(newPoint);\n\t\t\t\t\tnewPoints.add(newPoint);\n\t\t\t\t\triverBankDistance = riverBankDistance - traverseDistance;\n\t\t\t\t\tpoint1 = newPoint;\n\t\t\t} \n\t\t\t\tnewTraverseDistance = traverseDistance - riverBankDistance;\n\t\t}\n\t\treturn newBank;\n\t}\n    \n    private static void sourcePointsStartAndEnd(Point2D.Double bank1Point, Point2D.Double bank2Point, SourcePoints newPoints, double APERATURE_HEIGHT, double OVERLAP_FACTOR) {\n    \tdouble traverseDistance = APERATURE_HEIGHT / 2;\n    \tdouble totalDistance = findCartesianDistance(bank1Point, bank2Point);\n    \tnewPoints.addSourcePoint(findOffsetPoint(bank1Point, bank2Point, traverseDistance / totalDistance));\n    }\n    \n    //trying to fix issue with whiteField.json\n    /*private static Point2D.Double getProjectedPoint(double APERATURE_HEIGHT, double thetaO, Path2D.Double riverSegment, Point2D.Double bankNode){\n    \tdouble dx = (APERATURE_HEIGHT / 2) * Math.cos(thetaO);\n\t\tdouble dy = (APERATURE_HEIGHT / 2) * Math.sin(thetaO);\n\t\tdouble newX = bankNode.getX()+dx;\n\t\tdouble newY = bankNode.getY()+dy;\n\t\tPoint2D.Double newPoint  = new Point2D.Double(newX, newY);\n\t\tif(!riverSegment.contains(newPoint)) {\n\t\t\tnewPoint.setLocation(bankNode.getX()-dx, bankNode.getY()-dy);\n\t\t}\n\t\tif(!riverSegment.contains(newPoint)) {\n\t\t\tthetaO = thetaO - Math.PI;\n\t\t\tdx = (APERATURE_HEIGHT / 2) * Math.cos(thetaO);\n\t\t\tdy = (APERATURE_HEIGHT / 2) * Math.sin(thetaO);\n\t\t\tnewX = bankNode.getX()+dx;\n\t\t\tnewY = bankNode.getY()+dy;\n\t\t\tnewPoint.setLocation(newX, newY);\n\t\t}\n\t\tif(!riverSegment.contains(newPoint)) {\n\t\t\tnewPoint.setLocation(bankNode.getX()-dx, bankNode.getY()-dy);\n\t\t}\n\t\tif(!riverSegment.contains(newPoint)){\n\t\t\tSystem.out.println(\"couldn't find a projected point\");\n\t\t\treturn null;\n\t\t} else {\n\t\t\treturn newPoint;\n\t\t}\n    } */\n    \n    \n    /**\n     * This function projects the points in RiverBank out into the river segment and makes these points \n     * into a RoutePrimitive.\n     * @param bank1\n     * @param newPoints\n     * @param APERATURE_WIDTH\n     * @param OVERLAP_FACTOR\n     * @param riverSegment\n     * @return RoutePrimitive\n     */\n    private static SourcePoints projectPointsInwards(RiverBank bank1, RiverBank bank2, List<Point2D.Double> newPoints, double APERATURE_HEIGHT, double OVERLAP_FACTOR, Path2D.Double riverSegment) {\n\t\tSourcePoints newSourcePoints = new SourcePoints();\n\t\tdouble dx;\n\t\tdouble dy;\n\t\tdouble newX;\n\t\tdouble newY;\n\t\tHashSet<Point2D.Double> nodes = new HashSet<>(newPoints);\n\t\tsourcePointsStartAndEnd(bank1.get(0), bank2.get(0), newSourcePoints, APERATURE_HEIGHT, OVERLAP_FACTOR);\n\t\tfor(int i = 0; i < bank1.size()-2; i++) {\n\t\t\tif(!nodes.contains(bank1.get(i+1))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdouble theta1 = Geometry.getAngle(bank1.get(i), bank1.get(i+1));\n\t\t\tdouble theta2 = Geometry.getAngle(bank1.get(i+1), bank1.get(i+2));\n\t\t\tdouble theta = (theta1 + theta2) / 2;\n\t\t\tdouble thetaO;\n\t\t\t//this was trying to fix issue with whiteField.json\n\t\t\t/*if(theta1 == 0.0 && theta2 == 0.0) {\n\t\t\t\tthetaO = theta;\n\t\t\t} else {\n\t\t\t\tthetaO = theta + Math.PI / 2;\n\t\t\t}*/\n\t\t\tthetaO = theta + Math.PI / 2;\n\t\t\tdx = (APERATURE_HEIGHT / 2) * Math.cos(thetaO);\n\t\t\tdy = (APERATURE_HEIGHT / 2) * Math.sin(thetaO);\n\t\t\tnewX = bank1.get(i+1).getX()+dx;\n\t\t\tnewY = bank1.get(i+1).getY()+dy;\n\t\t\tPoint2D.Double newPoint  = new Point2D.Double(newX, newY);\n\t\t\tif(!riverSegment.contains(newPoint)) {\n\t\t\t\tnewPoint.setLocation(bank1.get(i+1).getX()-dx, bank1.get(i+1).getY()-dy);\n\t\t\t}\n\t\t\tif(!riverSegment.contains(newPoint)) {\n\t\t\t\tthetaO = theta - Math.PI / 2;\n\t\t\t\tdx = (APERATURE_HEIGHT / 2) * Math.cos(thetaO);\n\t\t\t\tdy = (APERATURE_HEIGHT / 2) * Math.sin(thetaO);\n\t\t\t\tnewX = bank1.get(i+1).getX()+dx;\n\t\t\t\tnewY = bank1.get(i+1).getY()+dy;\n\t\t\t\tnewPoint.setLocation(newX, newY);\n\t\t\t}\n\t\t\tif(!riverSegment.contains(newPoint)) {\n\t\t\t\tnewPoint.setLocation(bank1.get(i+1).getX()-dx, bank1.get(i+1).getY()-dy);\n\t\t\t}\n\t\t\tif(riverSegment.contains(newPoint)) {\n\t\t\t\tnewSourcePoints.addSourcePoint(newPoint);\n\t\t\t} \n\t\t}\n\t\tsourcePointsStartAndEnd(bank1.get(bank1.size()-1), bank2.get(bank2.size()-1), newSourcePoints, APERATURE_HEIGHT, OVERLAP_FACTOR);\n\t\treturn newSourcePoints;\n\t}\n    \n    \n    /**\n     * This function creates route primitives parallel to the riverbanks inside the river segment.\n     * @param APERATURE_WIDTH\n     * @param OVERLAP_FACTOR\n     * @param bankList\n     * @return RoutePrimitive objects for both riverbanks\n     */\n    public static List<SourcePoints> generateSourcePoints(double APERATURE_WIDTH, double APERATURE_HEIGHT, double OVERLAP_FACTOR, List<RiverBank> bankList, boolean innerCrissCross){\n    \tList<SourcePoints> sourcePointsList = new ArrayList<>();\n    \tsourcePointsList.add(new SourcePoints());\n    \tsourcePointsList.add(new SourcePoints());\n    \tList<Point2D.Double> newPoints = new ArrayList<>();\n\t\tList<Point2D.Double> newPoints1 = new ArrayList<>();\n\t\tRiverBank bank1;\n\t\tRiverBank bank2;\n\t\tPath2D.Double riverSegment = Utilities.makeTotalRiverSegment(bankList);\n\t\tRiverSubsegment newRiver = new RiverSubsegment();\n\n\t\tbank1 = bankList.get(0);\n\t\tbank2 = bankList.get(1);\n\t\tbank1 = findRiverBankOffset(bank1, newPoints, APERATURE_WIDTH, OVERLAP_FACTOR, riverSegment);\n\t\tbank2 = findRiverBankOffset(bank2, newPoints1, APERATURE_WIDTH, OVERLAP_FACTOR, riverSegment);\n\t\tnewRiver.add(bank1);  //what does this line actually do?\n\t\tnewRiver.add(bank2);\n\n\t\tif(innerCrissCross) {\n\t\t\tsourcePointsList.set(0, projectPointsInwards(bank1, bank2, newPoints, APERATURE_HEIGHT * 2, OVERLAP_FACTOR, riverSegment));\n\t\t\tsourcePointsList.set(1, projectPointsInwards(bank2, bank1, newPoints1, APERATURE_HEIGHT * 2, OVERLAP_FACTOR, riverSegment));\n\t\t} else {\n\t\t\tsourcePointsList.set(0, projectPointsInwards(bank1, bank2, newPoints, APERATURE_HEIGHT, OVERLAP_FACTOR, riverSegment));\n\t\t\tsourcePointsList.set(1, projectPointsInwards(bank2, bank1, newPoints1, APERATURE_HEIGHT, OVERLAP_FACTOR, riverSegment));\n\t\t}\n\t\treturn sourcePointsList;\n    }\n}"}, {"id": "SetGroundSpeedCommand.java", "body": "package edu.nd.dronology.core.vehicle.commands;\n\npublic class SetGroundSpeedCommand extends AbstractDroneCommand implements IDroneCommand {\n\n\t/**\n\t * \n\t * Command sent to the GCS for setting the groundspeed of the UAV.<br>\n\t * Ground speed is specified in m/s.\n\t * \n\t *  \n\t * @author Michael Vierhauser\n\t */\n\tprivate static final long serialVersionUID = -7987143017453423246L;\n\n\tpublic SetGroundSpeedCommand(String uavid, double speed) {\n\t\tsuper(uavid, CommandIds.SET_GROUND_SPEED_COMMAND);\n\t\tdata.put(ATTRIBUTE_SPEED, speed);\n\t}\n}\n"}, {"id": "DistanceCalculator.java", "body": "package edu.nd.dronology.core.simulator.simplesimulator;\n\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\n\npublic class DistanceCalculator {\n\n\tprivate static double distance(double lat1, double lon1, double lat2, double lon2, String unit) {\n\t\tdouble theta = lon1 - lon2;\n\t\tdouble dist = Math.sin(deg2rad(lat1)) * Math.sin(deg2rad(lat2))\n\t\t\t\t+ Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.cos(deg2rad(theta));\n\t\tdist = Math.acos(dist);\n\t\tdist = rad2deg(dist);\n\t\tdist = dist * 60 * 1.1515;\n\t\tif (unit == \"K\") {\n\t\t\tdist = dist * 1.609344;\n\t\t} else if (unit == \"N\") {\n\t\t\tdist = dist * 0.8684;\n\t\t}\n\n\t\treturn (dist);\n\t}\n\n\tprivate static double deg2rad(double deg) {\n\t\treturn (deg * Math.PI / 180.0);\n\t}\n\n\tprivate static double rad2deg(double rad) {\n\t\treturn (rad * 180 / Math.PI);\n\t}\n\n\tpublic static double distance(LlaCoordinate currentPosition, LlaCoordinate targetPosition) {\n\t\treturn distance(currentPosition.getLatitude(), currentPosition.getLongitude(), targetPosition.getLatitude(),\n\t\t\t\ttargetPosition.getLongitude(), \"K\");\n\t}\n\n}\n"}, {"id": "SimulatorScenario.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.UUID;\n\npublic class SimulatorScenario implements ISimulatorScenario {\n\n\tprivate String name;\n\tprivate String id;\n\tprivate String category = \"Default\";\n\tprivate List<AssignedDrone> drones;\n\tprivate List<String> flightPaths;\n\n\tpublic SimulatorScenario() {\n\t\tid = UUID.randomUUID().toString();\n\t\tname = id;\n\t\tdrones = new ArrayList<>();\n\t\tflightPaths = new ArrayList<>();\n\t}\n\n\t@Override\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\n\t}\n\n\t@Override\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic String getDescription() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void setDescription(String description) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n\t@Override\n\tpublic String getCategory() {\n\t\treturn category;\n\t}\n\n\t@Override\n\tpublic void setCategory(String category) {\n\t\tthis.category = category;\n\t}\n\n\t@Override\n\tpublic List<AssignedDrone> getAssignedDrones() {\n\t\treturn Collections.unmodifiableList(drones);\n\t}\n\n\t@Override\n\tpublic boolean addAssignedDrone(String droneId) {\n\t\tAssignedDrone toAdd = new AssignedDrone(droneId);\n\t\tif (drones.contains(toAdd)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn drones.add(toAdd);\n\t}\n\n\t@Override\n\tpublic boolean addAssignedPath(String pathId) {\n\t\tif (flightPaths.contains(pathId)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn flightPaths.add(pathId);\n\t}\n\n\t@Override\n\tpublic boolean removeAssignedDrone(String droneId) {\n\t\tAssignedDrone toRemove = new AssignedDrone(droneId);\n\t\tif (!drones.contains(toRemove)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn drones.remove(toRemove);\n\t}\n\n\t@Override\n\tpublic boolean removeAssignedPath(String pathId) {\n\t\tif (!flightPaths.contains(pathId)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn flightPaths.remove(pathId);\n\t}\n\n\t@Override\n\tpublic List<String> getAssignedFlightPaths() {\n\t\treturn Collections.unmodifiableList(flightPaths);\n\t}\n\n}\n"}, {"id": "UAVEquipmentTypeRegistrationInfo.java", "body": "package edu.nd.dronology.services.core.info;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class UAVEquipmentTypeRegistrationInfo extends RemoteInfoObject {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 2844123024068335148L;\n\tprivate String type = \"Default\";\n\tprivate List<String> uavids;\n\n\tpublic UAVEquipmentTypeRegistrationInfo(String name, String id) {\n\t\tsuper(name, id);\n\t}\n\n\tpublic String getType() {\n\t\treturn type;\n\t}\n\n\tpublic void setType(String type) {\n\t\tthis.type = type;\n\n\t}\n\n}\n"}, {"id": "ManagedDroneUpdateMessage.java", "body": "package edu.nd.dronology.core.collisionavoidance.backendmessage;\n\nimport edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;\nimport edu.nd.dronology.core.goal.IGoalSnapshot;\nimport edu.nd.dronology.core.vehicle.ManagedDrone;\n\nimport java.util.List;\nimport java.util.Set;\n\npublic class ManagedDroneUpdateMessage extends AbstractMessage {\n    public final String name;\n    public final List<Command> commandQueue;\n    public final Set<IGoalSnapshot> goals;\n    public final String state;\n    public final ManagedDrone managedDrone;\n    public ManagedDroneUpdateMessage(String name, List<Command> commandQueue, Set<IGoalSnapshot> goals, String state, ManagedDrone managedDrone) {\n        this.name = name;\n        this.commandQueue = commandQueue;\n        this.goals = goals;\n        this.state = state;\n        this.managedDrone = managedDrone;\n    }\n}\n"}, {"id": "IServiceListener.java", "body": "package edu.nd.dronology.services.core.listener;\n\nimport edu.nd.dronology.services.core.api.IServiceInstance;\nimport edu.nd.dronology.services.core.api.ServiceStatus;\n\n/**\n * Listener interface for notifying on status changes of a {@link IServiceInstance}\n * \n *  \n * @author Michael Vierhauser\n * \n */\npublic interface IServiceListener  {\n\n\t/**\n\t * \n\t * @param newState The new status of the server process.\n\t */\n\tpublic void statusChanged(ServiceStatus newState);\n\n}\n"}, {"id": "AreaMappingPersistenceProvider.java", "body": "package edu.nd.dronology.services.core.persistence;\n\nimport edu.nd.dronology.services.core.items.IAreaMapping;\nimport edu.nd.dronology.services.core.persistence.internal.AreaMappingXStreamPersistor;\nimport edu.nd.dronology.services.core.persistence.internal.UAVRegistrationXStreamPersistor;\n\n\n/**\n * Provider implementation for {@link IAreaMapping}.<br>\n * Details see {@link AbstractItemPersistenceProvider}\n * \n * @author Michael Vierhauser\n * \n */\npublic class AreaMappingPersistenceProvider extends AbstractItemPersistenceProvider<IAreaMapping> {\n\n\tpublic AreaMappingPersistenceProvider() {\n\t\tsuper();\n\t}\n\n\t@Override\n\tprotected void initPersistor() {\n\t\tPERSISTOR = new AreaMappingXStreamPersistor();\n\n\t}\n\n\t@Override\n\tprotected void initPersistor(String type) {\n\t\tinitPersistor();\n\t}\n\n\tpublic static AreaMappingPersistenceProvider getInstance() {\n\t\treturn new AreaMappingPersistenceProvider();\n\t}\n\n}\n"}, {"id": "AFMapViewOperations.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport com.vaadin.event.LayoutEvents.LayoutClickListener;\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.HorizontalLayout;\nimport com.vaadin.ui.Label;\nimport com.vaadin.ui.NativeButton;\nimport com.vaadin.ui.Upload;\nimport com.vaadin.ui.VerticalLayout;\n\n/**\n * This is the set of map operation buttons in the AFInfoPanel\n * \n * @author Patrick Falvey\n *\n */\n\npublic class AFMapViewOperations extends CustomComponent {\n\n\tprivate static final long serialVersionUID = -2249802562670339842L;\n\tprivate HorizontalLayout buttons = new HorizontalLayout();\n\n\t// \"Follow Selected<br>UAVs on Map // \"View All UAVs<br>on Map\"\n\n\tprivate NativeButton follow = new NativeButton(\"Follow Selected UAVs\");\n\tprivate NativeButton viewAll = new NativeButton(\"View All UAVs\");\n\n\tpublic AFMapViewOperations() {\n\t\tVerticalLayout layout = new VerticalLayout();\n\t\tlayout.addStyleName(\"af_operations_group\");\n\n\t\tLabel caption = new Label(\"Map View Operations\");\n\t\tfollow.setCaptionAsHtml(true);\n\t\tviewAll.setCaptionAsHtml(true);\n\n\t\tbuttons.addComponents(follow, viewAll);\n\t\tlayout.addComponents(caption, buttons);\n\n\t\tsetCompositionRoot(layout);\n\t}\n\n\tpublic NativeButton getFollowButton() {\n\t\treturn follow;\n\t}\n\n\tpublic NativeButton getViewButton() {\n\t\treturn viewAll;\n\t}\n\n\tpublic void addOnClickListener(LayoutClickListener listener) {\n\t\tbuttons.addLayoutClickListener(listener);\n\t}\n}\n"}, {"id": "AbstractItemPersistenceProvider.java", "body": "package edu.nd.dronology.services.core.persistence;\n\nimport java.io.File\n;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\n\nimport edu.nd.dronology.util.NullUtil;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * Abstract base class for all item factories.<br>\n * Provides methods for read/save of items\n * \n * @author Michael Vierhauser\n * \n * @param <ITEM>\n *          The interface of the persisted object\n */\npublic abstract class AbstractItemPersistenceProvider<ITEM> {\n\n\t/**\n\t * The persistor\n\t */\n\tprotected IPersistenceManager<ITEM> PERSISTOR;\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(AbstractItemPersistenceProvider.class);\n\n\t/**\n\t * Default constructor\n\t */\n\tpublic AbstractItemPersistenceProvider() {\n\t\tinitPersistor();\n\t}\n\n\tpublic AbstractItemPersistenceProvider(String type) {\n\t\tinitPersistor(type);\n\t}\n\n\t/**\n\t * needs to be implemented in subclasses - initialized the used persistor\n\t */\n\tprotected abstract void initPersistor();\n\t\n\tprotected abstract void initPersistor(String type);\n\n\t/**\n\t * \n\t * @return a singleton instance of the persistor\n\t */\n\tpublic static AbstractItemPersistenceProvider<?> getInstance() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Reads the item represented by resource\n\t * \n\t * @param resource\n\t * @return either the item represented by resource or an exception.\n\t * @throws PersistenceException\n\t */\n\tpublic ITEM loadItem(URL resource) throws PersistenceException {\n\t\tNullUtil.checkNull(resource);\n\t\ttry {\n\t\t\treturn loadItem(resource.openStream());\n\t\t} catch (IOException e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Reads the item stored at the given path\n\t * \n\t * @param path\n\t * @return either the item located at the path or an exception.\n\t * @throws PersistenceException\n\t */\n\tpublic ITEM loadItem(String path) throws PersistenceException {\n\t\tNullUtil.checkNull(path);\n\t\tFile f = new File(path);\n\t\treturn loadItem(f);\n\t}\n\t\n\tpublic ITEM loadItem(File file)throws PersistenceException {\n\t\tFileInputStream fin;\n\n\t\ttry {\n\t\t\tfin = new FileInputStream(file);\n\t\t} catch (FileNotFoundException e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t}\n\t\treturn loadItem(fin);\n\t}\n\n\t/**\n\t * Reads the item represented by the content\n\t * \n\t * @param content\n\t * @return either the item located by the content or an exception.\n\t * @throws PersistenceException\n\t */\n\tpublic ITEM loadItem(InputStream content) throws PersistenceException {\n\t\tNullUtil.checkNull(content);\n\t\tITEM model = null;\n\t\ttry {\n\t\t\tmodel = PERSISTOR.open(content);\n\t\t} catch (Exception e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (content != null) {\n\t\t\t\t\tcontent.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t}\n\t\t}\n\t\treturn model;\n\t}\n\n\t/**\n\t * \n\t * @param model\n\t *          The model object to save\n\t * @param out\n\t *          The ountput stream where to write the object.\n\t * @return true if saving was successful.\n\t * @throws PersistenceException\n\t */\n\tpublic boolean saveItem(ITEM model, OutputStream out) throws PersistenceException {\n\t\tNullUtil.checkNull(model, out);\n\t\tboolean success = PERSISTOR.save(model, out);\n\t\treturn success;\n\t}\n\n\t/**\n\t * \n\t * @param item\n\t *          The item object to save\n\t * @param path\n\t *          The path where to save the object.\n\t * @return true if saving was successful.\n\t * @throws PersistenceException\n\t */\n\tpublic boolean saveItem(ITEM item, String path) throws PersistenceException {\n\t\tNullUtil.checkNull(item, path);\n\t\tFile file = new File(path);\n\t\tFileOutputStream fout;\n\t\ttry {\n\t\t\tfout = new FileOutputStream(file);\n\t\t\tboolean success = saveItem(item, fout);\n\t\t\treturn success;\n\t\t} catch (FileNotFoundException e) {\n\t\t\tthrow new PersistenceException(e);\n\t\t}\n\t}\n\n}\n"}, {"id": "IUAVRegistration.java", "body": "package edu.nd.dronology.services.core.items;\n\nimport java.io.Serializable;\n\npublic interface IUAVRegistration extends IPersistableItem {\n\n\tString getDescription();\n\n\tvoid setType(String type);\n\n\tvoid setDescription(String description);\n\n\tString getType();\n\n\tSerializable getAttribute(String key);\n\n\tvoid addAttribute(String key, Serializable value);\n\n\tvoid setUAVImage(byte[] image);\n\n\tbyte[] getImage();\n\n}\n"}, {"id": "IUAVEquipmentTypeRegistrationServiceInstance.java", "body": "package edu.nd.dronology.services.instances.registration.equipment;\n\nimport edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;\nimport edu.nd.dronology.services.core.info.UAVEquipmentTypeRegistrationInfo;\n\npublic interface IUAVEquipmentTypeRegistrationServiceInstance extends IFileTransmitServiceInstance<UAVEquipmentTypeRegistrationInfo> {\n\n\t\n}\n"}, {"id": "AFAssignRouteComponent.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.Collection;\n\nimport org.vaadin.teemu.switchui.Switch;\n\nimport com.vaadin.icons.VaadinIcons;\nimport com.vaadin.ui.Alignment;\nimport com.vaadin.ui.Button;\nimport com.vaadin.ui.Component;\nimport com.vaadin.ui.CustomComponent;\nimport com.vaadin.ui.HorizontalLayout;\nimport com.vaadin.ui.Image;\nimport com.vaadin.ui.Label;\nimport com.vaadin.ui.Notification;\nimport com.vaadin.ui.Notification.Type;\nimport com.vaadin.ui.Panel;\nimport com.vaadin.ui.VerticalLayout;\nimport com.vaadin.ui.themes.ValoTheme;\n\nimport edu.nd.dronology.services.core.info.FlightInfo;\nimport edu.nd.dronology.services.core.info.FlightRouteInfo;\nimport edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;\nimport edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\nimport edu.nd.dronology.ui.vaadin.activeflights.AFDragLayout.WrappedComponent;\nimport edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;\nimport edu.nd.dronology.ui.vaadin.flightroutes.FRInfoBox;\nimport edu.nd.dronology.ui.vaadin.flightroutes.FRMainLayout;\nimport edu.nd.dronology.ui.vaadin.start.MyUI;\nimport edu.nd.dronology.ui.vaadin.utils.ImageProvider;\nimport edu.nd.dronology.ui.vaadin.utils.StyleConstants;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * This is the UI for assigning new routes to a UAV\n * \n * @author Patrick Falvey\n *  \n */ \n\npublic class AFAssignRouteComponent extends CustomComponent {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = -3476532205257979147L;\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(AFAssignRouteComponent.class);\n\n\tprivate VerticalLayout content = new VerticalLayout();\n\tprivate HorizontalLayout topContent = new HorizontalLayout();\n\tprivate HorizontalLayout sideContent = new HorizontalLayout();\n\tprivate HorizontalLayout bottomButtons = new HorizontalLayout();\n\tprivate VerticalLayout sideButtons = new VerticalLayout(); \n\tprivate AFDragLayout panelContent;\n\tprivate FRMainLayout frLayout = new FRMainLayout();\n\tprivate Panel sidePanel = new Panel();\n\tprivate Button cancel = new Button(\"Cancel\");\n\tprivate Button apply = new Button(\"Apply\");\n\tprivate Button left = new Button(\"<\");\n\tprivate Button right = new Button(\">\");\n\tprivate int numRoutes = 0;\n\tprivate Switch hoverSwitch = new Switch();\n\tprivate Button returnToHome = new Button(\"Return to Home\");\n\tprivate int index = -1;\n\tprivate int boxID = 0;\n\n\tprivate BaseServiceProvider provider = MyUI.getProvider();\n\tprivate IFlightManagerRemoteService flightRouteService;\n\tprivate FlightInfo flightRouteInfo = null;\n\tprivate IFlightRouteplanningRemoteService flightInfoService;\n\n\tprivate Image droneImage;\n\tprivate UAVStatusWrapper uavStatus;\n\n\tpublic AFAssignRouteComponent(UAVStatusWrapper uavStatus) {\n\t\tthis.uavStatus = uavStatus;\n\t}\n\n\tpublic void createContents() {\n\t\tthis.addStyleName(StyleConstants.AF_ASSING_ROUTE);\n\t\ttopContent.addStyleName(StyleConstants.AF_ASSING_ROUTE_TOP_CONTENT);\n\t\tsideContent.addStyleName(StyleConstants.AF_ASSING_ROUTE_MIDDLE_CONTENT);\n\t\tbottomButtons.addStyleName(StyleConstants.AF_ASSING_ROUTE_BOTTOM_CONTENT);\n\n\t\tpanelContent = new AFDragLayout(uavStatus.getName());\n\n\t\tdroneImage = ImageProvider.getDefaultUAVImage();\n\t\tVerticalLayout statusContent = new VerticalLayout();\n\n\t\tcreateStatusPannel(statusContent);\n\n\t\ttry {\n\t\t\tflightRouteService = (IFlightManagerRemoteService) provider.getRemoteManager()\n\t\t\t\t\t.getService(IFlightManagerRemoteService.class);\n\t\t\tflightRouteInfo = flightRouteService.getFlightInfo(uavStatus.getName());\n\t\t} catch (RemoteException e) {\n\t\t\tMyUI.setConnected(false);\n\t\t\tLOGGER.error(e);\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\n\t\tnumRoutes = flightRouteInfo.getPendingFlights().size();\n\n\t\tcreateSidePannel(sidePanel);\n\n\t\tbottomButtons.addComponents(cancel, apply);\n\t\tapply.addStyleName(\"btn-okay\");\n\t\tcontent.addComponents(topContent, sideContent, bottomButtons);\n\n\t\tsetCompositionRoot(content);\n\n\t}\n\n\tprivate void createSidePannel(Panel sidePanel) {\n\t\tsidePanel.addStyleName(\"fr_info_panel\");\n\t\tsidePanel.addStyleName(\"control_panel\");\n\t\tsidePanel.setCaption(numRoutes + \" Routes Assigned\");\n\t\tapply.setEnabled(true); \n\n\t\tsideButtons.addComponents(left, right);\n\t\tsideButtons.setComponentAlignment(left, Alignment.MIDDLE_CENTER);\n\t\tsideButtons.setComponentAlignment(right, Alignment.MIDDLE_CENTER);\n\n\t\t// when adding a route to be assigned\n\t\tleft.addClickListener(e -> {\n\t\t\tif (frLayout.getControls().getInfoPanel().getHighlightedFRInfoBox() != null) {\n\t\t\t\tFlightRouteInfo selectedFlight = frLayout.getControls().getInfoPanel().getHighlightedFRInfoBox()\n\t\t\t\t\t\t.getFlightRouteInfo();\n\t\t\t\tif (selectedFlight.getWaypoints().size() < 1) {\n\t\t\t\t\tNotification.show(\"There is no waypoint defined in \" + selectedFlight.getName()\n\t\t\t\t\t\t\t+ \". You cannot assign an empty route to a UAV.\");\n\t\t\t\t} else {\n\t\t\t\t\taddRoute(selectedFlight);\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tNotification.show(\"Please select route to assign.\");\n\t\t});\n\n\t\t// when removing a route from the assigned list\n\t\tright.addClickListener(e -> {\n\t\t\tif (index != -1) {\n\t\t\t\tremoveRoute(this.index);\n\t\t\t\tthis.index = -1;\n\t\t\t} else\n\t\t\t\tNotification.show(\"Please select assigned route to remove.\");\n\t\t});\n\n\t\t// when clicking on a route, focus the box and show the route on the map on the right\n\t\tpanelContent.getSortableLayout().getVerticalLayout().addLayoutClickListener(e -> {\n\t\t\tWrappedComponent child = (WrappedComponent) e.getChildComponent();\n\t\t\tComponent childContent = child.getContent();\n\t\t\tif (panelContent.getComponentIndex(childContent) != -1) {\n\t\t\t\t((FRInfoBox) childContent).addStyleName(\"info_box_focus\");\n\t\t\t\tfrLayout.switchRoute(((FRInfoBox) childContent));\n\t\t\t}\n\t\t\tindex = panelContent.getComponentIndex(childContent);\n\n\t\t\tint numComponents = panelContent.getComponentCount();\n\n\t\t\t// when one route is clicked, the others go back to default background color\n\t\t\tfor (int i = 0; i < numComponents; i++) {\n\t\t\t\tif (i != index) {\n\t\t\t\t\tpanelContent.getComponent(i).removeStyleName(\"info_box_focus\");\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\t\n\t\t// be able to add a route to the left with a double click\n\t\tfrLayout.getControls().getInfoPanel().getRoutes().addLayoutClickListener(e -> {\n\t\t\tif (e.isDoubleClick()) {\t\n\t\t\t\tif (frLayout.getControls().getInfoPanel().getHighlightedFRInfoBox() != null) {\n\t\t\t\t\tFlightRouteInfo selectedFlight = frLayout.getControls().getInfoPanel().getHighlightedFRInfoBox().getFlightRouteInfo();\n\t\t\t\t\tif (selectedFlight.getWaypoints().size() < 1) {\n\t\t\t\t\t\tNotification.show(\"There is no waypoint defined in \" + selectedFlight.getName()\n\t\t\t\t\t\t\t\t+ \". You cannot assign an empty route to a UAV.\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddRoute(selectedFlight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse Notification.show(\"Please select route to assign.\");\n\t\t\t}\n\t\t});\n\t\t\n\t\t// be able to add a route to the right with a double click\n\t\tpanelContent.getSortableLayout().getVerticalLayout().addLayoutClickListener(e -> {\n\t\t\tif (e.isDoubleClick()) {\n\t\t\t\tif (index != -1) {\n\t\t\t\t\tremoveRoute(this.index);\n\t\t\t\t\tthis.index = -1;\n\t\t\t\t} else\n\t\t\t\t\tNotification.show(\"Please select assigned route to remove.\");\n\t\t\t}\n\t\t});\n\t\n\t\t\n\t\t\n\t\tsidePanel.setContent(panelContent);\n\t\tsideContent.addComponents(sidePanel, sideButtons, frLayout);\n\n\t}\n\n\tprivate void createStatusPannel(VerticalLayout statusContent) {\n\n\t\tLabel statusInfo1 = new Label();\n\t\tLabel statusInfo2 = new Label();\n\t\tLabel statusInfo3 = new Label();\n\n\t\tstatusInfo1.setValue(\"Assigning Routes for \" + uavStatus.getName());\n\t\tstatusInfo1.addStyleName(\"info_box_name\");\n\t\tstatusInfo1.addStyleName(ValoTheme.LABEL_BOLD);\n\t\tstatusInfo2.setValue(\"Status: \" + uavStatus.getStatus());\n\n\t\tstatusInfo3.setValue(\"Battery Life: \" + uavStatus.getBatteryLife() + \" %\");\n\t\tstatusContent.addComponents(statusInfo1, statusInfo2, statusInfo3);\n\t\tstatusContent.setSpacing(false);\n\t\tLabel health = new Label();\n\t\thealth.setCaptionAsHtml(true);\n\t\thealth.setCaption(\"<span style=\\'color: \" + uavStatus.getHealthColor() + \" !important;\\'> \"\n\t\t\t\t+ VaadinIcons.CIRCLE.getHtml() + \"</span>\");\n\t\tif (uavStatus.getHealthColor().equals(\"green\"))\n\t\t\thealth.setDescription(\"Normally Functionable\");\n\t\telse if (uavStatus.getHealthColor().equals(\"yellow\"))\n\t\t\thealth.setDescription(\"Needs Attention\");\n\t\telse if (uavStatus.getHealthColor().equals(\"red\"))\n\t\t\thealth.setDescription(\"Needs Immediate Attention\");\n\n\t\ttopContent.addComponents(droneImage, statusContent, health);\n\t\ttopContent.setSpacing(false);\n\n\t\tVerticalLayout coordinates = new VerticalLayout();\n\t\tVerticalLayout altAndSpeed = new VerticalLayout();\n\t\tHorizontalLayout positionInfo = new HorizontalLayout();\n\n\t\tLabel locationInfo1 = new Label();\n\t\tLabel locationInfo2 = new Label();\n\t\tLabel locationInfo3 = new Label();\n\t\tLabel locationInfo4 = new Label();\n\n\t\tlocationInfo1.setValue(\"Latitude:\\t\" + uavStatus.getLatitude());\n\t\tlocationInfo2.setValue(\"Longitude:\\t\" + uavStatus.getLongitude());\n\t\tlocationInfo3.setValue(\"Altitude:\\t\" + uavStatus.getAltitude() + \" meters\");\n\n\t\tlocationInfo4.setValue(\"Ground Speed:\\t\" + uavStatus.getSpeed() + \" m/s\");\n\n\t\tcoordinates.addComponents(locationInfo1, locationInfo2);\n\t\taltAndSpeed.addComponents(locationInfo3, locationInfo4);\n\t\tpositionInfo.addComponents(coordinates, altAndSpeed);\n\n\t\ttopContent.addComponent(positionInfo);\n\n\t\tVerticalLayout buttons = new VerticalLayout();\n\n\t\tHorizontalLayout bottomSwitch = new HorizontalLayout();\n\t\tLabel caption = new Label(\"Hover in Place\");\n\t\tbottomSwitch.addComponents(caption, hoverSwitch);\n\n\t\tbuttons.addComponents(bottomSwitch, returnToHome);\n\n\t\ttopContent.addComponent(buttons);\n\n\t}\n\n\t/**\n\t * \n\t * @return in-order list of flight routes to be assigned to the UAV based on the order in the AFDragLayout\n\t */\n\tpublic Collection<FlightRouteInfo> getRoutesToAssign() {\n\t\tCollection<FlightRouteInfo> current = new ArrayList<>();\n\t\tCollection<FlightRouteInfo> items = null;\n\t\ttry {\n\t\t\tflightInfoService = (IFlightRouteplanningRemoteService) provider.getRemoteManager()\n\t\t\t\t\t.getService(IFlightRouteplanningRemoteService.class);\n\t\t\titems = flightInfoService.getItems();\n\t\t} catch (RemoteException | DronologyServiceException e) {\n\t\t\tMyUI.setConnected(false);\n\t\t\tLOGGER.error(e);\n\t\t}\n\n\t\tfor (int i = 0; i < panelContent.getComponentCount(); i++) {\n\t\t\tFRInfoBox box = (FRInfoBox) panelContent.getComponent(i);\n\t\t\tfor (FlightRouteInfo info : items) {\n\t\t\t\tif (box.getName().equals(info.getName())) {\n\t\t\t\t\tcurrent.add(info);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn current;\n\t}\n\n\tpublic void addRoute(FlightRouteInfo routeInfo) {\n\t\tFRInfoBox box = new FRInfoBox(routeInfo);\n\t\tbox.setId(Integer.toString(this.boxID));\n\t\tpanelContent.addNewComponent(box);\n\t\tnumRoutes += 1;\n\t\tsidePanel.setCaption(numRoutes + \" Routes Assigned\");\n\t}\n\n\t/**\n\t * removes a route from the AFDragLayout\n\t * \n\t * @param index\n\t */\n\tpublic void removeRoute(int index) {\n\t\tpanelContent.removeComponent(panelContent.getComponent(index));\n\t\tnumRoutes -= 1;\n\t\tsidePanel.setCaption(numRoutes + \" Routes Assigned\");\n\t}\n\n\tpublic Button getCancel() {\n\t\treturn cancel;\n\t} \n\n\tpublic Button getApply() {\n\t\treturn apply;\n\t}\n\n\tpublic Button getReturnToHome() {\n\t\treturn returnToHome;\n\t}\n\n\tpublic Switch getHover() {\n\t\treturn hoverSwitch;\n\t}\n\n}\n"}, {"id": "AbstractGoal.java", "body": "package edu.nd.dronology.core.goal;\n\nimport java.util.Observable;\nimport java.util.Observer;\n\n\n\n\npublic abstract class AbstractGoal extends Observable implements Observer {\n\n    public enum GoalState {\n        PENDING,\n        ACTIVE,\n        COMPLETE,\n        CANCELED\n    }\n\n    private GoalState state = GoalState.PENDING;\n\n    public synchronized GoalState getState() {\n        return state;\n    }\n\n    private synchronized void setState(GoalState newState) {\n        this.state = newState;\n        setChanged();\n        notifyObservers();\n    }\n\n    public abstract IGoalSnapshot buildSnapshot();\n\n    public void setPending() {\n        setState(GoalState.PENDING);\n    }\n\n    public void setActive() {\n        setState(GoalState.ACTIVE);\n    }\n\n    public void setCompleted() {\n        setState(GoalState.COMPLETE);\n    }\n\n    public void setCanceled() {\n        setState(GoalState.CANCELED);\n    }\n}\n"}, {"id": "Onion.java", "body": "package edu.nd.dronology.core.collisionavoidance.strategy;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Objects;\n\nimport edu.nd.dronology.core.collisionavoidance.CollisionAvoidanceUtil;\nimport edu.nd.dronology.core.collisionavoidance.CollisionAvoider;\nimport edu.nd.dronology.core.collisionavoidance.DronePair;\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshot;\nimport edu.nd.dronology.core.collisionavoidance.strategy.onionbackend.DefaultAction;\nimport edu.nd.dronology.core.collisionavoidance.strategy.onionbackend.IAction;\nimport edu.nd.dronology.core.collisionavoidance.strategy.onionbackend.ILayer;\nimport edu.nd.dronology.core.goal.IGoalSnapshot;\nimport edu.nd.dronology.core.goal.WaypointGoalSnapshot;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\n\n/**\n * This approach uses a collection of layers to determine avoidance actions. The inner most layer stops the drones. The next layer out might slow them. \n */\npublic class Onion implements CollisionAvoider {\n\n    private static final ILogger LOGGER = LoggerProvider.getLogger(Onion.class);\n\n    // List of layers, ordered inner most to outer most. \n    List<ILayer> layers;\n    HashMap<String, DroneSnapshot> nameLookup = new HashMap<>();\n    HashMap<String, Double> distanceLookup = new HashMap<>();\n    HashMap<String, String> nearestNeighbor = new HashMap<>();\n    final IAction defaultAction = new DefaultAction();\n\n    public Onion(ILayer...layers) {\n        this.layers = new ArrayList<>(Arrays.asList(layers));\n        Collections.sort(this.layers, (ILayer l1, ILayer l2) -> {\n            return Double.compare(l1.getTriggerDistance(), l2.getTriggerDistance());\n        });\n    }\n\n\t@Override\n\tpublic void avoid(ArrayList<DroneSnapshot> drones) {\n        setupLookupTables(drones);\n        for (DronePair pair : CollisionAvoidanceUtil.findPairs(drones)) {\n            double distance = pair.findDistance();\n            if (!distanceLookup.containsKey(pair.a.getName()) || \n                distance < distanceLookup.get(pair.a.getName())) {    \n                \n                distanceLookup.put(pair.a.getName(), distance);\n                nearestNeighbor.put(pair.a.getName(), pair.b.getName());\n\n            }\n            if (!distanceLookup.containsKey(pair.b.getName()) ||\n                distance < distanceLookup.get(pair.b.getName())) {\n                \n                distanceLookup.put(pair.b.getName(), distance);\n                nearestNeighbor.put(pair.b.getName(), pair.a.getName());\n            }\n        }\n\n        for (DroneSnapshot drone : drones) {\n            IAction activeLayer = defaultAction;\n            if (distanceLookup.size() != 0) {\n                double distance = distanceLookup.get(drone.getName());\n                ILayer layer = findInnerMostLayer(distance);\n                if (layer != null) {\n                    activeLayer = layer;\n                    String neighbor = nearestNeighbor.get(drone.getName());\n                    String msg = String.format(\"Collision avoidance is taking action. %s is %.2f meters from %s\", drone.getName(), distance, neighbor);\n                    LOGGER.warn(msg);\n                }\n            }\n            activeLayer.applyAction(drone);\n        }\n    }\n\n    private void setupLookupTables(ArrayList<DroneSnapshot> drones) {\n        nameLookup.clear();\n        distanceLookup.clear();\n        nearestNeighbor.clear();\n        for (DroneSnapshot drone : drones) {\n            nameLookup.put(drone.getName(), drone);\n        }\n    }\n    \n    private ILayer findInnerMostLayer(double distance) {\n        for (ILayer layer: layers) {\n            if (layer.isTriggered(distance)) {\n                return layer;\n            }\n        }\n        return null;\n    }\n\n}"}, {"id": "PatternTask.java", "body": "package edu.nd.dronology.services.extensions.missionplanning.tasks;\n\n/**\n * A {@link PatternTask} represents a predefined pattern that is expanded when the mission is created.\n * \n * @author Michael Vierhausers\n * \n */\npublic class PatternTask extends AbstractMissionTask {\n\n\tprotected PatternTask(String uavID, String taskName) {\n\t\tsuper(uavID, taskName);\n\t}\n}"}, {"id": "DroneSimulatorService.java", "body": "package edu.nd.dronology.services.instances.dronesimulator;\n\nimport java.util.Collection;\nimport java.util.List;\n\nimport edu.nd.dronology.services.core.base.AbstractFileTransmitServerService;\nimport edu.nd.dronology.services.core.info.SimulatorScenarioCategoryInfo;\nimport edu.nd.dronology.services.core.info.SimulatorScenarioInfo;\nimport edu.nd.dronology.services.core.util.DronologyServiceException;\n\npublic class DroneSimulatorService\n\t\textends AbstractFileTransmitServerService<IDroneSimulatorServiceInstance, SimulatorScenarioInfo> {\n\n\tprivate static volatile DroneSimulatorService INSTANCE;\n\n\tprotected DroneSimulatorService() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @return The singleton ConfigurationService instance\n\t */\n\tpublic static DroneSimulatorService getInstance() {\n\t\tif (INSTANCE == null) {\n\t\t\tsynchronized (DroneSimulatorService.class) {\n\t\t\t\tif (INSTANCE == null) {\n\t\t\t\t\tINSTANCE = new DroneSimulatorService();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn INSTANCE;\n\t}\n\n\t@Override\n\tprotected IDroneSimulatorServiceInstance initServiceInstance() {\n\t\treturn new DroneSimulatorServiceInstance();\n\t}\n\n\tpublic void activateScenario(SimulatorScenarioInfo scenario) throws DronologyServiceException {\n\t\tserviceInstance.activateScenario(scenario);\n\n\t}\n\n\tpublic Collection<SimulatorScenarioCategoryInfo> getCategories() {\n\t\treturn serviceInstance.getCategories();\n\t}\n\n}\n"}, {"id": "PhysicalDrone.java", "body": "package edu.nd.dronology.core.vehicle.internal;\n\nimport java.util.Random;\n\nimport edu.nd.dronology.core.CoordinateChange;\nimport edu.nd.dronology.core.DronologyConstants;\nimport edu.nd.dronology.core.IUAVPropertyUpdateNotifier;\nimport edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;\nimport edu.nd.dronology.core.coordinate.LlaCoordinate;\nimport edu.nd.dronology.core.exceptions.DroneException;\nimport edu.nd.dronology.core.exceptions.FlightZoneException;\nimport edu.nd.dronology.core.vehicle.AbstractDrone;\nimport edu.nd.dronology.core.vehicle.DroneFlightStateManager.FlightMode;\nimport edu.nd.dronology.core.vehicle.IDrone;\nimport edu.nd.dronology.core.vehicle.IDroneCommandHandler;\nimport edu.nd.dronology.core.vehicle.commands.AbstractDroneCommand;\nimport edu.nd.dronology.core.vehicle.commands.GoToCommand;\nimport edu.nd.dronology.core.vehicle.commands.LandCommand;\nimport edu.nd.dronology.core.vehicle.commands.SetGroundSpeedCommand;\nimport edu.nd.dronology.core.vehicle.commands.SetVelocityCommand;\nimport edu.nd.dronology.core.vehicle.commands.TakeoffCommand;\nimport net.mv.logging.ILogger;\nimport net.mv.logging.LoggerProvider;\nimport org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\n/**\n * Representation of a physical UAV which either interacts with real hardware or the SITL simulated UAV.\n * \n * @author Jane Cleland-Huang\n * \n */\npublic class PhysicalDrone extends AbstractDrone implements IDrone, IUAVPropertyUpdateNotifier {\n\n\tprivate static final ILogger LOGGER = LoggerProvider.getLogger(PhysicalDrone.class);\n\n\tprivate IDroneCommandHandler baseStation;\n\tprivate String droneID;\n\tprivate LlaCoordinate currentTarget;\n\tprivate AbstractDroneCommand lastCommand = null;\n\tprivate volatile DroneSnapshotInternal latestDroneSnapshot;\n\n\tpublic PhysicalDrone(String drnName, IDroneCommandHandler baseStation) {\n\t\tsuper(drnName);\n\t\tthis.baseStation = baseStation;\n\t\tcurrentTarget = new LlaCoordinate(0, 0, 0);\n\t\ttry {\n\t\t\tdroneID = drnName;\n\t\t\tbaseStation.setStatusCallbackNotifier(droneID, this);\n\t\t\tdroneStatus.setGroundstationId(baseStation.getHandlerId());\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic double getLatitude() {\n\t\treturn getCoordinates().getLatitude();\n\t}\n\n\t@Override\n\tpublic double getLongitude() {\n\t\treturn getCoordinates().getLongitude();\n\t}\n\n\t@Override\n\tpublic double getAltitude() {\n\t\treturn getCoordinates().getAltitude();\n\t}\n\n\tRandom r = new Random();\n\n\t@Override\n\tpublic void flyTo(LlaCoordinate targetCoordinates, Double speed) {\n\t\tif (targetCoordinates != currentTarget) {\n\t\t\t// TODO: add some time limit for refreshing the information in case it didn't\n\t\t\t// properly get sent\n\t\t\tcurrentTarget = targetCoordinates;\n\t\t\ttry { \n\t\t\t\tLOGGER.missionInfo(droneID + \" Flying to new waypoint \" + targetCoordinates);\n\t\t\t\tsendCommand(new GoToCommand(droneID, targetCoordinates));\n\n\t\t\t\tif (speed != null && speed > 0) {\n\t\t\t\t\tsendCommand(new SetGroundSpeedCommand(droneID, speed));\n\t\t\t\t}\n\t\t\t} catch (DroneException e) {\n\t\t\t\tLOGGER.error(e);\n\t\t\t} \n\t\t}\n\n\t}\n\n\t@Override\n\tpublic LlaCoordinate getCoordinates() {\n\t\treturn droneStatus.getCoordinates();\n\t}\n\n\t@Override\n\tpublic void land() throws FlightZoneException {\n\t\ttry {\n\t\t\tsendCommand(new LandCommand(droneID, LandCommand.MODE_LAND));\n\t\t} catch (DroneException e) {\n\t\t\tthrow new FlightZoneException(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void takeOff(double altitude) throws FlightZoneException {\n\t\ttry {\n\t\t\tbaseStation.sendCommand(new TakeoffCommand(droneID, altitude));\n\t\t} catch (DroneException e) {\n\t\t\tthrow new FlightZoneException(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic double getBatteryStatus() {\n\t\treturn droneStatus.getBatteryLevel();\n\t}\n\n\t@Override\n\tpublic boolean move(double i) {\n\t\t// update data from the server\n\t\t// TODO: this might not necessarily be the best place to update this\n\t\t// baseStation.getIncomingData();\n\t\treturn !isDestinationReached(0);\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n\t@Override\n\tpublic void setVoltageCheckPoint() {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n\t@Override\n\t@CoordinateChange\n\tpublic boolean isDestinationReached(int i) {\n\t\tdouble distancetotarget = Math.abs(currentPosition.distance(currentTarget));\n\t\tLOGGER.trace(droneID + \" - Distance to target:\" + distancetotarget);\n\t\treturn distancetotarget < DronologyConstants.THRESHOLD_WAYPOINT_DISTANCE;\n\t}\n\n\t@Override\n\tpublic void update(LlaCoordinate location, double batteryLevel, double speed, Vector3D velocity, Vector3D attitude) {\n\t\tupdateCoordinates(location);\n\t\tupdateVelocity(speed);\n\t\tupdateBatteryLevel(batteryLevel);\n\t\tupdateCollisionAvoidance(location, velocity, attitude);\n\n\t\tsuper.setChanged();\n\t\tsuper.notifyObservers();\n\t}\n\n\t@Override\n\tpublic void updateCoordinates(LlaCoordinate location) {\n\t\t// LOGGER.info(\"Coordinates updated\");\n\t\tsuper.setCoordinates(location);\n\n\t}\n\n\t@Override\n\tpublic void updateDroneState(String status) {\n\t\tLOGGER.info(status);\n\n\t}\n\n\t@Override\n\tpublic void setGroundSpeed(double speed) {\n\t\ttry {\n\t\t\tbaseStation.sendCommand(new SetGroundSpeedCommand(droneID, speed));\n\t\t} catch (DroneException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setVelocity(double x, double y, double z) {\n\t\ttry {\n\t\t\tbaseStation.sendCommand(new SetVelocityCommand(droneID, x, y, z));\n\t\t} catch (DroneException e) {\n\t\t\tLOGGER.error(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void updateBatteryLevel(double batteryLevel) {\n\t\tsuper.updateBatteryLevel(batteryLevel);\n\t}\n\n\t@Override\n\tpublic void updateVelocity(double velocity) {\n\t\tsuper.setVelocity(velocity);\n\t}\n\n\t@Override\n\tpublic void updateCollisionAvoidance(LlaCoordinate position, Vector3D velocity, Vector3D attitude) {\n\t\tDroneSnapshotInternal snapshot = new DroneSnapshotInternal(this.getDroneName(), position, velocity, attitude);\n\t\tthis.latestDroneSnapshot = snapshot;\n\t}\n\n\tpublic DroneSnapshotInternal getLatestDroneSnapshot() {\n\t\treturn latestDroneSnapshot;\n\t}\n\n\t@Override\n\tpublic void updateMode(String mode) {\n\t\tif (mode.equals(FlightMode.USER_CONTROLLED.toString())) {\n\t\t\tsuper.setUserControlled(); \n\t\t}\n\n\t}\n\n\t@Override\n\tpublic void sendCommand(AbstractDroneCommand command) throws DroneException {\n\t\tsynchronized (baseStation) {\n\t\t\tlastCommand = command;\n\t\t\tbaseStation.sendCommand(command);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resendCommand() throws DroneException { \n\t\tLOGGER.hwInfo(\"Resending previous command for '\" + droneID + \"'\");\n\t\tsynchronized (baseStation) {\n\t\t\tif (lastCommand == null) {\n\t\t\t\tLOGGER.hwFatal(\"No command recorded for uav '\" + droneID + \"'\");\n\t\t\t\tthrow new DroneException(\"no previous command found\");\n\t\t\t}\n\t\t\tLOGGER.info(\"Resending command for '\" + lastCommand + \"'\");\n\t\t\tsendCommand(lastCommand);\n\t\t}\n\n\t}\n}\n"}, {"id": "UAVStatusWrapper.java", "body": "package edu.nd.dronology.ui.vaadin.activeflights;\n\nimport edu.nd.dronology.core.vehicle.IUAVProxy;\n\n/**\n * Wrapper class for UAV data.,<br>\n * Provides uav status information (such as location, speed, etc.) in a properly formatted, ui friendly format.\n * \n * @author Michael Vierhauser\n *\n */\npublic class UAVStatusWrapper {\n\tpublic static final String STATUS_GREEN = \"green\";\n\n\tprivate final String batteryLife;\n\tprivate final String speed;\n\n\tprivate final String healthColor;\n\tprivate final String status;\n\tprivate final String name;\n\n\tprivate String latitude;\n\tprivate String longitude;\n\tprivate String altitude;\n\n\tpublic UAVStatusWrapper(double batteryLife, double speed, double lat, double lon, double alt, String healthColor,\n\t\t\tString status, String name) {\n\t\tthis.batteryLife = String.format(\"%.2f\", batteryLife);\n\t\tthis.speed = String.format(\"%.2f\", speed);\n\n\t\tthis.latitude = String.format(\"%.5f\", lat);\n\t\tthis.longitude = String.format(\"%.5f\", lon);\n\t\tthis.altitude = String.format(\"%.2f\", alt);\n\n\t\tthis.healthColor = healthColor;\n\t\tthis.status = status;\n\t\tthis.name = name;\n\t}\n\n\tpublic UAVStatusWrapper(IUAVProxy e) {\n\t\tthis(e.getBatteryLevel(), e.getVelocity(), e.getLatitude(), e.getLongitude(), e.getAltitude(), STATUS_GREEN,\n\t\t\t\te.getStatus(), e.getID());\n\t}\n\n\tpublic String getSpeed() {\n\t\treturn speed;\n\t}\n\n\tpublic String getBatteryLife() {\n\t\treturn batteryLife;\n\t}\n\n\tpublic String getLatitude() {\n\t\treturn latitude;\n\t}\n\n\tpublic String getLongitude() {\n\t\treturn longitude;\n\t}\n\n\tpublic String getAltitude() {\n\t\treturn altitude;\n\t}\n\n\tpublic String getHealthColor() {\n\t\treturn healthColor;\n\t}\n\n\tpublic String getStatus() {\n\t\treturn status;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n}"}, {"id": "ILayer.java", "body": "package edu.nd.dronology.core.collisionavoidance.strategy.onionbackend;\n\npublic interface ILayer extends IAction {\n    /**\n     * Given a distance, this method returns true if the layer should be triggered.\n     */\n    public boolean isTriggered(double distance);\n\n    public double getTriggerDistance();\n\n}"}]}