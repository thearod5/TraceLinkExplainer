id,text
PriorityArea.java,"package edu.nd.dronology.services.core.items;

public class PriorityArea extends MappedItem {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1072606981502113567L;

	public PriorityArea(String id) {
		super(id);
	}

}
"
UAVEquipmentTypeRegistrationServiceRemoteFacade.java,"package edu.nd.dronology.services.facades;

import java.rmi.RemoteException;

import java.util.Collection;

import org.apache.commons.lang.NotImplementedException;

import edu.nd.dronology.services.core.info.UAVEquipmentTypeRegistrationInfo;
import edu.nd.dronology.services.core.listener.IItemChangeListener;
import edu.nd.dronology.services.core.remote.IUAVEquipmentTypeRegistrationRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.instances.registration.equipment.UAVEquipmentTypeRegistrationService;
import edu.nd.dronology.services.remote.AbstractRemoteFacade;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class UAVEquipmentTypeRegistrationServiceRemoteFacade extends AbstractRemoteFacade implements IUAVEquipmentTypeRegistrationRemoteService {
	/**
	 * 
	 */
	private static final long serialVersionUID = -4580658378477037955L;
	private static final ILogger LOGGER = LoggerProvider.getLogger(UAVEquipmentTypeRegistrationServiceRemoteFacade.class);
	private static volatile UAVEquipmentTypeRegistrationServiceRemoteFacade INSTANCE;

	protected UAVEquipmentTypeRegistrationServiceRemoteFacade() throws RemoteException {
		super(UAVEquipmentTypeRegistrationService.getInstance());
	}

	public static IUAVEquipmentTypeRegistrationRemoteService getInstance() throws RemoteException {
		if (INSTANCE == null) {
			try {
				synchronized (UAVEquipmentTypeRegistrationServiceRemoteFacade.class) {
					if (INSTANCE == null) {
						INSTANCE = new UAVEquipmentTypeRegistrationServiceRemoteFacade();
					}
				}
			} catch (RemoteException e) {
				LOGGER.error(e);
			}
		}
		return INSTANCE;
	}

	@Override
	public byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException {
		return UAVEquipmentTypeRegistrationService.getInstance().requestFromServer(id);
	}

	@Override
	public void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException {
		UAVEquipmentTypeRegistrationService.getInstance().transmitToServer(id, content);

	}

	@Override
	public boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException {
		throw new NotImplementedException();
	}

	@Override
	public boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException {
		throw new NotImplementedException();
	}

	@Override
	public Collection<UAVEquipmentTypeRegistrationInfo> getItems() throws RemoteException {
		return UAVEquipmentTypeRegistrationService.getInstance().getItems();
	}

	@Override
	public UAVEquipmentTypeRegistrationInfo createItem() throws RemoteException, DronologyServiceException {
		return UAVEquipmentTypeRegistrationService.getInstance().createItem();
	}

	@Override
	public void deleteItem(String itemid) throws RemoteException, DronologyServiceException {
		// TODO Auto-generated method stub
		throw new NotImplementedException();
	}



}"
IFileTransmitRemoteService.java,"package edu.nd.dronology.services.core.remote;

import java.rmi.RemoteException;
import java.util.Collection;

import edu.nd.dronology.services.core.api.IRemotable;
import edu.nd.dronology.services.core.info.UAVTypeRegistrationInfo;
import edu.nd.dronology.services.core.listener.IItemChangeListener;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public interface IFileTransmitRemoteService<ITEM_TYPE> extends IRemotable {

	byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException;

	void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException;

	public boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException;

	public boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException;

	
	Collection<ITEM_TYPE> getItems() throws RemoteException;

	ITEM_TYPE createItem() throws RemoteException, DronologyServiceException;

	void deleteItem(String itemid) throws RemoteException, DronologyServiceException;
}
"
FullMissionPlan.java,"package edu.nd.dronology.services.extensions.missionplanning.v1;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import org.json.JSONException;

import edu.nd.dronology.core.DronologyConstants;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;
import edu.nd.dronology.services.extensions.missionplanning.plan.IExecuteableMissionPlan;
import edu.nd.dronology.services.extensions.missionplanning.plan.MissionUtil;
import edu.nd.dronology.services.extensions.missionplanning.plan.UAVMissionPlan;
import edu.nd.dronology.services.extensions.missionplanning.sync.SynchronizationManager;
import edu.nd.dronology.services.extensions.missionplanning.tasks.TaskFactory;
import edu.nd.dronology.services.instances.dronesetup.DroneSetupService;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Manages a mission plan. Each Mission plan has one <code>FullMissionPlan</code> instance, and one <code>UAVMissionPlan</code> instance for each UAV in the Mission plan. <br>
 * Each of the UAV's individual mission plans are composed of MissionTasks. <br>
 * Once the entire mission plan is loaded, a thread is created which checks each of the individual UAVMissionPlans to determine if they can start the next task.
 * 
 *@author Jane Cleland-Huang
 */
@Deprecated
public class FullMissionPlan implements IExecuteableMissionPlan {

	private static final ILogger LOGGER = LoggerProvider.getLogger(FullMissionPlan.class);

	private Map<String, UAVMissionPlan> uavMissionPlans;
	private SynchronizationManager synchPointMgr;
	private String mission;

	/**
	 * Constructs the CoordinatedMission instance. A mission consists of one or more UAVs, each of which has a set of assigned tasks and synchronization points.
	 * 
	 * @param mission
	 */
	public FullMissionPlan(String mission) {
		this.mission = mission;
		uavMissionPlans = new HashMap<>();
		synchPointMgr = SynchronizationManager.getInstance();

	}

	/**
	 * Loads mission from JSON file. Currently hard coded. 
	 * 
	 * @param mission
	 * @throws MissionExecutionException
	 */
	private void loadMission(String mission) throws MissionExecutionException {
		JSONMissionPlanReader jsonReader = new JSONMissionPlanReader(this);
		try {
			jsonReader.parseMission(mission);
		} catch (IOException | JSONException e) {
			throw new MissionExecutionException(e.getMessage());
		}
	}

	/**
	 * Adds an additional UAV to the mission plan. Creates the <code>UAVMissionTasks</code> instance and passes it a reference to the <code>synchPointMgr</code>
	 * 
	 * @param uavID
	 *          the ID of the UAV
	 * @throws MissionExecutionException
	 */
	public void addUAV(String uavID) throws MissionExecutionException {
		UAVMissionPlan plan = new UAVMissionPlan(uavID, synchPointMgr);
		if (uavMissionPlans.containsKey(uavID)) {
			throw new MissionExecutionException(""Mission Plan for UAV '"" + uavID + ""' already defined"");
		}
		uavMissionPlans.put(uavID, plan);
	}

	public void removeUAV(String uavID) {
		uavMissionPlans.remove(uavID);
	}

	/**
	 * Assigns a task to a specific UAV
	 * 
	 * @param uavID
	 *          UAV Identifier
	 * @param task
	 *          Task to perform (e.g., Route, Waypoint, Synchronize, FlightPattern)
	 * @param taskID
	 *          Task specifics (e.g., specific waypoint, route name etc)
	 * @throws MissionExecutionException
	 */
	public void addTask(String uavID, String task, String taskID, Object... params) throws MissionExecutionException {
		for (UAVMissionPlan plan : uavMissionPlans.values()) {
			if (plan.getUavID().equals(uavID)) {
				plan.addTask(TaskFactory.getTask(task, uavID, taskID, params), synchPointMgr);
				return;
			}
		}
		throw new MissionExecutionException(""UAVMissionPlan '"" + uavID + ""' not available!"");
	}

	@Override
	public boolean isMissionActive() {
		for (UAVMissionPlan plan : uavMissionPlans.values()) {
			if (plan.hasTasks()) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Build all synch points
	 */
	private void buildAllSynchPoints() {
		uavMissionPlans.forEach((uavId, plan) -> {
			plan.buildSynchPoints();
		});
	}

	/**
	 * Activates next task in each UAV mission, if there is no unfinished active task
	 * 
	 * @throws MissionExecutionException
	 */
	@Override
	public void checkAndActivateTask() throws MissionExecutionException {
		for (UAVMissionPlan plan : uavMissionPlans.values()) {
			if (!plan.hasActiveTask()) {
				plan.activateNextTask();
			}
		}
	}

	/**
	 * Expands flight pattern tasks (e.g., coordinatedTakeOff or coordinatedLanding)
	 * 
	 * @throws MissionExecutionException
	 *   
	 */
	private void expandAllTasks() throws MissionExecutionException {
		for (UAVMissionPlan plan : uavMissionPlans.values()) {
			plan.expandTaskList();
		}
	}

	public void build() throws MissionExecutionException {
		loadMission(mission);
		expandAllTasks();
		buildAllSynchPoints();
		synchPointMgr.activateAllSynchPoints();
		runPreChecks();

	}

	private void runPreChecks() throws MissionExecutionException {
		for (Entry<String, UAVMissionPlan> e : uavMissionPlans.entrySet()) {
			checkDistance(e.getKey(), e.getValue());
		}
	}

	private void checkDistance(String uavid, UAVMissionPlan plan) throws MissionExecutionException {
		LlaCoordinate coordinate = plan.getStartingRouteWaypoint();
		IUAVProxy uav = null;
		if (coordinate == null) {
			throw new MissionExecutionException(""Error when retrieving first waypoint for uav '"" + uavid + ""'"");
		}
		try {
			uav = DroneSetupService.getInstance().getActiveUAV(uavid);
		} catch (DronologyServiceException e) {
			throw new MissionExecutionException(e.getMessage());
		}
		double distanceToFirstWaypoint = uav.getCoordinates().distance(coordinate);
		if (distanceToFirstWaypoint > DronologyConstants.MISSION_MAX_STARTING_DISTANCE) {
			throw new MissionExecutionException(
					""Distance to first waypoint exceeds maximum safety distance: "" + distanceToFirstWaypoint + ""m"");
		}
		LOGGER.info(""Precheck passed -- Distance to first waypoint: "" + distanceToFirstWaypoint);

	}

	@Override
	public void cancelMission() {
		LOGGER.missionError(""Mission cancelled!"");
		for (UAVMissionPlan plan : uavMissionPlans.values()) {
			String uavid = plan.getUavID();
			MissionUtil.stopUAV(uavid);
		}
	}

}
"
MetricsStatistics.java,"package edu.nd.dronology.services.core.areamapping;

import java.util.Collections;
import java.util.List;

public class MetricsStatistics {
	private double equalityOfTasks;
	private double allocationCoverage;
	private double downstreamRatio;
	private boolean batteryFailed;
	private int collisions;
	private double allocationScore;
	private double totalDistance;
	private List<Double> droneDistances;
	private double allocationPriorityCoverage;
	
	public MetricsStatistics(double equalityOfTasks, double allocationCoverage, double downstreamRatio, boolean batteryFailed, int collisions, double totalDistance, 
			List<Double> droneDistances, double priorityCoverage) {
		this.equalityOfTasks = equalityOfTasks;
		this.allocationCoverage = allocationCoverage;
		this.downstreamRatio = downstreamRatio;
		this.batteryFailed = batteryFailed;
		this.collisions = collisions;
		this.totalDistance = totalDistance;
		this.droneDistances = droneDistances;
		this.allocationPriorityCoverage = priorityCoverage;
		calculateAllocationScore();
	}
	
	//score of all metrics combined here
	private void calculateAllocationScore() {
		if(batteryFailed) {
			allocationScore = 0;
		} else {
			allocationScore = 0.25*(equalityOfTasks + allocationCoverage + downstreamRatio - collisions / 5);
		}
	}
	
	public double getEqualityOfTasks() {
		return equalityOfTasks;
	}
	
	public double getAllocationCoverage() {
		return allocationCoverage;
	}
	
	public double getDownstreamToUpstreamRatio() {
		return downstreamRatio;
	}
	
	public boolean getBatteryFailed() {
		return batteryFailed;
	}
	
	public int getCollisions() {
		return collisions;
	}
	
	public double getAllocationScore() {
		return allocationScore;
	}
	
	public double getTotalDistance() {
		return totalDistance;
	}
	
	public List<Double> getDroneDistances(){
		return Collections.unmodifiableList(droneDistances);
	}
	
	public double getAllocationPriorityCoverage() {
		return allocationPriorityCoverage;
	}
}
"
UAVListenerManager.java,"package edu.nd.dronology.core.vehicle;

public class UAVListenerManager {

	private static volatile UAVListenerManager INSTANCE = null;

	public static UAVListenerManager getInstance() {

		if (INSTANCE == null) {
			synchronized (UAVListenerManager.class) {
				if (INSTANCE == null) {
					INSTANCE = new UAVListenerManager();
				}
			}
		}
		return INSTANCE;
	}

	public void notifyUAVFlightModeChanged(String id, String newState){
		//notify listeners...
	
	}

}
"
JSONMissionPlanReader.java,"package edu.nd.dronology.services.extensions.missionplanning.v1;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.List;
import java.util.Map;

import org.json.JSONException;

import com.google.gson.Gson;

import edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;

/**
 * Simple JSON Reader that converts a json String into a {@link FullMissionPlan} object.
 * 
 * @author Jane Cleland-Huang
 *
 */
@SuppressWarnings(""rawtypes"")
public class JSONMissionPlanReader {

	FullMissionPlan coordinatedMission;
	// String fileName;

	public JSONMissionPlanReader(FullMissionPlan coordinatedMission) {
		this.coordinatedMission = coordinatedMission;
	}

	public void parseMission(String content)
			throws FileNotFoundException, IOException, JSONException, MissionExecutionException {
		// parsing input file
		// Object obj = new JSONParser().parse(content);

		Map valueMap = new Gson().fromJson(content, Map.class);

		List plans = (List) valueMap.get(""plans"");

		for (Object object : plans) {
			Map jo2 = (Map) object;
			String uavid = (String) jo2.get(""id"");
			coordinatedMission.addUAV(uavid);

			List tasks = (List) jo2.get(""tasks"");
			for (Object task : tasks) {
				parseTasks(task, uavid);
			}
		}

	}

	private void parseTasks(Object item, String uavid) throws MissionExecutionException {
		Map jsnObject = (Map) item;
		String task = (String) jsnObject.get(""task"");
		String taskID;

		taskID = (String) jsnObject.get(""name"");
		String duration = (String) jsnObject.get(""duration"");

		if (duration != null) {
			coordinatedMission.addTask(uavid, task, taskID, duration);
		} else {
			coordinatedMission.addTask(uavid, task, taskID);
		}
	}

}
"
RemoteService.java,"package edu.nd.dronology.services.remote;

import java.util.Collection;

import edu.nd.dronology.services.core.base.AbstractServerService;
import edu.nd.dronology.services.core.remote.IRemoteManager;
import edu.nd.dronology.services.core.remote.RemoteInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.instances.remote.IRemoteConnectionServiceInstance;
import edu.nd.dronology.services.instances.remote.RemoteConnectionServiceInstance;

public class RemoteService extends AbstractServerService<IRemoteConnectionServiceInstance> {

	private static volatile RemoteService INSTANCE;

	@Override
	protected IRemoteConnectionServiceInstance initServiceInstance() {
		return new RemoteConnectionServiceInstance();
	}

	/**
	 * @return The singleton RemoteService instance
	 */
	public static RemoteService getInstance() {
		if (INSTANCE == null) {
			synchronized (RemoteService.class) {
				if (INSTANCE == null) {
					INSTANCE = new RemoteService();
				}
			}
		}
		return INSTANCE;
	}

	public void performCleanup() {
		// TODO Auto-generated method stub

	}

	public Collection<RemoteInfo> getRegisteredRemoteClients() {
		return serviceInstance.getRegisteredRemoteClients();
	}

	public void register(RemoteInfo rInfo) {
		serviceInstance.register(rInfo);
	}

	public void unregister(RemoteInfo rInfo) {
		serviceInstance.unregister(rInfo);
	}

	// public void logExternal(LogEventAdapter event) {
	// serviceInstance.logExternal(event);
	// }
	public void addRemoteManager(IRemoteManager manager) throws DronologyServiceException {
		serviceInstance.addRemoteManager(manager);

	}

}
"
ServiceIds.java,"package edu.nd.dronology.services.core.util;

/**
 * 
 * 
 * @author Michael Vierhauser
 * 
 */
public class ServiceIds {


	public static final String SERVICE_FLIGHROUTE = ""ROUTEPLANNING"";
	public static final String SERVICE_SIMULATOR = ""SIMULATOR"";
	public static final String SERVICE_REMOTE = ""REMOTE"";

	public static final String SERVICE_FLIGHTMANAGER = ""FLIGHTMANAGER"";
	public static final String SERVICE_DRONESETUP = ""DRONESETUP"";
	public static final String SERVICE_REGISTRATION = ""DRONEREGISTRATION"";
	public static final String SERVICE_EQUIP_TYPE_REGISTRATION = ""EQUIPDRONEREGISTRATION"";
	public static final String SERVICE_TYPEREGISTRATION = ""DRONETYPEREGISTRATION"";
	public static final String SERVICE_MISSIONPLANNING = ""MISSIONPLANNING"";
	public static final String SERVICE_AREAMAPPING = ""AREAMAPPING"";
	
}
"
VirtualDrone.java,"package edu.nd.dronology.core.vehicle.internal;

import com.google.common.util.concurrent.RateLimiter;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.exceptions.FlightZoneException;
import edu.nd.dronology.core.simulator.IFlightSimulator;
import edu.nd.dronology.core.simulator.SimulatorFactory;
import edu.nd.dronology.core.vehicle.AbstractDrone;
import edu.nd.dronology.core.vehicle.IDrone;
import edu.nd.dronology.core.vehicle.commands.AbstractDroneCommand;
import edu.nd.dronology.util.NullUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;
import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;

/**
 * Representation of a virtual UAV which is controlled by the internal simulator.
 * 
 * @author Jane Cleland-Huang
 * 
 */ 
public class VirtualDrone extends AbstractDrone implements IDrone {

	private static final ILogger LOGGER = LoggerProvider.getLogger(VirtualDrone.class);
	IFlightSimulator simulator;

	/**
	 * Constructs drone without specifying its current position. This will be used by the physical drone (later) where positioning status will be acquired from the drone.
	 * 
	 * @param drnName
	 */
	public VirtualDrone(String drnName) {
		super(drnName);
		simulator = SimulatorFactory.getSimulator(this);
	} 

	@Override 
	public void takeOff(double targetAltitude) throws FlightZoneException {
		simulator.startBatteryDrain();
		droneStatus.updateBatteryLevel(simulator.getVoltage()); // Need more
		super.setCoordinates(droneStatus.getLatitude(), droneStatus.getLongitude(), targetAltitude);
		try {
			Thread.sleep(new Double(targetAltitude).intValue() * 100); // Simulates
		} catch (InterruptedException e) {
			LOGGER.error(e);
		}
	}

	@Override
	public void flyTo(LlaCoordinate targetCoordinates, Double speed) {
		NullUtil.checkNull(targetCoordinates);
		// LOGGER.info(""Flying to: ""+ targetCoordinates.toString());
		simulator.setFlightPath(currentPosition, targetCoordinates);
	}

	@Override
	public void land() throws FlightZoneException {
		try { 
			Thread.sleep(1500);
			simulator.checkPoint();
			simulator.stopBatteryDrain();

		} catch (Throwable e) {
			LOGGER.error(e);
		}
	}

	@Override
	public double getBatteryStatus() {
		droneStatus.updateBatteryLevel(simulator.getVoltage());
		return simulator.getVoltage();
	}

	RateLimiter limiter = RateLimiter.create(5);

	@Override
	public boolean move(double i) { // ALSO NEEDS THINKING ABOUT FOR non-VIRTUAL
		getBatteryStatus();
		// limiter.acquire();
		boolean moveStatus = simulator.move(2);
		droneStatus.updateCoordinates(getLatitude(), getLongitude(), getAltitude());

		// DroneCollectionStatus.getInstance().testStatus();
		return moveStatus;
	}

	@Override
	public void setVoltageCheckPoint() {
		simulator.checkPoint();

	}

	@Override
	public boolean isDestinationReached(int distanceMovedPerTimeStep) {
		return simulator.isDestinationReached(distanceMovedPerTimeStep);
	}

	@Override
	public void setGroundSpeed(double speed) {
		// TODO Auto-generated method stub

	}

	@Override
	public void setVelocity(double x, double y, double z) {
		// TODO Auto-generated method stub

	}

	@Override
	public void sendCommand(AbstractDroneCommand command) throws DroneException {
		// TODO Auto-generated method stub

	}

	@Override
	public void resendCommand() {
		// TODO Auto-generated method stub
	}

	@Override
	public DroneSnapshotInternal getLatestDroneSnapshot() {
		//todo get velocity and attitude values
		Vector3D velocity = new Vector3D(0, 0, 0);
		Vector3D attitude = new Vector3D(0, 0, 0);
		return new DroneSnapshotInternal(this.droneName, droneStatus.getCoordinates(), velocity, attitude);
	}
}
"
CoverageTest.java,"package edu.nd.dronology.services.extensions.areamapping.output;

import org.junit.Test;

public class CoverageTest {
	
	final static double APERATURE_WIDTH = 10;
	final static double APERATURE_HEIGHT = APERATURE_WIDTH*0.8;
	final static double OVERLAP_FACTOR = 0.7;
	
	@Test
	public void testCalculateRouteCoverage() {
//		MapRiver riverMapper = new MapRiver();
//		List<RoutePrimitive> routes = riverMapper.generateRoutePrimitives();
//		MetricsRunner metricsRunner = new MetricsRunner(routes, riverMapper.getTotalRiverSegment(), riverMapper.getBankList(), APERATURE_WIDTH, APERATURE_HEIGHT, 4);
//		metricsRunner.droneSetup();
//		MetricsStatistics statistics = metricsRunner.runMetrics();
//		System.out.println(statistics.getAllocationCoverage());
//		assertTrue(statistics.getAllocationCoverage() > 0.98);
	}

}
"
TaskList.java,"package edu.nd.dronology.services.extensions.missionplanning.patterns;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import edu.nd.dronology.services.extensions.missionplanning.tasks.IMissionTask;

/**
 * Contains a list of {@link IMissionTask} part mission.
 * 
 * @author Jane Cleland-Huang
 *
 */
public class TaskList {

	List<IMissionTask> tasks = new ArrayList<>();

	public List<IMissionTask> getTasks() {
		return Collections.unmodifiableList(tasks);
	}

	public void addTask(IMissionTask task) {
		tasks.add(task);

	}

}
"
IMissionTask.java,"package edu.nd.dronology.services.extensions.missionplanning.tasks;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

/**
 * 
 * @author A specific task in a mission for a UAV.
 *
 */
public interface IMissionTask {

	/**
	 * 
	 * @return The id of the UAV the task belongs to.
	 */
	String getUAVId();

	/**
	 * 
	 * @return The name of the task.
	 */
	String getTaskName();

	/**
	 * 
	 * @return The waypoint associated with the task.
	 */
	LlaCoordinate getWaypoint();

}"
CommandIds.java,"package edu.nd.dronology.core.vehicle.commands;
/**
 * 
 * 	Ids for valid UAV commands 
 * 
 * @author Michael Vierhauser
 *
 */
public class CommandIds {

	public static final String SET_MODE_COMMAND = ""setMode"";
	public static final String GOTO_LOCATION_COMMAND = ""gotoLocation"";
	public static final String PING_PONG_COMMAND = ""pingpong""; //unused
	public static final String TAKEOFF_COMMAND = ""takeoff"";
	public static final String STOP_COMMAND = ""stop"";
	public static final String SET_GROUND_SPEED_COMMAND = ""setGroundspeed"";
	public static final String SET_VELOCITY_COMMAND = ""setVelocity"";
	public static final String SET_MONITOR_FREQUENCY_COMMAND = ""setMonitorFrequency"";
	public static final String SET_STATE_FREQUENCY_COMMAND = ""setStateFrequency"";
	public static final String CONNECTION_RESPONSE = ""connectionResponse"";
}
"
IUAVEquipmentTypeRegistrationRemoteService.java,"package edu.nd.dronology.services.core.remote;

import edu.nd.dronology.services.core.info.UAVEquipmentTypeRegistrationInfo;

public interface IUAVEquipmentTypeRegistrationRemoteService extends IRemoteableService, IFileTransmitRemoteService<UAVEquipmentTypeRegistrationInfo> {

	
	
}
"
SendToSubscriberCallable.java,"package edu.nd.dronology.monitoring;

import java.util.concurrent.Callable;

import edu.nd.dronology.core.monitoring.IMonitorableMessage;
import edu.nd.dronology.monitoring.service.DroneMonitoringService;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class SendToSubscriberCallable implements Callable {
	private static final ILogger LOGGER = LoggerProvider.getLogger(SendToSubscriberCallable.class);

	private IRemoteMonitoringMessageHandler handler;
	private IMonitorableMessage message;

	public SendToSubscriberCallable(IRemoteMonitoringMessageHandler handler, IMonitorableMessage message) {
		this.handler = handler;
		this.message = message;
	}

	@Override
	public Object call() throws Exception {
		try {
			handler.notifyMonitoringMessage(message);
		} catch (java.rmi.RemoteException e) {
			LOGGER.error(e.getMessage() + "" Unregistering Handler"");
			DroneMonitoringService.getInstance().unsubscribeHandler(handler);

		} catch (Throwable t) {
			t.printStackTrace();
		}
		return null;
	}
}
"
ResultCreationUtil.java,"package edu.nd.dronology.services.extensions.areamapping.selection;

import java.awt.geom.Point2D;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.services.core.areamapping.ExportAllocationInformation;
import edu.nd.dronology.services.core.areamapping.ExportDrone;
import edu.nd.dronology.services.core.items.FlightRoute;
import edu.nd.dronology.services.core.items.IFlightRoute;
import edu.nd.dronology.services.extensions.areamapping.internal.Geometry;
import edu.nd.dronology.services.extensions.areamapping.metrics.AllocationInformation;
import edu.nd.dronology.services.extensions.areamapping.metrics.Drone;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive.RouteType;
import edu.nd.dronology.services.extensions.areamapping.util.Utilities;

public class ResultCreationUtil {

	private static final double ALTITUDE = 20;
	private List<RoutePrimitive> routePrimitives;
	private Map<RouteType, AtomicInteger> typeCounter = new HashMap<>();
	private Map<RoutePrimitive, IFlightRoute> routeMap = new HashMap<>();
	private double avgLatitude;

	public ResultCreationUtil(List<RoutePrimitive> routePrimitives) {
		this.routePrimitives = routePrimitives;
	}

	public void createRoutes(double avgLatitude) {
		this.avgLatitude = avgLatitude;
		for (RoutePrimitive pr : routePrimitives) {
			int val = 1;
			pr = Utilities.cartesianRouteToGpsRoute(pr, avgLatitude);
			RouteType type = pr.getRouteType();
			if (typeCounter.containsKey(type)) {
				val = typeCounter.get(type).incrementAndGet();
			} else {
				typeCounter.put(type, new AtomicInteger(1));
			}
			makeFlightRoute(pr, ALTITUDE, type.toString() + ""_"" + val);

		}

	}

	// edit to return IFlightRoute with name as something with type of route
	public IFlightRoute makeFlightRoute(RoutePrimitive route, double altitude, String name) {
		IFlightRoute newRoute = new FlightRoute();
		for (Point2D.Double entry : route.getRoute()) {
			newRoute.addWaypoint(new Waypoint(new LlaCoordinate(entry.getX(), entry.getY(), altitude)));
		}
		newRoute.setName(name);
		routeMap.put(route, newRoute);
		return newRoute;
	}

	public RouteSelectionResult createResult(List<AllocationInformation> allAllocations) {
		RouteSelectionResult result = new RouteSelectionResult();
		// List<RoutePrimitive> exportedRouteAssignments = new ArrayList<>();
		for (AllocationInformation entry : allAllocations) {
			ExportAllocationInformation ass = new ExportAllocationInformation();
			ass.setMetricsStatistics(entry.getMetricStatistics());
			result.add(ass);
			for (Drone dr : entry.getDroneAllocations()) {
				ExportDrone exp = new ExportDrone(dr.getUAVId());
				java.awt.geom.Point2D.Double home = Geometry.cartesianToGPS(dr.getDroneHomeLocation(), avgLatitude);
				java.awt.geom.Point2D.Double start = Geometry.cartesianToGPS(dr.getDroneStartPoint(), avgLatitude);

				exp.setDroneHomeLocation(new LlaCoordinate(home.getX(), home.getY(), ALTITUDE));
				exp.setDroneStartPoint(new LlaCoordinate(start.getX(), start.getY(), ALTITUDE));

				dr.getDroneRouteAssignment().get().forEach(pr -> {
					exp.addRoute(routeMap.get(pr));
				});
				ass.addDroneAllocation(exp);
			}

		}
		// result.setExportAllocationInformation(info);
		return result;
	}

}
"
AFChooseMissionWindow.java,"package edu.nd.dronology.ui.vaadin.activeflights;


import java.io.ByteArrayInputStream;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import com.vaadin.ui.Button;
import com.vaadin.ui.Component;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Notification;
import com.vaadin.ui.Notification.Type;
import com.vaadin.ui.UI;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.Window;
import com.vaadin.ui.themes.ValoTheme;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.info.MissionInfo;
import edu.nd.dronology.services.core.info.UAVMappingInfo;
import edu.nd.dronology.services.core.items.IMissionPlan;
import edu.nd.dronology.services.core.items.IUAVMissionDescription;
import edu.nd.dronology.services.core.persistence.MissionPlanningPersistenceProvider;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;
import edu.nd.dronology.services.core.remote.IMissionPlanningRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.extensions.missionplanning.persistence.PersistableMissionPlan;
import edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;
import edu.nd.dronology.ui.vaadin.missionplanning.MPControlsComponent;
import edu.nd.dronology.ui.vaadin.missionplanning.MPInfoBox;
import edu.nd.dronology.ui.vaadin.missionplanning.MPInfoPanel;
import edu.nd.dronology.ui.vaadin.missionplanning.MPMainLayout;
import edu.nd.dronology.ui.vaadin.missionplanning.MissionPlanningIntoNameComparator;
import edu.nd.dronology.ui.vaadin.start.MyUI;

/*
 * This is a window that will allow users to choose a mission to execute from the list of missions in the mission planning
 * tab as opposed to having to choose a json on their computer
 * 
 */
public class AFChooseMissionWindow extends Window {
	
	private static final long serialVersionUID=32682356984592L;
	
	private MPMainLayout mpLayout = new MPMainLayout();
	private HorizontalLayout buttonLayout = new HorizontalLayout();
	private MPControlsComponent controls = new MPControlsComponent(mpLayout);
	private MPInfoPanel infoPanel = new MPInfoPanel(controls);
	private Collection<IUAVProxy> drones = null;
	
	public AFChooseMissionWindow(AFInfoPanel AFinfo) {
		 // update the info panel with all missions from dronology and remove all the buttons that allow for editing and deleting missions
		 infoPanel.refreshMission();
		 infoPanel.removeButton();
		
		 // total layout for the whole page
		 VerticalLayout allContent = new VerticalLayout();
		 
		 // remove the edit and delete buttons from each info box
		 for (Component box : infoPanel.getMissions()) {
			 ((MPInfoBox) box).removeButtons();
		 }
		 
		 // execute and cancel buttons
		 Button cancel = new Button(""Cancel"");
		 Button select = new Button(""Select"");
		 select.addStyleName(ValoTheme.BUTTON_PRIMARY);
		 Button execute = new Button(""Execute"");
		 execute.addStyleName(""btn-okay"");
		 buttonLayout.addComponents(cancel, select, execute);
		 
		 // gets all active drones from dronology
		 BaseServiceProvider provider = MyUI.getProvider();
		IDroneSetupRemoteService service1;
		try {
			service1 = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);
			Collection<IUAVProxy> activeDrones = service1.getActiveUAVs();
			drones = new ArrayList<>(activeDrones);
		} catch (DronologyServiceException | RemoteException e1) {
			MyUI.setConnected(false);
		}
		 
		// Listens for clicks on the panel and switches the highlighted mission accordingly
		VerticalLayout missions = infoPanel.getMissions();
		missions.addLayoutClickListener(e -> {
			Component childComponent = e.getChildComponent();
			int index = -1;
			if (childComponent != null && childComponent.getClass().equals(MPInfoBox.class)) {
				infoPanel.unhighlightAllInfoBoxes();
				MissionInfo info = ((MPInfoBox) childComponent).getMissionInfo();
				index = infoPanel.getMissionIndex(info);
				infoPanel.highlightInfoBox(index);
				
				// same as pressing select button
				if (e.isDoubleClick()) {
					MPInfoBox highlighted = infoPanel.getHighlightedMPInfoBox();
					MissionInfo missionInfo = highlighted.getMissionInfo();
					MissionPlanningPersistenceProvider planPersistor = MissionPlanningPersistenceProvider.getInstance();
					ByteArrayInputStream inStream;
					IMissionPlan missionPlan = null;
					IMissionPlanningRemoteService service;
					String id = missionInfo.getId();
					
					// pulls information from dronology, gets the info for the current mission
					try {
						service = (IMissionPlanningRemoteService) provider.getRemoteManager().getService(IMissionPlanningRemoteService.class);
						byte[] information = service.requestFromServer(id);
						inStream = new ByteArrayInputStream(information);
						missionPlan = planPersistor.loadItem(inStream);
					}
					catch (DronologyServiceException | RemoteException e1) {
						e1.printStackTrace();
						MyUI.setConnected(false);
					} catch (PersistenceException e1) {
						e1.printStackTrace();
					}
					
					List<IUAVMissionDescription> mission = ((PersistableMissionPlan) missionPlan).getMissionDescriptions();
					
					// let the user know that there are not currently enough active drones
					boolean enoughDrones = true;
					if (drones.size() < mission.size()) {
						enoughDrones = false;
						Notification.show(""Sorry, but you do not have enough active UAVs to execute this mission."", Type.ERROR_MESSAGE);
					}
					
					//MissionHandler handler = new MissionHandler();
					//handler.setMissionContent(info);
					//handler.executeMission();
					if (enoughDrones) {
						AFMapDrones mapDrones = new AFMapDrones(mission, missionInfo);
						UI.getCurrent().addWindow(mapDrones);
						UI.getCurrent().removeWindow(this);
					}
				}
			}
		});
		
		// Execute Button click listener
		select.addClickListener(e -> {
			MPInfoBox highlighted = infoPanel.getHighlightedMPInfoBox();
			if (highlighted == null) {
				Notification.show(""You must select a mission to execute."", Type.WARNING_MESSAGE);
			}
			else {
				MissionInfo missionInfo = highlighted.getMissionInfo();
				MissionPlanningPersistenceProvider planPersistor = MissionPlanningPersistenceProvider.getInstance();
				ByteArrayInputStream inStream;
				IMissionPlan missionPlan = null;
				IMissionPlanningRemoteService service;
				String id = missionInfo.getId();
				
				// pulls information from dronology, gets the info for the current mission
				try {
					service = (IMissionPlanningRemoteService) provider.getRemoteManager().getService(IMissionPlanningRemoteService.class);
					byte[] information = service.requestFromServer(id);
					inStream = new ByteArrayInputStream(information);
					missionPlan = planPersistor.loadItem(inStream);
				}
				catch (DronologyServiceException | RemoteException e1) {
					e1.printStackTrace();
					MyUI.setConnected(false);
				} catch (PersistenceException e1) {
					e1.printStackTrace();
				}
				
				List<IUAVMissionDescription> mission = ((PersistableMissionPlan) missionPlan).getMissionDescriptions();
				
				// let the user know that there are not currently enough active drones
				boolean enoughDrones = true;
				if (drones.size() < mission.size()) {
					enoughDrones = false;
					Notification.show(""Sorry, but you do not have enough active UAVs to execute this mission."", Type.ERROR_MESSAGE);
				}
				
				//MissionHandler handler = new MissionHandler();
				//handler.setMissionContent(info);
				//handler.executeMission();
				if (enoughDrones) {
					AFMapDrones mapDrones = new AFMapDrones(mission, missionInfo);
					UI.getCurrent().addWindow(mapDrones);
					UI.getCurrent().removeWindow(this);
				}
			}
		});
		
		// Execute Button click listener
		execute.addClickListener(e -> {
			MPInfoBox highlighted = infoPanel.getHighlightedMPInfoBox();
			if (highlighted == null) {
				Notification.show(""You must select a mission to execute."", Type.WARNING_MESSAGE);
			}
			else {
				MissionInfo missionInfo = highlighted.getMissionInfo();
				MissionPlanningPersistenceProvider planPersistor = MissionPlanningPersistenceProvider.getInstance();
				ByteArrayInputStream inStream;
				IMissionPlan missionPlan = null;
				IMissionPlanningRemoteService service = null;
				String id = missionInfo.getId();
				
				// pulls information from dronology, gets the info for the current mission
				try {
					service = (IMissionPlanningRemoteService) provider.getRemoteManager().getService(IMissionPlanningRemoteService.class);
					byte[] information = service.requestFromServer(id);
					inStream = new ByteArrayInputStream(information);
					missionPlan = planPersistor.loadItem(inStream);
				}
				catch (DronologyServiceException | RemoteException e1) {
					e1.printStackTrace();
					MyUI.setConnected(false);
				} catch (PersistenceException e1) {
					e1.printStackTrace();
				}
				
				List<IUAVMissionDescription> mission = ((PersistableMissionPlan) missionPlan).getMissionDescriptions();
				
				// let the user know that there are not currently enough active drones
				boolean enoughDrones = true;
				if (drones.size() < mission.size()) {
					enoughDrones = false;
					Notification.show(""Sorry, but you do not have enough active UAVs to execute this mission."", Type.ERROR_MESSAGE);
				}
				
				// execute the mission
				if (enoughDrones)  {
					ArrayList<String> activeDroneNames = new ArrayList<>();
					for (IUAVProxy drone : drones) {
						activeDroneNames.add(drone.getID());
					}
					// match any uav that has the same name in the mission plan and active uav panel
					UAVMappingInfo mappingInfo = new UAVMappingInfo();
					ArrayList<String> mappedNames = new ArrayList<>();
					for (IUAVMissionDescription uav : mission) {
						if (activeDroneNames.contains(uav.getName())) {
							mappingInfo.addAttribute(uav.getName(), uav.getName());
							activeDroneNames.remove(uav.getName());
							mappedNames.add(uav.getName());
						}
					}
					// match the rest of the drones with whatever is first in the list of names
					for (IUAVMissionDescription uav : mission) {
						if (!mappedNames.contains(uav.getName())) {
							mappingInfo.addAttribute(uav.getName(), activeDroneNames.get(0));
							activeDroneNames.remove(0);
						}
					}
					// use service to execute the mission with the mapping
					try {
						service.executeMissionPlan(missionInfo, mappingInfo);
					} catch (RemoteException | DronologyServiceException e1) {
						// TODO Auto-generated catch block
						e1.printStackTrace();
					}
					UI.getCurrent().removeWindow(this);
				}
			}
		});
		
		
		// Cancel Button click listener
		cancel.addClickListener(e -> {
			UI.getCurrent().removeWindow(this);
		});
		
		// Highlights missions selected with the search bar
		infoPanel.setUsingOtherSearchBar();
		infoPanel.refreshSearchBar();
		 
		infoPanel.getSearchBar().addValueChangeListener(event -> {
        	String name = infoPanel.getSearchBar().getValue();
        	
        	// go through all the missions in dronology and highlight the right one
        	IMissionPlanningRemoteService service;
        	try {
             	service=(IMissionPlanningRemoteService) provider.getRemoteManager().getService(IMissionPlanningRemoteService.class);
             	List<MissionInfo> allMissions=new ArrayList<>(service.getItems());
             	Collections.sort(allMissions, new MissionPlanningIntoNameComparator());
        	
	         	for(MissionInfo mission : allMissions )
	         	{
	         		if (name.equals(mission.getName())) {
	         			infoPanel.unhighlightAllInfoBoxes();
	        			infoPanel.highlightInfoBox(controls.getInfoPanel().getMissionIndex(mission));
	            		break;
	         		}
	    	 	}
         	
        	} catch(RemoteException | DronologyServiceException e) {
             	MyUI.setConnected(false);
             	e.printStackTrace();
             }
        	
        	infoPanel.getSearchBar().setValue("""");
	    });
		 
		 allContent.addComponents(infoPanel, buttonLayout);
		 
		 // format the window 
		 this.setContent(allContent);
		 this.setResizable(false);
		 this.setClosable(true);
		 this.setModal(true);
		 this.setHeight(""950"");
		 this.setWidth(""420"");
	}	

}
"
UAVRegistrationService.java,"package edu.nd.dronology.services.instances.registration.uavs;

import edu.nd.dronology.services.core.base.AbstractFileTransmitServerService;
import edu.nd.dronology.services.core.info.UAVRegistrationInfo;

public class UAVRegistrationService
		extends AbstractFileTransmitServerService<IUAVRegistrationServiceInstance, UAVRegistrationInfo> {

	private static volatile UAVRegistrationService INSTANCE;

	protected UAVRegistrationService() {
		super();
	}

	/**
	 * @return The singleton ConfigurationService instance
	 */
	public static UAVRegistrationService getInstance() {
		if (INSTANCE == null) {
			synchronized (UAVRegistrationService.class) {
				if (INSTANCE == null) {
					INSTANCE = new UAVRegistrationService();
				}
			}
		}
		return INSTANCE;

	}

	@Override
	protected IUAVRegistrationServiceInstance initServiceInstance() {
		return new UAVRegistrationServiceInstance();
	}



}
"
UAVEquipmentTypeRegistration.java,"package edu.nd.dronology.services.core.items;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class UAVEquipmentTypeRegistration implements IUAVEquipmentTypeRegistration {

	private String id;
	private String name;
	private String description;
	private Map<String, Serializable> attributes;

	public UAVEquipmentTypeRegistration() {
		id = UUID.randomUUID().toString();
		attributes = new HashMap<>();
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String getId() {
		return id;
	}

	@Override
	public String getDescription() {
		return description;
	}

	@Override
	public void setDescription(String description) {
		this.description = description;

	}

	@Override
	public Serializable getAttribute(String key) {
		return attributes.get(key);
	}

	@Override
	public void addAttribute(String key, Serializable value) {
		attributes.put(key, value);
	}

}
"
SimulatorScenarioInfo.java,"package edu.nd.dronology.services.core.info;

public class SimulatorScenarioInfo extends RemoteInfoObject {

	/**
	 * 
	 */
	private static final long serialVersionUID = -7327376857430499641L;

	private String category = ""Default"";
	
	


	public SimulatorScenarioInfo(String name, String id) {
		super(name, id);
	}
	
	public String getCategory() {
		return category;
	}


	public void setCategory(String category) {
		this.category = category;
	}

	

}
"
AreaMappingService.java,"package edu.nd.dronology.services.extensions.areamapping.instances;

import java.util.Collection;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.areamapping.GeneratedMappedArea;
import edu.nd.dronology.services.core.base.AbstractFileTransmitServerService;
import edu.nd.dronology.services.core.info.AreaMappingCategoryInfo;
import edu.nd.dronology.services.core.info.AreaMappingInfo;
import edu.nd.dronology.services.core.info.FlightRouteCategoryInfo;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

/**
 * 
 * 
 * 
 * 
 * @author Michael Vierhauser
 *
 */
public class AreaMappingService
		extends AbstractFileTransmitServerService<IAreaMappingServiceInstance, AreaMappingInfo> {

	private static volatile AreaMappingService INSTANCE;

	protected AreaMappingService() {
		super();
	}

	/**
	 * @return The singleton ConfigurationService instance
	 */
	public static AreaMappingService getInstance() {
		if (INSTANCE == null) {
			synchronized (AreaMappingService.class) {
				if (INSTANCE == null) {
					INSTANCE = new AreaMappingService();
				}
			}
		}
		return INSTANCE;
	}

	@Override
	protected IAreaMappingServiceInstance initServiceInstance() {
		return new AreaMappingServiceInstance();
	}

	public Collection<AreaMappingCategoryInfo> getMappingPathCategories() {
		return serviceInstance.getMappingPathCategories();
	}

	public AreaMappingInfo getItem(String name) throws DronologyServiceException {
		return serviceInstance.getItem(name);
	}

	public AreaMappingInfo getMappingByName(String mappingName) throws DronologyServiceException {
		return serviceInstance.getMappingByName(mappingName);
	}

	public GeneratedMappedArea generateAreaMapping(AreaMappingInfo info) throws DronologyServiceException {
		return serviceInstance.generateAreaMapping(info);
	}

	public GeneratedMappedArea generateAreaMapping(AreaMappingInfo info, Collection<IUAVProxy> selectedUAVs)
			throws DronologyServiceException {
		return serviceInstance.generateAreaMapping(info, selectedUAVs);
	}

	public void executeAreaMapping(GeneratedMappedArea area) throws DronologyServiceException {
		serviceInstance.executeAreaMapping(area);
	}
}
"
AbstractRMIRemoteObject.java,"package edu.nd.dronology.services.remote.rmi;

import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;

import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Abstract class for RMI remote objects taking care of registry re/unbind
 * 
 * @author Michael Vierhauser
 * 
 */
public abstract class AbstractRMIRemoteObject extends UnicastRemoteObject {

	private static final ILogger LOGGER = LoggerProvider.getLogger(AbstractRMIRemoteObject.class);
	protected int port = 9753;
	private String bindingName;
	protected Registry registry;

	protected AbstractRMIRemoteObject(int port, String bindingName) throws RemoteException {
		super();
		this.port = port;
		this.bindingName = bindingName;
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = -1684918850552214903L;

	public void initialize() throws RemoteException {
		if (registry == null) {
			try {
				registry = LocateRegistry.createRegistry(port);
			} catch (Exception e) {
				e.printStackTrace();
				registry = LocateRegistry.getRegistry(port);
			}
		}
		registry.rebind(bindingName, this);
		LOGGER.info("">> Binding '""+bindingName+""' established on port ""+port);
	}

	public void tearDown() throws Exception {
		registry.unbind(bindingName);
		LOGGER.info("">> Binding '""+bindingName+""' removed on port ""+port);
	}

}
"
RouteTask.java,"package edu.nd.dronology.services.extensions.missionplanning.tasks;

public class RouteTask extends AbstractMissionTask {

	protected RouteTask(String uavID, String taskName) {
		super(uavID, taskName);
	}
}"
WaypointCommand.java,"package edu.nd.dronology.core.collisionavoidance.guidancecommands;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

/**
 * A command that tells a UAV to fly to a specific place.
 */
public class WaypointCommand extends Command {

    private final LlaCoordinate destination;
    private final double speed;

    /**
     * <p>
     * Creates a command that tells the UAV to fly to the given coordinates on Earth.
     * </p>
     * <p>
     * For example, to command a UAV to fly to the Notre Dame Stadium (10m above the middle of the 50-yard line)
     * <pre>
     *         {@code
     *         WaypointCommand nd = new WaypointCommand(new LlaCoordinate(41.698394, -86.233923, 236.0))
     *         }
     *     </pre>
     * </p>
     *
     * @param destination the coordinates where the UAV should fly.
     */
    public WaypointCommand(LlaCoordinate destination, double speed) {
        this.destination = destination;
        this.speed = speed;
    }

    /**
     * @return destination coordinates. The place where the UAV should go.
     */
    public LlaCoordinate getDestination() {
        return destination;
    }

    public double getSpeed() {
        return speed;
    }

    @Override
    public String toString() {
        return ""WaypointCommand(lat:"" + destination.getLatitude() + "", long:"" + destination.getLongitude() + "", alt:"" +
                destination.getAltitude() + "", speed:"" + speed + "")"";
    }
}
"
IDroneConnectorServiceInstance.java,"package edu.nd.dronology.gstation.connector.service.connector;

import edu.nd.dronology.gstation.connector.GroundStationException;
import edu.nd.dronology.gstation.connector.GroundstationConnector;
import edu.nd.dronology.gstation.connector.messages.ConnectionRequestMessage;
import edu.nd.dronology.services.core.api.IServiceInstance;

public interface IDroneConnectorServiceInstance extends IServiceInstance {

	void unregisterConnection(String groundstationid) throws GroundStationException;

	void handleConnection(GroundstationConnector handler);

	void registerConnection(GroundstationConnector connector, ConnectionRequestMessage msg)
			throws GroundStationException;

}
"
IRemoteTransferObject.java,"package edu.nd.dronology.services.core.api;

import java.io.Serializable;

public interface IRemoteTransferObject extends Serializable{

}
"
UAVRegistrationPersistenceProvider.java,"package edu.nd.dronology.services.core.persistence;

import edu.nd.dronology.services.core.items.IUAVRegistration;
import edu.nd.dronology.services.core.persistence.internal.UAVRegistrationXStreamPersistor;


/**
 * Provider implementation for {@link IUAVRegistration}.<br>
 * Details see {@link AbstractItemPersistenceProvider}
 * 
 * @author Michael Vierhauser
 * 
 */
public class UAVRegistrationPersistenceProvider extends AbstractItemPersistenceProvider<IUAVRegistration> {

	public UAVRegistrationPersistenceProvider() {
		super();
	}

	@Override
	protected void initPersistor() {
		PERSISTOR = new UAVRegistrationXStreamPersistor();

	}

	@Override
	protected void initPersistor(String type) {
		initPersistor();
	}

	public static UAVRegistrationPersistenceProvider getInstance() {
		return new UAVRegistrationPersistenceProvider();
	}

}
"
DroneVoltageSimulator.java,"package edu.nd.dronology.core.simulator.simplesimulator;

/**
 * Voltage simulator.  For every minute of flight, the battery decreases by 0.25 volts.
 * @author Jane Cleland-Huang
 *
 */
public class DroneVoltageSimulator {
	
	private double voltage;
	private enum BatteryState {CHARGING, DEPLETING, STABLE}
	private BatteryState batteryState = BatteryState.STABLE;
	private static final double SIMULATOR_BATTERY_DRAIN_VOLTS = 0.25;
   
	private long checkPointTime;
	
	public DroneVoltageSimulator(){
		voltage = 15.0;
		checkPointTime = 0;
	}
	
	public void rechargeBattery(){
		batteryState = BatteryState.CHARGING;
		voltage = 15.0;
		batteryState = BatteryState.STABLE;
	}
	
	public void startBatteryDrain(){
		batteryState = BatteryState.DEPLETING;
		checkPointTime = System.currentTimeMillis();
	}
	
	public void stopBatteryDrain(){
		checkPoint();
		batteryState = BatteryState.STABLE;		
	}
	 
	public void checkPoint(){
		if(batteryState == BatteryState.DEPLETING){
			long timeSinceLastCheckPoint = System.currentTimeMillis() - checkPointTime;
			if (timeSinceLastCheckPoint > 5000) {
				checkPointTime = System.currentTimeMillis(); // Reset checkPoint time
			
				// Volts drained per second * number of elapsed seconds
				double voltageDrain = SIMULATOR_BATTERY_DRAIN_VOLTS/60 * (timeSinceLastCheckPoint/1000);
				voltage = voltage - voltageDrain;
			}
		} 
	}
	
	public double getVoltage(){
		return voltage;
	}
}
"
GoToCommand.java,"package edu.nd.dronology.core.vehicle.commands;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

/**
 * 
 * Command sent to the GCS for sending a new waypoint.
 * 
 * 
 * @author Michael Vierhauser
 */
public class GoToCommand extends AbstractDroneCommand implements IDroneCommand {

	/**
	 * 
	 */
	private static final long serialVersionUID = 4420565617484849238L;

	public GoToCommand(String uavid, LlaCoordinate coord) {
		super(uavid, CommandIds.GOTO_LOCATION_COMMAND);
		data.put(ATTRIBUTE_X, coord.getLatitude());
		data.put(ATTRIBUTE_Y, coord.getLongitude());
		data.put(ATTRIBUTE_Z, coord.getAltitude());
	}

}
"
CommandExecutorFactory.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal;

import edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.NedCommand;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand;
import edu.nd.dronology.core.vehicle.IDrone;
import edu.nd.dronology.core.vehicle.ManagedDrone;

/**
 * Managed Drones create an instance of this factory when they are constructed. This factory takes collision avoidance
 * commands and and makes executors that are specially configured to carryout the commands.
 */
public class CommandExecutorFactory {
    private IDrone drone;

    /**
     * Create a factory
     * @param drone the drone that executors act upon
     */
    public CommandExecutorFactory(IDrone drone) {
        this.drone = drone;
    }

    public CommandExecutor makeExecutor(Command cmd) {
        if (cmd instanceof WaypointCommand) {
            return new WaypointExecutor(this.drone, (WaypointCommand) cmd);
        }
        if (cmd instanceof StopCommand) {
            return new StopExecutor(this.drone, (StopCommand) cmd);
        }
        if (cmd instanceof NedCommand) {
            return new NedExecutor(this.drone, (NedCommand) cmd);
        }
        throw new IllegalArgumentException();
    }
}
"
TestStatusDispatchThread.java,"package edu.nd.dronology.gstation.connector.dispatch;

import edu.nd.dronology.core.IUAVPropertyUpdateNotifier;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.gstation.connector.messages.AbstractUAVMessage;
import edu.nd.dronology.gstation.connector.messages.UAVMessageFactory;
import edu.nd.dronology.gstation.connector.messages.UAVStateMessage;
import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;
import org.junit.Test;
import org.junit.Assert;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class TestStatusDispatchThread {

    class DispatchWrapper {
        public volatile StatusDispatchThread dispatcher;
    }

    @Test
    public void testCurrentBehavior() throws Throwable {
        /*
        Create a mock IUAVPropertyUpdateNotifier that checks the stubbed data gets passed in
         */
        final DispatchWrapper dispatchWrapper = new DispatchWrapper();
        BlockingQueue<AbstractUAVMessage> queue = new LinkedBlockingQueue();
        IUAVPropertyUpdateNotifier updateNotifier = new IUAVPropertyUpdateNotifier() {
            @Override
            public void update(LlaCoordinate location, double batteryLevel, double speed, Vector3D velocity, Vector3D attitude) {
                updateCoordinates(location);
                updateBatteryLevel(batteryLevel);
                updateVelocity(speed);
                updateCollisionAvoidance(location, velocity, attitude);
            }

            @Override
            public void updateCoordinates(LlaCoordinate location) {
                dispatchWrapper.dispatcher.tearDown();
                LlaCoordinate expected = new LlaCoordinate(41.519495,-86.239937,266.19);
                Assert.assertEquals(expected, location);
            }

            @Override
            public void updateDroneState(String status) {
                dispatchWrapper.dispatcher.tearDown();
                //todo investigate if this is the behavior we want
                Assert.fail(""This isn't called"");
            }

            @Override
            public void updateBatteryLevel(double batteryLevel) {
                dispatchWrapper.dispatcher.tearDown();
                Assert.assertEquals(100, batteryLevel, 0.0);

            }

            @Override
            public void updateVelocity(double velocity) {
                dispatchWrapper.dispatcher.tearDown();
                Assert.assertEquals(5.0, velocity, 0.0);
            }

            @Override
            public void updateCollisionAvoidance(LlaCoordinate position, Vector3D velocity, Vector3D attitude) {
                LlaCoordinate expected = new LlaCoordinate(41.519495,-86.239937,266.19);
                Assert.assertEquals(expected, position);

                Vector3D expectedVelcity = new Vector3D(3.0, 4.0, 0.0);
                Assert.assertEquals(expectedVelcity, velocity);

                Vector3D expectedAttitude = new Vector3D(30.0, 31.0, 32.0);
                Assert.assertEquals(expectedAttitude, attitude);
            }

			@Override
			public void updateMode(String mode) {
				
			}
        };

        String batteryState = ""{\n"" +
                ""\""voltage\"": 12.19,\n"" +
                ""\""current\"": 27.15,\n"" +
                ""\""level\"": 100\n"" +
                ""}"";
        String gsString =""{\n"" +
                ""\""type\"": \""state\"",\n"" +
                ""\""uavid\"":\""TESTING\"",\n"" +
                ""\""sendtimestamp\"":"" + System.currentTimeMillis() + "",\n"" +
                ""\""data\"":{\n"" +
                ""\""location\"": {\""x\"": 41.519495, \""y\"": -86.239937, \""z\"": 266.19},\n"" +
                ""\""attitude\"": {\""x\"": 30.0, \""y\"": 31.0, \""z\"": 32.0},\n"" +
                ""\""velocity\"": {\""x\"": 3, \""y\"": 4, \""z\"": 0},\n"" +
                ""\""status\"": \""ACTIVE\"",\n"" +
                ""\""heading\"": 53.1301025195,\n"" +
                ""\""airspeed\"": 5,\n"" +
                ""\""groundspeed\"": 5,\n"" +
                ""\""armed\"": true,\n"" +
                ""\""armable\"": true,\n"" +
                ""\""mode\"": \""GUIDED\"",\n"" +
                ""\""batterystatus\"": "" + batteryState + ""\n"" +
                ""}\n"" +
                ""}"";
        final UAVStateMessage x = (UAVStateMessage) UAVMessageFactory.create(gsString);
        queue.offer(x);
        dispatchWrapper.dispatcher = new StatusDispatchThread(queue, updateNotifier);
        dispatchWrapper.dispatcher.call();

    }
}
"
StopExecutorViaWaypoint2.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal;

import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.vehicle.IDrone;
import edu.nd.dronology.core.vehicle.ManagedDrone;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/*
This variation pick a waypoint some number of meters behind the UAV
*/
public class StopExecutorViaWaypoint2 implements CommandExecutor {

    private static final ILogger LOGGER = LoggerProvider.getLogger(StopExecutorViaWaypoint2.class);

    enum StopExecutionState {
        RADIOING,
        WATCHING_THE_CLOCK,
        WAITING_FOREVER,
        FINISHED;
    }

    private class UavData {
        public LlaCoordinate position;
        public Vector3D velocity;
        public double speed;
    }

    // Number of meters to set the waypoint away in the opposite direction of velocity
    private static final double WAYPOINT_DISTANCE = 20.0;

    private IDrone drone;
    StopExecutionState state = StopExecutionState.RADIOING;
    StopCommand data;
    long startTime;

    public StopExecutorViaWaypoint2(IDrone drone, StopCommand data) {
        this.drone = drone;
        this.data = data;
        LOGGER.debug(""Creating stop executor for "" + drone.getDroneName());
    }

    @Override
    public void process() {
        switch (state) {
            case RADIOING:
                radioDrone();
                break;

            case WATCHING_THE_CLOCK:
                checkClock();
                break;

            case WAITING_FOREVER:
            case FINISHED:
            default:
                // Do nothing.
                break;
        }
    }

    private void radioDrone() {
        LOGGER.debug(""RADIOING STOP TO "" + drone.getDroneName());
        UavData current = getUavData();
        Vector3D deltaPosition = current.velocity.normalize().scalarMultiply(-1.0 * WAYPOINT_DISTANCE);
        LlaCoordinate target = current.position.findLla(deltaPosition);
        drone.flyTo(target, current.speed);

        double waitDuration = data.getTime();
        if (waitDuration > 0.0) {
            startTime = System.nanoTime();
            state = StopExecutionState.WATCHING_THE_CLOCK;
        }
        else {
            state = StopExecutionState.WAITING_FOREVER;
        }
    }

    private void checkClock() {
        double waitDuration = data.getTime();
        long deltaNano = System.nanoTime()- startTime;
        double deltaT = deltaNano * 1.0e-9;
        if (deltaT > waitDuration) {
            state = StopExecutionState.FINISHED;
        }
    }

    @Override
    public boolean isFinished() {
        return state == StopExecutionState.FINISHED;
    }

    private UavData getUavData() {
        UavData result = new UavData();
        DroneSnapshotInternal currentState = drone.getLatestDroneSnapshot();
        result.position = currentState.getPosition();
        result.speed = Vector3D.distance(Vector3D.ZERO, currentState.getVelocity());
        result.velocity = currentState.getVelocity();
        return result;
    }

}
"
DroneFleetManager.java,"package edu.nd.dronology.core.fleet;

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.function.Consumer;

import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.monitoring.DronologyMonitoringManager;
import edu.nd.dronology.core.monitoring.MessageMarshaller;
import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;
import edu.nd.dronology.core.vehicle.ManagedDrone;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * Holds a fleet of virtual or physical drones.<br>
 * When activated, UAVs are registered with the fleet manager and can be retrieved for assigning routes to them.
 * 
 *  
 * @author Michael Vierhauser
 *
 */
public class DroneFleetManager {

	private static final ILogger LOGGER = LoggerProvider.getLogger(DroneFleetManager.class);
	private static volatile DroneFleetManager INSTANCE = null;

	private ConcurrentSkipListMap<String, ManagedDrone> registeredDrones;
	private Queue<ManagedDrone> availableDrones;
	private List<ManagedDrone> busyDrones;
	private List<DroneFleetListener> listeners;

	public static DroneFleetManager getInstance() {

		if (INSTANCE == null) {
			synchronized (DroneFleetManager.class) {
				if (INSTANCE == null) {
					INSTANCE = new DroneFleetManager();
				}
			}
		}
		return INSTANCE;
	}

	/**
	 * Specifies whether virtual or physical drones will be created according to the previously specified runtime drone type. (See RuntimeDroneTypes.java)
	 */
	protected DroneFleetManager() {
		// if (RuntimeDroneTypes.getInstance().isSimulation())
		// availableDrones = VirtualDroneFleetFactory.getInstance().getDrones();
		// else
		// availableDrones =
		// PhysicalDroneFleetFactory.getInstance().getDrones();
		registeredDrones = new ConcurrentSkipListMap();
		availableDrones = new ConcurrentLinkedQueue<>();
		busyDrones = new ArrayList<>();
		listeners = new ArrayList<>();
	}

	/**
	 * Checks for an available drone from the fleet.
	 * 
	 * @return true if drone is available, false if it is not.
	 */
	public boolean hasAvailableDrone() {
		LOGGER.info(""Drones available: "" + availableDrones.size());
		return availableDrones.size() > 0;

	}

	/**
	 * Returns the next available drone. Currently uses FIFO to recycle drones.
	 * 
	 * @return
	 */
	public ManagedDrone getAvailableDrone() {
		if (!availableDrones.isEmpty()) {
			ManagedDrone drone = availableDrones.poll();
			busyDrones.add(drone);
			return drone;
		} else
			return null;
	}

	public ManagedDrone getAvailableDrone(String designatedDroneId) {
		synchronized (availableDrones) {
			ManagedDrone found = null;
			if (!availableDrones.isEmpty()) {
				for (ManagedDrone d : availableDrones) {
					if (d.getDroneName().equals(designatedDroneId)) {
						found = d;
						break;
					}
				}
				if (found != null) {
					boolean success = availableDrones.remove(found);
					if (success) {
						busyDrones.add(found);
						return found;
					} else {
						LOGGER.error(""Error when queuing uav '"" + designatedDroneId + ""'"");
					}
				}
				// LOGGER.error(""Error when retrieving uav '"" + designatedDroneId + ""'"");
			}
			return null;
		}
	}

	private void notifyListeners(boolean add, ManagedDrone managedDrone) {
		Consumer<DroneFleetListener> update; 
		if (add) {
			update = listener -> listener.droneAdded(managedDrone);
		} else {
			update = listener -> listener.droneRemoved(managedDrone);
		}
		listeners.forEach(update);
	}

	/**
	 * When a drone completes a mission, returns it to the pool of available drones.
	 * 
	 * @param drone
	 */
	public void returnDroneToAvailablePool(ManagedDrone drone) {
		if (busyDrones.contains(drone)) {
			busyDrones.remove(drone);
		}
		// LOGGER.info(""Drone '""+drone.getDroneName()+""' added to available drone
		// pool"");
		availableDrones.offer(drone);

	}

	public void addDrone(ManagedDrone managedDrone) throws DroneException {
		if (registeredDrones.containsKey(managedDrone.getDroneName())) {
			throw new DroneException(""Drone '"" + managedDrone.getDroneName() + ""' already registered"");
		}
		registeredDrones.put(managedDrone.getDroneName(), managedDrone);
		returnDroneToAvailablePool(managedDrone);
		notifyListeners(true, managedDrone);

	}

	public void removeDrone(ManagedDrone managedDrone) throws DroneException {
		ManagedDrone value = registeredDrones.remove(managedDrone.getDroneName());
		if (value == null) {
			throw new DroneException(""Drone '"" + managedDrone.getDroneName() + ""' not found registered"");
		}
		LOGGER.info(""Drone '"" + managedDrone.getDroneName() + ""' removed from available drone pool"");
		DronologyMonitoringManager.getInstance()
				.publish(MessageMarshaller.createMessage(MessageType.PHYSICAL_UAV_DEACTIVATED, managedDrone.getDroneName()));
		availableDrones.remove(value);
		// TODO change how this class uses managed drone. Stopping must be sent to the drone using a goal model.
		value.stop();
		notifyListeners(false, managedDrone);
	}

	public ManagedDrone getRegisteredDrone(String uavid) throws DroneException {
		if (!registeredDrones.containsKey(uavid)) {
			throw new DroneException(""Drone '"" + uavid + ""' not found registered"");
		}
		return registeredDrones.get(uavid);

	}

	public List<ManagedDrone> getRegisteredDrones() { 
		return new ArrayList<>(registeredDrones.values());

	}

	public void unregisterDroe(String id) throws DroneException {
		ManagedDrone managedDrone = getRegisteredDrone(id);
		removeDrone(managedDrone);
	}

	public void addDroneFleetListener(DroneFleetListener listener) {
		listeners.add(listener);
	}

}
"
CollisionAvoider.java,"package edu.nd.dronology.core.collisionavoidance;

import java.util.ArrayList;

/**
 * <p>
 *     A collision avoidance strategy.
 * </p>
 * <p>
 *     This is the strategy pattern from Design Patterns (Gang of four) where all information is passed in as a
 *     parameter.
 * </p>
 *
 * <p>
 *     When implementing this class you need to use the data provided in the list of DroneSnapshotInternal(s) to figure out
 *     how to command each drone so that they dont crash into one another. You change where the drones will fly by
 *     changing the list of commands in each DroneSnapshotInternal(s). For example, if you want a drone to pause
 *     (hover in place) for 5 seconds before continuing with its mission, you would:
 * </p>
 * <pre>
 * {@code
 *
 * DroneSnapshotInternal drone = ...
 * drone.getCommands().add(0, new StopCommand(5.0));
 * }
 * </pre>
 *
 * <h2>FAQ</h2>
 * <h3>Who is this for?</h3>
 * <p>Developers who want to create a collision avoidance algorithm with Dronology.</p>
 * <h3>What do you need to know?</h3>
 * <p>You need to know how to read the state of each drone and how to command each drone to avoid crashing.</p>
 * <h3> How do you read the state of each drone?</h3>
 * <p>You iterate through the list of Drone Snapshots. Each Drone Snapshot includes getters for data sensed by each drone. For example, you can call the get position method to access the drone's position:</p>
 * <pre>
 *     {@code
 *     drone.getPosition();
 *     }
 * </pre>
 * <h3>How do you control each drone?</h3>
 * <p>Each drone snapshot includes a get Commands method that gives you access to an array list of commands. By changing this list you are changing the queue of actions a given drone will execute. For example, to have a drone pause for 5 seconds before continuing on with its mission, insert a stop command at the start of the commands list:</p>
 *
 * <pre>
 *     {@code
 *     drone.getCommands().add(0, new StopCommand(5.0));
 *     }
 * </pre>
 *
 * <p>This inserts the stop command at the start of the commands list. When Dronology sees this change, it will radio the drone's on board autopilot and tell it to hover in place for 5 seconds. After that Dronology will radio the autopilot again with the next command in the get commands list. Here are 3 examples of possible commands you can create:
 * <ul>
 *     <li>A NedCommand. This command tells a drone to fly at given North, East, and Down velocity for a specified amount of time. @see {@link edu.nd.dronology.core.collisionavoidance.guidancecommands.NedCommand}</li>
 *     <li>A StopCommand. This tells a drone to hover in place for a specified amount of time. @see {@link edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand}</li>
 *     <li>A WaypointCommand. This tells a drone to fly to a given waypoint. @see {@link edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand}</li>
 * </ul>
 * Finally, you can also remove commands from the commands list.
 * </p>
 */
public interface CollisionAvoider {
    public void avoid(ArrayList<DroneSnapshot> drones);
}
"
IUAVMissionTask.java,"package edu.nd.dronology.services.core.items;

import java.io.Serializable;
import java.util.Map;

public interface IUAVMissionTask {

	String getType();

	String getId();

	Serializable getAttribute(String key);

	Map<String, Serializable> getParameters();


}
"
AbstractStatusDispatchThread.java,"package edu.nd.dronology.gstation.connector.dispatch;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicBoolean;

public abstract class AbstractStatusDispatchThread<MESSAGE_TYPE> implements Callable {

	protected AtomicBoolean cont = new AtomicBoolean(true);
	protected BlockingQueue<MESSAGE_TYPE> queue;
	
	
	public AbstractStatusDispatchThread(BlockingQueue<MESSAGE_TYPE> queue) {
		this.queue = queue;
	}

	int getQueueSize() {
		return queue.size();
	}

	public void tearDown() {
		cont.set(false);
	}

	
	
}
"
AMEditPrioritiesController.java,"package edu.nd.dronology.ui.vaadin.areamapping;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Vector;

import com.vaadin.ui.Button;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Label;
import com.vaadin.ui.Notification;
import com.vaadin.ui.UI;

import edu.nd.dronology.services.core.areamapping.EdgeLla;
import edu.nd.dronology.services.core.info.AreaMappingInfo;
import edu.nd.dronology.services.core.items.IAreaMapping;
import edu.nd.dronology.services.core.persistence.AreaMappingPersistenceProvider;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import edu.nd.dronology.services.core.remote.IAreaMappingRemoteService;

import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.ui.vaadin.areamapping.windows.AMPriorityAreaCreationWindow;
import edu.nd.dronology.ui.vaadin.areamapping.windows.AMPrioritySideCreationWindow;
import edu.nd.dronology.ui.vaadin.areamapping.windows.AMSaveAreaWithoutFinishWindow;
import edu.nd.dronology.ui.vaadin.areamapping.windows.AMSaveSideWithoutFinishWindow;
import edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;
import edu.nd.dronology.ui.vaadin.start.MyUI;

/**
 * This allows the user to create and edit mappings by changing the priority areas.
 * 
 * @author Andrew Slavin
 *
 */

public class AMEditPrioritiesController extends CustomComponent {
	/**
	 *  
	 */
	private static final long serialVersionUID = 212323831233690123L;
	private AMMapComponent mapComponent;
	private AMSaveAreaWithoutFinishWindow saveAreaWithoutFinishWindow;
	private AMSaveSideWithoutFinishWindow saveSideWithoutFinishWindow;
	private AMPriorityAreaCreationWindow priorityAreaCreationWindow;
	private AMPrioritySideCreationWindow prioritySideCreationWindow;
	private HorizontalLayout totalLayout = new HorizontalLayout();
	private Button editSidesButton = new Button(""Sides"");
	private Button editPrioritiesButton = new Button(""Priorities"");
	private Button drawAreaButton = new Button();
	private Button drawSidesButton = new Button();
	private Button cancelButton = new Button(""Cancel"");
	private Button saveButton = new Button(""Save"");
	private Label smallText = new Label(""Select sides or areas to edit."");

	private List<UIEdgePoint> sidePoints0 = new ArrayList<>();
	private List<UIEdgePoint> sidePoints1 = new ArrayList<>();
	private String storedName = """";
	private String storedDescription = """";
	private Boolean drawingArea;
	private Boolean drawingSide;
	private Boolean finishAreaThenSave;
	private Boolean finishSideThenSave;
	private Boolean selectingUpstream;

	public AMEditPrioritiesController(AMMapComponent mapComponent) {
		this.mapComponent = mapComponent;
		priorityAreaCreationWindow = new AMPriorityAreaCreationWindow(mapComponent);
		prioritySideCreationWindow = new AMPrioritySideCreationWindow(mapComponent);
		saveAreaWithoutFinishWindow = new AMSaveAreaWithoutFinishWindow(this);
		saveSideWithoutFinishWindow = new AMSaveSideWithoutFinishWindow(this);
		drawAreaButton.setCaption(""Start Area"");
		drawSidesButton.setCaption(""Start Side"");
		
		drawingArea = false;
		drawingSide = false;
		finishAreaThenSave = false;
		finishSideThenSave = false;
		selectingUpstream = false;

		setStyleName(""am_edit_bar"");
		smallText.setStyleName(""small_text"");

		cancelButton.setHeight(""25px"");
		saveButton.setHeight(""25px"");
		editSidesButton.setHeight(""100px"");
		editSidesButton.addStyleName(""sides_button"");
		editPrioritiesButton.setHeight(""35px"");
		editPrioritiesButton.setEnabled(false);
		editSidesButton.addStyleName(""toggle_button"");
		editPrioritiesButton.addStyleName(""toggle_button"");
		drawAreaButton.setHeight(""25px"");
		drawSidesButton.setHeight(""25px"");

		totalLayout.addComponents(editSidesButton, editPrioritiesButton, smallText, drawSidesButton, drawAreaButton, cancelButton, saveButton);
		setCompositionRoot(totalLayout);

		// Click listeners for the cancel and saves buttons on edit bar
		
		// cancel button resets the other buttons and exits edit mode
		cancelButton.addClickListener(e -> {
			drawAreaButton.setEnabled(true);
			drawSidesButton.setEnabled(true);
			exitEditMode();
			cancelClick();
		});
		
		// save changes to priorities. If still in a drawing mode, prompt user to finish
		saveButton.addClickListener(e -> {
			
			// if the user hasn't selected upstream yet, prompt them to do so
			if (mapComponent.getMapUtilities().getUpstream() == null) {
				Notification.show(""Please select the most upstream side A coordinate."", Notification.Type.ERROR_MESSAGE);
				selectingUpstream = true;
				return;
			}
			
			drawAreaButton.setEnabled(true);
			drawSidesButton.setEnabled(true);
			if (drawingArea) {
				if (mapComponent.getMapUtilities().getPolygonVertices().size() < 3) {
					Notification.show(""Please finish your unfinished priority area."", Notification.Type.ERROR_MESSAGE);
					return;
				}
				UI.getCurrent().addWindow(saveAreaWithoutFinishWindow);
			}
			else if (drawingSide) {
				if (mapComponent.getMapUtilities().getNewPrioritySideLines().size() == 0) {
					Notification.show(""Please finish your unfinished priority area."", Notification.Type.ERROR_MESSAGE);
				}
				UI.getCurrent().addWindow(saveSideWithoutFinishWindow);
			}
			else
				saveClick();
		});
		
		// switch over to editing sides rather than priorities
		editSidesButton.addClickListener(e -> {
			exitEditMode();
			mapComponent.getEditSidesController().enterEditMode();
		});
		
		// on each click, alternate between drawingArea mode and finishing the area
		drawAreaButton.addClickListener(e -> {
			if (!drawingArea) {// entering drawing mode
				drawingArea = !drawingArea;
				drawAreaButton.setCaption(""Finish Area"");
				smallText.setValue(""Click or drag area points."");
				drawSidesButton.setEnabled(false);
			}
			else { // finishing polygon
				if (mapComponent.getMapUtilities().getPolygonVertices().size() < 3) {
					Notification.show(""Priority area must be at least 3 sides."", Notification.Type.ERROR_MESSAGE);
					return;
				}
				drawingArea = !drawingArea;
				drawAreaButton.setCaption(""Start Area"");
				smallText.setValue(""Select sides or areas to edit."");
				
				// window pops up for user to set info about polygon
				UI.getCurrent().addWindow(priorityAreaCreationWindow);
				drawSidesButton.setEnabled(true);
			}
		});
		
		// alternate between drawingSide mode and finshing side
		drawSidesButton.addClickListener(e -> {
			if (!drawingSide) {// entering drawing mode
				drawingSide = !drawingSide;
				drawSidesButton.setCaption(""Finish Sides"");
				smallText.setValue(""Click consecutive side segments to prioritize."");
				drawAreaButton.setEnabled(false);
			}
			else { // finishing side
				if (mapComponent.getMapUtilities().getNewPrioritySideLines().size() == 0) {
					Notification.show(""Please select at least one bank segment."", Notification.Type.ERROR_MESSAGE);
					return;
				}
				drawingSide = !drawingSide;
				drawSidesButton.setCaption(""Draw Side"");
				smallText.setValue(""Select sides or areas to edit."");
				drawAreaButton.setEnabled(true);
				
				// pop-up window so that the user can set info about the priority side
				UI.getCurrent().addWindow(prioritySideCreationWindow);
			}
		});
	}

	// Called when the cancel button is clicked. Disables editing and reverts
	// changes back to the previous save
	public void cancelClick() {
		
		// if drawing an area or a side, clean it up
		if (drawingArea)
			cleanUnfinishedPolygon();
		if (drawingSide) {
			drawingSide = false;
			drawSidesButton.setCaption(""Start Side"");
		}

		// Reverts the changes by clearing mapPoints and adding storedPoints.
		mapComponent.getMapUtilities().getNewPrioritySideLines().clear();
		mapComponent.getMapUtilities().getAllPrioritySides().clear();
		mapComponent.getMapUtilities().getAllPriorityLines().clear();
		mapComponent.getMapUtilities().removeAllPins();
		mapComponent.getMapUtilities().removeAllLines();
		
		for (int i = 0; i < sidePoints0.size(); i++) {
			UIEdgePoint point = sidePoints0.get(i);
			mapComponent.getMapUtilities().addNewPin(point, -1);
		}
		for (int i = 0; i < sidePoints1.size(); i++) {
			UIEdgePoint point = sidePoints1.get(i);
			mapComponent.getMapUtilities().addNewPin(point, -1);
		}
 
		mapComponent.getMetaInfo().setMappingName(storedName);
		mapComponent.getMetaInfo().setMappingDescription(storedDescription);

		
		mapComponent.updateLinesAndGrid();
		mapComponent.getMainLayout().getControls().getInfoPanel().refreshMappings();
	}

	/*
	 * Called when the save button on the edit bar is clicked. It exits edit mode,
	 * sends the points to dronology, and uses stored points to display the correct
	 * waypoints on the map. 
	 */
	public void saveClick() {
		
		Vector<List<UIEdgePoint>> newWaypoints = mapComponent.getMapUtilities().getOrderedWayPoints();
				
		AreaMappingPersistenceProvider mappingPersistor = AreaMappingPersistenceProvider.getInstance();
		ByteArrayInputStream inStream;
		IAreaMapping amapping = null;

		IAreaMappingRemoteService service;
		BaseServiceProvider provider = MyUI.getProvider();

		String id = mapComponent.getMainLayout().getControls().getInfoPanel().getHighlightedAMInfoBox().getId();

		// Sends the information to dronology to be saved.
		try {
			service = (IAreaMappingRemoteService) provider.getRemoteManager()
					.getService(IAreaMappingRemoteService.class);

			byte[] information = service.requestFromServer(id);
			inStream = new ByteArrayInputStream(information);
			amapping = mappingPersistor.loadItem(inStream);

			amapping.setName(mapComponent.getMetaInfo().getMappingName());
			amapping.setDescription(mapComponent.getMetaInfo().getMappingDescription());

			// differentiate between parts
			ArrayList<EdgeLla> oldCoords0 = new ArrayList<>(amapping.getMappedPoints(0));
			for (EdgeLla cord : oldCoords0) {
				amapping.removeCoordinate(0, cord);
			}
			ArrayList<EdgeLla> oldCoords1 = new ArrayList<>(amapping.getMappedPoints(1));
			for (EdgeLla cord : oldCoords1) {
				amapping.removeCoordinate(1, cord);
			}

			// add all the new waypoints to the area mapping			
			for (int i = 0; i < newWaypoints.size(); i++) {
				for (UIEdgePoint way : newWaypoints.get(i)) {
					double lon = 0;
					double lat = 0; 
					double side = 0;
	
					try {
						lon = Double.parseDouble(way.getLongitude());
					} catch (NumberFormatException e) {
						e.printStackTrace();
					}
					try {
						lat = Double.parseDouble(way.getLatitude());
					} catch (NumberFormatException e) {
						e.printStackTrace();
					}
					try {
						side = (double)way.getSide();
					} catch (NumberFormatException e) {
						e.printStackTrace();
					}
					
					amapping.addMappedArea(i, new EdgeLla(lat, lon, side));
				}
			}
			
			// save upstream side and clear it in mapUtilities
			amapping.setUpstream(mapComponent.getMapUtilities().getUpstream());
			mapComponent.getMapUtilities().setUpstream(null);
			
			// clear old location mappings
			amapping.getLocationMappings().clear();
			
			// save priority areas
			if (mapComponent.getMapUtilities().getAllPriorityAreas().size() > 0) {
				for (int i = 0; i < mapComponent.getMapUtilities().getAllPriorityAreas().size(); i++) {
					amapping.addMappedLocation(mapComponent.getMapUtilities().getAllPriorityAreas().get(i));
				}
			}
			
			// save priority sides
			if (mapComponent.getMapUtilities().getAllPrioritySides().size() > 0) {
				for (int i = 0; i < mapComponent.getMapUtilities().getAllPrioritySides().size(); i++) {
					amapping.addMappedLocation(mapComponent.getMapUtilities().getAllPrioritySides().get(i));
				}
			}
			
			// clear old priority sides
			mapComponent.getMapUtilities().getAllPrioritySides().clear();
			mapComponent.getMapUtilities().getAllPriorityLines().clear();
			mapComponent.getMapUtilities().getNewPrioritySideLines().clear();
			
			ByteArrayOutputStream outs = new ByteArrayOutputStream();
			mappingPersistor.saveItem(amapping, outs);
			byte[] bytes = outs.toByteArray();

			service.transmitToServer(amapping.getId(), bytes);
		} catch (DronologyServiceException | RemoteException e1) {
			e1.printStackTrace();
			MyUI.setConnected(false);
		} catch (PersistenceException e1) {
			e1.printStackTrace();
		}

		// differentiate between sides
		List<EdgeLla> newCoordinatesToSave0 = amapping.getMappedPoints(0);
		List<EdgeLla> newCoordinatesToSave1 = amapping.getMappedPoints(1);
		String newMappingNameToSave = amapping.getName();
		mapComponent.getMainLayout().getWaitingWindow().showWindow(""Saving mapping..."", () -> {
			// Test if the mapping is updated in dronology
			Collection<AreaMappingInfo> mappings = mapComponent.getMainLayout().getControls().getInfoPanel()
					.getMappingsFromDronology();
			AreaMappingInfo mappingFromDronology = null;
			for (AreaMappingInfo mapping : mappings) {
				if (mapping.getId().equals(id)) {
					mappingFromDronology = mapping;
					break;
				}
			}
			
			// if the coordinate sizes are different, then it is not updated
			if (mappingFromDronology == null || mappingFromDronology.getCoordinates(0).size() != newCoordinatesToSave0.size() || 
					mappingFromDronology.getCoordinates(1).size() != newCoordinatesToSave1.size() || !newMappingNameToSave.equals(mappingFromDronology.getName())) {
				return false;
			} else {
				for (int i = 0; i < newCoordinatesToSave0.size(); ++i) {
					// if the waypoint info is different, then it is not updated
					if (!newCoordinatesToSave0.get(i).equals(mappingFromDronology.getCoordinates(0).get(i))) {
						return false;
					}
				}
				for (int i = 0; i < newCoordinatesToSave1.size(); ++i) {
					// if the waypoint info is different, then it is not updated
					if (!newCoordinatesToSave1.get(i).equals(mappingFromDronology.getCoordinates(1).get(i))) {
						return false;
					}
				}
				// otherwise, it is updated
				return true;
			}
			
		}, closeEvent -> {
			// upon closing, reset and refresh everything
			drawingSide = false;
			drawSidesButton.setCaption(""Start Side"");
			exitEditMode();
			mapComponent.getMainLayout().getControls().getInfoPanel().refreshMappings();
			mapComponent.getMainLayout().getControls().getInfoPanel().refreshSearchBar();
			mapComponent.getMainLayout()
					.switchMapping(mapComponent.getMainLayout().getControls().getInfoPanel().getMappingInfoBox(id));
		});
	}

	// remove the lines and points from an unfinished polygon
	public void cleanUnfinishedPolygon() {
		drawingArea = false;
		drawAreaButton.setCaption(""Start Area"");
		mapComponent.getMapUtilities().clearPolygonVertices();
	}
	
	// Enables editing, gets the sides, and adds the edit bar
	public void enterEditMode() {
		sidePoints0 = mapComponent.getMapUtilities().getOrderedWayPoints().get(0);
		sidePoints1 = mapComponent.getMapUtilities().getOrderedWayPoints().get(1);
		storedName = mapComponent.getMetaInfo().getMappingName();
		storedDescription = mapComponent.getMetaInfo().getMappingDescription();

		mapComponent.getMapUtilities().setPrioritiesAreEditable(true);
		mapComponent.getMapUtilities().setSidesAreEditable(false);
		this.setVisible(true);
		mapComponent.getMap().addStyleName(""fr_leaflet_map_edit_mode"");
	}

	// Disables editing, clears the points, removes the edit bar, 
	// and changes the component styles accordingly.
	public void exitEditMode() {
		sidePoints0.clear();
		sidePoints1.clear();

		storedName = """";
		storedDescription = """";

		mapComponent.getMapUtilities().setPrioritiesAreEditable(false);
		this.setVisible(false);
		mapComponent.getEditSidesController().setVisible(false);

		mapComponent.getMap().removeStyleName(""fr_leaflet_map_edit_mode"");
	}
	
	// returns true if an area is currently being drawn
	public Boolean getDrawingArea() {
		return drawingArea;
	}
	
	// returns true if a priority side is currenty being drawn
	public Boolean getDrawingSide() {
		return drawingSide;
	}
	
	public Button getDrawAreaButton() {
		return drawAreaButton;
	}
	
	public Button getDrawSideButton() {
		return drawSidesButton;
	}
	
	// ensures that a save click first finishes the area in progress
	public void setFinishAreaThenSave(Boolean finishThenSave) {
		this.finishAreaThenSave = finishThenSave;
	}

	public Boolean getFinishAreaThenSave() {
		return finishAreaThenSave;
	}
	
	// ensures that a save click first finishes the side in progress
	public void setFinishSideThenSave(Boolean finishThenSave) {
		this.finishSideThenSave = finishThenSave;
	}
	
	public Boolean getFinishSideThenSave() {
		return finishSideThenSave;
	}
	
	public AMMapComponent getMapComponent() {
		return mapComponent;
	}
	
	public Boolean getSelectingUpstream() {
		return selectingUpstream;
	}
	
	public void setSelectingUpstream(Boolean selectingUpstream) {
		this.selectingUpstream = selectingUpstream;
	}
	
	public Button getSaveButton() {
		return saveButton;
	}
}
"
IUAVRegistrationServiceInstance.java,"package edu.nd.dronology.services.instances.registration.uavs;

import edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;
import edu.nd.dronology.services.core.info.UAVRegistrationInfo;

public interface IUAVRegistrationServiceInstance extends IFileTransmitServiceInstance<UAVRegistrationInfo> {


}
"
GoalUpdateMessage.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal.message; 
import edu.nd.dronology.core.goal.AbstractGoal;

public class GoalUpdateMessage extends AbstractMessage {
    public final AbstractGoal goal;
    public GoalUpdateMessage(AbstractGoal goal) {
        this.goal = goal;
    }
}"
SetMonitoringFrequencyCommand.java,"package edu.nd.dronology.core.vehicle.commands;

/**
 * 
 * Command sent to the GCS for adjusting the monitoring frequency.<br>
 * The frequency is sent in ms.
 *  
 * @author Michael Vierhauser
 */
public class SetMonitoringFrequencyCommand extends AbstractDroneCommand implements IDroneCommand {

	private static final long serialVersionUID = 4075558216191030210L;

	public SetMonitoringFrequencyCommand(String droneId, long frequency) {
		super(droneId, CommandIds.SET_MONITOR_FREQUENCY_COMMAND);
		data.put(ATTRIBUTE_FREQUENCY, frequency);
	}

}
"
LlaCoordinate.java,"/**
 * 
 */
package edu.nd.dronology.core.coordinate;

import java.io.Serializable;

import com.google.gson.annotations.SerializedName;

/**
 * A terrestrial position defined by latitude, longitude, and altitude (LLA)
 *  
 * @author Michael Murphy
 *
 */
public class LlaCoordinate  extends AbstractPosition  implements Serializable {
 
	private static final long serialVersionUID = 1261660925357051253L;
	@SerializedName(""x"")
	private final double latitude;    
	@SerializedName(""y"")
	private final double longitude;
	@SerializedName(""z"")
	private final double altitude; 

	/**
	 * A terrestrial position defined by latitude, longitude, and altitude (LLA).
	 * 
	 * @param latitude 
	 *          the angle north of the equator in degrees (negative angles define latitudes in the southern hemisphere). Must be a value within this interval: -90 <= latitude <= 90
	 * @param longitude
	 *          the angle east of the prime meridian in degrees (negative angles define longitudes in the western hemisphere). Must be a value within this interval: -180 < longitude <= 180
	 * @param altitude
	 *          the distance above sea level in meters or more precisely the distance above the surface of the WGS-84 reference ellipsoid.
	 * @throws IllegalArgumentException
	 *           when the latitude or longitude is outside the specified range
	 */
	public LlaCoordinate(double latitude, double longitude, double altitude) {
		this.latitude = checkLatitudeRange(latitude);
		this.longitude = checkLongitudeRange(longitude);
		this.altitude = checkAltitudeRange(altitude);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof LlaCoordinate))
			return false;
		LlaCoordinate other = (LlaCoordinate) obj;
		if (Double.doubleToLongBits(altitude) != Double.doubleToLongBits(other.altitude))
			return false;
		if (Double.doubleToLongBits(latitude) != Double.doubleToLongBits(other.latitude))
			return false;
		if (Double.doubleToLongBits(longitude) != Double.doubleToLongBits(other.longitude))
			return false;
		return true;
	}

	/**
	 * The altitude
	 * 
	 * @return the distance above sea level or more precisely the distance above the surface of the WGS-84 reference ellipsoid. For this project we need this distance in meters
	 */
	public double getAltitude() {
		return altitude;
	}

	@Override
	public String toString() {
		return String.format(""LlaCoordinate(%f, %f, %f)"", latitude, longitude, altitude);
	}

	/**
	 * The latitude angle.
	 * 
	 * @return the angle north of the equator in degrees (negative angles define latitudes in the southern hemisphere).
	 */
	public double getLatitude() {
		return latitude;
	}

	/**
	 * The longitude angle
	 * 
	 * @return the angle east of the prime meridian in degrees (negative angles define longitudes in the western hemisphere)
	 */
	public double getLongitude() {
		return longitude;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		long temp;
		temp = Double.doubleToLongBits(altitude);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		temp = Double.doubleToLongBits(latitude);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		temp = Double.doubleToLongBits(longitude);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		return result;
	}

	/**
	 * @return a terrestrial position defined by an N-vector plus altitude
	 */
	@Override
	public NVector toNVector() {
		/*
		 * The formula this code is based on can be found in a journal article called: ""A Non-singular Horizontal Position Representation"" by Kenneth Gade. You can find it at https://goo.gl/iCqdCn (see
		 * equation 3 in 5.2.1.)
		 * 
		 * Note: equation 3 is unconventional as it swaps the z component with x component. This code follows the more common convention and returns z and x to their proper place
		 */
		double lat = Math.toRadians(latitude);
		double lon = Math.toRadians(longitude);
		double cosLat = Math.cos(lat);
		double x = Math.cos(lon) * cosLat;
		double y = Math.sin(lon) * cosLat;
		double z = Math.sin(lat);
		return new NVector(x, y, z, altitude);
	}

	/**
	 * @return a terrestrial position defined by an x, y, and z coordinate in an Earth centered Earth fixed reference frame.
	 */
	@Override
	public PVector toPVector() {
		return this.toNVector().toPVector();
	}

	private double checkAltitudeRange(double altitude) {
		// on wrong side of the earth...
		// if (altitude < -6378137) {
		// throw new IllegalArgumentException(""Invalid altitude"");
		// }
		return altitude;
	}

	private double checkLatitudeRange(double latitude) {
		if (Math.abs(latitude) > 90) {
			throw new IllegalArgumentException(""Invalid latitude"");
		}
		return latitude;
	}

	private double checkLongitudeRange(double longitude) {
		if (longitude > 180 || longitude <= -180) {
			throw new IllegalArgumentException(""Invalid longitude"");
		}
		return longitude;
	}

	@Override
	public LlaCoordinate toLlaCoordinate() {
		return this;
	}

}
"
TaskFactory.java,"package edu.nd.dronology.services.extensions.missionplanning.tasks;

import java.io.Serializable;
import java.util.Map;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;

public class TaskFactory {

	public static final String FLIGHTPATTERN = ""FLIGHTPATTERN"";
	public static final String ROUTE = ""ROUTE"";
	public static final String SYNC = ""SYNC"";
	public static final String WAYPOINT = ""WAYPOINT"";
	public static final String TAKEOFF = ""TAKEOFF"";
	public static final String LAND = ""LAND"";
	public static final String DELAY = ""DELAY"";

	@Deprecated
	public static IMissionTask getTask(String type, String uavid, String taskname, Object... params)
			throws MissionExecutionException {
		switch (type) {
		case FLIGHTPATTERN:
			return new PatternTask(uavid, taskname);

		case ROUTE:
			return new RouteTask(uavid, taskname);

		case SYNC:
			return new SyncTask(uavid, taskname);

		case DELAY:
			if (params.length != 1) {
				throw new MissionExecutionException(""missing duration parameter"");
			}
			double duration = Double.parseDouble(params[0].toString());
			return new DelayTask(uavid, taskname, duration);

		default:
			throw new MissionExecutionException(""Type "" + type + "" not supported"");
		}
	}

	
	
	public static IMissionTask getTask(String type, String uavid, String taskname,Map<String, Serializable> params)
			throws MissionExecutionException {
		switch (type) {
		case FLIGHTPATTERN:
			return new PatternTask(uavid, taskname);

		case ROUTE:
			return new RouteTask(uavid, taskname);

		case SYNC:
			return new SyncTask(uavid, taskname);

		case DELAY:
			if (!params.containsKey(""duration"")) {
				throw new MissionExecutionException(""missing duration parameer"");
			}
			double duration = Double.parseDouble(params.get(""duration"").toString());
			return new DelayTask(uavid, taskname, duration);

		default:
			throw new MissionExecutionException(""Type "" + type + "" not supported"");
		}
	}

	public static IMissionTask getTask(String type, String uavid, LlaCoordinate coordinate) {
		switch (type) {
		case WAYPOINT:
			return new WaypointTask(uavid, coordinate);

		case TAKEOFF:
			return new TakeoffTask(uavid, coordinate);

		case LAND:
			return new LandTask(uavid, coordinate);

		default:
			throw new IllegalArgumentException(""Type "" + type + "" not supported"");
		}
	}

}
"
IRemotable.java,"package edu.nd.dronology.services.core.api;

import java.io.Serializable;
import java.rmi.Remote;

public interface IRemotable extends Remote,Serializable {

}
"
SlowLayer.java,"package edu.nd.dronology.core.collisionavoidance.strategy.onionbackend;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand;
import edu.nd.dronology.core.collisionavoidance.strategy.StopEveryone;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.goal.WaypointGoal;
import edu.nd.dronology.core.goal.WaypointGoalSnapshot;

public class SlowLayer implements ILayer {
    private final double speed;
    private final double distance;

    public SlowLayer(double triggerDistance, double speed)  {
        this.speed = speed;
        this.distance = triggerDistance;
    }

	@Override
	public void applyAction(DroneSnapshot snapshot) {
        WaypointGoalSnapshot wpGoal = StopEveryone.findActiveWaypointGoal(snapshot.getGoals());
        if (wpGoal != null) {
            double cmdSpeed = Math.min(wpGoal.getSpeed(), this.speed);
            flyToTargetAtSpeedIfNotAlready(snapshot, wpGoal.getPosition().toLlaCoordinate(), cmdSpeed);
        }
	}

	@Override
	public boolean isTriggered(double distance) {
		return distance < this.distance;
	}

	@Override
	public double getTriggerDistance() {
		return distance;
    }
    
    private void flyToTargetAtSpeedIfNotAlready(DroneSnapshot drone, LlaCoordinate target, double speed) {
        if (drone.getCommands().size() == 1) {
            if (drone.getCommands().get(0) instanceof WaypointCommand) {
                WaypointCommand wp = (WaypointCommand) drone.getCommands().get(0);
                boolean sameDest = wp.getDestination().toLlaCoordinate().equals(target);
                boolean sameSpeed = wp.getSpeed() == speed;
                if (sameDest && sameSpeed) {
                    return;
                }
            }
        }
        drone.getCommands().clear();
        WaypointCommand cmd = new WaypointCommand(target, speed);
        drone.getCommands().add(cmd);
    }

}"
FlightZoneManager2.java,"package edu.nd.dronology.core.flightzone;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.atomic.AtomicInteger;

import com.google.common.util.concurrent.RateLimiter;

import edu.nd.dronology.core.fleet.DroneFleetListener;
import edu.nd.dronology.core.DronologyConstants;
import edu.nd.dronology.core.collisionavoidance.CollisionAvoidanceBackend;
import edu.nd.dronology.core.collisionavoidance.CollisionAvoidanceCheckTask;
import edu.nd.dronology.core.collisionavoidance.CollisionAvoidanceMessenger;
import edu.nd.dronology.core.collisionavoidance.strategy.StopEveryone;
import edu.nd.dronology.core.collisionavoidance.strategy.StopEveryoneWaypoint;
import edu.nd.dronology.core.collisionavoidance.strategy.onionbackend.SlowLayer;
import edu.nd.dronology.core.collisionavoidance.strategy.onionbackend.StopLayer;
import edu.nd.dronology.core.collisionavoidance.strategy.FollowTheLeaderNed;
import edu.nd.dronology.core.collisionavoidance.strategy.FollowTheLeaderWaypoint;
import edu.nd.dronology.core.collisionavoidance.strategy.Onion;
import edu.nd.dronology.core.collisionavoidance.strategy.PassThrough;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.exceptions.FlightZoneException;
import edu.nd.dronology.core.fleet.DroneFleetManager;
import edu.nd.dronology.core.flight.FlightPlanFactory;
import edu.nd.dronology.core.flight.IFlightDirector;
import edu.nd.dronology.core.flight.IFlightPlan;
import edu.nd.dronology.core.flight.IPlanStatusChangeListener; 
import edu.nd.dronology.core.flight.PlanPoolManager;
import edu.nd.dronology.core.flight.internal.SimpleTakeoffFlightPlan;
import edu.nd.dronology.core.flight.internal.SoloDirector;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.core.vehicle.ManagedDrone;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider; 

/**
 * 
 * Central management class for all UAV related actions. <br>
 * This includes take-off, and landing checks as well as assignment of flight plans to UAVs.
 * 
 * @author Michael Vierhauser
 *  
 */ 
public class FlightZoneManager2 implements IPlanStatusChangeListener {

	private static final ILogger LOGGER = LoggerProvider.getLogger(FlightZoneManager2.class);

	private PlanPoolManager planPoolManager;
	private DroneFleetManager droneFleet;
	private CollisionAvoidanceMessenger ca;

	private final AtomicInteger activeUAVS = new AtomicInteger(0);

	private final List<IFlightPlan> awaitingTakeOffFlights = Collections.synchronizedList(new ArrayList<>());
	private final List<IFlightPlan> awaitingLandingFlights = Collections.synchronizedList(new ArrayList<>());

	private final Timer timer = new Timer();

	/**
	 * Constructs a new FlightZoneManager.
	 * 
	 * @throws InterruptedException
	 */
	public FlightZoneManager2() throws InterruptedException {
		droneFleet = DroneFleetManager.getInstance();
		planPoolManager = PlanPoolManager.getInstance();
		planPoolManager.addPlanStatusChangeListener(this);

		// CollisionAvoidanceBackend backend = new CollisionAvoidanceBackend(new StopEveryone(10));
		// ca = backend.getMessenger();

		// timer.scheduleAtFixedRate(new AvoidanceCheckTask(), 100, DronologyConstants.FREQUENCY_COLLISION_CHECKS);
		timer.scheduleAtFixedRate(new StatusCheckTask(), 100, DronologyConstants.FREQUENCY_STATUS_CHECKS);
		// CollisionAvoidanceCheckTask caTask = new CollisionAvoidanceCheckTask(new PassThrough());
		// CollisionAvoidanceCheckTask caTask = new CollisionAvoidanceCheckTask(new StopEveryone(0));
		CollisionAvoidanceCheckTask caTask = new CollisionAvoidanceCheckTask(new StopEveryoneWaypoint(20));
		// CollisionAvoidanceCheckTask caTask = new CollisionAvoidanceCheckTask(new FollowTheLeaderNed());
		// CollisionAvoidanceCheckTask caTask = new CollisionAvoidanceCheckTask(new FollowTheLeaderWaypoint(10, 10, -10));
		// CollisionAvoidanceCheckTask caTask = new CollisionAvoidanceCheckTask(new Onion(
		// 	new StopLayer(5),
		// 	new SlowLayer(10, 0.2),
		// 	new SlowLayer(20, 0.5),
		// 	new SlowLayer(40, 2.0),
		// 	new SlowLayer(80, 4.0),
		// 	new SlowLayer(160, 6.0)
		// ));
		
		Thread caThread = new Thread(new Runnable(){
		
			@Override
			public void run() {
				try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				RateLimiter limiter = RateLimiter.create(DronologyConstants.FREQUENCY_COLLISION_CHECKS);
				while(true) {
					limiter.acquire();
					caTask.run();
				}
			}
		});
		caThread.setDaemon(true);
		caThread.start();
		// droneFleet.addDroneFleetListener(new DroneCARegistration());
	}

	private ManagedDrone tryAssignUAV() throws DroneException, FlightZoneException {
		IFlightPlan nextPlan = planPoolManager.getNextPendingPlan();
		ManagedDrone drone;
		if (nextPlan.getDesignatedDroneId() == null) {
			drone = droneFleet.getAvailableDrone();
			if (drone != null) {
				planPoolManager.assignPlan(nextPlan, drone.getDroneName());
			}
		} else {
			drone = droneFleet.getAvailableDrone(nextPlan.getDesignatedDroneId());
		}

		// TODO try to find a free uav from all plans..
		if (drone != null && (planPoolManager.getCurrentPlan(drone.getDroneName()) == null)) {
			planPoolManager.activatePlan(nextPlan, drone.getDroneName());
			if (drone.getFlightModeState().isOnGround()) {
				awaitingTakeOffFlights.add(nextPlan);
			}

			IFlightDirector flightDirectives = new SoloDirector(drone);
			flightDirectives.setWayPoints(nextPlan.getWayPoints());
			drone.getMessenger().assignFlight(flightDirectives);
			// // this needs to be moved to launch....
			nextPlan.setStatusToFlying(drone);
			if (drone.getFlightModeState().isInAir()) {
				drone.getFlightModeState().setModeToFlying();
			} else {
				drone.getFlightModeState().setModeToAwaitingTakeOffClearance();
			}
			return drone;
		}
		return null;
	}

	private class DroneCARegistration implements DroneFleetListener {
		@Override
		public void droneAdded(ManagedDrone drone) {
			drone.addObserver((observable, arg) -> {
				ca.sendManagedDroneUpdate(drone.getDroneName(), null, null, null, drone);
			});

		}

		@Override
		public void droneRemoved(ManagedDrone drone) {
			
		}
	}
	private class AvoidanceCheckTask extends TimerTask {
		@Override
		public void run() {
			ca.sendCheckTask();
		}
	}

	private class StatusCheckTask extends TimerTask {

		@Override
		public void run() {
			try {
				try {
					// checkForLandedFlights();
					checkForCompletedPlans();
				} catch (DroneException e) {
					LOGGER.error(e);
				}

				if (activeUAVS.get() == DronologyConstants.MAX_IN_AIR) {
					checkPendingForFlying();

				} else if (planPoolManager.hasPendingFlights()) {
					try {
						tryAssignUAV();
						checkPendingForFlyingWithTakeoff();
					} catch (DroneException e) {
						LOGGER.error(e);
					}

				}

				if (hasAwaitingTakeOff() && activeUAVS.get() < DronologyConstants.MAX_IN_AIR) {
					LOGGER.info(""Awaiting Takeoff:"" + getAwaitingTakeOffFlights().get(0).getFlightID());
					try {
						checkForTakeOffReadiness();
					} catch (FlightZoneException e1) {
						LOGGER.error(""Failed Check for takeoff readiness."", e1);
					}
				}
				if (hasAwaitingLanding()) {
					checkForLandingReadiness();
				}

			} catch (Throwable t) {
				LOGGER.error(t);
			}
		}

	}

	/**
	 * Checks if the next pending flight is able to takeoff. Currently takeoff occurs in order of pending list.
	 * 
	 * @param droneFleet
	 * @throws FlightZoneException
	 */
	public void checkForTakeOffReadiness() throws FlightZoneException {
		// Technical debt.
		// Checks first waiting drone each time it is called.
		if (!awaitingTakeOffFlights.isEmpty()) {
			IFlightPlan awaitingFlightPlan = awaitingTakeOffFlights.get(0);
			ManagedDrone drone = awaitingFlightPlan.getAssignedDrone();
			if (drone.permissionForTakeoff()) {
				// drone.setTargetAltitude(awaitingFlightPlan.getTakeoffAltitude());
				drone.setTargetAltitude(DronologyConstants.TAKE_OFF_ALTITUDE);
				drone.takeOff();
				activeUAVS.incrementAndGet();
				awaitingTakeOffFlights.remove(awaitingFlightPlan);
			}
		}
	}
 
	public void checkPendingForFlying() {
		for (IFlightPlan pendingPlan : planPoolManager.getPendingPlans()) {
			try {
				checkForScheduling(pendingPlan);
			} catch (DroneException | FlightZoneException e) {
				LOGGER.error(e);
			}
		}

	}

	public void checkPendingForFlyingWithTakeoff() {
		for (IFlightPlan pendingPlan : planPoolManager.getPendingPlans()) {
			try {
				checkForSchedulingWithTakeoff(pendingPlan);
			} catch (DroneException | FlightZoneException e) {
				LOGGER.error(e);
			}
		}

	}

	private void checkForScheduling(IFlightPlan pendingPlan) throws DroneException, FlightZoneException {
		ManagedDrone drone;
		if (pendingPlan.getDesignatedDroneId() == null) {
			drone = droneFleet.getAvailableDrone();
			if (drone != null) {
				planPoolManager.assignPlan(pendingPlan, drone.getDroneName());
			}
		} else {
			drone = droneFleet.getAvailableDrone(pendingPlan.getDesignatedDroneId());
		}

		if (drone == null || !drone.getFlightModeState().isInAir()
				|| (planPoolManager.getCurrentPlan(drone.getDroneName()) != null)) {
			if (drone != null) {
				droneFleet.returnDroneToAvailablePool(drone);
			}
			return;
		}

		planPoolManager.activatePlan(pendingPlan, drone.getDroneName());

		IFlightDirector flightDirectives = new SoloDirector(drone);
		flightDirectives.setWayPoints(pendingPlan.getWayPoints());
		drone.getMessenger().assignFlight(flightDirectives);
		// // this needs to be moved to launch....
		pendingPlan.setStatusToFlying(drone);
		if (drone.getFlightModeState().isInAir()) {
			drone.getFlightModeState().setModeToFlying();
		}
	}

	private void checkForSchedulingWithTakeoff(IFlightPlan pendingPlan) throws DroneException, FlightZoneException {
		ManagedDrone drone;
		if (pendingPlan.getDesignatedDroneId() == null) {
			drone = droneFleet.getAvailableDrone();
			if (drone != null) {
				planPoolManager.assignPlan(pendingPlan, drone.getDroneName());
			}
		} else {
			drone = droneFleet.getAvailableDrone(pendingPlan.getDesignatedDroneId());
		}

		if (drone == null || (planPoolManager.getCurrentPlan(drone.getDroneName()) != null)) {
			return;
		}
		planPoolManager.activatePlan(pendingPlan, drone.getDroneName());

		IFlightDirector flightDirectives = new SoloDirector(drone);
		flightDirectives.setWayPoints(pendingPlan.getWayPoints());
		drone.getMessenger().assignFlight(flightDirectives);
		// // this needs to be moved to launch....
		pendingPlan.setStatusToFlying(drone);
		if (drone.getFlightModeState().isInAir()) {
			drone.getFlightModeState().setModeToFlying();
		} else if (drone.getFlightModeState().isOnGround()) {
			awaitingTakeOffFlights.add(pendingPlan);
			drone.getFlightModeState().setModeToAwaitingTakeOffClearance();
		}

	}

	public void checkForLandingReadiness() {
		if (!awaitingLandingFlights.isEmpty() && awaitingLandingFlights.get(0).isCompleted()) {
			try {
				IFlightPlan awaitingFlightPlan = awaitingLandingFlights.get(0);
				ManagedDrone drone = droneFleet.getRegisteredDrone(awaitingFlightPlan.getDesignatedDroneId());
				LOGGER.info(""Drone '"" + drone.getDroneName() + ""' ready to land"");

				drone.land();
				// land after alt <1
				activeUAVS.decrementAndGet();
				awaitingLandingFlights.remove(0);
			} catch (FlightZoneException | DroneException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}

	}

	public boolean hasAwaitingLanding() {
		return awaitingLandingFlights.size() > 0;
	}

	public List<IFlightPlan> getAwaitingTakeOffFlights() {
		return Collections.unmodifiableList(awaitingTakeOffFlights);
	}

	public void checkForCompletedPlans() throws DroneException {
		planPoolManager.checkFormCompletedPlans();

	}

	public boolean hasAwaitingTakeOff() {
		return !awaitingTakeOffFlights.isEmpty();

	}

	public void planFlight(String uavid, String planName, List<Waypoint> waypoints) throws DroneException {
		IFlightPlan plan = FlightPlanFactory.create(uavid, planName, waypoints);
		PlanPoolManager.getInstance().addNewPlan(plan); 

	}

	public void planFlight(String planName, List<Waypoint> waypoints) throws DroneException {
 		IFlightPlan plan = FlightPlanFactory.create(planName, waypoints);
		PlanPoolManager.getInstance().addNewPlan(plan);

	}

	@Override
	public void notifyPlanChange(IFlightPlan changedPlan) {
		if (changedPlan.isCompleted()) {
			ManagedDrone drone = changedPlan.getAssignedDrone();
			if (drone != null) {
				droneFleet.returnDroneToAvailablePool(drone);
			}
		}

	}

	public void returnToHome(String uavid) throws DroneException {
		LOGGER.info(uavid + "" returning to home"");
		ManagedDrone drone = droneFleet.getRegisteredDrone(uavid);
		LlaCoordinate baseCoordinate = drone.getBaseCoordinates();

		double currentAltitude = drone.getCoordinates().getAltitude();
		LlaCoordinate homeCoordinate = new LlaCoordinate(baseCoordinate.getLatitude(), baseCoordinate.getLongitude(),
				currentAltitude);

		LlaCoordinate homeCoordinateAltitude = new LlaCoordinate(baseCoordinate.getLatitude(),
				baseCoordinate.getLongitude(), DronologyConstants.HOME_ALTITUDE);

		Waypoint wps = new Waypoint(homeCoordinate);
		Waypoint wps2 = new Waypoint(homeCoordinateAltitude);
		List<Waypoint> wpsList = new ArrayList<>();
		wpsList.add(wps);
		wpsList.add(wps2);
		IFlightPlan homePlane = FlightPlanFactory.create(uavid, ""Return to Home"", wpsList);
		try {
			planPoolManager.overridePlan(homePlane, uavid);
			if (drone.getFlightModeState().isFlying()) {
				drone.getFlightModeState().setModeToInAir();
			}
			IFlightDirector flightDirectives = new SoloDirector(drone);
			flightDirectives.setWayPoints(homePlane.getWayPoints());
			drone.getMessenger().assignFlight(flightDirectives);
			awaitingLandingFlights.add(homePlane);

			drone.getFlightModeState().setModeToFlying();
			drone.returnToHome();
			homePlane.setStatusToFlying(drone);
		} catch (FlightZoneException e) {
			LOGGER.error(e);
		}
	}

	public void cancelPendingFlights(String uavid) throws DroneException {
		PlanPoolManager.getInstance().cancelPendingPlans(uavid);
	}

	public void pauseFlight(String uavid) throws DroneException {
		ManagedDrone drone = droneFleet.getRegisteredDrone(uavid);
		if (drone.getFlightSafetyModeState().isSafetyModeHalted()) {
			return;
		}
		LOGGER.info(uavid + "" Pause current flight"");
		drone.haltInPlace(300000);
	}

	public void resumeFlight(String uavid) throws DroneException, FlightZoneException {
		LOGGER.info(uavid + "" Resume current flight"");
		ManagedDrone drone = droneFleet.getRegisteredDrone(uavid);
		drone.resumeFlight();
	}

	public void takeoff(String uavid, double altitude) throws DroneException, FlightZoneException {
		LOGGER.info(uavid + "" Takeoff"");
		ManagedDrone drone = droneFleet.getRegisteredDrone(uavid);
		PlanPoolManager.getInstance().addNewPlan(new SimpleTakeoffFlightPlan(drone, ""TAKE-OFF"", altitude));
	}

	public void emergencyStop(String uavid) throws DroneException {
		ManagedDrone drone = droneFleet.getRegisteredDrone(uavid);
		drone.emergencyStop();
	}
}
"
MockupProbe.java,"package edu.nd.dronology.monitoring.reminds;

import java.util.UUID;

import at.jku.mevss.eventdistributor.core.commandsocket.AbstractCommand;
import at.jku.mevss.eventpublisher.core.api.AbstractProbePoint;
import at.jku.mevss.eventpublisher.core.internal.Publisher;

public class MockupProbe extends AbstractProbePoint {

	// private static final String SOURCE = ""CL2-MOCKUP"";
	// private EventGeneratorTask generator;
	private int nrOfEventsPerSend;
	private String id = UUID.randomUUID().toString();
	// private String source;

	public MockupProbe(String id, String container, String source) {

		super(id, container, source);
	
	}

	@Override
	protected void doHandleCommand(AbstractCommand command) {
		// TODO Auto-generated method stub

	}

	public void run() {
		super.start();
	}

	// public void publish(long timestamp, String typeName, List<Map<String, Serializable>> data) {
	// ArrayList<TransmittableEventDataObject> list = new ArrayList<>();
	// for (Map m : data) {
	// TransmittableEventDataObject eventdata = TransmittableObjectFactory.createEventData(m);
	// list.add(eventdata);
	// }
	//
	// if (nrOfEventsPerSend == 1) {
	// TransmittableEventObject obj = TransmittableObjectFactory.createEventObject(source, timestamp, typeName, list);
	// publish(source, obj);
	// } else {
	// List<TransmittableEventObject> events = new ArrayList<>();
	// for (int i = 0; i < nrOfEventsPerSend; i++) {
	// TransmittableEventObject obj = TransmittableObjectFactory.createEventObject(source, timestamp, typeName, new ArrayList(list));
	// events.add(obj);
	// }
	// sendData(source, events.toArray(new TransmittableEventObject[0]));
	// }
	//
	// }

}
"
PreciseTimestamp.java,"package edu.nd.dronology.core.util;

import java.io.Serializable;

public class PreciseTimestamp implements Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 4565636114409035692L;
	private long nanotime;
	private long timestamp;
	private boolean isPrecise;
	static final long NUM_100NS_INTERVALS_SINCE_UUID_EPOCH = 0x01b21dd213814000L;

	public PreciseTimestamp(long timestamp, boolean isPrecise) {
		this.timestamp = timestamp;
		this.isPrecise = isPrecise;
		this.nanotime = System.nanoTime();
	}

	public long getNanotime() {
		return nanotime;
	}

	public long getTimestamp() {
		return timestamp;
	}

	public int compareTo(PreciseTimestamp that) {
		int result = Long.compare(this.getTimestamp(), that.getTimestamp());
		if (result == 0) {
			return compareTimeStamps(this.nanotime, that.nanotime);
		}
		return result;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + (int) (nanotime ^ (nanotime >>> 32));
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		PreciseTimestamp other = ((PreciseTimestamp) obj);
		if (timestamp != other.timestamp) {
			return false;
		}
		if (nanotime != other.nanotime) {
			return false;
		}
		return true;
	}

	private  int compareTimeStamps(long start, long comp) {
		if (start == comp) {
			return 0;
		}
		if (comp - start > 0) {
			return -1;
		}
		return 1;
	}

	@Override
	public String toString() {
		return ""Timestamp: "" + timestamp + "" nanotime:"" + nanotime;
	}

	public static synchronized PreciseTimestamp create(long timestamp) {
		return new PreciseTimestamp(timestamp, true);
	}

	public static synchronized PreciseTimestamp create(long timestamp, boolean isPrecise) {
		return new PreciseTimestamp(timestamp, isPrecise);
	}

	public static synchronized PreciseTimestamp create() {
		return new PreciseTimestamp(System.currentTimeMillis(), true);
	}
}"
IGoalSnapshot.java,"package edu.nd.dronology.core.goal;

/**
 * Read-only snapshot of a goal.
 */
public interface IGoalSnapshot {
    public abstract AbstractGoal.GoalState getState();
}
"
IDroneMonitoringServiceInstance.java,"package edu.nd.dronology.monitoring.service;

import java.util.Set;

import edu.nd.dronology.core.monitoring.ArtifactIdentifier;
import edu.nd.dronology.monitoring.IRemoteMonitoringMessageHandler;
import edu.nd.dronology.services.core.api.IServiceInstance;
 
public interface IDroneMonitoringServiceInstance extends IServiceInstance {

	void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler);

	Set<IRemoteMonitoringMessageHandler> getSubscribedHandler(ArtifactIdentifier identifier);

	void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler,
			ArtifactIdentifier<IRemoteMonitoringMessageHandler> identifier);

	void unsubscribeHandler(IRemoteMonitoringMessageHandler handler);

}
"
SetGimbalRotationCommand.java,"package edu.nd.dronology.core.vehicle.commands;

import edu.nd.dronology.core.CoordinateChange;
import edu.nd.dronology.core.coordinate.LlaCoordinate;

@CoordinateChange
public class SetGimbalRotationCommand extends AbstractDroneCommand implements IDroneCommand {

	/**
	 * 
	 */
	private static final long serialVersionUID = -3345889656265155714L;

	public SetGimbalRotationCommand(String uavid, LlaCoordinate coord) {
		super(uavid, """");
	}

}
"
IFlightRouteplanningRemoteService.java,"package edu.nd.dronology.services.core.remote;

import java.rmi.RemoteException;
import java.util.Collection;

import edu.nd.dronology.services.core.info.FlightRouteCategoryInfo;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
/**
 * Extends {@link IFileTransmitRemoteService} and provides methods for retrieving and saving models from the server.
 * 
 * @author Michael Vierhauser
 * 
 */
public interface IFlightRouteplanningRemoteService extends IRemoteableService, IFileTransmitRemoteService<FlightRouteInfo> {

	
 Collection<FlightRouteCategoryInfo> getFlightPathCategories() throws RemoteException;
	
}
"
PingPongCommand.java,"package edu.nd.dronology.core.vehicle.commands;

import edu.nd.dronology.core.CoordinateChange;

@CoordinateChange
public class PingPongCommand extends AbstractDroneCommand implements IDroneCommand {

	/**
	 * 
	 */
	private static final long serialVersionUID = 4365284928942347912L;

	public PingPongCommand(String uavid) {
		super(uavid, CommandIds.PING_PONG_COMMAND);
	}

}
"
LandCommand.java,"package edu.nd.dronology.core.vehicle.commands;

public class LandCommand extends AbstractDroneCommand implements IDroneCommand {

	/**
	 * 
	 */
	private static final long serialVersionUID = -8475187449318434454L;
	public static final transient String MODE_LAND = ""LAND"";

	public LandCommand(String uavid, String mode) {
		super(uavid, CommandIds.SET_MODE_COMMAND);
		data.put(ATTRIBUTE_MODE, mode);
	}

}
"
DroneAttribute.java,"package edu.nd.dronology.core.vehicle;

public class DroneAttribute<T> implements IDroneAttribute<T> {

	private final String key;
	private final T value;

	public DroneAttribute(String key, T value) {
		this.key = key;
		this.value = value;
	}

	@Override
	public String getKey() {
		return key;
	}
	@Override
	public T getValue() {
		return value;
	}

}
"
RouteCreationRunner.java,"package edu.nd.dronology.services.extensions.areamapping.unused;
//package edu.nd.dronology.services.extensions.areamapping;
//
//import java.util.Collection;
//import java.util.logging.Logger;
//
//import edu.nd.dronology.core.vehicle.IUAVProxy;
//import edu.nd.dronology.services.core.areamapping.ExportAllocationInformation;
//import edu.nd.dronology.services.core.items.IAreaMapping;
//import edu.nd.dronology.services.core.util.DronologyServiceException;
//import edu.nd.dronology.services.extensions.areamapping.creation.IRouteCreator;
//import edu.nd.dronology.services.extensions.areamapping.creation.MapRiver;
//import edu.nd.dronology.services.extensions.areamapping.selection.GeneratedRoutesInfo;
//import edu.nd.dronology.services.extensions.areamapping.selection.IRouteSelectionStrategy;
//import edu.nd.dronology.services.extensions.areamapping.selection.RouteSelectionResult;
//
//public class RouteCreationRunner {
//
//	private IRouteCreator riverMapper;
//
//	public RouteSelectionResult run(IAreaMapping mapping, Collection<IUAVProxy> uavs) {
//
////		riverMapper = new MapRiver(mapping);
////
////		IRouteSelectionStrategy selector = StrategyFactory.getSelectionStrategy();
////
////		long startGenerate = System.currentTimeMillis();
////		GeneratedRoutesInfo gInfo = new GeneratedRoutesInfo(riverMapper.generateRoutePrimitives(),
////				riverMapper.getAverageLatitude(), riverMapper.getTotalRiverSegment(), riverMapper.getBankList());
////		long endGenerate = System.currentTimeMillis();
////
////		try {
////			selector.initialize(gInfo, uavs, mapping);
////
////			long startSelect = System.currentTimeMillis();
////			RouteSelectionResult createdRouteAssignments = selector.generateAssignments();
////			long endSelect = System.currentTimeMillis();
////
////			System.out.println(""ROUTE Generation: "" + (endGenerate - startGenerate) / 1000);
////			System.out.println(""ROUTE Selection: "" + (endSelect - startSelect) / 1000);
////			System.out.println(""Specs: "");
////			ExportAllocationInformation flight = createdRouteAssignments.getEportAllocationInformation().get(0);
////			System.out.println(""Mission Score: "" + flight.getMetricStatistics().getAllocationScore());
////			System.out.println(""Coverage: "" + flight.getMetricStatistics().getAllocationCoverage());
////			System.out.println(""Equality of Tasks: "" + flight.getMetricStatistics().getEqualityOfTasks());
////			System.out.println(""Collisions: "" + flight.getMetricStatistics().getCollisions());
////			return createdRouteAssignments;
////		} catch (Throwable e) {
////			e.printStackTrace();
////			System.out.println(e);
////		}
////		/// fix throw Exception...
////		return new RouteSelectionResult();
////
////	}
//
//}
"
ExportDrone.java,"package edu.nd.dronology.services.core.areamapping;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.services.core.items.IFlightRoute;

public class ExportDrone implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = -6744520905964759937L;
	private LlaCoordinate startPoint;
	private LlaCoordinate homeLocation;
	private List<IFlightRoute> routeAssignment;
	private final String UAVId;

	public ExportDrone(String UAVId) {
		this.UAVId = UAVId;
		routeAssignment = new ArrayList<>();
	}

	public LlaCoordinate getDroneStartPoint() {
		return startPoint;
	}

	public LlaCoordinate getDroneHomeLocation() {
		return homeLocation;
	}

	public List<IFlightRoute> getDroneRouteAssignment() {
		return routeAssignment;
	}

	public void setDroneStartPoint(LlaCoordinate start) {
		startPoint = start;
	}

	public void setDroneHomeLocation(LlaCoordinate home) {
		homeLocation = home;
	}

	// public void setDroneRouteAssignment(ExportDroneRouteAssignment route) {
	// routeAssignment = route;
	// }

	public String getUAVId() {
		return UAVId;
	}
	//
	// public void setUAVId(String UAVId) {
	// this.UAVId = UAVId;
	// }

	public void addRoute(IFlightRoute route) {
		routeAssignment.add(route);

	}
}
"
DroneMonitoringServiceInstance.java,"package edu.nd.dronology.monitoring.service;

import java.util.HashSet;
import java.util.Set;

import edu.nd.dronology.core.monitoring.ArtifactIdentifier;
import edu.nd.dronology.monitoring.IRemoteMonitoringMessageHandler;
import edu.nd.dronology.monitoring.tree.ArtifactIdentifierTree;
import edu.nd.dronology.services.core.base.AbstractServiceInstance;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

@SuppressWarnings(""rawtypes"")
public class DroneMonitoringServiceInstance extends AbstractServiceInstance implements IDroneMonitoringServiceInstance {

	private static final ILogger LOGGER = LoggerProvider.getLogger(DroneMonitoringServiceInstance.class);
	private final ArtifactIdentifier ROOT_NODE = new ArtifactIdentifier(ArtifactIdentifier.ROOT);
	private final ArtifactIdentifierTree handlerTree = new ArtifactIdentifierTree(ROOT_NODE);

	public DroneMonitoringServiceInstance() {
		super(""DRONEMONITORING"");
	}

	@Override
	protected Class<?> getServiceClass() {
		return DroneMonitoringService.class;
	}

	@Override
	protected int getOrder() {
		// TODO Auto-generated method stub
		return 14;
	}

	@Override
	protected String getPropertyPath() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected void doStartService() throws Exception {

	}

	@Override
	protected void doStopService() throws Exception {
		// TODO Auto-generated method stub

	}

	@Override
	public void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler) {
		registerMonitoringMessageHandler(handler, new ArtifactIdentifier(ArtifactIdentifier.ROOT));

	}

	@Override
	public void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler,
			ArtifactIdentifier<IRemoteMonitoringMessageHandler> identifier) {
		LOGGER.info(""Attaching handler: "" + identifier.toString());
		identifier.attachItem(handler);
		handlerTree.add(identifier);

	}
	@Override
	public Set<IRemoteMonitoringMessageHandler> getSubscribedHandler(ArtifactIdentifier identifier) {
		Set<ArtifactIdentifier> related = handlerTree.getParents(identifier);
		Set<IRemoteMonitoringMessageHandler> selectedHandler = new HashSet<>();

		for (ArtifactIdentifier ident : related) {
			selectedHandler.addAll(ident.getAttachedItems());
		}

		return selectedHandler;
	}

	@Override
	public void unsubscribeHandler(IRemoteMonitoringMessageHandler handler) {
		Set<ArtifactIdentifier> related = handlerTree.getAllRelatedIdentifier(ROOT_NODE);
		ROOT_NODE.removeAttachedItem(handler);
		for (ArtifactIdentifier id : related) {
			id.removeAttachedItem(handler);
		}

	}

}
"
TakeoffCommand.java,"package edu.nd.dronology.core.vehicle.commands;

public class TakeoffCommand extends AbstractDroneCommand implements IDroneCommand {

	/**
	 * 
	 * Command sent to the GCS for taking off to a given alitude.<br>
	 * The altitude is specified in meter.
	 * 
	 * 
	 * @author Michael Vierhauser
	 */ 
	private static final long serialVersionUID = 7724695547149579828L;

	public TakeoffCommand(String droneId, double altitude) {
		super(droneId, CommandIds.TAKEOFF_COMMAND);
		data.put(ATTRIBUTE_ALTITUDE, altitude);
	}

}
"
MapRiver.java,"package edu.nd.dronology.services.extensions.areamapping.creation;

import com.google.gson.FieldNamingPolicy;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.awt.geom.*;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;

import javax.rmi.CORBA.Util;
import javax.xml.transform.Source;

import org.apache.commons.collections4.Get;

import java.rmi.Naming;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;
import edu.nd.dronology.services.core.remote.IRemoteManager;
import edu.nd.dronology.services.extensions.areamapping.internal.AdaptedCreepingLinePrimitive;
import edu.nd.dronology.services.extensions.areamapping.internal.Geometry;
import edu.nd.dronology.services.extensions.areamapping.internal.PriorityPolygonPrimitive;
import edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;
import edu.nd.dronology.services.extensions.areamapping.internal.RiverBankPrimitive;
import edu.nd.dronology.services.extensions.areamapping.internal.RiverList;
import edu.nd.dronology.services.extensions.areamapping.internal.SearchPatternStrategy;
import edu.nd.dronology.services.extensions.areamapping.internal.SourcePoints;
import edu.nd.dronology.services.extensions.areamapping.metrics.MetricsRunner;
import edu.nd.dronology.services.extensions.areamapping.model.RiverSubsegment;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive.RouteType;
import edu.nd.dronology.services.extensions.areamapping.util.Utilities;
import edu.nd.dronology.services.core.areamapping.EdgeLla;
import edu.nd.dronology.services.core.items.IAreaMapping;
import edu.nd.dronology.services.core.items.IMappedItem;
import edu.nd.dronology.services.core.items.PriorityArea;


public class MapRiver implements IRouteCreator{
	/*
	 * ASSUMPTIONS: APERATURE_WIDTH shall be measured in meters. MAX_RIVER_WIDTH
	 * assumed to be 1000 meters.
	 */
	final static double OVERLAP_FACTOR = 0.7;
	final static double APERATURE_WIDTH = 10;
	final static double APERATURE_HEIGHT = APERATURE_WIDTH*0.8;
	final static double MAX_RIVER_WIDTH = 10000;
	private static int dronesNum = 10;
	private static final String ADDRESS_SCHEME = ""rmi://%s:%s/Remote"";
	private Vector<Double> latitudeBounds;
	private List<RiverBank> bankList;
	private Path2D.Double totalRiverSegment;
	private RiverList bankMapping;
	private List<SourcePoints> priorityAreas;

	@Deprecated
	public MapRiver() {
		parseJSON();
		latitudeBounds = new Vector<>();
		preprocessRiverBanks(bankMapping);
	}
	
	public MapRiver(IAreaMapping mapping) {
		latitudeBounds = new Vector<>();
		priorityAreas = new ArrayList<>();
		bankList = Utilities.processDronologyInput(Utilities.edgeLlaToRiverBank(mapping.getMappedPoints(0)), Utilities.edgeLlaToRiverBank(mapping.getMappedPoints(1)), latitudeBounds);
		Utilities.verifyInputOrder(bankList.get(0), bankList.get(1));
		List<IMappedItem> prioritySpots = mapping.getLocationMappings();
		for(IMappedItem area : prioritySpots) {
			priorityAreas.add(Utilities.transformPriorityArea(area, getAverageLatitude()));
		}
	}
	
	@Override
	public List<RiverBank> getBankList(){
		return bankList;
	}
	
	@Override
	public Path2D.Double getTotalRiverSegment(){
		return totalRiverSegment;
	}
	
	@Override
	public double getAverageLatitude() {
		return Utilities.getAvgLatitude(latitudeBounds.get(0), latitudeBounds.get(1));
	}
	
	/**
	 * This method uses the GSON library to automatically parse the riverbank JSON file
	 */
	private void parseJSON() {
		Gson GSON = new GsonBuilder().enableComplexMapKeySerialization()
				.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).serializeSpecialFloatingPointValues()
				.create();

		try {
			// Importing JSON file
			List<String> jsonString = java.nio.file.Files.readAllLines(Paths.get(System.getProperty(""user.dir"")
					+ ""/src/edu/nd/dronology/services/extensions/areamapping/json/riverSegment1.json""));
			StringBuilder sb = new StringBuilder();
			for (String s : jsonString) {
				sb.append(s);
			}
			// Automatic parsing of JSON file with GSON library
			bankMapping = GSON.fromJson(sb.toString(), RiverList.class);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	/*private void parseAreaMapping(AreaMapping mappedRiverSegment) {
		
	}*/
	
	/**
	 * This method preprocesses the riverbank nodes to ensure that they are in the necessary order for the route generation algorithms.
	 * @param bankMapping
	 * @return river banks in the required order
	 */
	private void preprocessRiverBanks(RiverList bankMapping) {
		bankList = Utilities.makeBankVectors(bankMapping, latitudeBounds);
		Utilities.verifyInputOrder(bankList.get(0), bankList.get(1));
	}
	
	// Connect to dronology and send search routes to drones
	/**
	 * This method exports the routes to the drones
	 * @param routes
	 */
	public void exportRoutes(List<RoutePrimitive> routes) {
		for (int i = 0; i < routes.size(); i++) {
			routes.set(i, Utilities.cartesianRouteToGpsRoute(routes.get(i), Utilities.getAvgLatitude(latitudeBounds.get(0), latitudeBounds.get(1))));
		}
		try {
			IRemoteManager manager = (IRemoteManager) Naming
					.lookup(String.format(ADDRESS_SCHEME, ""127.0.0.1"", 9779));
			IFlightManagerRemoteService managerService = (IFlightManagerRemoteService) manager
					.getService(IFlightManagerRemoteService.class);
			List<List<Waypoint>> waypointList = new ArrayList<>();
			for (RoutePrimitive rlist : routes) {
				List<Waypoint> route1 = new ArrayList<>();
				for (Point2D.Double entry : rlist.getRoute()) {
					route1.add(new Waypoint(new LlaCoordinate(entry.getX(), entry.getY(), 10)));
				}
				waypointList.add(route1);
			}
			System.out.println(""route1: "" + waypointList.get(0));
			managerService.planFlight(""VRTL0"", ""TestRoute1"", waypointList.get(0));
			//managerService.planFlight(""VRTL1"", ""TestRoute2"", waypointList.get(1));
			// managerService.planFlight(""ND-3"", ""TestRoute3"", waypointList.get(2));
		} catch (Exception e) {
			e.printStackTrace();
		}	
	}
	
	
	/**
	 * This method generates a variety of route primitive options for selection.
	 * @return route primitives
	 */
	@Override
	public List<RoutePrimitive> generateRoutePrimitives() {
			// Generate search route primitives
			List<SourcePoints> sourcePoints = new ArrayList<>();
			List<RoutePrimitive> routes = new ArrayList<>();

			
			//just for getting home location for drones in metrics runner
			System.out.println(bankList.get(0).get(0) + "", "" + bankList.get(0).get(1) + "", "" + bankList.get(0).get(2));
			
			//used for the printout
			Vector<RiverSubsegment> riverVectors = new Vector<>();
			riverVectors.add(new RiverSubsegment(bankList.get(0),bankList.get(1)));
			
			sourcePoints = Geometry.generateSourcePoints(APERATURE_WIDTH, APERATURE_HEIGHT, OVERLAP_FACTOR, bankList, false);
			SearchPatternStrategy bankRoutes = new RiverBankPrimitive();
			bankRoutes.setSourcePoints(sourcePoints);
			bankRoutes.setRouteType(RouteType.RIVERBANK);
			routes.addAll(bankRoutes.generateRoutePrimitive(APERATURE_HEIGHT, OVERLAP_FACTOR));
			Utilities.debugPrintOut(riverVectors, routes);
			
			SearchPatternStrategy creepingLine = new AdaptedCreepingLinePrimitive();
			creepingLine.setSourcePoints(sourcePoints);
			creepingLine.setRouteType(RouteType.CRISSCROSS);
			routes.addAll(creepingLine.generateRoutePrimitive(APERATURE_HEIGHT, OVERLAP_FACTOR));
			
			sourcePoints = Geometry.generateSourcePoints(APERATURE_WIDTH, APERATURE_HEIGHT, OVERLAP_FACTOR, bankList, true);
			SearchPatternStrategy innerCreepingLine = new AdaptedCreepingLinePrimitive();
			innerCreepingLine.setSourcePoints(sourcePoints);
			innerCreepingLine.setRouteType(RouteType.INNER_CRISSCROSS);
			routes.addAll(innerCreepingLine.generateRoutePrimitive(APERATURE_HEIGHT, OVERLAP_FACTOR));
			
			Utilities.debugPrintOut(riverVectors, routes);
			
			totalRiverSegment = Utilities.makeTotalRiverSegment(bankList);

			//routes = Utilities.splitRoutePrimitives(routes, dronesNum, APERATURE_HEIGHT, OVERLAP_FACTOR);
			Utilities.debugPrintOut(riverVectors, routes);
			
			
			SearchPatternStrategy priorityArea = new PriorityPolygonPrimitive();
			//priorityArea.generateRoutePrimitive(APERATURE_HEIGHT, OVERLAP_FACTOR);
			priorityArea.setSourcePoints(priorityAreas);
			priorityArea.setRouteType(RouteType.PRIORITYAREA);
			routes.addAll(priorityArea.generateRoutePrimitive(APERATURE_HEIGHT, OVERLAP_FACTOR));
			for(RoutePrimitive routePrimitive : routes) {
				System.out.println(""route type: "" + routePrimitive.getRouteType());
			}
			return routes;
	}

	public static void main(String[] args) {
		MapRiver runRoute = new MapRiver();
		List<RoutePrimitive> routes = runRoute.generateRoutePrimitives();
		//MetricsRunner metricsRunner = new MetricsRunner(routes, runRoute.totalRiverSegment, runRoute.bankList, APERATURE_WIDTH, APERATURE_HEIGHT);
		long startTime = System.currentTimeMillis();
		for(int i = 0; i < 1; i ++) {
			//metricsRunner.runMetrics();
		}
		long endTime = System.currentTimeMillis();
		System.out.println(""That took "" + (endTime - startTime) + "" milliseconds"");
		//runRoute.exportRoutes(routes);
	}

}"
ManagedHashTableList.java,"package edu.nd.dronology.core.util;


import java.util.ArrayList;
import java.util.Collections;
import java.util.Hashtable;
import java.util.List;

/**
 * 
 * Managed Hashtable: stores a key and a list as value -> a query on the hashtable never returns null but an empty list. The list does not need to be created initially
 * 
 * 
 * @author Michael Vierhauser
 * @param <K>
 *          Key type.
 * @param <V>
 *          Value type.
 * 
 */
public class ManagedHashTableList<K, V> extends Hashtable<K, List<V>> {

	private static final long serialVersionUID = -5755802656779154509L;

	public synchronized boolean removeAll(K key) {
		List<V> list = super.get(key);
		if(list!=null && list.size()>0){
			list.clear();
				return true;
		}
		return false;
	}

	@Override
	public synchronized List<V> get(Object key) {
		if (super.get(key) == null) {
			return Collections.emptyList();
		} else {
			return super.get(key);
		}
	}

	public synchronized void add(K hashCode, V elem) {
		if (super.get(hashCode) == null) {
			List<V> l = new ArrayList<>();
			l.add(elem);
			super.put(hashCode, l);
		} else {
			List<V> l = super.get(hashCode);
			l.add(elem);
			// super.put(hashCode, l);
		}

	}
}
"
RemoteRMIRemoteObject.java,"package edu.nd.dronology.services.remote.rmi;

import java.rmi.RemoteException;
import java.util.List;

import edu.nd.dronology.services.core.api.ServiceInfo;
import edu.nd.dronology.services.core.remote.IRemoteManager;
import edu.nd.dronology.services.core.remote.IRemoteServiceListener;
import edu.nd.dronology.services.core.remote.IRemoteableService;
import edu.nd.dronology.services.core.remote.RemoteInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.remote.RemoteManager;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class RemoteRMIRemoteObject extends AbstractRMIRemoteObject implements IRemoteManager {

	/**
	 * 
	 */
	private static final long serialVersionUID = -3719197265334713068L;
	private static final ILogger LOGGER = LoggerProvider.getLogger(RemoteRMIRemoteObject.class);
	private static int DEFAULT_PORT = 9779;
	private static String REG_BINDING = ""Registration"";
	private static IRemoteManager instance;

	protected RemoteRMIRemoteObject(int port) throws RemoteException {
		super(port, ""Remote"");
	}

	protected RemoteRMIRemoteObject() throws RemoteException {
		this(DEFAULT_PORT);
	}

	@Override
	public void initialize() throws RemoteException {
		super.initialize();
		// registry.rebind(REG_BINDING,
		// RegistryServiceRemoteFacade.getInstance());
		// LOGGER.info("">> Binding '"" + REG_BINDING + ""' established on port "" +
		// port);
	}

	@Override
	public Object getService(Class service) throws RemoteException, DronologyServiceException {
		return RemoteManager.getInstance().getService(service);

	}

	@Override
	public void addServiceListener(IRemoteServiceListener processListener) throws RemoteException {
		RemoteManager.getInstance().addServiceListener(processListener);

	}

	@Override
	public void removeServiceListener(IRemoteServiceListener processListener) throws RemoteException {
		RemoteManager.getInstance().removeServiceListener(processListener);
	}

	@Override
	public List<ServiceInfo> getServices() throws RemoteException, DronologyServiceException {
		return RemoteManager.getInstance().getServices();
	}

	@Override
	public List<ServiceInfo> getCoreServices() throws RemoteException, DronologyServiceException {
		return RemoteManager.getInstance().getCoreServices();
	}

	@Override
	public List<ServiceInfo> getAllServices() throws RemoteException, DronologyServiceException {
		return RemoteManager.getInstance().getAllServices();
	}

	@Override
	public List<ServiceInfo> getFileServices() throws RemoteException, DronologyServiceException {
		return RemoteManager.getInstance().getFileServices();
	}

	@Override
	public void register(RemoteInfo rInfo) throws RemoteException {
		RemoteManager.getInstance().register(rInfo);

	}

	@Override
	public void unregister(RemoteInfo rInfo) throws RemoteException {
		RemoteManager.getInstance().unregister(rInfo);
	}

	@Override
	public void tearDown() throws RemoteException, DronologyServiceException {
		try {
			super.tearDown();
			registry.unbind(REG_BINDING);
			LOGGER.info("">> Binding '"" + REG_BINDING + ""' removed on port "" + port);
		} catch (Exception e) {
			throw new DronologyServiceException(e.getMessage());
		}
	}

	public static IRemoteManager getInstance(Integer port) {
		if (instance == null) {
			synchronized (RemoteRMIRemoteObject.class) {
				try {
					if (port == null) {
						instance = new RemoteRMIRemoteObject();
					} else {
						instance = new RemoteRMIRemoteObject(port);
					}
				} catch (RemoteException e) {
					LOGGER.error(e);
				}
			}
		}
		return instance;
	}

	@Override
	public void contributeService(Class service, IRemoteableService serviceInstance)
			throws RemoteException, DronologyServiceException {
		RemoteManager.getInstance().contributeService(service,serviceInstance);
		
	}

}
"
StopExecutor.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal;

import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.vehicle.IDrone;
import edu.nd.dronology.core.vehicle.ManagedDrone;

public class StopExecutor implements CommandExecutor {

    enum StopExecutionState {
        RADIOING,
        WATCHING_THE_CLOCK,
        WAITING_FOREVER,
        FINISHED;
    }

    private IDrone drone;
    StopExecutionState state = StopExecutionState.RADIOING;
    StopCommand data;
    long startTime;

    public StopExecutor(IDrone drone, StopCommand data) {
        this.drone = drone;
        this.data = data;
    }

    @Override
    public void process() {
        switch (state) {
            case RADIOING:
                radioDrone();
                break;

            case WATCHING_THE_CLOCK:
                checkClock();
                break;

            case WAITING_FOREVER:
            case FINISHED:
            default:
                // Do nothing.
                break;
        }
    }

    private void radioDrone() {
        drone.setVelocity(0.0, 0.0, 0.0);

        double waitDuration = data.getTime();
        if (waitDuration > 0.0) {
            startTime = System.nanoTime();
            state = StopExecutionState.WATCHING_THE_CLOCK;
        }
        else {
            state = StopExecutionState.WAITING_FOREVER;
        }
    }

    private void checkClock() {
        double waitDuration = data.getTime();
        long deltaNano = System.nanoTime()- startTime;
        double deltaT = deltaNano * 1.0e-9;
        if (deltaT > waitDuration) {
            state = StopExecutionState.FINISHED;
        }
    }

    @Override
    public boolean isFinished() {
        return state == StopExecutionState.FINISHED;
    }

}
"
FlightRoutePersistenceProvider.java,"package edu.nd.dronology.services.core.persistence;

import edu.nd.dronology.services.core.items.IFlightRoute;
import edu.nd.dronology.services.core.persistence.internal.FlightRouteXStreamPersistor;

/**
 * Provider implementation for {@link IFlightRoute}.<br>
 * Details see {@link AbstractItemPersistenceProvider}
 * 
 * @author Michael Vierhauser
 *  
 */
public class FlightRoutePersistenceProvider extends AbstractItemPersistenceProvider<IFlightRoute> {

	public FlightRoutePersistenceProvider() {
		super();
	}

	@Override
	protected void initPersistor() {
		PERSISTOR = new FlightRouteXStreamPersistor();

	}

	@Override
	protected void initPersistor(String type) {
		initPersistor();
	}

	public static FlightRoutePersistenceProvider getInstance() {
		return new FlightRoutePersistenceProvider();
	}

}
"
UAVRegistrationServiceInstance.java,"package edu.nd.dronology.services.instances.registration.uavs;

import java.io.File;
import java.util.Set;

import edu.nd.dronology.services.core.api.IFileChangeNotifyable;
import edu.nd.dronology.services.core.api.ServiceInfo;
import edu.nd.dronology.services.core.base.AbstractFileTransmitServiceInstance;
import edu.nd.dronology.services.core.info.UAVRegistrationInfo;
import edu.nd.dronology.services.core.items.IUAVRegistration;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import edu.nd.dronology.services.core.persistence.UAVRegistrationPersistenceProvider;
import edu.nd.dronology.services.core.util.DronologyConstants;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.core.util.ServiceIds;
import edu.nd.dronology.services.instances.DronologyElementFactory;
import edu.nd.dronology.services.supervisor.SupervisorService;
import edu.nd.dronology.util.FileUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class UAVRegistrationServiceInstance extends AbstractFileTransmitServiceInstance<UAVRegistrationInfo>
		implements IFileChangeNotifyable, IUAVRegistrationServiceInstance {

	private static final ILogger LOGGER = LoggerProvider.getLogger(UAVRegistrationServiceInstance.class);

	private static final int ORDER = 2;

	public static final String EXTENSION = DronologyConstants.EXTENSION_REGISTRATION;

	public UAVRegistrationServiceInstance() {
		super(ServiceIds.SERVICE_REGISTRATION, ""UAV Rgistration Management"", EXTENSION);
	}

	@Override
	protected Class<?> getServiceClass() {
		return UAVRegistrationServiceInstance.class;
	}

	@Override
	protected int getOrder() {
		return ORDER;
	}

	@Override
	protected String getPropertyPath() {
		return null;
	}

	@Override
	protected void doStartService() throws Exception {
		reloadItems();
	}

	@Override
	protected void doStopService() throws Exception {
		fileManager.tearDown();
	}

	@Override
	public ServiceInfo getServiceInfo() {
		ServiceInfo sInfo = super.getServiceInfo();
		sInfo.addAttribute(ServiceInfo.ATTRIBUTE_TYPE, ServiceInfo.ATTRIBUTE_FILE);
		return sInfo;
	}

	@Override
	public UAVRegistrationInfo createItem() throws DronologyServiceException {
		UAVRegistrationPersistenceProvider persistor = UAVRegistrationPersistenceProvider.getInstance();
		IUAVRegistration specification = DronologyElementFactory.createNewUAVRegistration();
		specification.setName(""New-DroneSpecification"");
		String savePath = FileUtil.concat(storagePath, specification.getId(), EXTENSION);

		try {
			persistor.saveItem(specification, savePath);
		} catch (PersistenceException e) {
			throw new DronologyServiceException(""Error when creating drone euqipment: "" + e.getMessage());
		}
		return new UAVRegistrationInfo(specification.getName(), specification.getId());
	}

	@Override
	protected String getPath() {
		String path = SupervisorService.getInstance().getDroneSpecificationLocation();
		return path;
	}

	@Override
	protected UAVRegistrationInfo fromFile(String id, File file) throws Throwable {
		IUAVRegistration atm = UAVRegistrationPersistenceProvider.getInstance().loadItem(file.toURI().toURL());
		UAVRegistrationInfo info = new UAVRegistrationInfo(atm.getName(), id);
		info.setType(atm.getType());
		return info;
	}

	@Override
	protected boolean hasProperties() {
		return false;
	}

	@Override
	public void notifyFileChange(Set<String> changed) {
		for (String s : changed) {
			updateItem(s);
		}
		super.notifyFileChange(changed);
		for (String s : changed) {
			String id = s.replace(""."" + extension, """");
			if (!itemmap.containsKey(id)) {

			}
		}
	}

	private void updateItem(String s) {
		System.out.println(""UPDATE"");

	}

}
"
SimpleSimulator.java,"package edu.nd.dronology.core.simulator.simplesimulator;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.simulator.IFlightSimulator;
import edu.nd.dronology.core.vehicle.internal.VirtualDrone;

/**
 * Simple simulator implementation containing a flight simulator and a battery simulator.
 */
public class SimpleSimulator implements IFlightSimulator {

	FlightSimulator flightSimulator; 
	DroneVoltageSimulator voltageSimulator;

	public SimpleSimulator(VirtualDrone drone) {
		flightSimulator = new FlightSimulator(drone);
		voltageSimulator = new DroneVoltageSimulator();
	}

	@Override
	public void startBatteryDrain() {
		voltageSimulator.startBatteryDrain();

	}

	@Override
	public double getVoltage() {
		return voltageSimulator.getVoltage();
	}

	@Override
	public void setFlightPath(LlaCoordinate currentPosition, LlaCoordinate targetCoordinates) {
		flightSimulator.setFlightPath(currentPosition, targetCoordinates);

	}

	@Override
	public void checkPoint() {
		voltageSimulator.checkPoint();

	}

	@Override
	public boolean isDestinationReached(double distanceMovedPerTimeStep) {
		return flightSimulator.isDestinationReached(distanceMovedPerTimeStep);
	}

	@Override
	public void stopBatteryDrain() {
		voltageSimulator.startBatteryDrain();

	}

	@Override
	public boolean move(double step) {
		return flightSimulator.move(step);
	}

}
"
SetStateFrequencyCommand.java,"package edu.nd.dronology.core.vehicle.commands;

/**
 * 
 * Command sent to the GCS for adjusting the state frequency.<br>
 * The frequency is sent in ms. 
 * 
 * @author Michael Vierhauser
 */
public class SetStateFrequencyCommand extends AbstractDroneCommand implements IDroneCommand {

	private static final long serialVersionUID = -3014662856674586911L;

	protected SetStateFrequencyCommand(String droneId, long frequency) {
		super(droneId, CommandIds.SET_STATE_FREQUENCY_COMMAND);
		data.put(ATTRIBUTE_FREQUENCY, frequency);
	}

}
"
DronologyListenerManager.java,"package edu.nd.dronology.core.status;

import java.util.ArrayList;
import java.util.List;

public class DronologyListenerManager implements IDronologyChangeListener {

	private static final DronologyListenerManager INSTANCE = new DronologyListenerManager();

	public static DronologyListenerManager getInstance() {
		return INSTANCE;
	}

	private List<IDronologyChangeListener> listeners = new ArrayList<>();

	public void addListener(IDronologyChangeListener listener) {
		listeners.add(listener);
	}

	@Override
	public void notifyUAVRemoved(String uavid) {
		for (IDronologyChangeListener l : listeners) {
			l.notifyUAVRemoved(uavid);
		}
	}

	@Override
	public void notifyGCSShutdown(String groundstationid) {
		for (IDronologyChangeListener l : listeners) {
			l.notifyGCSShutdown(groundstationid);
		}
	}

	public boolean removeListener(IDronologyChangeListener listener) {
		return listeners.remove(listener);

	}

}
"
EmergencyStopCommand.java,"package edu.nd.dronology.core.vehicle.commands;

public class EmergencyStopCommand extends AbstractDroneCommand implements IDroneCommand {

	/**
	 * 
	 * Command sent to the GCS for stopping immediately and remain hovering in place.
	 * 
	 * 
	 * @author Michael Vierhauser
	 */
	private static final long serialVersionUID = -8748426132223249721L;

	public EmergencyStopCommand(String droneId) {
		super(droneId, CommandIds.STOP_COMMAND);
	}

}
"
FlightRouteCategoryInfo.java,"package edu.nd.dronology.services.core.info;

public class FlightRouteCategoryInfo extends RemoteInfoObject {

	/**
	 * 
	 */
	private static final long serialVersionUID = -7327376857430499641L;

	public FlightRouteCategoryInfo(String name, String id) {
		super(name, id);
	}

}
"
IUAVPropertyUpdateNotifier.java,"package edu.nd.dronology.core;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;


public interface IUAVPropertyUpdateNotifier {

	void update(LlaCoordinate location, double batteryLevel, double speed, Vector3D velocity, Vector3D attitude);

	void updateCoordinates(LlaCoordinate location);

	void updateDroneState(String status);

	void updateBatteryLevel(double batteryLevel);

	void updateVelocity(double velocity);

	void updateCollisionAvoidance(LlaCoordinate position, Vector3D velocity, Vector3D attitude);

	void updateMode(String mode);

}
"
CoordinatedTakeoffPattern.java,"package edu.nd.dronology.services.extensions.missionplanning.patterns;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;
import edu.nd.dronology.services.extensions.missionplanning.plan.UAVMissionPlan;
import edu.nd.dronology.services.extensions.missionplanning.sync.SyncConstants;
import edu.nd.dronology.services.extensions.missionplanning.tasks.PatternTask;
import edu.nd.dronology.services.extensions.missionplanning.tasks.TaskFactory;
import edu.nd.dronology.services.extensions.missionplanning.v1.FullMissionPlan;
import edu.nd.dronology.util.NullUtil;

/**
 * 
 * Predefined pattern for coordinated take-off that is expanded as part of a
 * {@link PatternTask} in a {@link FullMissionPlan}.<br>
 * 
 * @author Michael Vierhauser
 *
 */
public class CoordinatedTakeoffPattern extends AbstractFlightPattern implements IFlightPattern {

	CoordinatedTakeoffPattern() {

	}

	@Override
	public void expandFlightPattern(UAVMissionPlan uavMission, LlaCoordinate currentLocation,
			LlaCoordinate targetLocation) throws MissionExecutionException {
		NullUtil.checkNull(uavMission, currentLocation, targetLocation);

		if (uavMission.getCoordinationAltitude() == 0) {
			uavMission.setCoordinationAltitude(synchPointMgr.getNextAltitude());
		}

		LlaCoordinate wp1 = new LlaCoordinate(currentLocation.getLatitude(), currentLocation.getLongitude(),
				uavMission.getCoordinationAltitude());

		LlaCoordinate wp2 = new LlaCoordinate(targetLocation.getLatitude(), targetLocation.getLongitude(),
				uavMission.getCoordinationAltitude());

		LlaCoordinate wp3 = new LlaCoordinate(targetLocation.getLatitude(), targetLocation.getLongitude(),
				targetLocation.getAltitude());

		addTask(TaskFactory.getTask(TaskFactory.TAKEOFF, uavMission.getUavID(), wp1));
		addTask(TaskFactory.getTask(TaskFactory.SYNC, uavMission.getUavID(), SyncConstants.TAKEOFF_ASC_REACHED));

		addTask(TaskFactory.getTask(TaskFactory.WAYPOINT, uavMission.getUavID(), wp2));
		addTask(TaskFactory.getTask(TaskFactory.SYNC, uavMission.getUavID(), SyncConstants.TAKEOFF_LATLON_REACHED));

		addTask(TaskFactory.getTask(TaskFactory.WAYPOINT, uavMission.getUavID(), wp3));
		addTask(TaskFactory.getTask(TaskFactory.SYNC, uavMission.getUavID(), SyncConstants.TAKEOFF_WP_REACHED));

	}

	@Override
	protected void doCreateSyncPoints() {
		addSyncPoint(""SP-TakeOff-AscentTargetReached"");
		addSyncPoint(""SP-TakeOff-LonLatReached"");
		addSyncPoint(""SP-TakeOff-FirstWayPointReached"");

	}

}
"
MappingInfo.java,"package edu.nd.dronology.services.core.info;

import java.io.Serializable;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public class MappingInfo implements Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1025240228593672234L;

	String artifactid;
	Set<String> mappedElements;
	
	public MappingInfo(String artifactid, Set<String> mappedElements){
		this.artifactid = artifactid;
		this.mappedElements = new HashSet<>(mappedElements);
	}

	public Collection<String> getMappedElementId() {
		return Collections.unmodifiableCollection(mappedElements);
	}

}
"
DefaultDroneCollector.java,"package edu.nd.dronology.core.collisionavoidance;

import edu.nd.dronology.core.vehicle.ManagedDrone;

import java.util.Collections;
import java.util.List;

public class DefaultDroneCollector implements DroneCollector {
    @Override
    public List<ManagedDrone> getManagedDrones() {
        return Collections.<ManagedDrone>emptyList();
    }
}
"
StopMessage.java,"package edu.nd.dronology.core.collisionavoidance.backendmessage;

public class StopMessage extends AbstractMessage {
}
"
SimpleChecker.java,"package edu.nd.dronology.monitoring.simplechecker.checker;

import java.rmi.RemoteException;

import edu.nd.dronology.core.monitoring.ArtifactIdentifier;
import edu.nd.dronology.monitoring.service.IDroneMonitoringRemoteService;
import edu.nd.dronology.monitoring.simplechecker.BaseServiceProvider;
import edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public class SimpleChecker {
	private static volatile SimpleChecker INSTANCE = null;
	BaseServiceProvider provider = new BaseServiceProvider();

	private SimpleChecker() {

	}

	public static SimpleChecker getInstance() {
		if (INSTANCE == null) {
			synchronized (SimpleChecker.class) {
				if (INSTANCE == null) {
					INSTANCE = new SimpleChecker();
				}
			}
		}
		return INSTANCE;
	}

	public void init() {

		try {
			System.setProperty(""java.rmi.server.hostname"", ""localhost"");

			IDroneMonitoringRemoteService sevice = (IDroneMonitoringRemoteService) provider.getRemoteManager()
					.getService(IDroneMonitoringRemoteService.class);

			// ArtifactIdentifier id = new ArtifactIdentifier(ArtifactIdentifier.ROOT,
			// ""INTERNAL"");
			ArtifactIdentifier id = new ArtifactIdentifier(ArtifactIdentifier.ROOT, ""INTERNAL"");
			ArtifactIdentifier id2 = new ArtifactIdentifier(ArtifactIdentifier.ROOT, ""GCS-DEFAULT"");

			SimpleCheckerMessageHandler handler = new SimpleCheckerMessageHandler();
			sevice.registerMonitoringMessageHandler(handler, id);
			sevice.registerMonitoringMessageHandler(handler, id2);
		} catch (Throwable e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public void emergencyStop(String uavid) {
		try {
			IFlightManagerRemoteService sevice = (IFlightManagerRemoteService) provider.getRemoteManager()
					.getService(IFlightManagerRemoteService.class);
			sevice.pauseFlight(uavid);

		} catch (RemoteException | DronologyServiceException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
"
FakePythonGroundstation.java,"package edu.nd.dronology.misc.gcs;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.text.DateFormat;
import java.util.Random;

import org.apache.commons.io.FileUtils;

import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.gstation.connector.messages.UAVHandshakeMessage;
import edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;

public class FakePythonGroundstation {

	private static Socket socket;

	final static Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()
			.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)
			.setVersion(1.0).serializeSpecialFloatingPointValues().create();

	private static String STATUS_MESSAGE;

	public static void main(String[] args) {
		try {
			int port = 1234;
			ServerSocket serverSocket = new ServerSocket(port);
			// Server is running always. This is done using this while(true) loop

			File mfile = new File(""sac"" + File.separator + ""message.txt"");
			System.out.println(mfile.getAbsolutePath());
			STATUS_MESSAGE = FileUtils.readFileToString(mfile);

			socket = serverSocket.accept();
			System.out.println(""Client has connected!"");
			InputStream is = socket.getInputStream();
			InputStreamReader isr = new InputStreamReader(is);
			BufferedReader br = new BufferedReader(isr);

			LlaCoordinate cord1 = new LlaCoordinate(41.519200, -86.239127, 0);
			LlaCoordinate cord2 = new LlaCoordinate(41.519400, -86.239527, 0);
			LlaCoordinate cord3 = new LlaCoordinate(41.519600, -86.239927, 0);

			UAVHandshakeMessage handshake = new UAVHandshakeMessage(""FAKE"", ""Drone1"");
			handshake.setHome(cord1);
			handshake.setType(UAVHandshakeMessage.MESSAGE_TYPE);
			File file = new File(""sac"" + File.separator + ""sacjson.txt"");
			System.out.println(file.getAbsolutePath());
			String sac = FileUtils.readFileToString(file);
			handshake.addPropery(""safetycase"", sac);

			UAVHandshakeMessage handshake2 = new UAVHandshakeMessage(""FAKE"",  ""Drone2"");
			handshake2.setHome(cord2);
			handshake2.setType(UAVHandshakeMessage.MESSAGE_TYPE);
			handshake2.addPropery(""safetycase"", sac);

			UAVHandshakeMessage handshake3 = new UAVHandshakeMessage(""FAKE"",  ""Drone3"");
			handshake3.setHome(cord3);
			handshake3.setType(UAVHandshakeMessage.MESSAGE_TYPE);
			handshake3.addPropery(""safetycase"", sac);

			String handshakeString = GSON.toJson(handshake);
			String handshakeString2 = GSON.toJson(handshake2);
			String handshakeString3 = GSON.toJson(handshake3);
			Thread.sleep(3000);
			OutputStream os = socket.getOutputStream();
			OutputStreamWriter osw = new OutputStreamWriter(os);
			BufferedWriter bw = new BufferedWriter(osw);
			bw.write(handshakeString);
			bw.write(""\n"");
			System.out.println(""Message sent to the client is "" + handshakeString);
			bw.flush();

			Thread.sleep(1000);
			bw.write(handshakeString2);
			bw.write(""\n"");
			System.out.println(""Message sent to the client is "" + handshakeString2);
			bw.flush();

			Thread.sleep(1000);
			bw.write(handshakeString3);
			bw.write(""\n"");
			System.out.println(""Message sent to the client is "" + handshakeString3);
			bw.flush();

			// br.readLine();
			// bw.write(""\n"");
			// bw.flush();

			Thread.sleep(500);
			int run = 0;
			while (true) {
				String toSend;
				if (run % 5 == 0) {
					toSend = sendMonitoringMessage();
				} else {
					// toSend = sendStatusMessage();
					toSend = sendMonitoringMessage();
				}

				// if flying mission mlevel > 20%
				// if retunr home blvel > 10;

				// Reading the message from the client

				// String number = br.readLine();
				// System.out.println(""Message received from client is "" + number);

				// Multiplying the number by 2 and forming the return message
				// String returnMessage;
				// try {
				// int numberInIntFormat = Integer.parseInt(number);
				// int returnValue = numberInIntFormat * 2;
				// returnMessage = String.valueOf(returnValue) + ""\n"";
				// } catch (NumberFormatException e) {
				// // Input was not a number. Sending proper message back to client.
				// returnMessage = ""Please send a proper number\n"";
				// }

				// Sending the response back to the client.
				// OutputStream os = socket.getOutputStream();
				// OutputStreamWriter osw = new OutputStreamWriter(os);
				// BufferedWriter bw = new BufferedWriter(osw);
				bw.write(toSend);
				bw.write(""\n"");
				System.out.println(""Message sent to the client is "" + toSend);
				bw.flush();
				run++;
				Thread.sleep(1000);

			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	private static String sendStatusMessage() {

		return STATUS_MESSAGE;
	}

	private static String sendMonitoringMessage() {
		UAVMonitoringMessage mm = new UAVMonitoringMessage(""Drone1"",""FAKE"",  ""Drone1"");
		Random rand = new Random();
		mm.setType(UAVMonitoringMessage.MESSAGE_TYPE);
		// mm.setuavid(""DRONE1"");

		mm.addPropery(""longitude"", ""23"");
		mm.addPropery(""velocity"", ""80"");
		mm.addPropery(""altitude"", ""50"");
		mm.addPropery(""battery_remaining_percentage"", rand.nextInt(10) + 1);
		mm.addPropery(""gps_bias"", ""1"");
		// mm.addPropery(""max_velocity"", ""60"");
		String toSend = GSON.toJson(mm);
		return toSend;
	}

}"
IPersistableItem.java,"package edu.nd.dronology.services.core.items;

public interface IPersistableItem {

	String getId();

	String getName();

	void setName(String string);
	
}
"
UAVRegistrationInfo.java,"package edu.nd.dronology.services.core.info;

public class UAVRegistrationInfo extends RemoteInfoObject {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2844123024068335148L;
	private String type = ""Default"";

	public UAVRegistrationInfo(String name, String id) {
		super(name, id);
	}

	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;

	}

}
"
GroundstationConnector.java,"package edu.nd.dronology.gstation.connector;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Socket;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import edu.nd.dronology.core.IUAVPropertyUpdateNotifier;
import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.fleet.RuntimeDroneTypes;
import edu.nd.dronology.core.monitoring.DronologyMonitoringManager;
import edu.nd.dronology.core.monitoring.MessageMarshaller;
import edu.nd.dronology.core.status.DronologyListenerManager;
import edu.nd.dronology.core.vehicle.IDroneCommandHandler;
import edu.nd.dronology.core.vehicle.commands.ConnectionResponseCommand;
import edu.nd.dronology.core.vehicle.commands.IDroneCommand;
import edu.nd.dronology.gstation.connector.connect.IncommingGroundstationConnectionServer;
import edu.nd.dronology.gstation.connector.dispatch.DispatchQueueManager;
import edu.nd.dronology.gstation.connector.dispatch.ReadDispatcher;
import edu.nd.dronology.gstation.connector.dispatch.WriteDispatcher;
import edu.nd.dronology.gstation.connector.messages.AbstractUAVMessage;
import edu.nd.dronology.gstation.connector.messages.ConnectionRequestMessage;
import edu.nd.dronology.gstation.connector.messages.UAVMessageFactory;
import edu.nd.dronology.gstation.connector.service.connector.DroneConnectorService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.util.NamedThreadFactory;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Establishes new, and handles established connections between Dronology and
 * multiple GCS.<br>
 * Creates new {@link ReadDispatcher} and {@link WriteDispatcher} threads when a
 * connection to a new GCS is established.
 * 
 * @author Michael Vierhauser
 *
 */
public class GroundstationConnector implements IDroneCommandHandler, Runnable {

	private static final ILogger LOGGER = LoggerProvider.getLogger(GroundstationConnector.class);

	protected static final ExecutorService EXECUTOR = Executors.newFixedThreadPool(10,
			new NamedThreadFactory(""Groundstation-Threads""));

	// socket for communication with python ground station
	private Socket socket;
	private final Map<String, IUAVPropertyUpdateNotifier> registeredListeners = new ConcurrentHashMap<>();
	private ReadDispatcher readDispatcher;
	private WriteDispatcher writeDispatcher;
	private String groundstationid;
	private DispatchQueueManager dispatchQueueManager;
	private boolean connected;
	private IncommingGroundstationConnectionServer server;

	public GroundstationConnector(IncommingGroundstationConnectionServer server, Socket socket) {

		this.connected = false;
		this.server = server;
		this.socket = socket;
	}

	@Override
	public void sendCommand(IDroneCommand cmd) throws DroneException {
		LOGGER.trace(groundstationid + "" Sending Command to UAV "" + cmd.toString());
		dispatchQueueManager.send(cmd);
		DronologyMonitoringManager.getInstance().publish(MessageMarshaller.createMessage(cmd));
	}

	@Override
	public void setStatusCallbackNotifier(String id, IUAVPropertyUpdateNotifier listener) throws DroneException {
		if (registeredListeners.containsKey(id)) {
			throw new DroneException(""An listener with '"" + id + ""' is already registered"");
		}
		registeredListeners.put(id, listener);
		dispatchQueueManager.createDispatchThread(id, listener);
	}

	public void tearDown() {
		try {
			readDispatcher.tearDown();
		} catch (Exception e) {
			LOGGER.error(e);
		}
		try {
			writeDispatcher.tearDown();
		} catch (Exception e) {
			LOGGER.error(e);
		}
		try {
			dispatchQueueManager.tearDown();
		} catch (Exception e) {
			LOGGER.error(e);
		}

		DronologyListenerManager.getInstance().notifyGCSShutdown(groundstationid);

	}

	@Override
	public String getHandlerId() {
		return groundstationid;
	}

	public void registerSafetyValidator(IUAVSafetyValidator validator) {
		dispatchQueueManager.registerSafetyValidator(validator);

	}

	@Override
	public void run() {
		LOGGER.info(""GroundstationConnector started"");
		BufferedReader reader;
		try {
			reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));

			String line = reader.readLine();
			AbstractUAVMessage msg = UAVMessageFactory.create(line);
			if (!(msg instanceof ConnectionRequestMessage)) {
				LOGGER.hwFatal(""Invalid Connection Request from groundstation! "" + line);
				return;
			}
			boolean connectionSuccess = false;
			try {
				DroneConnectorService.getInstance().registerConnection(this, (ConnectionRequestMessage) msg);
				this.groundstationid = msg.getGCSId();
				setupConnection();
				connectionSuccess = true;
			} catch (GroundStationException ex) {
				LOGGER.hwFatal(ex.getMessage());
			}
			BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
			ConnectionResponseCommand ackCommand = new ConnectionResponseCommand(groundstationid, connectionSuccess);
			writer.write(ackCommand.toJsonString());
			writer.write(System.lineSeparator());
			writer.flush();
		} catch (Exception e) {
			e.printStackTrace();
			LOGGER.hwFatal(""Error when establishing connection to groundstation "" + e.getMessage());
		}

	}

	private void setupConnection() {
		try {
			dispatchQueueManager = new DispatchQueueManager(groundstationid);

			readDispatcher = new ReadDispatcher(socket, dispatchQueueManager);
			writeDispatcher = new WriteDispatcher(socket, dispatchQueueManager.getOutgoingCommandQueue());
			EXECUTOR.submit(readDispatcher);
			EXECUTOR.submit(writeDispatcher);
			RuntimeDroneTypes.getInstance().registerCommandHandler(this);
			connected = true;
		} catch (Throwable e) {
			LOGGER.hwFatal(""Can't connect to Python Groundstation "" + e.getMessage());
		}
	}

	private void scheduleReconnect() {
		// TODO Auto-generated method stub

	}

}
"
IFileChangeNotifyable.java,"package edu.nd.dronology.services.core.api;

import java.util.Set;

/**
 * Interface for being notified on changing objects on the server.
 * @author Michael Vierhauser
 *
 */
public interface IFileChangeNotifyable {

/**
 * 
 * @param changed The set of changed item names.
 */
	void notifyFileChange(Set<String> changed);

}
"
IExecuteableMissionPlan.java,"package edu.nd.dronology.services.extensions.missionplanning.plan;

import edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;

public interface IExecuteableMissionPlan {

	boolean isMissionActive();

	void checkAndActivateTask() throws MissionExecutionException;

	void cancelMission();

}
"
InfoNotification.java,"package edu.nd.dronology.services.core.message;

public class InfoNotification {

	
	//message
	//severity warning/info/error
	//type ""battery""
	// infrastrucuture... 
}
"
IAreaMappingRemoteService.java,"package edu.nd.dronology.services.core.remote;

import java.rmi.RemoteException;
import java.util.Collection;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.areamapping.GeneratedMappedArea;
import edu.nd.dronology.services.core.info.AreaMappingCategoryInfo;
import edu.nd.dronology.services.core.info.AreaMappingInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

/**
 * 
 * @author Michael Vierhauser
 * 
 */
public interface IAreaMappingRemoteService extends IRemoteableService, IFileTransmitRemoteService<AreaMappingInfo> {

	Collection<AreaMappingCategoryInfo> getMappingPathCategories() throws RemoteException;

	GeneratedMappedArea generateAreaMapping(AreaMappingInfo info) throws DronologyServiceException, RemoteException;

	void executeAreaMapping(GeneratedMappedArea info) throws DronologyServiceException, RemoteException;

	GeneratedMappedArea generateAreaMapping(AreaMappingInfo info, Collection<IUAVProxy> selectedUAVs)
			throws DronologyServiceException, RemoteException;

}
"
AFMapDrones.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.vaadin.ui.Button;
import com.vaadin.ui.ComboBox;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Notification;
import com.vaadin.ui.Notification.Type;
import com.vaadin.ui.UI;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.Window;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.info.MissionInfo;
import edu.nd.dronology.services.core.info.UAVMappingInfo;
import edu.nd.dronology.services.core.items.IUAVMissionDescription;
import edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;
import edu.nd.dronology.services.core.remote.IMissionPlanningRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;
import edu.nd.dronology.ui.vaadin.start.MyUI;

/*
 * This class produces a window that is used to map the drones in a mission to the drones available in active flights
 * 
 * @author Jack Hill
 */
public class AFMapDrones extends Window {

	/**
	 * 
	 */
	private static final long serialVersionUID = -8656528814008366370L;
	
	private Map<String, String> droneMapping = new HashMap<String, String>();
	private VerticalLayout totalLayout = new VerticalLayout();
	private VerticalLayout leftMappingLayout = new VerticalLayout();
	private VerticalLayout rightMappingLayout = new VerticalLayout();
	private HorizontalLayout mappingLayout = new HorizontalLayout();
	private Collection<IUAVProxy> drones;
	private IDroneSetupRemoteService service;
	private BaseServiceProvider provider = MyUI.getProvider();
	private ArrayList<String> droneList = new ArrayList<>();
	private ArrayList<String> comboList = new ArrayList<>();
	private ArrayList<ComboBox<String>> allBoxes = new ArrayList<>();
	private UAVMappingInfo mappingInfo = new UAVMappingInfo();

	public AFMapDrones(List<IUAVMissionDescription> mission, MissionInfo missionInfo) {
		// pulls all of the active drones from dronology
		try {
			service = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);
			Collection<IUAVProxy> activeDrones = service.getActiveUAVs();
			drones = new ArrayList<>(activeDrones);
		} catch (DronologyServiceException | RemoteException e1) {
			MyUI.setConnected(false);
		}
		
		// create two lists of all the drone name, one that will stay full and one that will be used in the combo boxes and decremented
		// whenever an active UAV is assigned to a mission UAV
		for (IUAVProxy drone : drones) {
			comboList.add(drone.getID());
			droneList.add(drone.getID());
		}
		Collections.sort(comboList);
		Collections.sort(droneList);
		
		// create a combo box for each UAV in the mission
		int numDrones = mission.size();
		int index = 0;
		for (IUAVMissionDescription uav : mission) {
			ComboBox<String> uavMap = new ComboBox<>(uav.getName());
			uavMap.setItems(comboList);
			// add the pair to a mapping once an active UAV is assigned to a mission UAV
			uavMap.addValueChangeListener(e -> {
				droneMapping.put(uavMap.getCaption(), uavMap.getValue());
				uavMap.setId(uavMap.getValue());
				refreshBoxes();
			});
			
			allBoxes.add(uavMap);
			if (numDrones > 5) {
				//Notification.show(""HERE0"", Type.ERROR_MESSAGE);
				//Notification.show(""index: "" + index, Type.ERROR_MESSAGE);
				if (index < (numDrones + 1)/2) {
					leftMappingLayout.addComponent(uavMap);
				}
				else {
					rightMappingLayout.addComponent(uavMap);
					//Notification.show(""HERE1"", Type.ERROR_MESSAGE);
				}
			}
			else {
				leftMappingLayout.addComponent(uavMap);
			}
			index++;
		}
		
		// make a list with all the names of the active uavs
		ArrayList<String> activeDroneNames = new ArrayList<>();
		for (IUAVProxy drone : drones) {
			activeDroneNames.add(drone.getID());
		}
		
		// match any uav that has the same name in the mission plan and active uav panel
		for (IUAVMissionDescription uav : mission) {
			if (activeDroneNames.contains(uav.getName())) {
				droneMapping.put(uav.getName(), uav.getName());
				activeDroneNames.remove(uav.getName());
				for (ComboBox<String> comboBox : allBoxes) {
					if (comboBox.getCaption().equals(uav.getName())) {
						comboBox.setValue(uav.getName());
						comboBox.setId(uav.getName());
						refreshBoxes();
						break;
					}
				}
			}
		}
		
		Button execute = new Button(""Execute"");
		execute.addStyleName(""btn-okay"");
		Button cancel = new Button(""Cancel"");
		HorizontalLayout buttons = new HorizontalLayout();
		buttons.addComponents(cancel, execute);
		
		// execute the mission with the current mapping
		execute.addClickListener(e -> {
			// canClose will be set to false if the user has not assigned every UAV in the mission to an active UAV
			boolean canClose = true;
			for (ComboBox<String> box : allBoxes) {
				if (box.getId() == null) {
					canClose = false;
				}
			}
			if (canClose) {
				// create the map object that will be used to execute the mission
				for (Map.Entry<String, String> entry : droneMapping.entrySet()) {
				    String key = entry.getKey();
				    String value = entry.getValue();
				    mappingInfo.addAttribute(key, value);
				}
				
				// use service to execute the mission with the mapping
				IMissionPlanningRemoteService service = null;
				try {
					service = (IMissionPlanningRemoteService) provider.getRemoteManager().getService(IMissionPlanningRemoteService.class);
				}
				catch (DronologyServiceException | RemoteException e1) {
					e1.printStackTrace();
					MyUI.setConnected(false);
				}
				try {
					service.executeMissionPlan(missionInfo, mappingInfo);
				} catch (RemoteException | DronologyServiceException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
				
				
				UI.getCurrent().removeWindow(this);
			}
			else {
				Notification.show(""You must assign an active UAV for each drone in the mission."", Type.ERROR_MESSAGE);
			}
		});
		
		// cancel and return to the active flights tab
		cancel.addClickListener(e -> {
			UI.getCurrent().removeWindow(this);
		});
		
		mappingLayout.addComponent(leftMappingLayout);
		if (numDrones > 5) {
			mappingLayout.addComponent(rightMappingLayout);
		}
		totalLayout.addComponents(mappingLayout, buttons);
		
		this.setContent(totalLayout);
		this.setResizable(false);
		this.setClosable(false);
		this.setModal(true);
		this.center();
	}
	
	// only show the remaining active UAVs in the combo boxes so that a user does not try and assign one active UAV to multiple UAVs in the mission
	public void refreshBoxes() {
		for (String name : droneList) {
			if (!comboList.contains(name)) {
				comboList.add(name);
			}
		}
		Collections.sort(comboList);
		for (ComboBox<String> box : allBoxes) {
			if (box.getId() != null) {
				comboList.remove(box.getId());
			}
			box.setItems(comboList);
		}
	}
}
"
IAreaMappingServiceInstance.java,"package edu.nd.dronology.services.extensions.areamapping.instances;

import java.util.Collection;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;
import edu.nd.dronology.services.core.areamapping.GeneratedMappedArea;
import edu.nd.dronology.services.core.info.AreaMappingCategoryInfo;
import edu.nd.dronology.services.core.info.AreaMappingInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public interface IAreaMappingServiceInstance extends IFileTransmitServiceInstance<AreaMappingInfo> {

	Collection<AreaMappingCategoryInfo> getMappingPathCategories();

	AreaMappingInfo getMappingByName(String mappingName) throws DronologyServiceException;

	GeneratedMappedArea generateAreaMapping(AreaMappingInfo info) throws DronologyServiceException;

	void executeAreaMapping(GeneratedMappedArea area) throws DronologyServiceException;

	GeneratedMappedArea generateAreaMapping(AreaMappingInfo info, Collection<IUAVProxy> selectedUAVs)
			throws DronologyServiceException;

}
"
AFControlsComponent.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.VerticalLayout;

/**
 * This is the control panel framework for the Activated Flights UI
 * 
 * @author Jinghui Cheng
 */
public class AFControlsComponent extends CustomComponent {
	private static final long serialVersionUID = 1L;
	private AFInfoPanel info = new AFInfoPanel();
	public AFControlsComponent() {
		this.setWidth(""100%"");
		addStyleName(""controls_component"");
		
		VerticalLayout content = new VerticalLayout();

		content.addComponent(info);
		setCompositionRoot(content);
	}
	
	public AFInfoPanel getPanel(){
		return info;
	}
	
}
"
DronologyPersistenceUtil.java,"package edu.nd.dronology.services.core.persistence;

import com.thoughtworks.xstream.XStream;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.services.core.items.UAVRegistration;
import edu.nd.dronology.services.core.items.FlightRoute;

public class DronologyPersistenceUtil {

	private static final String ROUTE_ALIAS = ""FlightRoute"";
	private static final String COORDINATE_ALIAS = ""Coordinate"";
	private static final String SPEC_ALIAS = ""UAVSpecification"";
	private static final String WAYPOINT_ALIAS = ""Waypoint"";
	
	public static void preprocessStream(XStream xstream) {

		xstream.alias(ROUTE_ALIAS, FlightRoute.class);
		xstream.alias(COORDINATE_ALIAS, LlaCoordinate.class);
		xstream.alias(WAYPOINT_ALIAS, Waypoint.class);
		
		xstream.alias(SPEC_ALIAS, UAVRegistration.class);

	}

}
"
FollowTheLeaderWaypoint.java,"package edu.nd.dronology.core.collisionavoidance.strategy;

import java.util.ArrayList;

import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;

import edu.nd.dronology.core.collisionavoidance.CollisionAvoider;
import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.goal.WaypointGoalSnapshot;

public class FollowTheLeaderWaypoint implements CollisionAvoider {

    private final Vector3D nedOffset;
    private final double defaultSpeed = 5.0;

    public FollowTheLeaderWaypoint(Vector3D nedOffset) {
        this.nedOffset = nedOffset;
    }

    public FollowTheLeaderWaypoint(double north, double east, double down) {
        this(new Vector3D(north, east, down));
    }

	@Override
	public void avoid(ArrayList<DroneSnapshot> drones) {
        DroneSnapshot leader = FollowTheLeaderNed.findLeader(drones);
        DroneSnapshot follower = FollowTheLeaderNed.findFollower(drones);

        if (leader != null) {
            double followSpeed = defaultSpeed;
            WaypointGoalSnapshot wp = StopEveryone.findActiveWaypointGoal(leader.getGoals());
            if (wp != null) {
                StopEveryone.flyToGoalIfNotAlready(leader, wp);
                followSpeed = wp.getSpeed();
            }

            if (follower != null) {
                LlaCoordinate followerWaypoint = leader.getPosition().findLla(this.nedOffset);
                follower.getCommands().clear();
                follower.getCommands().add(new WaypointCommand(followerWaypoint, followSpeed));
            }
        } else if (follower != null) {
            WaypointGoalSnapshot wp = StopEveryone.findActiveWaypointGoal(follower.getGoals());
            if (wp != null) {
                StopEveryone.flyToGoalIfNotAlready(follower, wp);
            }   
        }
	}

}"
RemoteInfoObject.java,"package edu.nd.dronology.services.core.info;

import java.util.Map;
import java.util.Map.Entry;

import edu.nd.dronology.services.core.api.IRemoteInfoObject;

import java.util.Set;
import java.util.TreeMap;

/**
 * 
 * Abstract base class for all info objects.
 * 
 * @author Michael Vierhauser
 * 
 */
public abstract class RemoteInfoObject implements IRemoteInfoObject {

	/**
	 * 
	 */
	private static final long serialVersionUID = -1610958467030762516L;
	private String name;
	private String id;
	private Map<String, String> attributes = new TreeMap<>();

	/**
	 * @param name
	 *          The name of the object; must not be null.
	 * @param id
	 *          The unique id of the object; must not be null.
	 */
	public RemoteInfoObject(String name, String id) {
		if (name == null || id == null) {
			throw new IllegalArgumentException(""Parameter must not be null!"");
		}
		this.name = name;
		this.id = id;
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public String getId() {
		return id;
	}

	@Override
	public Set<Entry<String, String>> getAttributes() {
		return attributes.entrySet();
	}

	@Override
	public void addAttribute(String key, String value) {
		if (key == null || value == null) {
			throw new IllegalArgumentException(""Parameter must not be null!"");
		}
		attributes.put(key, value);
	}

	@Override
	public String getAttribute(String key) {
		if (key == null) {
			throw new IllegalArgumentException(""Parameter must not be null!"");
		}
		if (attributes.containsKey(key)) {
			return attributes.get(key);
		}
		return null;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		RemoteInfoObject other = (RemoteInfoObject) obj;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		return true;
	}

	
	
	@Override
	public int compareTo(IRemoteInfoObject o) {
		return this.id.compareTo(o.getId());
	}

}
"
FlightInfo.java,"package edu.nd.dronology.services.core.info;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class FlightInfo extends RemoteInfoObject {

	/**
	 * 
	 */
	private static final long serialVersionUID = 256865471183839829L;
	private FlightPlanInfo currentFlight = null;
	private List<FlightPlanInfo> pending = Collections.emptyList();
	private List<FlightPlanInfo> completed = Collections.emptyList();

	public FlightInfo(String name, String id) {
		super(name, id);
		pending = new ArrayList<>();
		completed = new ArrayList<>();
	}

	public void setCurrentFlight(FlightPlanInfo currentFlight) {
		this.currentFlight = currentFlight;
	}

	public FlightPlanInfo getCurrentFlights() {
		return currentFlight;
	}

	public List<FlightPlanInfo> getPendingFlights() {
		return pending;
	}

	public List<FlightPlanInfo> getCompletedFlights() {
		return completed;
	}

	public void addPending(FlightPlanInfo planInfo) {
		pending.add(planInfo);

	}

	public void addCompleted(FlightPlanInfo planInfo) {
		completed.add(planInfo);

	}


}
"
PhysicalDroneUpdateMessage.java,"package edu.nd.dronology.core.collisionavoidance.backendmessage;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;

public class PhysicalDroneUpdateMessage extends AbstractMessage {
    public String name;
    public final LlaCoordinate position;
    public final Vector3D velocity;
    public final Vector3D attitude;
    public PhysicalDroneUpdateMessage(String name, LlaCoordinate position, Vector3D velocity, Vector3D attitude) {
        this.name = name;
        this.position = position;
        this.velocity = velocity;
        this.attitude = attitude;
    }
}
"
RuntimeDroneTypes.java,"package edu.nd.dronology.core.fleet;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.exceptions.FlightZoneException;
import edu.nd.dronology.core.vehicle.IDroneCommandHandler;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * This is a SINGLETON class. To get an instance call getInstance() Sets the runtime mode of FlightZone either as SIMULATION or PHYSICAL The mode may only be set one time during execution. Simulation
 * uses soft drone objects. Physical uses real drones controlled using Dronekit API.
 * 
 * @author Jane Cleland-Huang 
 *
 */
public class RuntimeDroneTypes {
	private enum Mode {
		SIMULATION, PHYSICAL
	}

	private static final ILogger LOGGER = LoggerProvider.getLogger(RuntimeDroneTypes.class);

	private Mode currentMode;

	Map<String, IDroneCommandHandler> commandHandlers = new ConcurrentHashMap<>();
	private static volatile RuntimeDroneTypes INSTANCE = null;

	protected RuntimeDroneTypes() {
	}

	public static RuntimeDroneTypes getInstance() {
		if (INSTANCE == null) {
			synchronized (RuntimeDroneTypes.class) {
				if (INSTANCE == null) {
					INSTANCE = new RuntimeDroneTypes();
				}
			}
		}
		return INSTANCE;
	}

	/**
	 * Sets flightmode to SIMULATION. Does not allow the flight mode to be reset after it is initially set.
	 * 
	 * @throws FlightZoneException
	 */
	public void setVirtualEnvironment() throws FlightZoneException {
		if (currentMode == null) {
			currentMode = Mode.SIMULATION;
		} else if (currentMode == Mode.PHYSICAL) {
			// Do nothing
		} else
			throw new FlightZoneException(
					""Flight mode has already been set to PHYSICAL.  You may not reset to SIMULATION runtime."");
	}

	/**
	 * Sets flightmode to PHYSICAL Does not allow the flight mode to be reset after it is initially set.
	 * 
	 * @throws FlightZoneException
	 */
	public void setPhysicalEnvironment() throws FlightZoneException {
		if (currentMode == null) {
			currentMode = Mode.PHYSICAL;
		} else if (currentMode == Mode.SIMULATION) {
			// Do nothing
		} else
			throw new FlightZoneException(
					""Flight mode has already been set to SIMULATION.  You may not reset to PHYSICAL runtime."");
	}

	/**
	 * 
	 * @return true if in SIMULATION mode. False otherwise.
	 */
	public boolean isSimulation() {
		return currentMode == Mode.SIMULATION;
	}

	/**
	 * 
	 * @return true if in PHYSICAL mode. False otherwise.
	 */
	public boolean isPhysical() {
		return currentMode == Mode.PHYSICAL;
	}

	public void registerCommandHandler(IDroneCommandHandler commandHandler) throws DroneException {
		String handlerId = commandHandler.getHandlerId();
		LOGGER.info(""Drone command handler added '"" + handlerId + ""' - "" + commandHandler.getClass());
		if (commandHandlers.containsKey(handlerId)) {
			throw new DroneException(""CommandHandler with id '"" + handlerId + ""' already registered"");
		}
		commandHandlers.put(handlerId, commandHandler);
	}

	public IDroneCommandHandler getCommandHandler(String handlerId) throws DroneException {
		if (!commandHandlers.containsKey(handlerId)) {
			throw new DroneException(""CommandHandler with id '"" + handlerId + ""' not registered"");
		}
		return commandHandlers.get(handlerId);
	}

	public void unregisterCommandHandler(String handlerId) throws DroneException {
		// String handlerId = commandHandler.getHandlerId();
		// LOGGER.info(""Drone command handler added '"" + handlerId + ""' - "" + commandHandler.getClass());
		if (!commandHandlers.containsKey(handlerId)) {
			throw new DroneException(""CommandHandler with id '"" + handlerId + ""' not registered"");
		}
		commandHandlers.remove(handlerId);
		LOGGER.info(""Drone command handler removed '"" + handlerId);
	}
}
"
ISimulatorScenario.java,"package edu.nd.dronology.services.core.items;

import java.util.List;

public interface ISimulatorScenario extends IPersistableItem {
	
	String getDescription();

	void setDescription(String description);

	String getCategory();

	void setCategory(String category);
	
	
	List<AssignedDrone> getAssignedDrones();
	List<String> getAssignedFlightPaths();

	boolean removeAssignedDrone(String droneId);

	boolean removeAssignedPath(String pathId);

	boolean addAssignedPath(String pathId);

	boolean addAssignedDrone(String droneId);
	
}
"
PVector.java,"package edu.nd.dronology.core.coordinate;

/**
 * A position on Earth, represented as an X, Y and Z coordinate in an
 * Earth centered Earth fixed reference frame.
 *
 * The origin of this frame is at the center of mass of the Earth. The X-axis
 * points towards where the equator meets the prime meridean (latitude 0,
 * longitude 0). The Z-axis points towards the geographic north pole (latitude
 * 90, longitude undefined). The Y-axis can be derived using right hand rule and
 * points towards latitude 0, longitude 90. All units are in meters.
 * 
 * @author Michael Murphy 
 * 
 */ 
public class PVector  extends AbstractPosition {
	private double x;
	private double y;
	private double z;

	/**
	 * @param x
	 *            the distance in meters along the axis that points from the
	 *            center of mass of the Earth towards where the equator meets
	 *            the prime meridean (latitude 0, longitude 0)
	 * @param y
	 *            the distance in meters along the axis that points from the
	 *            center of mass of the Earth towards latitude 0, longitude 90
	 * @param z
	 *            the distance in meters along the axis that points from the
	 *            center of mass of the Earth towards the geographic north pole
	 *            (latitude 90, longitude undefined)
	 */
	public PVector(double x, double y, double z) {
		this.x = x;
		this.y = y;
		this.z = z;
	}

	/**
	 * @return the x
	 */
	public double getX() {
		return x;
	}

	/**
	 * @return the y
	 */
	public double getY() {
		return y;
	}

	/**
	 * @return the z
	 */
	public double getZ() {
		return z;
	}

	/**
	 * @return the n-vector plus altitude for this position
	 */
	@Override
	public NVector toNVector() {
		/*
		 * The formula this code is based on can be found in a journal article
		 * called: ""A Non-singular Horizontal Position Representation"" by
		 * Kenneth Gade. You can find it at https://goo.gl/iCqdCn (see equation
		 * 23 in Appendix B.2.)
		 * 
		 * Note: equation 23 is unconventional as it swaps the z component with
		 * x component. This code follows the more common convention and returns
		 * z and x to their proper place
		 */
		double a = NVector.SEMI_MAJOR;
		double b = NVector.SEMI_MINOR;
		double e = Math.sqrt(1 - (b * b) / (a * a));
		double q = (1.0 - e * e) / (a * a) * this.z * this.z;
		double p = (this.y * this.y + this.x * this.x) / (a * a);
		double r = (p + q - Math.pow(e, 4.0)) / 6.0;
		double s = (Math.pow(e, 4) * p * q) / (4 * Math.pow(r, 3));
		double t = Math.pow((1.0 + s + Math.sqrt(s * (2.0 + s))), 1.0 / 3.0);
		double u = r * (1.0 + t + 1.0 / t);
		double v = Math.sqrt(u * u + Math.pow(e, 4.0) * q);
		double w = e * e * (u + v - q) / (2 * v);
		double k = Math.sqrt(u + v + w * w) - w;
		double d = (k * Math.sqrt(this.y * this.y + this.x * this.x)) / (k + e * e);
		double f = 1.0 / (Math.sqrt(d * d + this.z * this.z));
		double f2 = k / (k + e * e);
		double x = f * f2 * this.x;
		double y = f * f2 * this.y;
		double z = f * this.z;
		double alt = (k + e * e - 1) / k * Math.sqrt(d * d + this.z * this.z);

		return new NVector(x, y, z, alt);
	}

	/**
	 * @return the latitude, longitude, and altitude for this position
	 */
	@Override
	public LlaCoordinate toLlaCoordinate() {
		return toNVector().toLlaCoordinate();
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		long temp;
		temp = Double.doubleToLongBits(x);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		temp = Double.doubleToLongBits(y);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		temp = Double.doubleToLongBits(z);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		return result;
	}

	@Override
	public String toString() {
		return String.format(""PVector(%f, %f, %f)"", this.x, this.y, this.z);
	}
	
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof PVector))
			return false;
		PVector other = (PVector) obj;
		if (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))
			return false;
		if (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))
			return false;
		if (Double.doubleToLongBits(z) != Double.doubleToLongBits(other.z))
			return false;
		return true;
	}

	@Override
	public PVector toPVector() {
		return this;
	}
}
"
FlightRouteInfo.java,"package edu.nd.dronology.services.core.info;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import edu.nd.dronology.core.util.Waypoint;

public class FlightRouteInfo extends RemoteInfoObject {

	/**
	 * 
	 */
	private static final long serialVersionUID = -7327376857430499641L;
	private String category;
	private List<Waypoint> waypoints = new ArrayList<>();
	private long dateCreated;
	private long dateModified;
	private double length;
	private String description;

	public FlightRouteInfo(String name, String id) {
		super(name, id);
	}

	public String getCategory() {
		return category;
	}

	public void setCategory(String category) {
		this.category = category;

	}

	public List<Waypoint> getWaypoints() {
		return Collections.unmodifiableList(waypoints);
	}

	public void setDateModified(long dateModified) {
		this.dateModified = dateModified;
	}

	public void setDateCreated(long dateCreated) {
		this.dateCreated = dateCreated;
	}

	public void addWaypoint(Waypoint waypoint) {
		waypoints.add(waypoint);
	}

	public void removeWaypoint(Waypoint waypoint) {
		waypoints.remove(waypoint);
	}

	public double getRouteLength() {
		return length;
	}

	public long getDateCreated() {
		return dateCreated;
	}

	public long getDateModified() {
		return dateModified;
	}

	public void setRouteLength(double length) {
		this.length = length;

	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

}
"
SimulatorScenarioXStreamPersistor.java,"package edu.nd.dronology.services.core.persistence.internal;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.XppDriver;

import edu.nd.dronology.services.core.items.ISimulatorScenario;
import edu.nd.dronology.services.core.persistence.DronologyPersistenceUtil;
import edu.nd.dronology.services.core.persistence.IPersistenceManager;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class SimulatorScenarioXStreamPersistor implements IPersistenceManager<ISimulatorScenario> {

	private static final XStream xstream = new XStream(new XppDriver());
	private static ILogger LOGGER = LoggerProvider.getLogger(SimulatorScenarioXStreamPersistor.class);

	static final boolean useCompression = false;

	@Override
	public ISimulatorScenario open(InputStream fin) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
	//	 xstream.setMode(XStream.);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");
		
		if (useCompression) {
			return loadedCompressedStream(fin);
		} else {
			return loadUncompressedStream(fin);
		}
	}

	private ISimulatorScenario loadUncompressedStream(InputStream fin) throws PersistenceException {
		try {
			InputStreamReader reader = new InputStreamReader(new BufferedInputStream(fin), Charset.forName(""UTF-8""));
			Object model = xstream.fromXML(reader);
			return (ISimulatorScenario) model;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (fin != null) {
					fin.close();
				}
			} catch (Exception e) {
				LOGGER.error(e);
			}
		}
	}

	private ISimulatorScenario loadedCompressedStream(InputStream fin) throws PersistenceException {
		InputStream zIn = null;
		try {
			zIn = new GZIPInputStream(fin);
			Object model = xstream.fromXML(new BufferedReader(new InputStreamReader(zIn, ""UTF-8"")));

			return (ISimulatorScenario) model;
		} catch (IOException e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (zIn != null) {
					zIn.close();
				}
				if (fin != null) {
					fin.close();
				}
			} catch (Exception e) {
				LOGGER.error(e);
			}

		}
	}
 
	@Override
	public boolean save(ISimulatorScenario o, OutputStream fout) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
		// xstream.setMode(XStream.ID_REFERENCES);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");
		// xstream.addImplicitMap(ImplMEEvent.class, ""relatedEvents"", ImplMEEvent.class, ""relatedEvents"");

		if (useCompression) {
			return saveCompressedStream(o, fout);
		} else {
			return saveUncompressedStream(o, fout);
		}

	}

	private boolean saveUncompressedStream(ISimulatorScenario o, OutputStream fout) throws PersistenceException {
		OutputStreamWriter writer = null;
		try {
			writer = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(""UTF-8""));
			xstream.toXML(o, writer);
			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (writer != null) {
					writer.close();
				}
				if (fout != null) {
					fout.close();
				}
			} catch (IOException e) {
				LOGGER.error(e);
			}
		}

	}

	private boolean saveCompressedStream(ISimulatorScenario o, OutputStream fout) throws PersistenceException {
		try {
			GZIPOutputStream zOut = new GZIPOutputStream(fout);
			xstream.toXML(o, new BufferedWriter(new OutputStreamWriter(zOut, ""UTF-8"")));

			zOut.close();
			fout.close();

			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		}
	}

}
"
AreaMappingXStreamPersistor.java,"package edu.nd.dronology.services.core.persistence.internal;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.XppDriver;

import edu.nd.dronology.services.core.items.IAreaMapping;
import edu.nd.dronology.services.core.persistence.DronologyPersistenceUtil;
import edu.nd.dronology.services.core.persistence.IPersistenceManager;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class AreaMappingXStreamPersistor implements IPersistenceManager<IAreaMapping> {

	private static final XStream xstream = new XStream(new XppDriver());
	private static ILogger LOGGER = LoggerProvider.getLogger(AreaMappingXStreamPersistor.class);

	static final boolean useCompression = false;

	@Override
	public IAreaMapping open(InputStream fin) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
	//	 xstream.setMode(XStream.);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");
		
		if (useCompression) {
			return loadedCompressedStream(fin);
		} else {
			return loadUncompressedStream(fin);
		}
	}

	private IAreaMapping loadUncompressedStream(InputStream fin) throws PersistenceException {
		try {
			InputStreamReader reader = new InputStreamReader(new BufferedInputStream(fin), Charset.forName(""UTF-8""));
			Object model = xstream.fromXML(reader);
			return (IAreaMapping) model;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (fin != null) {
					fin.close();
				}
			} catch (Exception e) {
				LOGGER.error(e);
			}
		}
	}

	private IAreaMapping loadedCompressedStream(InputStream fin) throws PersistenceException {
		InputStream zIn = null;
		try {
			zIn = new GZIPInputStream(fin);
			Object model = xstream.fromXML(new BufferedReader(new InputStreamReader(zIn, ""UTF-8"")));

			return (IAreaMapping) model;
		} catch (IOException e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (zIn != null) {
					zIn.close();
				}
				if (fin != null) {
					fin.close();
				}
			} catch (Exception e) {
				LOGGER.error(e);
			}

		}
	}
 
	@Override
	public boolean save(IAreaMapping o, OutputStream fout) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
		// xstream.setMode(XStream.ID_REFERENCES);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");
		// xstream.addImplicitMap(ImplMEEvent.class, ""relatedEvents"", ImplMEEvent.class, ""relatedEvents"");

		if (useCompression) {
			return saveCompressedStream(o, fout);
		} else {
			return saveUncompressedStream(o, fout);
		}

	}

	private boolean saveUncompressedStream(IAreaMapping o, OutputStream fout) throws PersistenceException {
		OutputStreamWriter writer = null;
		try {
			writer = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(""UTF-8""));
			xstream.toXML(o, writer);
			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (writer != null) {
					writer.close();
				}
				if (fout != null) {
					fout.close();
				}
			} catch (IOException e) {
				LOGGER.error(e);
			}
		}

	}

	private boolean saveCompressedStream(IAreaMapping o, OutputStream fout) throws PersistenceException {
		try {
			GZIPOutputStream zOut = new GZIPOutputStream(fout);
			xstream.toXML(o, new BufferedWriter(new OutputStreamWriter(zOut, ""UTF-8"")));

			zOut.close();
			fout.close();

			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		}
	}

}
"
AbstractMessage.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal.message;

public abstract class AbstractMessage {
}
"
UAVMappingInfo.java,"package edu.nd.dronology.services.core.info;

public class UAVMappingInfo extends RemoteInfoObject {

	/**
	 * 
	 */
	private static final long serialVersionUID = -2373680748153869356L;

	public UAVMappingInfo() {
		super("""", """");
	}

}
"
WriteDispatcher.java,"package edu.nd.dronology.gstation.connector.dispatch;

import java.io.IOException;
import java.io.OutputStream;
import java.net.Socket;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;

import edu.nd.dronology.core.vehicle.commands.IDroneCommand;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * Writer Thread takes items from the outbound queue and writes it to the
 * socket.
 * 
 * @author Michael Vierhauser
 *
 */
public class WriteDispatcher implements Runnable {

	private OutputStream outputStream;
	private AtomicBoolean cont = new AtomicBoolean(true);
	private BlockingQueue<IDroneCommand> outputQueue;
	private static final ILogger LOGGER = LoggerProvider.getLogger(WriteDispatcher.class);

	public WriteDispatcher(Socket pythonSocket, BlockingQueue<IDroneCommand> outputQueue) {
		try {
			outputStream = pythonSocket.getOutputStream();
			this.outputQueue = outputQueue;
			cont.set(true);
		} catch (IOException e) {
			LOGGER.error(e);
		}
	}

	@Override
	public void run() {
		LOGGER.info(""Write-Dispatcher started"");
		try {
			while (cont.get()) {
				try {
					IDroneCommand toSend = outputQueue.take();
					if (toSend instanceof MarkerObject) {
						continue;
					}
					LOGGER.hwInfo(""Sending Command to UAV -"" + toSend.toString());
					toSend.timestamp();
					outputStream.write(toSend.toJsonString().getBytes());
					outputStream.write(System.getProperty(""line.separator"").getBytes());
					outputStream.flush();
				} catch (Exception e) {
					LOGGER.error(e); 

				}
			}
			LOGGER.info(""Writer Thread shutdown"");
			try {
				outputStream.close();
			} catch (IOException e) {
				LOGGER.error(e);
			}
		} catch (Throwable t) {
			t.printStackTrace();
		}
	}

	public void tearDown() {
		cont.set(false);
		try {
			outputQueue.put(new MarkerObject());
		} catch (InterruptedException e) {
			LOGGER.error(e);
		}
	}

	public class MarkerObject implements IDroneCommand {

		/**
		 * 
		 */
		private static final long serialVersionUID = 7890483609236721982L;

		@Override
		public String toJsonString() {
			// TODO Auto-generated method stub
			return null;
		}

		@Override
		public void timestamp() {
			// TODO Auto-generated method stub

		}

		@Override
		public String getUAVId() {
			// TODO Auto-generated method stub
			return null;
		}

	}

}
"
KMLMapCreator.java,"package edu.nd.dronology.misc.kml;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

import edu.nd.dronology.gstation.connector.messages.UAVMessageFactory;
import edu.nd.dronology.gstation.connector.messages.UAVStateMessage;

public class KMLMapCreator {

	private static final String UAVID = ""IRIS2"";
	private String name = ""result"";
	private String datapath = ""d:\\kmlexport"";

	public static void main(String[] args) {

		new KMLMapCreator().createKMLFile(""d:\\log.log"");

	}

	public void createKMLFile(String logfile) {

		List<UAVStateMessage> messages = readMessages(logfile);

		String kmlString = createKMLBody(messages);

		writeToFile(kmlString);
	}

	private List<UAVStateMessage> readMessages(String logfile) {
		List<UAVStateMessage> messageList = new ArrayList<>();
		try {

			List<String> lines = Files.readAllLines(Paths.get(logfile));

			lines.forEach(l -> messageList.add(parseLine(l)));
			return messageList;
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return messageList;
	}

	private UAVStateMessage parseLine(String l) {
		int start = l.indexOf(""{"");
		String msgText = l.substring(start);

		UAVStateMessage msg;
		try {
			msg = (UAVStateMessage) UAVMessageFactory.create(msgText);
			return msg;
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;

	}

	private void writeToFile(String kmlString) {
		File testexists = new File(datapath + ""/"" + name + "".kml"");
		Writer fwriter;

		if (!testexists.exists()) {
			try {

				fwriter = new FileWriter(datapath + ""/"" + name + "".kml"");
				fwriter.write(kmlString);
				fwriter.flush();
				fwriter.close();
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}

		else {

			// schleifenvariable
			String filecontent = """";

			ArrayList<String> newoutput = new ArrayList<String>();
			;

			try {
				BufferedReader in = new BufferedReader(new FileReader(testexists));
				while ((filecontent = in.readLine()) != null)

					newoutput.add(filecontent);

			} catch (FileNotFoundException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}

			// newoutput.add(2, kmlelement);

			String rewrite = """";
			for (String s : newoutput) {
				rewrite += s;
			}

			try {
				fwriter = new FileWriter(datapath + ""/"" + name + "".kml"");
				fwriter.write(rewrite);
				fwriter.flush();
				fwriter.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}

	}

	private final String kmlstart = ""<?xml version=\""1.0\"" encoding=\""utf-8\""?>\n""
			+ ""<kml xmlns=\""http://www.opengis.net/kml/2.2\"">\n"";

	// private final String kmlelement = ""\t<Placemark>\n"" + ""\t<name>WP%num</name>\n"" + ""\t<description>"" + name
	// + ""</description>\n"" + ""\t<Point>\n"" + ""\t\t<coordinates>%lon,%lat,%alt</coordinates>\n"" + """"
	// + ""\t<gx:TimeSpan>\n""
	// + ""\t<begin>%time</begin>\n""
	// + ""\t</gx:TimeSpan>\n""
	// + ""\t</Point>\n""
	// + ""\t</Placemark>\n"";
	//

	private final String kmlelement = ""\t<Placemark>\n"" + ""\t<name>WP%num</name>\n"" + ""\t<description> %desc""
			+ ""</description>\n"" + ""\t<LineString>\n"" + ""<extrude>1</extrude>"" + ""<tessellate>1</tessellate>""
			+ ""<altitudeMode>absolute</altitudeMode>"" + ""\t\t<coordinates>%coords</coordinates>\n"" + ""</LineString>""
			+ ""\t</Placemark>\n"";

	private String createKMLBody(List<UAVStateMessage> messages) {

		String kmlend = ""</kml>"";

		ArrayList<String> content = new ArrayList<String>();
		content.add(kmlstart);

		StringBuilder cordBuilder = new StringBuilder();
		for (UAVStateMessage m : messages) {
			String res = createKMLElement(m);
			if (res != null) {
				cordBuilder.append(res);
			}
		}

		String kmElement = kmlelement.replace(""%coords"", cordBuilder.toString());
		kmElement = kmElement.replace(""%desc"", UAVID);
		content.add(kmElement);
		content.add(kmlend);

		StringBuilder sb = new StringBuilder();
		content.forEach(str -> {
			sb.append(str);
			sb.append(""\n"");
		});
		return sb.toString();

	}

	private String createKMLElement(UAVStateMessage m) {

		if (!m.getUavid().equals(UAVID)) {
			return null;
		}

		StringBuilder sb = new StringBuilder();
		sb.append(m.getLocation().getLongitude());
		sb.append("","");
		sb.append(m.getLocation().getLatitude());
		sb.append("","");
		sb.append(m.getLocation().getAltitude());
		sb.append("","");

		return sb.toString();
	}
}
"
IUAVEquipmentTypeRegistration.java,"package edu.nd.dronology.services.core.items;

import java.io.Serializable;

public interface IUAVEquipmentTypeRegistration  extends IPersistableItem {

	String getDescription();

	void setDescription(String description);

	Serializable getAttribute(String key);

	void addAttribute(String key, Serializable value);

	
}
"
PlanPool.java,"package edu.nd.dronology.core.flight;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.exceptions.FlightZoneException;
import edu.nd.dronology.core.util.DummyLockObject;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * The {@link PlanPool} manages pending, executing, and completed plans for a single UAV.
 * 
 * @author Michael Vierhauser
 *
 */
public class PlanPool {

	private static final ILogger LOGGER = LoggerProvider.getLogger(PlanPool.class);

	private DummyLockObject lockObject = new DummyLockObject();
	private final List<IFlightPlan> pendingPlans = Collections.synchronizedList(new ArrayList<>());
	private IFlightPlan currentPlan;
	private final List<IFlightPlan> completedPlans = Collections.synchronizedList(new ArrayList<>());
	private String id; 

	public PlanPool(String id) {
		this.id = id;
	}

	public void setCurrentFlightCompleted() throws DroneException {
		synchronized (lockObject) {
			if (currentPlan == null) {
				throw new DroneException(""No active Plan to complete!"");
			}
			completedPlans.add(currentPlan);
			try {
				currentPlan.setStatusToCompleted();
			} catch (FlightZoneException e) {
				LOGGER.error(e); 
			}
			LOGGER.trace(""Plan '"" + currentPlan.getFlightID() + ""' completed"");
			currentPlan = null;
		}

	}

	public void setNextPlanToCurrent() throws DroneException {
		synchronized (lockObject) { 
			if (currentPlan != null) {
				throw new DroneException(""Current plan not completed!"");
			}
			if (pendingPlans.isEmpty()) {
				throw new DroneException(""No pending flights scheduled!"");
			}
			currentPlan = pendingPlans.remove(0);

			LOGGER.info(id + "" - Plan '"" + currentPlan.getFlightID() + ""' setActive"");
		}

	}

	public void addPlan(IFlightPlan plan) { 
		LOGGER.info(""New Flight Plan '"" + plan.getFlightID() + ""' scheduled for "" + id);
		pendingPlans.add(plan);

	}

	public boolean hasPendingPlans() {
		return pendingPlans.size() > 0;
	}

	public IFlightPlan getCurrentPlan() {
		return currentPlan;
	}

	public List<IFlightPlan> getPendingPlans() {
		return Collections.unmodifiableList(new ArrayList<>(pendingPlans));
	}

	public List<IFlightPlan> getCompletedPlans() {
		return Collections.unmodifiableList(new ArrayList<>(completedPlans));
	}
 
	public void overridePlan(IFlightPlan masterPlan) {
		synchronized (this) {
			if (currentPlan != null) {
				LOGGER.info(""Current flight plan '"" + currentPlan.getFlightID() + ""' cancelled"");
				LOGGER.missionError(""Current flight plan '"" + currentPlan.getFlightID() + ""' "" + id + "" cancelled"");
				currentPlan = null;
			}
			if (pendingPlans.size() > 0) {
				LOGGER.info(pendingPlans.size() + "" Pending flight plans cancelled"");
				LOGGER.missionError(pendingPlans.size() + "" Pending flight plans for "" + id + "" cancelled"");
				pendingPlans.clear();
			}
			currentPlan = masterPlan;
		} 

	}

	public void cancelPendingPlans() { 
		if (pendingPlans.size() > 0) {
			LOGGER.info(pendingPlans.size() + "" Pending flight plans cancelled"");
			LOGGER.missionError(pendingPlans.size() + "" Pending flight plans for "" + id + "" cancelled"");
			pendingPlans.clear();
		}
	}
}
"
DronologyConstants.java,"package edu.nd.dronology.services.core.util;

import java.io.File;

public class DronologyConstants {
	public static final String DEFAULT_ROOT_FOLDER = ""D:"" + File.pathSeparator + ""dronology-workspace""
			+ File.pathSeparator;

	public static final String DRONOLOGY_ROOT_FOLDER = ""dronology-workspace"";

	public static final String EXTENSION_FLIGHTROUTE = ""froute"";
	public static final String EXTENSION_REGISTRATION = ""reg"";
	public static final String EXTENSION_TYPEREGISTRATION = ""type"";
	public static final String EXTENSION_EQUIPMENT_TYPEREGISTRATION = ""type"";

	public static final String FOLDER_FLIGHTROUTE = ""flightroute"";
	public static final String FOLDER_REGISTRATION = ""registration"";

	public static final String FOLDERN_SIM_SCENARIO = ""simscenario"";
	public static final String EXTENSION_SIM_SCENARIO = ""sim"";

	public static final String EXTENSION_MISSION = ""mission"";
	public static final String EXTENSION_AREA = ""area"";

	public static final String FOLDER_AREAMAPPING = ""areamapping"";

	public static final String FOLDER_MISSIONPLANNING = ""missionplanning"";
}
"
AbstractUAVMessage.java,"package edu.nd.dronology.gstation.connector.messages;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import edu.nd.dronology.core.monitoring.ArtifactIdentifier;
import edu.nd.dronology.core.monitoring.IMonitorableMessage;
import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;
import edu.nd.dronology.core.util.PreciseTimestamp;

public class AbstractUAVMessage<T> implements Serializable, IMonitorableMessage {

	private static final long serialVersionUID = 8470856533906132618L;

	private transient PreciseTimestamp receiveTimestamp;
	private long sendtimestamp;

	protected String type;
	protected final Map<String, T> data = new HashMap<>();
	protected String uavid;
	private String groundstationid;

	public AbstractUAVMessage(String type, String groundstationid, String uavid) {
		this.type = type;
		this.uavid = uavid;
		this.groundstationid = groundstationid;
		this.receiveTimestamp = PreciseTimestamp.create();
	}

	public void timestamp() {
		this.receiveTimestamp = PreciseTimestamp.create();

	}

	@Override
	public PreciseTimestamp getTimestamp() {
		return receiveTimestamp;
	}

	public long getSendtimestamp() {
		return sendtimestamp;
	}

	@Override
	public String toString() {
		return UAVMessageFactory.GSON.toJson(this);
	}

	@Override
	public String getUavid() {
		return uavid;
	}

	public void setUavid(String uavid) {
		this.uavid = uavid;
	}

	public void addPropery(String key, T value) {
		data.put(key, value);

	}

	public T getProperty(String key) {
		return data.get(key);

	}

	public Set<Entry<String, T>> getProperties() {
		return data.entrySet();
	}

	public void setType(String type) {
		this.type = type;

	}

	public String getGCSId() {
		return groundstationid;
	}

	@Override
	public ArtifactIdentifier<?> getIdentifier() {
		return new ArtifactIdentifier(ArtifactIdentifier.ROOT, groundstationid, uavid, getClass().getSimpleName());

	}

	@Override
	public String getData() {
		return this.toString();
	}

	@Override
	public MessageType getType() {
		return MessageType.GCS_MONITORING;
	}

}
"
DelayTask.java,"package edu.nd.dronology.services.extensions.missionplanning.tasks;

import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * Delay tasks specifying a delay after a route has been executed before commencing with the next round. 
 * 
 * @author Michael Vierhauser
 *
 */
public class DelayTask extends AbstractMissionTask {
	private static final ILogger LOGGER = LoggerProvider.getLogger(DelayTask.class);

	private final double duration;
	private long startTime;

	/**
	 * 
	 * @param uavID
	 * @param taskName
	 * @param duration
	 *          in seconds
	 */
	protected DelayTask(String uavID, String taskName, double duration) {
		super(uavID, taskName);
		this.duration = duration;
	}

	public double getDuration() {
		return duration;
	}

	public void startDelayTask() {
		LOGGER.info(""Delay started for UAV '"" + getUAVId() + ""' duration: "" + duration);
		startTime = System.currentTimeMillis();
	}

	public boolean isFinished() {
		boolean finished = System.currentTimeMillis() - startTime > duration * 1000;

		if (finished) {
			LOGGER.info(""Delay finished for UAV '"" + getUAVId() + ""'"");
		}
		return finished;

	}

}"
AFInfoBox.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import org.vaadin.teemu.switchui.Switch;

import com.vaadin.server.Resource;
import com.vaadin.ui.Alignment;
import com.vaadin.ui.Button;
import com.vaadin.ui.CheckBox;
import com.vaadin.ui.Component;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.GridLayout;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Image;
import com.vaadin.ui.Label;
import com.vaadin.ui.Notification;
import com.vaadin.ui.UI;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.themes.ValoTheme;

import edu.nd.dronology.core.vehicle.DroneFlightStateManager.FlightMode;
import edu.nd.dronology.ui.vaadin.connector.DronologyActionExecutor;
import edu.nd.dronology.ui.vaadin.flightroutes.windows.TakeoffAltitudeWindow;
import edu.nd.dronology.ui.vaadin.utils.ImageProvider;
import edu.nd.dronology.ui.vaadin.utils.StyleConstants; 

/**
 * This is the box in the side panel that contains a UAV's information
 * 
 * @author Patrick Falvey
 *
 */

public class AFInfoBox extends CustomComponent {
	private static final long serialVersionUID = -8541147696474050819L;

	private boolean visible = false;
	private boolean isChecked;
	private boolean hoverInPlace;
	private boolean checkClicked = false;

	private CheckBox check = new CheckBox();
	private Label statusInfo1 = new Label();
	private Label statusInfo2 = new Label();
	private Label statusInfo3 = new Label();
	private Label health = new Label();
	private Label locationInfo1 = new Label();
	// private Label locationInfo2 = new Label();
	// private Label locationInfo3 = new Label();
	private Label locationInfo4 = new Label();
	private Switch hoverSwitch = new Switch();
	private Button returnToHome = new Button("""");
	private Button takeoff = new Button("""");

	private Resource takeoffIcon = ImageProvider.getTaekoffResource();
	private Resource rtlIcon = ImageProvider.getRTLResource();
	private Resource assignRouteIcon = ImageProvider.getAssignRouteResource();
	private Resource resendIcon = ImageProvider.getResendCommandResource();
	private Resource okIcon = ImageProvider.getStatusOKResource();
	private Resource user_controlled = ImageProvider.getStatusUsercontrolledResource();

	private Button assignNewRoute = new Button("""");
	private Button resendCommand = new Button("""");

	private VerticalLayout mainContent = new VerticalLayout();
	private HorizontalLayout topContent = new HorizontalLayout();
	private VerticalLayout middleContent = new VerticalLayout();
	private HorizontalLayout bottomContent = new HorizontalLayout();
	private UAVStatusWrapper uavStatus;

	public AFInfoBox(boolean isChecked, UAVStatusWrapper uavStatus, boolean hoverInPlace) {
		this.uavStatus = uavStatus;
		this.isChecked = isChecked;
		this.hoverInPlace = hoverInPlace;
	}

	public void createContents() {
		this.addStyleName(StyleConstants.INFO_BOX);
		this.addStyleName(StyleConstants.AF_INFO_BOX);

		topContent.addStyleName(StyleConstants.AF_BOX_INFO_TOP_CONTENT);
		middleContent.addStyleName(StyleConstants.AF_BOX_INFO_DETAIL_CONTENT);
		bottomContent.addStyleName(StyleConstants.AF_BOX_INFO_BOTTOM_CONTENT);

		createTopComponent();

		middleContent.addComponents(locationInfo1, locationInfo4);

		createBottomComponent();

		mainContent.addComponents(topContent, middleContent, bottomContent);
		mainContent.setSizeUndefined();
		mainContent.setSpacing(false);

		middleContent.setVisible(visible);
		bottomContent.setVisible(visible);

		setCompositionRoot(mainContent);

		returnToHome.setHeight(""30px"");
		assignNewRoute.setHeight(""30px"");
		takeoff.setHeight(""30px"");
		resendCommand.setHeight(""30px"");

		takeoff.setWidth(""55px""); 
		returnToHome.setWidth(""55px"");
		assignNewRoute.setWidth(""55px"");
		resendCommand.setWidth(""55px"");

		takeoff.setDescription(""Take-off to target altitude"");
		resendCommand.setDescription(""Resend previous command"");
		returnToHome.setDescription(""Cancel all routes and return to home imediatelly"");
		assignNewRoute.setDescription(""Assign a new flight route"");

		takeoff.setStyleName(ValoTheme.BUTTON_ICON_ONLY);
		
		takeoff.setIcon(takeoffIcon);
		returnToHome.setIcon(rtlIcon);
		assignNewRoute.setIcon(assignRouteIcon);
		resendCommand.setIcon(resendIcon);
		addListener();
		update(uavStatus);
	}

	private void createBottomComponent() {
		GridLayout bottomButtons = new GridLayout(2, 2);
		bottomButtons.setWidth(""150px"");
		bottomButtons.setHeight(""70px"");
		VerticalLayout bottomSwitch = new VerticalLayout();

		hoverSwitch.setValue(this.hoverInPlace);

		Label caption = new Label(""Hover in Place"");
		bottomSwitch.addComponents(caption, hoverSwitch);

		bottomButtons.addComponents(takeoff, returnToHome, assignNewRoute, resendCommand);
		bottomContent.addComponents(bottomSwitch, bottomButtons);

	}

	private void createTopComponent() {
		VerticalLayout statusContent = new VerticalLayout();
		check.setValue(this.isChecked);
		Image droneImage = ImageProvider.getDefaultUAVImage();

		statusInfo1.addStyleName(""info_box_name"");
		statusInfo1.addStyleName(ValoTheme.LABEL_BOLD);

		statusContent.addComponents(statusInfo1, statusInfo2, statusInfo3);
		statusContent.setSpacing(false);
		// health.setCaptionAsHtml(true);
		health.setIcon(okIcon);

		topContent.addComponents(check, droneImage, statusContent, health);
		topContent.setSpacing(false);
		topContent.setComponentAlignment(check, Alignment.TOP_LEFT);
		topContent.setComponentAlignment(droneImage, Alignment.TOP_LEFT);
		topContent.setComponentAlignment(statusContent, Alignment.TOP_LEFT);
		topContent.setComponentAlignment(health, Alignment.TOP_RIGHT);

	}

	private void addListener() {
		returnToHome.addClickListener(e -> {
			DronologyActionExecutor.returnHome(null, uavStatus);
		});

		takeoff.addClickListener(e -> {
			this.takeOff();
		});

		assignNewRoute.addClickListener(assignEvent -> { // this opens the assign routes UI
			DronologyActionExecutor.assignRouteToUAV(uavStatus);
		});
		
		resendCommand.addClickListener(assignEvent -> { // this opens the assign routes UI
			DronologyActionExecutor.resendCommand(uavStatus);
		});

		hoverSwitch.addValueChangeListener(e -> {
			this.setHoverInPlace(this.hoverSwitch.getValue());
		});

		// this listener assists with whether a box is focused or only checked
		topContent.addLayoutClickListener(e -> {
			Component child = e.getChildComponent();
			if (child != null && child.getClass() == CheckBox.class) {
				checkClicked = true;
			} else {
				checkClicked = false;
			}
		});

		topContent.addLayoutClickListener(e -> {
			Component child = e.getChildComponent();
			if (child == null || !child.getClass().getCanonicalName().equals(""com.vaadin.ui.CheckBox"")) {
				setBoxVisible(visible);
			}
		});

	}

	private void takeOff() {
		if (!this.uavStatus.getStatus().equals(""ON_GROUND"")) {
			Notification.show(uavStatus.getName() + "" is already in the air."");
			return;
		}
		TakeoffAltitudeWindow takeoffAltitudeWindow = new TakeoffAltitudeWindow(uavStatus.getName());

		UI.getCurrent().addWindow(takeoffAltitudeWindow);
	}

	/**
	 * default constructor
	 */
	public AFInfoBox() {
		// this(false, ""NAME/ID of UAV"", ""Status"", 0, ""green"", 0, 0, 0, 0, false);
	}

	public void setIsChecked(boolean isChecked) {
		this.isChecked = isChecked;
		check.setValue(this.isChecked);
	}

	public boolean getIsChecked() {
		this.isChecked = check.getValue();
		return this.isChecked;
	}

	public CheckBox getCheckBox() {
		return this.check;
	}

	public void setHoverInPlace(boolean hoverInPlace) {
		this.hoverInPlace = hoverInPlace;
		hoverSwitch.setValue(this.hoverInPlace);
		// if (this.hoverInPlace) {
		// this.status = ""Hovering"";
		// statusInfo2.setValue(""Status: "");
		// } else {
		// this.status = """";
		// statusInfo2.setValue(""Status: "");
		// }
	}

	public boolean getHoverInPlace() {
		return this.hoverInPlace;
	}

	public Switch getHoverSwitch() {
		return this.hoverSwitch;
	}

	/**
	 * Expands and collapses the box
	 * 
	 * @param visible
	 */
	public void setBoxVisible(boolean visible) {
		if (visible) {
			this.visible = false;
			middleContent.setVisible(this.visible);
			bottomContent.setVisible(this.visible);
		} else {
			this.visible = true;
			middleContent.setVisible(this.visible);
			bottomContent.setVisible(this.visible);
		}
	}

	public boolean getBoxVisible() {
		return this.visible;
	}

	public Button getHomeButton() {
		return this.returnToHome;
	}

	public Button getRouteButton() {
		return this.assignNewRoute;
	}

	public boolean getCheckClick() {
		return checkClicked;
	}

	public void setCheckClick(boolean checkClicked) {
		this.checkClicked = checkClicked;
	}

	public void update(UAVStatusWrapper uavStatus) {
		this.uavStatus = uavStatus;
		statusInfo1.setValue(uavStatus.getName());
		statusInfo2.setValue(""Status: "" + uavStatus.getStatus());
		statusInfo3.setValue(""Battery Life: "" + uavStatus.getBatteryLife() + "" %"");

		String locString = String.format(""Lat: %s | Long: %s | Alt: %s"", uavStatus.getLatitude(),
				uavStatus.getLongitude(), uavStatus.getAltitude());

		locationInfo1.setValue(locString);
		// locationInfo2.setValue(""Longitude:\t"" + uavStatus.getLongitude());
		// locationInfo3.setValue(""Altitude:\t"" + uavStatus.getAltitude() + "" meters"");
		locationInfo4.setValue(""Ground Speed:\t"" + uavStatus.getSpeed() + "" m/s"");

		// health.setCaption(""<span style=\'color: "" + uavStatus.getHealthColor() + ""
		// !important;\'> ""
		// + VaadinIcons.CIRCLE.getHtml() + ""</span>"");
		// if (uavStatus.getHealthColor().equals(""green""))
		// health.setDescription(""Normally Functionable"");
		// else if (uavStatus.getHealthColor().equals(""yellow""))
		// health.setDescription(""Needs Attention"");
		// else if (uavStatus.getHealthColor().equals(""red""))
		// health.setDescription(""Needs Immediate Attention"");

		if (uavStatus.getStatus().equals(FlightMode.USER_CONTROLLED.toString())) {
			health.setIcon(user_controlled);
			this.setEnabled(false);
			setBoxVisible(true);
		} else {
			health.setIcon(okIcon);
			this.setEnabled(true);
		}

	}

	public String getName() {
		return uavStatus.getName();
	}

	public String getStatus() {
		return uavStatus.getStatus();
	}

	public String getHealthColor() {
		return uavStatus.getHealthColor();
	}
}
"
IdentifierCreator.java,"package edu.nd.dronology.monitoring.tree;

/**
 * 
 * Factory Class for Artifact Identifier for creating Artifact Identifier for
 * the VarModel <br>
 * <br>
 * <b> Only use the factory methods for creating Artifact Identifier! </b>
 * <p/>
 * 
 * @author Michael Vierhauser
 * 
 */
public class IdentifierCreator {

	

	// public static ArtifactIdentifier createIdentifier(String gid, UAVStateMessage
	// message) {
	// String uavid = message.getUavid();
	// return new ArtifactIdentifier(ArtifactIdentifier.ROOT, gid, uavid,
	// UAVStateMessage.class.getSimpleName());
	//
	// }
	//
	// public static ArtifactIdentifier createIdentifier(String gid,
	// UAVMonitoringMessage message) {
	// String uavid = message.getUavid();
	// return new ArtifactIdentifier(ArtifactIdentifier.ROOT, gid, uavid,
	// UAVMonitoringMessage.class.getSimpleName());
	//
	// }

	// public static ArtifactIdentifier createIdentifier(String gid,
	// IMonitorableMessage message) {
	// if (message instanceof UAVStateMessage) {
	// return createIdentifier(gid, (UAVStateMessage) message);
	// }
	// if (message instanceof UAVMonitoringMessage) {
	// return createIdentifier(gid, (UAVMonitoringMessage) message);
	// }
	// return null;
	// }

}
"
IMappedItem.java,"package edu.nd.dronology.services.core.items;

import java.util.List;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

public interface IMappedItem {

	String getId();

	String getDescription();

	void setDescription(String description);

	void setId(String id);

	String getType();

	void setType(String type);
	
	void setImportance(Integer importance);
	
	Integer getImportance();

	void addCoordinate(LlaCoordinate coord);
	
	void setCoordinates(List<LlaCoordinate> coords);

	void removeCoodinate(LlaCoordinate coord);

	List<LlaCoordinate> getCoordinates();

}
"
SynchronizationPoint.java,"package edu.nd.dronology.services.extensions.missionplanning.sync;

import java.util.HashSet;
import java.util.Set;

/**
 * 
 * Synchronization Point for routes assigned to UAVs. <br>
 * Once a {@link SynchronizationPoint} is {@link SynchronizationState#ACTIVE} by one UAV, all collaborators (i.e., registered UAV) have to reach the sync point in order to proceed.
 * 
 * @author Jane Cleland-Huang
 *
 */
public class SynchronizationPoint {
	private String synchName;
	private Set<String> collaborators;
	private SynchronizationState synchronizationState;

	public SynchronizationPoint(String name) { 
		synchName = name;
		collaborators = new HashSet<>();
		synchronizationState = SynchronizationState.NOTACTIVATED;
	}

	@Override
	public String toString() {
		return synchName + "" Members: "" + collaborators.size();
	}

	public void registerCollaborator(String UAV) {
		collaborators.add(UAV);
	}

	public void activateSynchronizationPoint() {
		synchronizationState = SynchronizationState.ACTIVE;
	}

	public void removeCollaborator(String uavid) {
		if (collaborators.contains(uavid)) { //It may already have been removed. Do nothing if its already removed
			collaborators.remove(uavid);
		}

		if (collaborators.isEmpty() && synchronizationState.equals(SynchronizationState.ACTIVE))
			synchronizationState = SynchronizationState.SYNCHED; // Assumes all collaborators are added before it
		// becomes active.
	}

	public int countUnsynched() {
		return collaborators.size();
	}

	public boolean isSynched() {
		return synchronizationState == SynchronizationState.SYNCHED;
	}
}"
IDroneAttribute.java,"package edu.nd.dronology.core.vehicle;

public interface IDroneAttribute<T> {
	
	
	public final String ATTRIBUTE_BATTERY_VOLTAGE = ""batteryVoltage"";
	
	public final String ATTRIBUTE_LOCATION = ""location"";

	String getKey();

	T getValue();

}
"
WaypointTask.java,"package edu.nd.dronology.services.extensions.missionplanning.tasks;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

public class WaypointTask extends AbstractMissionTask {

	private final LlaCoordinate coordinate;

	protected WaypointTask(String uavID, LlaCoordinate coordinate) {
		super(uavID, coordinate.toString());
		this.coordinate = coordinate;
	}

	@Override
	public LlaCoordinate getWaypoint() {
		return coordinate;
	}
}"
ModeChangeMessageTypeAdapter.java,"package edu.nd.dronology.gstation.connector.messages;

import java.lang.reflect.Type;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import edu.nd.dronology.core.vehicle.DroneFlightStateManager.FlightMode;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class ModeChangeMessageTypeAdapter implements JsonDeserializer<UAVModeChangeMessage> {

	private static final ILogger LOGGER = LoggerProvider.getLogger(ModeChangeMessageTypeAdapter.class);

	@Override
	public UAVModeChangeMessage deserialize(JsonElement element, Type mapType, JsonDeserializationContext arg2)
			throws JsonParseException {
		JsonObject mapObject = element.getAsJsonObject();
		String uavid = mapObject.get(UAVModeChangeMessage.UAV_ID).getAsString();
		String gsid = mapObject.get(UAVModeChangeMessage.GS_ID).getAsString();
		JsonObject data = mapObject.getAsJsonObject(""data"");

		String mode = data.get(UAVModeChangeMessage.MODE).getAsString();

		String dMode = FlightMode.USER_CONTROLLED.toString();

		if (""LOITER"".equals(mode)) {
			dMode = FlightMode.USER_CONTROLLED.toString();
		} else if (""STABILIZE"".equals(mode)) {
			dMode = FlightMode.IN_AIR.toString();
		} else if (""GUIDED"".equals(mode)) {
			dMode = FlightMode.IN_AIR.toString();
		} else if (""LAND"".equals(mode)) {
			dMode = FlightMode.IN_AIR.toString();
		} else {
			LOGGER.hwFatal(""Mode '"" + mode + ""' not recognized!"");
		}

		UAVModeChangeMessage message = new UAVModeChangeMessage(gsid, uavid, dMode);

		return message;
	}

}
"
LandTask.java,"package edu.nd.dronology.services.extensions.missionplanning.tasks;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

public class LandTask extends AbstractMissionTask {

	private final LlaCoordinate coordinate;

	protected LandTask(String uavID, LlaCoordinate coordinate) {
		super(uavID, coordinate.toString());
		this.coordinate = coordinate;

	}

	@Override
	public LlaCoordinate getWaypoint() {
		return coordinate;
	}

}"
IBatterySimulator.java,"package edu.nd.dronology.core.simulator;

import edu.nd.dronology.core.vehicle.internal.VirtualDrone;

/**
 * 
 * The battery simulator simulates the battery usage / voltage drain while a {@link VirtualDrone} is in flight.
 * 
 * @author Michael Vierhauser
 *
 */
public interface IBatterySimulator {

	void startBatteryDrain();

	void stopBatteryDrain();

	double getVoltage();

}
"
ExportRoutePrimitive.java,"package edu.nd.dronology.services.core.unused;
//package edu.nd.dronology.services.core.areamapping;
//
//import java.io.Serializable;
//import java.util.Collections;
//import java.util.List;
//import java.util.Vector;
//
//import edu.nd.dronology.core.coordinate.LlaCoordinate;
//
//public class ExportRoutePrimitive implements Serializable{
//	/**
//	 * 
//	 */
//	private static final long serialVersionUID = -7238362877727584258L;
//	private List<LlaCoordinate> routePrimitive;
//	private boolean downstreamDirection;
//	
//	public ExportRoutePrimitive() {
//		routePrimitive = new Vector<LlaCoordinate>();
//		downstreamDirection = true;
//	}
//	
//	public void addRouteWaypoint(LlaCoordinate routeWaypoint) {
//		routePrimitive.add(routeWaypoint);
//	}
//	
//	public void reverseRoute() {
//		Collections.reverse(routePrimitive);
//		if(downstreamDirection) {
//			downstreamDirection = false;
//		} else {
//			downstreamDirection = true;
//		}
//	}
//	
//	public boolean getDownstreamDirection() {
//		return downstreamDirection;
//	}
//	
//	public List<LlaCoordinate> getRoute(){
//		return Collections.unmodifiableList(routePrimitive);
//	}
//	
//	public LlaCoordinate getRouteStartPoint(){
//		return routePrimitive.get(0);
//	}
//	
//	public LlaCoordinate getRouteEndPoint(){
//		return routePrimitive.get(size()-1);
//	}
//	
//	public LlaCoordinate getRouteWaypoint(int entry){
//		return routePrimitive.get(entry);
//	}
//	
//	public void insertRouteWaypoint(int index, LlaCoordinate waypoint) {
//		routePrimitive.add(index, waypoint);
//	}
//	
//	public void setRouteWaypoint(int index, LlaCoordinate entry) {
//		routePrimitive.set(index, entry);
//	}
//	
//	public void setDownstreamDirection(boolean downstream) {
//		downstreamDirection = downstream;
//	}
//	
//	public int size() {
//		return routePrimitive.size();
//	}
//}
"
FlightRouteplanningServiceInstance.java,"package edu.nd.dronology.services.instances.flightroute;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.services.core.api.IFileChangeNotifyable;
import edu.nd.dronology.services.core.api.ServiceInfo;
import edu.nd.dronology.services.core.base.AbstractFileTransmitServiceInstance;
import edu.nd.dronology.services.core.info.FlightRouteCategoryInfo;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.items.FlightRoute;
import edu.nd.dronology.services.core.items.IFlightRoute;
import edu.nd.dronology.services.core.persistence.FlightRoutePersistenceProvider;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import edu.nd.dronology.services.core.util.DronologyConstants;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.core.util.ServiceIds;
import edu.nd.dronology.services.instances.DronologyElementFactory;
import edu.nd.dronology.services.supervisor.SupervisorService;
import edu.nd.dronology.util.FileUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * The {@link FlightRouteplanningServiceInstance} provides capabilities for retrieving {@link FlightRoute} from the file system.<br>
 * When a new {@link FlightRoute} is detected in the file system it gets automatically loaded.<br>
 * Routes are provided via {@link FlightRouteInfo} proxies containing, basic info on the flight route.
 * 
 *   
 * 
 * @author Michael Vierhauser
 * 
 *
 */
public class FlightRouteplanningServiceInstance extends AbstractFileTransmitServiceInstance<FlightRouteInfo>
		implements IFileChangeNotifyable, IFlightRouteplanningServiceInstance {
 
	private static final ILogger LOGGER = LoggerProvider.getLogger(FlightRouteplanningServiceInstance.class);

	private static final int ORDER = 2;

	public static final String EXTENSION = DronologyConstants.EXTENSION_FLIGHTROUTE;

	private Map<String, FlightRouteInfo> flightPaths = new Hashtable<>();

	private Collection<FlightRouteCategoryInfo> categories = new ArrayList<>();

	public FlightRouteplanningServiceInstance() {
		super(ServiceIds.SERVICE_FLIGHROUTE, ""Routeplanning Management"", EXTENSION);

		categories.add(new FlightRouteCategoryInfo(""South-Bend Area"", ""sba""));
		categories.add(new FlightRouteCategoryInfo(""River"", ""river""));
		categories.add(new FlightRouteCategoryInfo(""Default"", ""Default""));
	}

	@Override
	protected Class<?> getServiceClass() {
		return FlightRouteplanningService.class;
	}

	@Override
	protected int getOrder() {
		return ORDER;
	}

	@Override
	protected String getPropertyPath() {
		return null;
	}

	@Override
	protected void doStartService() throws Exception {
		reloadItems();
	}

	@Override
	protected void doStopService() throws Exception {
		fileManager.tearDown();
	}

	@Override
	public ServiceInfo getServiceInfo() {
		ServiceInfo sInfo = super.getServiceInfo();
		sInfo.addAttribute(ServiceInfo.ATTRIBUTE_TYPE, ServiceInfo.ATTRIBUTE_FILE);
		return sInfo;
	}

	@Override
	public FlightRouteInfo createItem() throws DronologyServiceException {
		FlightRoutePersistenceProvider persistor = FlightRoutePersistenceProvider.getInstance();
		IFlightRoute flightRoute = DronologyElementFactory.createNewFlightPath();
		flightRoute.setName(""New-FlightRoute"");
		String savePath = FileUtil.concat(storagePath, flightRoute.getId(), EXTENSION);

		try {
			persistor.saveItem(flightRoute, savePath);
		} catch (PersistenceException e) {
			throw new DronologyServiceException(""Error when creating flight route: "" + e.getMessage());
		}
		return new FlightRouteInfo(flightRoute.getName(), flightRoute.getId());
	}

	@Override
	protected String getPath() {
		String path = SupervisorService.getInstance().getFlightPathLocation();
		return path;
	}

	@Override
	protected FlightRouteInfo fromFile(String id, File file) throws Throwable {
		IFlightRoute atm = FlightRoutePersistenceProvider.getInstance().loadItem(file.toURI().toURL());
		FlightRouteInfo info = new FlightRouteInfo(atm.getName(), id);
		info.setCategory(atm.getCategory());
		for (Waypoint waypoint : atm.getWaypoints()) {
			info.addWaypoint(waypoint);
		}

		BasicFileAttributes attr = Files.readAttributes(Paths.get(file.toURI()), BasicFileAttributes.class);
		if (atm.getWaypoints().size() > 1) {
			double distance = calculateDistance(atm.getWaypoints());
			info.setRouteLength(distance);
		} else {
			info.setRouteLength(0);
		}
		info.setDateCreated(attr.creationTime().toMillis());
		info.setDateModified(attr.lastModifiedTime().toMillis());
		info.setDescription(atm.getDescription());
		return info;
	} 

	private double calculateDistance(List<Waypoint> waypoints) {
		LinkedList<Waypoint> ll = new LinkedList<>(waypoints);
		Waypoint current = ll.remove(0);
		double distance = 0;
		while (!ll.isEmpty()) {
			Waypoint next = ll.remove(0);
			distance += Math.abs(current.getCoordinate().distance(next.getCoordinate()));
			current = next;
		}
		return distance;
	}

	@Override
	protected boolean hasProperties() {
		return false;
	}

	@Override
	public void notifyFileChange(Set<String> changed) {
		super.notifyFileChange(changed);
		for (String s : changed) {
			String id = s.replace(""."" + extension, """");
			if (!itemmap.containsKey(id)) {
				HashSet<Entry<String, FlightRouteInfo>> allEntries = new HashSet(flightPaths.entrySet());
				for (Entry<String, FlightRouteInfo> e : allEntries) {
					if (e.getValue().getId().equals(changed)) {
						flightPaths.remove(e.getKey());
					}
				}
			}
		}
	}

	@Override
	public Collection<FlightRouteCategoryInfo> getFlightPathCategories() {
		return Collections.unmodifiableCollection(categories);
	}

	@Override
	public FlightRouteInfo getItem(String name) throws DronologyServiceException {
		for (FlightRouteInfo item : itemmap.values()) {
			if (item.getId().equals(name)) {
				return item;
			}
		}
		throw new DronologyServiceException(""Flighroute '"" + name + ""' not found"");
	}

	@Override
	public FlightRouteInfo getRouteByName(String routeName) throws DronologyServiceException {
		for (FlightRouteInfo item : itemmap.values()) {
			if (item.getName().equals(routeName)) {
				return item;
			}
		}
		throw new DronologyServiceException(""Flighroute '"" + routeName + ""' not found"");
	}
}
"
NVector.java,"package edu.nd.dronology.core.coordinate;

import edu.nd.dronology.core.simulator.nvecsimulator.NvecInterpolator;

/**
 * A terrestrial position defined by a normal vector (N-vector) and an altitude.
 * 
 * An N-vector is a normal Vector that points out from the surface of the WGS-84
 * reference ellipsoid. The normal vector is combined with an altitude which
 * represents the distance above (or below) the reference ellipsoid (note this
 * is the distance above sea level as sea level is defined as the surface of the
 * ellipsoid in WGS-84). The n-vector and altitude together precisely define a
 * position on Earth. The n-vector should be a unit vector (i.e. a vector with a
 * magnitude = 1). The altitude should be in meters.
 *  
 * @author Michael Murphy 
 *  
 */ 
public class NVector extends AbstractPosition {

	public static final double SEMI_MAJOR = 6378137.0;
	public static final double SEMI_MINOR = 6356752.31;// 4245;

	private double x;

	private double y;

	private double z;

	private double altitude;

	/**
	 * 
	 * @param x
	 *            the x component of the normal vector
	 * @param y
	 *            the y component of the normal vector
	 * @param z
	 *            the z component of the normal vector
	 * @param altitude
	 *            the distance above the reference ellipsoid (negative altitudes
	 *            represent altitude below this ellipsoid).
	 */
	public NVector(double x, double y, double z, double altitude) {
		double m = Math.sqrt(x * x + y * y + z * z);
		this.x = x / m;
		this.y = y / m;
		this.z = z / m;
		this.altitude = altitude;
	}

	@Override
	public NVector toNVector() {
		return this;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		long temp;
		temp = Double.doubleToLongBits(x);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		temp = Double.doubleToLongBits(y);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		temp = Double.doubleToLongBits(z);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		temp = Double.doubleToLongBits(altitude);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof NVector))
			return false;
		NVector other = (NVector) obj;
		if (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))
			return false;
		if (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))
			return false;
		if (Double.doubleToLongBits(z) != Double.doubleToLongBits(other.z))
			return false;
		if (Double.doubleToLongBits(altitude) != Double.doubleToLongBits(other.altitude))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return String.format(""NVector(%f, %f, %f, altitude=%f)"", x, y, z, altitude);
	}

	/**
	 * @return the distance above sea level in meters
	 */
	public double getAltitude() {
		return altitude;
	}

	/**
	 * @return the x component of the n-vector
	 */
	public double getX() {
		return x;
	}

	/**
	 * @return the y component of the n-vector
	 */
	public double getY() {
		return y;
	}

	/**
	 * @return the z component of the n-vector
	 */
	public double getZ() {
		return z;
	}

	/**
	 * Finds the distance in meters from this NVector to another.
	 * 
	 * This is the distance that a laser would travel.
	 * 
	 * @param other
	 *            the other position to find the position to.
	 * @return The distance from this position to the other in meters
	 */
	public double distance(NVector other) {
		PVector pSelf = toPVector();
		PVector pOther = other.toPVector();
		double dx = pSelf.getX() - pOther.getX();
		double dy = pSelf.getY() - pOther.getY();
		double dz = pSelf.getZ() - pOther.getZ();
		return Math.sqrt(dx * dx + dy * dy + dz * dz);

	}

	/**
	 * @return a terrestrial position defined by an x, y, and z coordinate in an
	 *         Earth centered Earth fixed reference frame.
	 */
	@Override
	public PVector toPVector() {
		/*
		 * The formula this code is based on can be found in a journal article
		 * called: ""A Non-singular Horizontal Position Representation"" by
		 * Kenneth Gade. You can find it at https://goo.gl/iCqdCn (see equation
		 * 22 in appendix B)
		 * 
		 * Note: equation 22 is unconventional as it swaps the z component with
		 * x component. This code follows the more common convention and returns
		 * z and x to their proper place
		 */
		double a = SEMI_MAJOR;
		double b = SEMI_MINOR;
		double ab2 = (a * a) / (b * b);
		double f = b / Math.sqrt(z * z + ab2 * y * y + ab2 * x * x);
		double pz = f * z + altitude * z;
		double py = f * ab2 * y + altitude * y;
		double px = f * ab2 * x + altitude * x;
		return new PVector(px, py, pz);
	}

	/**
	 * @return a terrestrial position defined by a latitude, longitude, and
	 *         altitude.
	 */
	@Override
	public LlaCoordinate toLlaCoordinate() {
		double lat = Math.atan2(this.getZ(), Math.sqrt(this.getX() * this.getX() + this.getY() * this.getY()));
		double lon = Math.atan2(this.getY(), this.getX());
		return new LlaCoordinate(Math.toDegrees(lat), Math.toDegrees(lon), this.getAltitude());
	}
	
	public static double laserDistance(NVector a, NVector b) {
		PVector pa = a.toPVector();
		PVector pb = b.toPVector();
		double dx = pa.getX() - pb.getX();
		double dy = pa.getY() - pb.getY();
		double dz = pa.getZ() - pb.getZ();
		return Math.sqrt(dx * dx + dy * dy + dz * dz);
	}
	
	public static double travelDistance(NVector a, NVector b, double stepDistance) {
		double dist = 0.0;
		NVector current = a;
		while (current.distance(b) > stepDistance) {
			current = NvecInterpolator.move(current, b, 1.0);
			dist += stepDistance;
		}
		dist += current.distance(b);
		return dist;
	}
	
	public static double travelDistance(NVector a, NVector b) {
		return travelDistance(a, b, 1.0);
	}

}
"
DistanceUtil.java,"package edu.nd.dronology.core.util;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.util.NullUtil;

public class DistanceUtil {

	/**
	 * Calculate distance between two points in latitude and longitude taking into account height difference. If you are not interested in height difference pass 0.0. Uses Haversine method as its base.
	 * 
	 * lat1, lon1 Start point lat2, lon2 End point el1 Start altitude in meters el2 End altitude in meters
	 * 
	 * @returns Distance in Meters
	 */
	public static double distance(double lat1, double lat2, double lon1, double lon2, double el1, double el2) {

		// lat1 = lat1/1000000;
		// lat2 = lat2/1000000;
		// lon1 = lon1/1000000;
		// lon2 = lon2/1000000;
		final int R = 6371; // Radius of the earth

		double latDistance = Math.toRadians(lat2 - lat1);
		double lonDistance = Math.toRadians(lon2 - lon1);
		double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2) + Math.cos(Math.toRadians(lat1))
				* Math.cos(Math.toRadians(lat2)) * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
		double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
		double distance = R * c * 1000; // convert to meters

		double height = el1 - el2;

		distance = Math.pow(distance, 2) + Math.pow(height, 2);

		return Math.sqrt(distance);
	}

	public static double distance(LlaCoordinate currentPosition, LlaCoordinate targetPosition) {
		return distance(currentPosition.getLatitude(), targetPosition.getLatitude(), currentPosition.getLongitude(),
				targetPosition.getLongitude(), 0, 0);
	}

	public static double calculateTotalDistance(LlaCoordinate... coordinates) {
		NullUtil.checkArrayNull(coordinates);
		if (coordinates.length < 2) {
			throw new IllegalArgumentException(""At least 2 coordinates are required to calculate the distance between them!"");
		}
		double totaldistance = 0;
		for (int i = 0; i < coordinates.length; i++) {
			LlaCoordinate current = coordinates[i];
			if (coordinates.length < (i + 2)) {
				break;
			}
			LlaCoordinate next = coordinates[i + 1];
			totaldistance = distance(current, next);
		}
		return totaldistance;
	}

}
"
UAVProxy.java,"package edu.nd.dronology.core.vehicle.proxy;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.vehicle.IUAVProxy;

/**
 * 
 * Proxy class for Manged Drones. <br>
 * This datastructure is intended to be passed to external clients and contains
 * necessary information regarding the actual UAV managed by Dronology
 *
 */
public class UAVProxy implements Serializable, IUAVProxy {
	/**
	 * 
	 */
	private static final long serialVersionUID = -3319827887969940655L;
	private volatile double latitude;
	private volatile double longitude;
	private volatile double altitude;
	private final String ID;
	private volatile double batteryLevel;
	private volatile double velocity;
	private Map<String, String> info;
	private String status;
	private String groundstationId;
	private LlaCoordinate home;

	public UAVProxy(String ID, long latitude, long longitude, int altitude, double batteryLevel, double velocity) {
		this.ID = ID;
		this.latitude = latitude;
		this.longitude = longitude;
		this.altitude = altitude;
		this.batteryLevel = batteryLevel;
		this.velocity = velocity;
		info = new HashMap<>();
		status = ""UNKNOWN"";
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getID()
	 */
	@Override
	public String getID() {
		return ID;
	}

	@Override
	public String getGroundstationId() {
		return groundstationId;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getStatus()
	 */
	@Override
	public String getStatus() {
		return status;
	}

	public void updateCoordinates(double latitude, double longitude, double altitude) {
		this.latitude = latitude;
		this.longitude = longitude;
		this.altitude = altitude;
	}

	public void updateBatteryLevel(double batteryLevel) {
		this.batteryLevel = batteryLevel;
	}

	public void updateVelocity(double velocity) {
		this.velocity = velocity;
	}

	@Override
	public String toString() {
		return ""ID: "" + ID + "" Pos: ("" + latitude + "","" + longitude + "","" + altitude + "") "" + "" Vel: "" + velocity
				+ "" Bat: "" + batteryLevel + "" --- "" + this.status;
	}

	@Override
	public int hashCode() {
		return 17 + ID.hashCode();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getLongitude()
	 */
	@Override
	public double getLongitude() {
		return longitude;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getLatitude()
	 */
	@Override
	public double getLatitude() {
		return latitude;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getAltitude()
	 */
	@Override
	public double getAltitude() {
		return altitude;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getBatteryLevel()
	 */
	@Override
	public double getBatteryLevel() {
		return batteryLevel;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getVelocity()
	 */
	@Override
	public double getVelocity() {
		return velocity;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getInfo()
	 */
	@Override
	public Map<String, String> getInfo() {
		return info;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see edu.nd.dronology.core.vehicle.proxy.IUAVProxy2#getCoordinates()
	 */
	@Override
	public LlaCoordinate getCoordinates() {
		return new LlaCoordinate(latitude, longitude, altitude);
	}

	public void setVelocity(double velocity) {
		this.velocity = velocity;

	}

	public void setGroundstationId(String groundstationId) {
		this.groundstationId = groundstationId;

	}

	@Override
	public LlaCoordinate getHomeLocation() {
		return home;
	}

	public void setHomeLocation(LlaCoordinate home) {
		this.home = home;

	}

}
"
RemoteConnectionServiceInstance.java,"package edu.nd.dronology.services.instances.remote;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Timer;

import edu.nd.dronology.services.core.api.ServiceInfo;
import edu.nd.dronology.services.core.base.AbstractRegisterableUnit;
import edu.nd.dronology.services.core.base.AbstractServiceInstance;
import edu.nd.dronology.services.core.remote.IRemoteManager;
import edu.nd.dronology.services.core.remote.RemoteInfo;
import edu.nd.dronology.services.core.util.ServiceIds;
import edu.nd.dronology.services.remote.RemoteService;
import edu.nd.dronology.services.remote.rmi.RemoteManagerFactory;
import edu.nd.dronology.util.Immutables;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class RemoteConnectionServiceInstance extends AbstractServiceInstance implements
		IRemoteConnectionServiceInstance {

	/**
	 * 
	 */
	private static final long serialVersionUID = -8000279798861818920L;
	boolean started = false;
	// private AbstractRMIRemoteObject remoteObject;
//	private RemoteLogger remoteLogger;
	//private RemoteConnectionServiceInstance.CheckConnectionTask connectionTask;
	private static final ILogger LOGGER = LoggerProvider.getLogger(RemoteConnectionServiceInstance.class);

	List<IRemoteManager> remoteManager = new ArrayList<>();

	private static final Map<String, RemoteInfo> clients = new Hashtable<>();
	private Timer timer;

	public RemoteConnectionServiceInstance() {
		super(ServiceIds.SERVICE_REMOTE, ""Managing remote connections"");
		timer = new Timer();
	}

	@Override
	protected void doStartService() throws Exception {
		Properties prp = getConfigurationProperties();
		List<IRemoteManager> rmiObjects;
		if (prp.get(PORT_PROPERTY) != null) {
			// remoteObject = RemoteRMIRemoteObject.getInstance(Integer.parseInt((String) prp.get(PORT_PROPERTY)));
			rmiObjects = RemoteManagerFactory.createRMIObjects(Integer.parseInt((String) prp.get(PORT_PROPERTY)));

		} else {
			// remoteObject = RemoteRMIRemoteObject.getInstance(null);
			rmiObjects = RemoteManagerFactory.createRMIObjects(null);
		}
		remoteManager.addAll(rmiObjects);

		started = true;
//		remoteLogger = new RemoteLogger();
//		remoteLogger.start();

		for (IRemoteManager mng : remoteManager) {
			mng.initialize();
		}

//		connectionTask = new CheckConnectionTask();
//		timer.scheduleAtFixedRate(connectionTask, 10000, 60000);
	}

	@Override
	protected void doStopService() throws Exception {
		started = false;

		for (IRemoteManager mng : remoteManager) {
			mng.tearDown();
		}


	}

	@Override
	protected String getPropertyPath() {
		return ""config/remoteServer.properties"";
	}

	@Override
	public void register(RemoteInfo rInfo) {
		long timeStamp = System.currentTimeMillis();
		rInfo.addAttribute(AbstractRegisterableUnit.TIMESTAMP, Long.toString(timeStamp));
		if (clients.containsKey(rInfo.getID())) {
			LOGGER.info(""Keep alive received: "" + rInfo.toString());
		} else {
			LOGGER.info(""Remote client registered: "" + rInfo.toString());
		}
		clients.put(rInfo.getID(), rInfo);
	}

	@Override
	public void unregister(RemoteInfo rInfo) {
		clients.remove(rInfo);
	}

	@Override
	public Collection<RemoteInfo> getRegisteredRemoteClients() {
		synchronized (clients) {
			return Immutables.linkedListCopy(clients.values());
		}
	}

	@Override
	protected Class<?> getServiceClass() {
		return RemoteService.class;
	}

//	@Override
//	public void logExternal(LogEventAdapter event) {
//		remoteLogger.logExternal(event);
//	}

	@Override
	protected int getOrder() {
		return 0;
	}

	@Override
	public ServiceInfo getServiceInfo() {
		ServiceInfo sInfo = super.getServiceInfo();
		sInfo.addAttribute(ServiceInfo.ATTRIBUTE_TYPE, ServiceInfo.ATTRIBUTE_REMOTE);
		return sInfo;
	}

//	private class CheckConnectionTask extends TimerTask {
//
//		@Override
//		public void run() {
//			for (RemoteInfo info : getRegisteredRemoteClients()) {
//				if (!UnitUtil.isAlive(info)) {
//					unregister(info);
//				}
//			}
//		}
//	}

	@Override
	public void addRemoteManager(IRemoteManager manager) {
		remoteManager.add(manager);
		
	}
}
"
MissionPlanningServiceRemoteFacade.java,"package edu.nd.dronology.services.extensions.missionplanning.service;

import java.rmi.RemoteException;
import java.util.Collection;

import edu.nd.dronology.services.core.info.MissionInfo;
import edu.nd.dronology.services.core.info.UAVMappingInfo;
import edu.nd.dronology.services.core.listener.IItemChangeListener;
import edu.nd.dronology.services.core.remote.IMissionPlanningRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.extensions.missionplanning.service.internal.MissionPlanningService;
import edu.nd.dronology.services.instances.flightmanager.FlightManagerService;
import edu.nd.dronology.services.remote.AbstractRemoteFacade;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Remote facade for handling MissionPlanning<br>
 * Initial implementation of mission planning capabilities. <br>
 * Allows retrieving sending a mission plan as JSON String to Dronology.
 * 
 * 
 * @author Michael Vierhauser
 *
 */
public class MissionPlanningServiceRemoteFacade extends AbstractRemoteFacade implements IMissionPlanningRemoteService {
	/**
	 * 
	 */
	private static final long serialVersionUID = -4580658378477037955L;
	private static final ILogger LOGGER = LoggerProvider.getLogger(MissionPlanningServiceRemoteFacade.class);
	private static volatile MissionPlanningServiceRemoteFacade INSTANCE;

	protected MissionPlanningServiceRemoteFacade() throws RemoteException {
		super(FlightManagerService.getInstance());
	}

	public static IMissionPlanningRemoteService getInstance() throws RemoteException {
		if (INSTANCE == null) {
			try {
				synchronized (MissionPlanningServiceRemoteFacade.class) {
					if (INSTANCE == null) {
						INSTANCE = new MissionPlanningServiceRemoteFacade();
					}
				}

			} catch (RemoteException e) {
				LOGGER.error(e);
			}
		}
		return INSTANCE;
	}

	@Override
	public void executeMissionPlan(String mission) throws RemoteException, DronologyServiceException {
		MissionPlanningService.getInstance().executeMissionPlan(mission);

	}

	@Override
	public void executeMissionPlan(MissionInfo info) throws RemoteException, DronologyServiceException {
		MissionPlanningService.getInstance().executeMissionPlan(info);

	}

	@Override
	public void cancelMission() throws RemoteException, DronologyServiceException {
		MissionPlanningService.getInstance().cancelMission();

	}

	@Override
	public byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException {
		return MissionPlanningService.getInstance().requestFromServer(id);
	}

	@Override
	public void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException {
		MissionPlanningService.getInstance().transmitToServer(id, content);
	}

	@Override
	public boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException {
		return MissionPlanningService.getInstance().addItemChangeListener(listener);
	}

	@Override
	public boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException {
		return MissionPlanningService.getInstance().removeItemChangeListener(listener);

	}

	@Override
	public Collection<MissionInfo> getItems() throws RemoteException {
		return MissionPlanningService.getInstance().getItems();

	}

	@Override
	public MissionInfo createItem() throws RemoteException, DronologyServiceException {
		return MissionPlanningService.getInstance().createItem();

	}

	@Override
	public void deleteItem(String itemid) throws RemoteException, DronologyServiceException {
		MissionPlanningService.getInstance().deleteItem(itemid);

	}

	@Override
	public void executeMissionPlan(MissionInfo mission, UAVMappingInfo mapping)
			throws RemoteException, DronologyServiceException {
		MissionPlanningService.getInstance().executeMissionPlan(mission, mapping);

	}

}"
IDroneSetupRemoteService.java,"package edu.nd.dronology.services.core.remote;

import java.rmi.RemoteException;
import java.util.Collection;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.info.DroneInitializationInfo;
import edu.nd.dronology.services.core.listener.IDroneStatusChangeListener;
import edu.nd.dronology.services.core.util.DronologyServiceException;

/**
 * 
 * Remote Interface for handling UAVs.<br>
 * Allows initializing new UAVs. <br>
 * Allows retrieving active UAVs which returns a proxy ({@link IUAVProxy}) of the actual physical or virtual uav.
 * 
 * 
 * @author Michael Vierhauser
 *
 */
public interface IDroneSetupRemoteService extends IRemoteableService {

	Collection<IUAVProxy> getActiveUAVs() throws RemoteException;

	void initializeDrones(DroneInitializationInfo... info) throws RemoteException, DronologyServiceException;

	void addDroneStatusChangeListener(IDroneStatusChangeListener listener)
			throws RemoteException, DronologyServiceException;

	void removeDroneStatusChangeListener(IDroneStatusChangeListener listener)
			throws RemoteException, DronologyServiceException;

	void resendCommand(String uavid) throws RemoteException, DronologyServiceException;

}
"
StopExecutorViaReverse.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal;

import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.vehicle.IDrone;
import edu.nd.dronology.core.vehicle.ManagedDrone;

public class StopExecutorViaReverse implements CommandExecutor {

    enum StopExecutionState {
        RADIOING_REVERSE,
        WAITING_TO_REVERSE,
        RADIOING_STOP,
        WATCHING_THE_CLOCK,
        WAITING_FOREVER,
        FINISHED;
    }

    // seconds to wait after sending reverse NED command before sending NED(0,0,0) command
    private static final double REVERSAL_WAIT_TIME = 2.0;

    // how fast should the UAV reverse to stop
    private static final double REVERSAL_SPEED = 7.0;

    private IDrone drone;
    StopExecutionState state = StopExecutionState.RADIOING_REVERSE;
    StopCommand data;
    long reverseRadioTime;
    long startTime;

    public StopExecutorViaReverse(IDrone drone, StopCommand data) {
        this.drone = drone;
        this.data = data;
    }

    @Override
    public void process() {
        switch (state) {
            case RADIOING_REVERSE:
                radioReverse();
                break;
            case WAITING_TO_REVERSE:
                waitForReversal();
                break;
            case RADIOING_STOP:
                radioStop();
                break;
            case WATCHING_THE_CLOCK:
                checkClock();
                break;

            case WAITING_FOREVER:
            case FINISHED:
            default:
                // Do nothing.
                break;
        }
    }

    private void radioReverse() {
        //should this flatten? what if the UAV is going up?
        Vector3D reverseNED = drone.getLatestDroneSnapshot().getVelocity().scalarMultiply(-1.0).normalize().scalarMultiply(REVERSAL_SPEED);
        drone.setVelocity(reverseNED.getX(), reverseNED.getY(), reverseNED.getZ());
        reverseRadioTime = System.nanoTime();
        state = StopExecutionState.WAITING_TO_REVERSE;
    }

    private void waitForReversal() {
        double reversalWaitTimer = (System.nanoTime() - reverseRadioTime) * 1.0e-9;
        if (REVERSAL_WAIT_TIME < reversalWaitTimer) {
            state = StopExecutionState.RADIOING_STOP;
        }
    }

    private void radioStop() {
        drone.setVelocity(0.0, 0.0, 0.0);

        double waitDuration = data.getTime();
        if (waitDuration > 0.0) {
            startTime = System.nanoTime();
            state = StopExecutionState.WATCHING_THE_CLOCK;
        }
        else {
            state = StopExecutionState.WAITING_FOREVER;
        }
    }

    private void checkClock() {
        double waitDuration = data.getTime();
        long deltaNano = System.nanoTime()- startTime;
        double deltaT = deltaNano * 1.0e-9;
        if (deltaT > waitDuration) {
            state = StopExecutionState.FINISHED;
        }
    }

    @Override
    public boolean isFinished() {
        return state == StopExecutionState.FINISHED;
    }

}
"
FlightRouteplanningServiceRemoteFacade.java,"package edu.nd.dronology.services.facades;

import java.rmi.RemoteException;
import java.util.Collection;

import edu.nd.dronology.services.core.info.FlightRouteCategoryInfo;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.listener.IItemChangeListener;
import edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.instances.flightroute.FlightRouteplanningService;
import edu.nd.dronology.services.remote.AbstractRemoteFacade;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Remote facade for handling UAV routes<br>
 * Allows creating and modifying routes.
 * 
 * 
 * @author Michael Vierhauser
 * 
 */
public class FlightRouteplanningServiceRemoteFacade extends AbstractRemoteFacade
		implements IFlightRouteplanningRemoteService {
	/**
	 * 
	 */
	private static final long serialVersionUID = -4580658378477037955L;
	private static final ILogger LOGGER = LoggerProvider.getLogger(FlightRouteplanningServiceRemoteFacade.class);
	private static volatile FlightRouteplanningServiceRemoteFacade INSTANCE;

	protected FlightRouteplanningServiceRemoteFacade() throws RemoteException {
		super(FlightRouteplanningService.getInstance());
	}

	public static IFlightRouteplanningRemoteService getInstance() throws RemoteException {
		if (INSTANCE == null) {
			try {
				synchronized (FlightRouteplanningServiceRemoteFacade.class) {
					if (INSTANCE == null) {
						INSTANCE = new FlightRouteplanningServiceRemoteFacade();
					}
				}
			} catch (RemoteException e) {
				LOGGER.error(e);
			}
		}
		return INSTANCE;
	}

	@Override
	public byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException {
		return FlightRouteplanningService.getInstance().requestFromServer(id);
	}

	@Override
	public void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException {
		FlightRouteplanningService.getInstance().transmitToServer(id, content);

	}

	@Override
	public boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException {
		return FlightRouteplanningService.getInstance().addItemChangeListener(listener);
	}

	@Override
	public boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException {
		return FlightRouteplanningService.getInstance().removeItemChangeListener(listener);
	}

	@Override
	public Collection<FlightRouteInfo> getItems() throws RemoteException {
		return FlightRouteplanningService.getInstance().getItems();
	}

	@Override
	public FlightRouteInfo createItem() throws RemoteException, DronologyServiceException {
		return FlightRouteplanningService.getInstance().createItem();
	}

	@Override
	public void deleteItem(String itemid) throws RemoteException, DronologyServiceException {
		FlightRouteplanningService.getInstance().deleteItem(itemid);

	}

	@Override
	public Collection<FlightRouteCategoryInfo> getFlightPathCategories() {
		return FlightRouteplanningService.getInstance().getFlightPathCategories();
	}

}"
PhysicalDroneFleetFactory.java,"package edu.nd.dronology.core.fleet;

import edu.nd.dronology.core.Discuss;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.monitoring.DronologyMonitoringManager;
import edu.nd.dronology.core.monitoring.MessageMarshaller;
import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;
import edu.nd.dronology.core.vehicle.IDrone;
import edu.nd.dronology.core.vehicle.IDroneCommandHandler;
import edu.nd.dronology.core.vehicle.ManagedDrone;
import edu.nd.dronology.core.vehicle.internal.PhysicalDrone;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * Factory class for initializing a new {@link PhysicalDrone} instance.
 *  
 * @author Jane Cleland-Huang
 *  
 */
public class PhysicalDroneFleetFactory extends AbstractDroneFleetFactory {
 
	private static final ILogger LOGGER = LoggerProvider.getLogger(PhysicalDroneFleetFactory.class);

	private static volatile PhysicalDroneFleetFactory INSTANCE = null;
	private IDroneCommandHandler commandHandler;

	protected PhysicalDroneFleetFactory() {
	}

	public void setCommandHandler(IDroneCommandHandler commandHandler) {
		this.commandHandler = commandHandler;
	}

	public static PhysicalDroneFleetFactory getInstance() {
		if (INSTANCE == null) {
			synchronized (PhysicalDroneFleetFactory.class) {
				if (INSTANCE == null) { 
					INSTANCE = new PhysicalDroneFleetFactory();
				}
			}
		}
		return INSTANCE;
	}

	@Override
	@Discuss(discuss = ""todo: fligh to altitude 10... workaround just for testing purposes... needs to be fixed.."")
	public ManagedDrone initializeDrone(String droneID, String droneType, double latitude, double longitude,
			double altitude) throws DroneException {

		String[] ids = droneID.split("":""); 
		if (ids.length != 2) {
			throw new DroneException(""Invalid drone id '"" + droneID + ""' --> - droneid:groundstationid"");
		}
		String drnId = ids[0];
		String groundstationid = ids[1];

		IDrone drone = new PhysicalDrone(createDroneID(drnId),
				RuntimeDroneTypes.getInstance().getCommandHandler(groundstationid));
		ManagedDrone managedDrone = new ManagedDrone(drone);
		drone.setManagedDrone(managedDrone);

		LlaCoordinate currentPosition = new LlaCoordinate(latitude, longitude, 10);
		LOGGER.info(""Drone initialized at: "" + currentPosition.toString());
		DronologyMonitoringManager.getInstance().publish(MessageMarshaller
				.createMessage(MessageType.PHYSICAL_UAV_ACTIVATED, drone.getDroneName(), currentPosition));

		drone.setBaseCoordinates(currentPosition);
		drone.setCoordinates(currentPosition.getLatitude(), currentPosition.getLongitude(), currentPosition.getAltitude());
		managedDrone.start();
		DroneFleetManager.getInstance().addDrone(managedDrone);
		return managedDrone;
	}
}"
RRDemoScript.java,"package edu.nd.dronology.misc.scripts;

import java.net.MalformedURLException;
import java.rmi.Naming;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;
import edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;
import edu.nd.dronology.services.core.remote.IRemoteManager;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public class RRDemoScript {

	private static final String ADDRESS_SCHEME = ""rmi://%s:%s/Remote"";

	public static void main(String[] args) {
		try {

			IRemoteManager manager = (IRemoteManager) Naming.lookup(String.format(ADDRESS_SCHEME, ""127.0.0.1"", 9779));

			// IDroneSetupRemoteService service = (IDroneSetupRemoteService)
			// manager.getService(IDroneSetupRemoteService.class);
			//
			IFlightManagerRemoteService managerService = (IFlightManagerRemoteService) manager
					.getService(IFlightManagerRemoteService.class);

			IFlightRouteplanningRemoteService planningService = (IFlightRouteplanningRemoteService) manager
					.getService(IFlightRouteplanningRemoteService.class);
			//

			List<FlightRouteInfo> allRoutes = new ArrayList<>(planningService.getItems());

			for (FlightRouteInfo r : allRoutes) {
				System.out.println(r.getName());

			}

			FlightRouteInfo r1 = getRouteByName(""RR2_SouthArea"", allRoutes);
			FlightRouteInfo r2 = getRouteByName(""RR3A_RiverBank"", allRoutes);
			FlightRouteInfo r3 = getRouteByName(""RR3B_RiverBank"", allRoutes);
			FlightRouteInfo r4 = getRouteByName(""RR4A_RiverBank2"", allRoutes);
			FlightRouteInfo r5 = getRouteByName(""RR4B_RiverBank2"", allRoutes);

			if (r1 == null) {
				System.out.println(""RR2_SouthArea not found!!!"");
			}
			if (r2 == null) {
				System.out.println(""RR3A_RiverBank not found!!!"");
			}
			if (r3 == null) {
				System.out.println(""RR3B_RiverBank not found!!!"");
			}
			if (r4 == null) {
				System.out.println(""RR4A_RiverBank2 not found!!!"");
			}
			if (r5 == null) {
				System.out.println(""RR4B_RiverBank2 not found!!!"");
			}

			managerService.planFlight(""SBFD-2"", ""RR2_SouthArea"", r1.getWaypoints());
			managerService.planFlight(""SBFD-3"", ""RR3A_RiverBank"", r2.getWaypoints());
			managerService.planFlight(""SBFD-3"", ""RR3B_RiverBank"", r3.getWaypoints());
			managerService.planFlight(""SBFD-4"", ""RR4A_RiverBank2"", r4.getWaypoints());
			managerService.planFlight(""SBFD-4"", ""RR4B_RiverBank2"", r5.getWaypoints());
			Thread.sleep(2000);

		} catch (RemoteException | DronologyServiceException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NotBoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	private static FlightRouteInfo getRouteByName(String name, List<FlightRouteInfo> allRoutes) {
		for (FlightRouteInfo r : allRoutes) {
			if (r.getName().equals(name)) {
				return r;
			}

		}
		return null;
	}

	static Random rand = new Random();

}
"
JsonTester2.java,"package edu.nd.dronology.misc.gcs;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.util.Map;

import org.apache.commons.io.FileUtils;

import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import edu.nd.dronology.gstation.connector.messages.StateMessageTypeAdapter;
import edu.nd.dronology.gstation.connector.messages.UAVStateMessage;

public class JsonTester2 {

	static final Gson GSON = new GsonBuilder().serializeNulls()
			.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)
			.setVersion(1.0).serializeSpecialFloatingPointValues().registerTypeAdapter(Map.class, new StateMessageTypeAdapter()).create();

	public static void main(String[] args) {
		try {
			String string = FileUtils.readFileToString(new File(""D:\\state.txt""));

			UAVStateMessage message = GSON.fromJson(string, UAVStateMessage.class);
		
			
			System.out.println(message.getLocation());
			System.out.println(message.getGroundspeed());
			System.out.println(message.getUavid());
			System.out.println(message.getAttitude());
			System.out.println(message.getBatterystatus());
			System.out.println(message.getMode());
			System.out.println(message.getStatus());
			System.out.println(message.getVelocity());
			System.out.println(message.getLocation());
			System.out.println(message.getLocation());
			System.out.println(message.getLocation());
			
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}
"
DroneCollectionStatus.java,"package edu.nd.dronology.core.status;

import java.util.HashMap;
import java.util.Map;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.core.vehicle.proxy.UAVProxy;
import edu.nd.dronology.util.Immutables;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

// Singleton class
public class DroneCollectionStatus {

	private static final ILogger LOGGER = LoggerProvider.getLogger(DroneCollectionStatus.class);

	private Map<String, UAVProxy> drones;
	private static volatile DroneCollectionStatus INSTANCE = null;

	protected DroneCollectionStatus() {
		drones = new HashMap<>();
	}

	public static DroneCollectionStatus getInstance() {
		if (INSTANCE == null) {
			synchronized (DroneCollectionStatus.class) {
				if (INSTANCE == null) {
					INSTANCE = new DroneCollectionStatus();
				}
			}
		}
		return INSTANCE;
	}

	public void testStatus() {
		LOGGER.info(""Print current drone dump"");
		for (UAVProxy droneStatus : drones.values()) {
			LOGGER.info(droneStatus.toString());
		}
	}

	public Map<String, UAVProxy> getDrones() {
		return Immutables.hashMapCopy(drones);
	}

	public void addDrone(UAVProxy drone) {
		drones.put(drone.getID(), drone);
	}

	public void removeDrone(String droneID) {
		if (drones.containsKey(droneID)) {
			drones.remove(droneID);
		}
	}

	public void removeDrone(IUAVProxy drone) {
		if (drones.containsKey(drone.getID())) {
			drones.remove(drone.getID());
		}
	}

	public UAVProxy getDrone(String droneID) {
		if (drones.containsKey(droneID)) {
			return drones.get(droneID);
		}
		return null;
	}
}
"
UAVRegistrationServiceRemoteFacade.java,"package edu.nd.dronology.services.facades;

import java.rmi.RemoteException;
import java.util.Collection;

import org.apache.commons.lang.NotImplementedException;

import edu.nd.dronology.services.core.info.UAVRegistrationInfo;
import edu.nd.dronology.services.core.info.TypeRegistrationInfo;
import edu.nd.dronology.services.core.listener.IItemChangeListener;
import edu.nd.dronology.services.core.remote.IUAVRegistrationRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.instances.registration.uavs.UAVRegistrationService;
import edu.nd.dronology.services.remote.AbstractRemoteFacade;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class UAVRegistrationServiceRemoteFacade extends AbstractRemoteFacade implements IUAVRegistrationRemoteService {
	/**
	 * 
	 */
	private static final long serialVersionUID = -4580658378477037955L;
	private static final ILogger LOGGER = LoggerProvider.getLogger(UAVRegistrationServiceRemoteFacade.class);
	private static volatile UAVRegistrationServiceRemoteFacade INSTANCE;

	protected UAVRegistrationServiceRemoteFacade() throws RemoteException {
		super(UAVRegistrationService.getInstance());
	}

	public static IUAVRegistrationRemoteService getInstance() throws RemoteException {
		if (INSTANCE == null) {
			try {
				synchronized (UAVRegistrationServiceRemoteFacade.class) {
					if (INSTANCE == null) {
						INSTANCE = new UAVRegistrationServiceRemoteFacade();
					}
				}
			} catch (RemoteException e) {
				LOGGER.error(e);
			}
		}
		return INSTANCE;
	}

	@Override
	public byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException {
		return UAVRegistrationService.getInstance().requestFromServer(id);
	}

	@Override
	public void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException {
		UAVRegistrationService.getInstance().transmitToServer(id, content);

	}

	@Override
	public boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException {
		throw new NotImplementedException();
	}

	@Override
	public boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException {
		throw new NotImplementedException();
	}

	@Override
	public Collection<UAVRegistrationInfo> getItems() throws RemoteException {
		return UAVRegistrationService.getInstance().getItems();
	}

	@Override
	public UAVRegistrationInfo createItem() throws RemoteException, DronologyServiceException {
		return UAVRegistrationService.getInstance().createItem();
	}

	@Override
	public void deleteItem(String itemid) throws RemoteException, DronologyServiceException {
		// TODO Auto-generated method stub
		throw new NotImplementedException();
	}



}"
Utilities.java,"package edu.nd.dronology.services.extensions.areamapping.util;

import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Vector;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.services.core.areamapping.EdgeLla;
import edu.nd.dronology.services.core.items.FlightRoute;
import edu.nd.dronology.services.core.items.IFlightRoute;
import edu.nd.dronology.services.core.items.IMappedItem;
import edu.nd.dronology.services.extensions.areamapping.internal.Geometry;
import edu.nd.dronology.services.extensions.areamapping.internal.ImageWaypoint;
import edu.nd.dronology.services.extensions.areamapping.internal.ImageWaypoints;
import edu.nd.dronology.services.extensions.areamapping.internal.MapNode;
import edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;
import edu.nd.dronology.services.extensions.areamapping.internal.RiverList;
import edu.nd.dronology.services.extensions.areamapping.internal.SourcePoints;
import edu.nd.dronology.services.extensions.areamapping.model.RiverSubsegment;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive.RouteType;


public class Utilities {

    /**
     * This function calculates the average latitude.
     * @return average latitude
     */
    public static double getAvgLatitude(double minLatitude, double maxLatitude){
        return (minLatitude + maxLatitude)/2;
    }
    
    public static RiverBank edgeLlaToRiverBank(List<EdgeLla> input){
    	RiverBank newBank = new RiverBank();
    	for(EdgeLla entry : input) {
    		newBank.add(new Point2D.Double(entry.getLatitude(), entry.getLongitude()));
    	}
    	return newBank;
    }
    
    public static List<RiverBank> processDronologyInput(RiverBank bank1, RiverBank bank2, Vector<Double> latitudeBounds){
    	List<RiverBank> bankList = new ArrayList<>();
	    double minLatitude = 1000;
	    double maxLatitude = -1000;
	    double latitude;
	    for(Point2D.Double node : bank1.get()){
	        latitude = node.getX();
	        if(latitude < minLatitude){
	            minLatitude = latitude;
	        }
	        if(maxLatitude < latitude){
	            maxLatitude = latitude;
	        }
	    }
	    for(Point2D.Double node : bank2.get()){
	        latitude = node.getX();
	        if(latitude < minLatitude){
	            minLatitude = latitude;
	        }
	        if(maxLatitude < latitude){
	            maxLatitude = latitude;
	        }
	    }
	    double avgLatitude = getAvgLatitude(minLatitude, maxLatitude);
	    latitudeBounds.add(minLatitude);
	    latitudeBounds.add(maxLatitude);
	    bank1 = gpsRiverBankToCartesianRiverBank(avgLatitude, bank1);
	    bank2 = gpsRiverBankToCartesianRiverBank(avgLatitude, bank2);
	    bankList.add(bank1);
	    bankList.add(bank2);
	    return bankList;
    	
    }

    /**
     * This splits the nodes from the JSON input into vectors for each bank of the river and puts these vectors
     * into a list.
     * @param riverList
     * @return a list of Vectors of Point2D.Double representing the banks of the river
     */
    
    public static List<RiverBank> makeBankVectors(RiverList riverList, Vector<Double> latitudeBounds){
        List<RiverBank> bankList = new ArrayList<>();
        RiverBank bank1 = new RiverBank();
        RiverBank bank2 = new RiverBank();
        double minLatitude = 1000;
        double maxLatitude = -1000;
        double latitude;
        for(MapNode node : riverList.getNodes()){
            latitude = node.getLatitude();
            if(latitude < minLatitude){
                minLatitude = latitude;
            }
            if(maxLatitude < latitude){
                maxLatitude = latitude;
            }
            if(node.get_riverSide() == 1) {
                bank1.add(new Point2D.Double(node.getLatitude(),node.getLongitude()));
            } else {
                bank2.add(new Point2D.Double(node.getLatitude(),node.getLongitude()));
            }
        }
        double avgLatitude = getAvgLatitude(minLatitude, maxLatitude);
        latitudeBounds.add(minLatitude);
        latitudeBounds.add(maxLatitude);
        bank1 = gpsRiverBankToCartesianRiverBank(avgLatitude, bank1);
        bank2 = gpsRiverBankToCartesianRiverBank(avgLatitude, bank2);
        bankList.add(bank1);
        bankList.add(bank2);
        return bankList;
    }
    
    /**
     * This function converts the river bank vectors containing gps coordinates into vectors of cartesian
     * coordinates for all the calculations during the dynamic route generation algorithm.
     * @param avgLatitude
     * @param gpsBank
     * @return RiverBank in cartesian coordinates
     */
    private static RiverBank gpsRiverBankToCartesianRiverBank(double avgLatitude, RiverBank gpsBank) {
        RiverBank riverBank = new RiverBank();
        for(Point2D.Double entry : gpsBank.get()){
            riverBank.add(Geometry.gpsToCartesian(entry,avgLatitude));
        }
        return riverBank;
    }
    
    
    /**
     * This function converts the riverbank nodes from cartesian coordinates to gps coordinates.
     * @param avgLatitude
     * @param cartesianBank
     * @return RiverBank in gps coordinates
     */
    public static RiverBank cartesianRiverBankToGpsRiverBank(double avgLatitude, RiverBank cartesianBank) {
    	RiverBank riverBank = new RiverBank();
    	for(Point2D.Double entry : cartesianBank.get()){
            riverBank.add(Geometry.cartesianToGPS(entry,avgLatitude));
        }
        return riverBank;
    }
    
    
    /**
     * This function converts the route primitive to cartesian coordinates from gps coordinates.
     * @param l
     * @param avgLatitude
     * @return RoutePrimitive in cartesian coordinates
     */
    public static RoutePrimitive gpsRouteToCartesianRoute(RoutePrimitive l, double avgLatitude) {
    	for(int i = 0; i < l.size(); i++) {
    		l.setRouteWaypoint(i,Geometry.gpsToCartesian(l.getRouteWaypoint(i),avgLatitude));
    	}
    	return l;
    }

    /**
     * This function convertes the route primitive to gps coordinates from cartesian coordinates.
     * @param l
     * @return RoutePrimitive in gps coordinates
     */
    public static RoutePrimitive cartesianRouteToGpsRoute(RoutePrimitive l, double avgLatitude){
        for(int i = 0; i < l.size(); i++){
            l.setRouteWaypoint(i,Geometry.cartesianToGPS(l.getRouteWaypoint(i),avgLatitude));
        }
        return l;
    }

    /**
     * This function verifies the input order of the nodes from the JSON file to ensure that they are in the expected
     * order. It transforms them to the expected form if necessary.
     */
    
    /**
     * This function takes the RiverBanks created from the JSON file to make sure that they are in the necessary order.
     * @param gpsBank1
     * @param gpsBank2
     */
    public static void verifyInputOrder(RiverBank gpsBank1, RiverBank gpsBank2){
        Point2D.Double start1 = gpsBank1.get(0);
        Point2D.Double end1 = gpsBank1.get(gpsBank1.size()-1);
        Point2D.Double start2 = gpsBank2.get(0);
        Point2D.Double end2 = gpsBank2.get(gpsBank2.size()-1);
        boolean intersect = Line2D.linesIntersect(start1.getX(),start1.getY(),start2.getX(), start2.getY(),end1.getX(),end1.getY(),end2.getX(),end2.getY());
        if(intersect){
        	System.out.println(""bank2 reversed"");
            gpsBank2.reverse();
        }
    }

    /**
     * This function splits up the riverbank nodes into sections for each drone to search and returns a vector of lists
     * of vectors. Each list corresponds to the segment one drone will search, and each vector in the list
     * corresonds to a bank of the river.
     * @return a vector of lists corresponding to the section each drone will search
     */
    
    //note: don't really need this function anymore
    public static Vector<RiverSubsegment> makeRiverVectors(List<RiverBank> bankList, int drones, int bank1SegmentSize, int bank2SegmentSize){
        RiverBank riverBank1 = bankList.get(0);
        RiverBank riverBank2 = bankList.get(1);
        Vector<RiverSubsegment> riverVectors = new Vector<RiverSubsegment>();

        int counter1 = 0;
        int counter2 = 0;
        for(int i = 0; i < drones-1; i++){
            RiverSubsegment riverSegment = new RiverSubsegment();
            RiverBank bank1 = new RiverBank();


            makeVector1(counter1,bank1,riverBank1,bank1SegmentSize);
            riverSegment.add(bank1);
            counter1 += bank1SegmentSize-1;

            RiverBank bank2 = new RiverBank();
            makeVector2(counter2,bank2,riverBank2,bank2SegmentSize);
            riverSegment.add(bank2);
            counter2 += bank2SegmentSize -1;

            riverVectors.add(riverSegment);
        }
        RiverSubsegment riverSegment = new RiverSubsegment();
        RiverBank bank1 = new RiverBank();
        RiverBank bank2 = new RiverBank();
        makeFinalVectors(counter1,riverSegment,bank1,riverBank1);
        makeFinalVectors(counter2,riverSegment,bank2,riverBank2);
        riverVectors.add(riverSegment);
        return riverVectors;
    }

    /**
     * This function is a helper function for makeRiverVectors(). It forms the vectors of nodes for one bank
     * of the river except for the very last vector on that side.
     * @param counter1
     * @param bank1
     */
    private static void makeVector1(int counter1,  RiverBank bank1, RiverBank riverBank1, int bank1SegmentSize){
        for(int j = counter1; j < counter1 + bank1SegmentSize; j++){
            bank1.add(riverBank1.get(j));
        }
    }

    /**
     * This function is a helper function for makeRiverVectors(). It forms the vectors of nodes for the other bank
     * of the river except for the last vector on this side.
     * @param counter2
     * @param bank2
     */
    private static void makeVector2(int counter2, RiverBank bank2, RiverBank riverBank2, int bank2SegmentSize){
        for(int j = counter2; j < counter2 + bank2SegmentSize; j++){
            bank2.add(riverBank2.get(j));
        }
    }

    /**
     * This function is a helper function for makeRiverVectors(). It makes the last vector of nodes for each bank
     * of the river.
     * @param counter1
     * @param counter2
     * @param riverSegment
     * @param bank1
     * @param bank2
     */
    private static void makeFinalVectors(int counter, RiverSubsegment riverSegment, RiverBank bank, RiverBank riverBank){
        for(int j = counter; j < riverBank.size(); j++) {
            bank.add(riverBank.get(j));
        }
        riverSegment.add(bank);
    }
    
    
    /**
     * This function makes a polygon of the entire river segment. This allows checking for points contained within the 
     * river segment.
     * @param bankList
     * @return Path2D.Double polygon of the river segment
     */
    public static Path2D.Double makeTotalRiverSegment(List<RiverBank> bankList){
    	Path2D.Double totalSegment = new Path2D.Double();
    	RiverBank bank1 = bankList.get(0);
    	RiverBank bank2 = bankList.get(1);
    	totalSegment.moveTo(bank1.get(0).getX(), bank1.get(0).getY());
    	for(int i = 1; i < bank1.size(); i++) {
    		totalSegment.lineTo(bank1.get(i).getX(), bank1.get(i).getY());
    	}
    	for(int i = bank2.size()-1; i >= 0; i--) {
    		totalSegment.lineTo(bank2.get(i).getX(), bank2.get(i).getY());
    	}
    	return totalSegment;
    }

    /**
     * This function creates Path2D.Double shapes to represent each subsegment of the riversegment. This is used for
     * checking if a point is inside the shape, which is done to determine the stopping point for each search route.
     * @return vector of Path2D.Double shapes representing subsegments of the riversegment
     */
    //Assumes riverVectors has been called beforehand so that riverBanks are in cartesian coordinates
    public static Vector<Path2D.Double> makeRiverSegments(List<RiverBank> bankList, int drones, int bank1SegmentSize, int bank2SegmentSize){
    		Vector<Path2D.Double> riverSegments = new Vector<Path2D.Double>();
            RiverBank riverBank1 = bankList.get(0);
            RiverBank riverBank2 = bankList.get(1);
            int counter1 = 0;
            int counter2 = 0;
            for(int i = 0; i < drones-1; i++){
                Path2D.Double riverSegment = new Path2D.Double();
                Point2D.Double node0 = riverBank1.get(counter1);
                riverSegment.moveTo(node0.getX(),node0.getY());

                makeRiverbank1(counter1,riverSegment,riverBank1,bank1SegmentSize);
                counter1 += bank1SegmentSize-1;

                makeRiverbank2(counter2,riverSegment,riverBank2,bank2SegmentSize);
                counter2 += bank2SegmentSize -1;

                riverSegment.closePath();
                riverSegments.add(riverSegment);
            }
            Path2D.Double riverSegment = new Path2D.Double();
            Point2D.Double node0 = riverBank1.get(counter1);
            riverSegment.moveTo(node0.getX(),node0.getY());
            makeFinalSegment(counter1,counter2,riverSegment,riverBank1,riverBank2);
            riverSegment.closePath();
            riverSegments.add(riverSegment);
            return riverSegments;
    }

    /**
     * This function is a helper function for makeRiverSegments(). It adds the nodes from the first bank of the river
     * to the shape.
     * @param counter1
     * @param riverSegment
     */
    private static void makeRiverbank1(int counter1, Path2D.Double riverSegment, RiverBank riverBank1, int bank1SegmentSize){
        for(int j = counter1 + 1; j < counter1 + bank1SegmentSize; j++){
            Point2D.Double node = riverBank1.get(j);
            riverSegment.lineTo(node.getX(),node.getY());
        }
    }

    /**
     * This function is a helper function for makeRiverSegments(). It adds the nodes from the second bank of the river
     * to the shape.
     * @param counter2
     * @param riverSegment
     */
    private static void makeRiverbank2(int counter2, Path2D.Double riverSegment, RiverBank riverBank2, int bank2SegmentSize){
        for(int j = counter2 + bank2SegmentSize - 1; j >= counter2; j--){
            Point2D.Double node = riverBank2.get(j);
            riverSegment.lineTo(node.getX(),node.getY());
        }
    }

    /**
     * This function is a helper function for makeRiverSegments(). It adds the remaining nodes from each side of the
     * river to make the last subsegment of the riversegment.
     * @param counter1
     * @param counter2
     * @param riverSegment
     */
    private static void makeFinalSegment(int counter1,int counter2,Path2D.Double riverSegment, RiverBank riverBank1, RiverBank riverBank2) {
        for (int j = counter1 + 1; j < riverBank1.size(); j++) {
            Point2D.Double node = riverBank1.get(j);
            riverSegment.lineTo(node.getX(), node.getY());
        }
        for (int j = riverBank2.size() - 1; j >= counter2; j--) {
            Point2D.Double node = riverBank2.get(j);
            riverSegment.lineTo(node.getX(), node.getY());
        }
    }
    
    
    /**
     * This function generates image waypoints at a specified distance along a RoutePrimitive
     * @param route
     * @param APERATURE_HEIGHT
     * @param OVERLAP_FACTOR
     */
    public static void generateImageWaypoints(RoutePrimitive route, double APERATURE_HEIGHT, double OVERLAP_FACTOR) {
		Point2D.Double newPoint = new Point2D.Double();
		ImageWaypoint imagePoint = new ImageWaypoint();
		Point2D.Double point1;
		Point2D.Double point2;
		ImageWaypoints imagePoints = route.getIWP();
		double routeSegmentDistance;
		double traverseDistance = APERATURE_HEIGHT*OVERLAP_FACTOR;;
		double distanceRatio;
		double theta = Geometry.getAngle(route.getRouteWaypoint(0), route.getRouteWaypoint(1));
		imagePoints.add(new ImageWaypoint(route.getRouteWaypoint(0),theta));
		for(int i = 0; i < route.size()-1; i++) {
			point1 = route.getRouteWaypoint(i);
			point2 = route.getRouteWaypoint(i+1);
			theta = Geometry.getAngle(point1, point2);
			if(Geometry.findCartesianDistance(point1, imagePoints.get(imagePoints.size()-1).getWaypoint()) > 2.0) {
				imagePoints.add(new ImageWaypoint(point1,theta));
			}
			//imagePoints.add(point1);
			routeSegmentDistance = Geometry.findCartesianDistance(point1, point2);
			while(traverseDistance <= routeSegmentDistance) {
					distanceRatio = traverseDistance / routeSegmentDistance;
					newPoint = Geometry.findOffsetPoint(point1, point2, distanceRatio);
					imagePoints.add(new ImageWaypoint(newPoint,theta));
					routeSegmentDistance = routeSegmentDistance - traverseDistance;
					point1 = newPoint;
			} 
		}
		imagePoints.add(new ImageWaypoint(route.getRouteWaypoint(route.size()-1),theta));
    }
    
    private static int determineRouteSplit(RoutePrimitive route) {
    	int splitNumber = 1;
    	if(route.getRouteType() == RoutePrimitive.RouteType.CRISSCROSS || route.getRouteType() == RoutePrimitive.RouteType.INNER_CRISSCROSS) {
    		splitNumber = 4;
    	}
    	else if(route.getRouteType() == RoutePrimitive.RouteType.RIVERBANK) {
    		splitNumber = 2;
    	}
    	return splitNumber;
    }
  
    public static List<RoutePrimitive> splitRoutePrimitives(List<RoutePrimitive> currentRoutes, double APERATURE_HEIGHT, double OVERLAP_FACTOR){
    	List<RoutePrimitive> newRoutes = new ArrayList<>();
    	for(RoutePrimitive route : currentRoutes) {
    		int splitNumber = determineRouteSplit(route);
    		int nodesNumber = route.size() / splitNumber + 1;
    		int counter = 0;
    		boolean lastSplit = false;
    		for(int i = 0; i < splitNumber - 1; i++) {
    			newRoutes.add(smallerRoutePrimitive(route, nodesNumber, counter, lastSplit, APERATURE_HEIGHT, OVERLAP_FACTOR));
    			counter += nodesNumber - 1;
    		}
    		lastSplit = true;
    		newRoutes.add(smallerRoutePrimitive(route, nodesNumber, counter, lastSplit, APERATURE_HEIGHT, OVERLAP_FACTOR));
    	}
    	return newRoutes;
    }
    
    private static RoutePrimitive smallerRoutePrimitive(RoutePrimitive route, int nodesNumber, int startPoint, boolean lastSplit, double APERATURE_HEIGHT, double OVERLAP_FACTOR){
    	RoutePrimitive newRoute = new RoutePrimitive(route.getRouteType(),route.getRouteWeight());
    	if(lastSplit) {
    		nodesNumber  = route.size() - startPoint;
    	}
    	for(int i = startPoint; i < startPoint + nodesNumber; i++) {
    		newRoute.addRouteWaypoint(route.getRouteWaypoint(i));
    	}
    	generateImageWaypoints(newRoute, APERATURE_HEIGHT, OVERLAP_FACTOR);
    	return newRoute;
    }
//    // NOTE: change all of these to expect IFlightRoute instead of ExportRoutePrimitive
//    public static ExportAllocationInformation makeExportAllocationInformation(AllocationInformation allocationInformation) {
//    	ExportAllocationInformation newAllocationInformation = new ExportAllocationInformation();
//    	double altitude = 15;
//    	for(Drone drone : allocationInformation.getDroneAllocations()) {
//    		newAllocationInformation.addDroneAllocation(makeExportDrone(drone, altitude));
//    		altitude += 5;
//    	}
//    	newAllocationInformation.setMetricsStatistics(allocationInformation.getMetricStatistics());
//    	return newAllocationInformation;
//    }
    
//    public static ExportDrone makeExportDrone(Drone drone, double altitude) {
//    	ExportDrone newDrone = new ExportDrone();
//    	newDrone.setDroneStartPoint(new LlaCoordinate(drone.getDroneStartPoint().getX(), drone.getDroneStartPoint().getY(), altitude));
//    	newDrone.setDroneHomeLocation(new LlaCoordinate(drone.getDroneHomeLocation().getX(), drone.getDroneHomeLocation().getY(), altitude));
//    	newDrone.setUAVId(drone.getUAVId());
//    	newDrone.setDroneRouteAssignment(makeExportDroneRouteAssignment(drone.getDroneRouteAssignment(), altitude));
//    	return newDrone;
//    }
//    	
//    private static ExportDroneRouteAssignment makeExportDroneRouteAssignment(DroneRouteAssignment routeAssignment, double altitude) {
//    	ExportDroneRouteAssignment newRouteAssignment = new ExportDroneRouteAssignment();
//    	HashMap<RouteType, Integer> routePrimitiveCounters = new HashMap<>();
//    	routePrimitiveCounters.put(RouteType.CRISSCROSS, 0);
//    	routePrimitiveCounters.put(RouteType.RIVERBANK, 0);
//    	routePrimitiveCounters.put(RouteType.PRIORITYAREA, 0);
//    	for(RoutePrimitive routePrimitive : routeAssignment.get()) {
//    		newRouteAssignment.add(makeFlightRoute(routePrimitive, altitude, routePrimitiveCounters));
//    	}
//    	return newRouteAssignment;
//    }
    
    private static String assignFlightRouteName(RoutePrimitive route, HashMap<RoutePrimitive.RouteType, Integer> counters) {
    	RouteType routeType = route.getRouteType();
    	String name;
    	if(routeType == RouteType.CRISSCROSS) {
    		name = ""CrissCross Route "" + counters.get(RouteType.CRISSCROSS);
    		counters.put(RouteType.CRISSCROSS, counters.get(RouteType.CRISSCROSS) + 1);
    	}
    	else if(routeType == RouteType.RIVERBANK) {
    		name = ""RiverBank Route "" + counters.get(RouteType.RIVERBANK);
    		counters.put(RouteType.RIVERBANK, counters.get(RouteType.RIVERBANK) + 1);
    	} else {
    		name = ""PriorityArea Route "" + counters.get(RouteType.PRIORITYAREA);
    		counters.put(RouteType.PRIORITYAREA, counters.get(RouteType.PRIORITYAREA) + 1);
    	}
    	return name;
    }
    
    //edit to return IFlightRoute with name as something with type of route
    public static IFlightRoute makeFlightRoute(RoutePrimitive route, double altitude, HashMap<RoutePrimitive.RouteType, Integer> counters) {
    	IFlightRoute newRoute = new FlightRoute();
    	for(Point2D.Double entry : route.getRoute()) {
    		newRoute.addWaypoint(new Waypoint(new LlaCoordinate(entry.getX(), entry.getY(), altitude)));
    	}
    	newRoute.setName(assignFlightRouteName(route, counters));
    	return newRoute;
    }
    
    public static SourcePoints transformPriorityArea(IMappedItem area, double centralLatitude){
    	SourcePoints newArea = new SourcePoints(area.getImportance());
    	for(LlaCoordinate entry : area.getCoordinates()) {
    		Point2D.Double newPoint = new Point2D.Double(entry.getLatitude(), entry.getLongitude());
    		newArea.addSourcePoint(Geometry.gpsToCartesian(newPoint, centralLatitude));
    	}
    	return newArea;
    }
    
    public static void printRiverSegment(Vector<RiverSubsegment> riverVectors) {
    	System.out.println(""riverVectors: "");
		//printout for graph visualization
		System.out.printf(""["");
		for(RiverSubsegment l : riverVectors){
			System.out.printf(""["");
			for(RiverBank v : l.get()){
				System.out.printf(""["");
				for(Point2D.Double entry : v.get()){
					System.out.printf(""[""+entry.getX()+"",""+entry.getY()+""],"");
				}
				System.out.printf(""],"");
			}
			System.out.printf(""],"");
		}
		System.out.println(""]"");
    }
    
    public static void printRoutePrimitives(List<RoutePrimitive> routes) {
    	System.out.println(""routePrimitives: "");
		System.out.printf(""["");
		for(RoutePrimitive rList : routes){
			System.out.printf(""["");
			for(Point2D.Double entry: rList.getRoute()){
				System.out.printf(""[""+entry.getX()+"", ""+entry.getY()+""],"");
			}
			System.out.printf(""],"");
		}
		System.out.println(""]"");
    }
    
    public static void printImageWaypoints(List<RoutePrimitive> routes) {
    	System.out.println(""image Waypoints: "");
		System.out.printf(""["");
		for(RoutePrimitive rList : routes){
			ImageWaypoints imagePoints = rList.getIWP();
			System.out.printf(""["");
			for(ImageWaypoint entry: imagePoints.get()){
				System.out.printf(""[""+entry.getWaypoint().getX()+"", ""+entry.getWaypoint().getY()+""],"");
			}
			System.out.printf(""],"");
		}
		System.out.println(""]"");
    }
    
    public static void printSourcePoints(List<SourcePoints> sourcePoints) {
    	System.out.println(""sourcePoints: "");
		System.out.printf(""["");
		for(SourcePoints points : sourcePoints){
			System.out.printf(""["");
			for(Point2D.Double entry: points.getSourcePoints()){
				System.out.printf(""[""+entry.getX()+"", ""+entry.getY()+""],"");
			}
			System.out.printf(""],"");
		}
		System.out.println(""]"");
    }
    
    /**
     * This function prints out the information for python visualization 
     * @param riverVectors
     * @param routes
     */
    public static void debugPrintOut(Vector<RiverSubsegment> riverVectors,List<RoutePrimitive> routes){
    	printRiverSegment(riverVectors);
    	printRoutePrimitives(routes);
    	printImageWaypoints(routes);
	}
}


"
IMovementSimulator.java,"package edu.nd.dronology.core.simulator;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.vehicle.internal.VirtualDrone;

/**
 * 
 * The movement simulator simulates the movement of a {@link VirtualDrone} to reach its assigned waypoints.
 * 
 * @author Michael Vierhauser
 *
 */
public interface IMovementSimulator {

	boolean move(double i);

	void setFlightPath(LlaCoordinate currentPosition, LlaCoordinate targetCoordinates);

	void checkPoint();

	boolean isDestinationReached(double distanceMovedPerTimeStep);

}
"
StopCommand.java,"package edu.nd.dronology.core.collisionavoidance.guidancecommands;

/**
 * A command that tells the UAV to hover in place.
 */
public class StopCommand extends Command {

    private final double time;

    /**
     * <p>
     * Creates a stop command. This command tells the UAV to hover in place for the specified number of seconds. If
     * given a negative or zero time parameter, then this command will remain in effect indefinitely.
     * </p>
     * <p>
     * <p>
     * For example, to create a stop command that lasts for 10 seconds
     * <pre>
     *         {@code
     *         StopCommand stop = new StopCommand(10.0);
     *         }
     *     </pre>
     * </p>
     * <p>
     * <p>
     * To create a stop command that lasts until someone or something intervenes
     * <pre>
     *         {@code
     *         StopCommand stopForever = new StopCommand(0);
     *         }
     *     </pre>
     * </p>
     *
     * @param time in seconds that this stop command is to remain in effect. A value less than or equal to 0 indicates
     *             that this command should remain in effect indefinitely or until someone or something intervenes.
     */
    public StopCommand(double time) {
        this.time = time;
    }

    /**
     * Return the amount of time this command should remain in effect. A value less than or equal to 0 indicates that
     * this command should remain in effect indefinitely.
     *
     * @return time this stop command is to remain in effect. A value less than or equal to 0 indicates that this
     * command should remain in effect indefinitely.
     */
    public double getTime() {
        return time;
    }

    @Override
    public String toString() {
        return ""StopCommand("" + time + "" seconds)"";
    }
}
"
IUAVTypeRegistration.java,"package edu.nd.dronology.services.core.items;

import java.io.Serializable;

public interface IUAVTypeRegistration extends IPersistableItem {

	String getDescription();

	void setDescription(String description);

	Serializable getAttribute(String key);

	void addAttribute(String key, Serializable value);

	void setUAVImage(byte[] image);

	byte[] getImage();

}
"
StatusDispatchThread.java,"package edu.nd.dronology.gstation.connector.dispatch;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;

import edu.nd.dronology.core.IUAVPropertyUpdateNotifier;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.status.DronologyListenerManager;
import edu.nd.dronology.core.vehicle.DroneFlightStateManager.FlightMode;
import edu.nd.dronology.gstation.connector.messages.AbstractUAVMessage;
import edu.nd.dronology.gstation.connector.messages.UAVModeChangeMessage;
import edu.nd.dronology.gstation.connector.messages.UAVStateMessage;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class StatusDispatchThread extends AbstractStatusDispatchThread<AbstractUAVMessage> implements Callable {
	private static final ILogger LOGGER = LoggerProvider.getLogger(StatusDispatchThread.class);

	private IUAVPropertyUpdateNotifier listener;

	public StatusDispatchThread(final BlockingQueue<AbstractUAVMessage> queue, IUAVPropertyUpdateNotifier listener) {
		super(queue);
		this.listener = listener;
	}

	protected void notifyListener() throws Exception {

	}

	@Override
	public Object call() {
		while (cont.get()) {

			try {
				AbstractUAVMessage state = queue.take();
				if (state instanceof UAVStateMessage) {
					UAVStateMessage sm = (UAVStateMessage) state;
					LlaCoordinate location = sm.getLocation();
					double level = sm.getBatterystatus().getBatteryLevel();
					double speed = sm.getGroundspeed();
					listener.update(location, level, speed, sm.getVelocity(), sm.getAttitude());
				} else if (state instanceof UAVModeChangeMessage) {
					UAVModeChangeMessage mcm = (UAVModeChangeMessage) state;
					
					listener.updateMode(mcm.getMode());

					// If the new mode is LOITER, we should remove this drone from its mission plan
					// (if it has one).
					// TODO: determine if this is actually the right place to do this.
					// TODO: potentially create an enum for mode names.
					if (mcm.getMode().equals(FlightMode.USER_CONTROLLED.toString())) {
						DronologyListenerManager.getInstance().notifyUAVRemoved(mcm.getUavid());
						// notify flight plan pool... remove active plans..

					}

				} else {
					LOGGER.error(""Unhandled message type detected "" + state.getClass());
				}
			} catch (InterruptedException e) {
				LOGGER.warn(""Status Dispatch Thread terminated"");
			} catch (Exception e) {
				LOGGER.error(e);
			}

		}
		LOGGER.info(""Dispatcher shutdown!"");
		return null;
	}

}
"
ExportDroneRouteAssignment.java,"package edu.nd.dronology.services.core.unused;
//package edu.nd.dronology.services.core.areamapping;
//
//import java.io.Serializable;
//import java.util.ArrayList;
//import java.util.Collections;
//import java.util.List;
//
//import edu.nd.dronology.services.core.items.FlightRoute;
//import edu.nd.dronology.services.core.items.IFlightRoute;
//
//public class ExportDroneRouteAssignment implements Serializable {
//	/**
//	 * 
//	 */
//	private static final long serialVersionUID = -942703933531286156L;
//	List<IFlightRoute> droneRoute;
//	
//	public ExportDroneRouteAssignment() {
//		droneRoute = new ArrayList<>();
//	}
//	
//	public void add(IFlightRoute flightRoute) {
//		droneRoute.add(flightRoute);
//	}
//	
//	public List<IFlightRoute> get(){
//		return Collections.unmodifiableList(droneRoute);
//	}
//	
//	public IFlightRoute get(int entry) {
//		return droneRoute.get(entry);
//	}
//	
//	public void set(int index, FlightRoute entry) {
//		droneRoute.set(index, entry);
//	}
//	
//	public void setDroneRouteAssignment(List<IFlightRoute> assignment) {
//		droneRoute = assignment;
//	}
//}
"
AMInfoPanel.java,"package edu.nd.dronology.ui.vaadin.areamapping;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import com.vaadin.ui.Button;
import com.vaadin.ui.ComboBox;
import com.vaadin.ui.Component;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.Panel;
import com.vaadin.ui.VerticalLayout;

import edu.nd.dronology.services.core.info.AreaMappingInfo;
import edu.nd.dronology.services.core.remote.IAreaMappingRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.ui.vaadin.areamapping.windows.AMUnsavedChangesConfirmation.ChangeType;
import edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;
import edu.nd.dronology.ui.vaadin.start.MyUI;

/**
 * This is the side panel that shows the list of existing mappings.
 * 
 * @author Andrew Slavin
 *
 */

public class AMInfoPanel extends CustomComponent{
	
	private static final long serialVersionUID = 3661239148456256352L;

	private VerticalLayout mappingListLayout = new VerticalLayout(); // contains list of mappings
	private MapCreationComponent mapCreation; // contains new mapping and sub-map buttons
	private VerticalLayout inPanelLayout = new VerticalLayout(); // contains mapCreation and mappingListLayout
	private AMControlsComponent controlComponent;
	private Panel panel = new Panel();
	private List<String> mappingList = new ArrayList<>();
	ComboBox<String> comboBox = new ComboBox<>(); // search bar for existing mappings
	
	public AMInfoPanel(AMControlsComponent controls) {
		controlComponent = controls;
		mapCreation = new MapCreationComponent(this, controls);
		inPanelLayout.addComponents(mapCreation, comboBox, mappingListLayout);
		panel.setContent(inPanelLayout);
		panel.addStyleName(""am_info_panel"");
		panel.addStyleName(""control_panel"");

		setCompositionRoot(panel);
		
        BaseServiceProvider provider=MyUI.getProvider();
		
		refreshMappings();
		refreshSearchBar();
		comboBox.setItems(mappingList);
		comboBox.setSizeFull();
		
	    //highlight the route chosen on the map 
		comboBox.addValueChangeListener(event -> {
        	
        	String name=comboBox.getValue();
        	
        	IAreaMappingRemoteService service;
        	 try {
             	service=(IAreaMappingRemoteService) provider.getRemoteManager().getService(IAreaMappingRemoteService.class);
             	List<AreaMappingInfo> allMappings = new ArrayList<>(service.getItems());
             	Collections.sort(allMappings, new AreaMappingIntoNameComparator());
             	
             	//puts the routes into the list that gets loaded onto the search bar 
             	for(AreaMappingInfo mapping : allMappings ) {
             		if (name.equals(mapping.getName())) {
             			controls.getInfoPanel().unhighlightAllInfoBoxes();
            			controls.getInfoPanel().highlightInfoBox(controls.getInfoPanel().getMappingIndex(mapping));

                		// Displays the mapping on map also.
            			controlComponent.getMainLayout().setMapComponent(controls.getMainLayout().getMapComponent());
            			controlComponent.getMainLayout().getMapComponent().getMetaInfo().showInfoForSelectedMapping(mapping);
            			controlComponent.getMainLayout().getMapComponent().displayAreaMapping(mapping);
            			controlComponent.getMainLayout().getMapComponent().setMappingCenter();
                		break;
             		}
        	 	}
             	
             } catch(RemoteException | DronologyServiceException e) {
             	MyUI.setConnected(false);
             	e.printStackTrace();
             }
        	 // reset search bar
        	 comboBox.setValue("""");
        });
		
		// click listener for when another mapping is selected
		mappingListLayout.addLayoutClickListener(e -> {
			// if editing, bring up unsaved changes box
			if (controls.getMainLayout().getMapComponent().getMapUtilities().getSidesAreEditable() || controls.getMainLayout().getMapComponent().getMapUtilities().getPrioritiesAreEditable()) {
				controls.getMainLayout().getUnsavedChangesConfirmation()
						.showWindow(this.getHighlightedAMInfoBox().getAreaMappingInfo().getName(), ChangeType.SWITCH_MAPPING, e);
			} else {
				// If map is not in edit mode, then just switch to the other mapping.
				Component childComponent = e.getChildComponent();
				if (childComponent != null && childComponent.getClass().equals(AMInfoBox.class)) {
					controls.getMainLayout().switchMapping((AMInfoBox) childComponent);
				}
			}
		});
		
	}
	
	

	// Ensures mappings are updated by removing and re-adding mappings.
	public void refreshMappings() {
		AMInfoBox highlightedBox = this.getHighlightedAMInfoBox();
		String highlightedId = highlightedBox == null ? """" : highlightedBox.getId();

		mappingListLayout.removeAllComponents();
		Collection<AreaMappingInfo> allMappings = getMappingsFromDronology();
		panel.setCaption(allMappings.size() + "" Mappings"");

		// Iterates through the mappings, gets the fields of each, and creates an infobox.
		for (AreaMappingInfo info : allMappings) {
			AMInfoBox mappingBox = addMapping(info);
			// To preserve previous route selection
			if (highlightedId.equals(mappingBox.getId())) {
				this.getControls().getMainLayout().switchMapping(mappingBox);
			}
		}
	}
	
	//ensures that the routes in the search bar are updated by removing and re-adding them
	public void refreshSearchBar() {
		
		//puts the routes into the list that gets loaded onto the search bar
		mappingList.clear();
		
		Collection<AreaMappingInfo> allMappings = getMappingsFromDronology();
		for(AreaMappingInfo mapping : allMappings )
    	{
    		mappingList.add(mapping.getName());
    	}
		comboBox.setItems(mappingList);
	}
	
	// fetch mappings information from dronology
	public Collection<AreaMappingInfo> getMappingsFromDronology() {
		IAreaMappingRemoteService service;
		BaseServiceProvider provider = MyUI.getProvider();
		try {
			service = (IAreaMappingRemoteService) provider.getRemoteManager()
					.getService(IAreaMappingRemoteService.class);
			List<AreaMappingInfo> allMappings = new ArrayList<>(service.getItems());
			Collections.sort(allMappings, new AreaMappingIntoNameComparator());

			return allMappings;
		} catch (RemoteException | DronologyServiceException e) {
			MyUI.setConnected(false);
			e.printStackTrace();
		}
		return null;
	}
	
	// Gets AreaMappingInfo based on mapping index.
	public AreaMappingInfo getAreaMappingInfo(int index) {
		return ((AMInfoBox) mappingListLayout.getComponent(index)).getAreaMappingInfo();
	}

	// Gets the mapping index based on the AreaMappingInfo.
	public int getMappingIndex(AreaMappingInfo info) {
		for (int i = 0; i < mappingListLayout.getComponentCount(); i++) {
			if (info.equals(((AMInfoBox) mappingListLayout.getComponent(i)).getAreaMappingInfo()))
				return i;
		}
		return -1;
	}

	// Gets the mapping info box based on the AreaMappingInfo.
	public AMInfoBox getMappingInfoBox(AreaMappingInfo info) {
		for (int i = 0; i < mappingListLayout.getComponentCount(); i++) {
			if (info.equals(((AMInfoBox) mappingListLayout.getComponent(i)).getAreaMappingInfo()))
				return (AMInfoBox) mappingListLayout.getComponent(i);
		}
		return null;
	}

	// Gets the mapping info box based on the AreaMappingInfo id.
	public AMInfoBox getMappingInfoBox(String id) {
		for (int i = 0; i < mappingListLayout.getComponentCount(); i++) {
			if (id.equals(((AMInfoBox) mappingListLayout.getComponent(i)).getAreaMappingInfo().getId()))
				return (AMInfoBox) mappingListLayout.getComponent(i);
		}
		return null;
	}

	// Adds a mapping to the infobox based on parameters.
	public AMInfoBox addMapping(AreaMappingInfo areaMappingInfo) {
		AMInfoBox mappingBox = new AMInfoBox(this, areaMappingInfo);
		mappingListLayout.addComponent(mappingBox);
		return mappingBox;
	}

	public void unhighlightAllInfoBoxes() {
		for (int i = 0; i < mappingListLayout.getComponentCount(); i++) {
			mappingListLayout.getComponent(i).removeStyleName(""info_box_focus"");
		}
	}

	public void highlightInfoBox(int index) {
		mappingListLayout.getComponent(index).addStyleName(""info_box_focus"");
	}

	public AMInfoBox getHighlightedAMInfoBox() {
		for (int i = 0; i < mappingListLayout.getComponentCount(); i++) {
			if (mappingListLayout.getComponent(i).getStyleName().contains(""info_box_focus""))
				return (AMInfoBox) mappingListLayout.getComponent(i);
		}
		return null;
	}

	// Gets the mapping layout.
	public VerticalLayout getMappings() {
		return mappingListLayout;
	}

	// Gets the controls component that was passed in through the constructor.
	public AMControlsComponent getControls() {
		return controlComponent;
	}

	// Gets the button used to display the mapping creation window.
	public Button getNewMappingButtonFromCreationComponent() {
		return mapCreation.getNewMappingButton();
	}

	// Removes the current window (used to remove mapping creation window).
	public void removeNewMappingWindow() {
		mapCreation.removeNewMappingWindow();
	}	
}
"
UAVHandshakeMessage.java,"package edu.nd.dronology.gstation.connector.messages;

import java.io.Serializable;
import java.util.Map;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

public class UAVHandshakeMessage extends AbstractUAVMessage<Object> implements Serializable {

	private static final long serialVersionUID = 1502042637906425729L;
	public static final String MESSAGE_TYPE = ""handshake"";
	public static final String HOME = ""home"";
	public static final String SAFETY_CASE = ""safetycase"";

	public UAVHandshakeMessage(String groundstationid, String uavid) {
		super(MESSAGE_TYPE, groundstationid, uavid); 
	}

	public LlaCoordinate getHome() {
		if (data.get(HOME) instanceof LlaCoordinate) {
			return (LlaCoordinate) data.get(HOME);
		}
		Map<String, Double> homeMap = (Map<String, Double>) data.get(HOME);
		data.put(HOME, new LlaCoordinate(homeMap.get(""x""), homeMap.get(""y""), homeMap.get(""z"")));
		return (LlaCoordinate) data.get(HOME);
	}

	public String getSafetyCase() {
		return data.get(SAFETY_CASE) != null ? data.get(SAFETY_CASE).toString() : null;
	}

	public void setHome(LlaCoordinate coordinate) {
		data.put(HOME, coordinate);

	}

}
"
FullMissionPlan2.java,"package edu.nd.dronology.services.extensions.missionplanning.plan;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import edu.nd.dronology.core.DronologyConstants;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.info.UAVMappingInfo;
import edu.nd.dronology.services.core.items.IMissionPlan;
import edu.nd.dronology.services.core.items.IUAVMissionDescription;
import edu.nd.dronology.services.core.items.IUAVMissionTask;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;
import edu.nd.dronology.services.extensions.missionplanning.sync.SynchronizationManager;
import edu.nd.dronology.services.extensions.missionplanning.tasks.TaskFactory;
import edu.nd.dronology.services.instances.dronesetup.DroneSetupService;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Manages a mission plan. Each Mission plan has one
 * <code>FullMissionPlan</code> instance, and one <code>UAVMissionPlan</code>
 * instance for each UAV in the Mission plan. <br>
 * Each of the UAV's individual mission plans are composed of MissionTasks. <br>
 * Once the entire mission plan is loaded, a thread is created which checks each
 * of the individual UAVMissionPlans to determine if they can start the next
 * task.
 * 
 * @author Jane Cleland-Huang
 */
public class FullMissionPlan2 implements IExecuteableMissionPlan {

	private static final ILogger LOGGER = LoggerProvider.getLogger(FullMissionPlan2.class);

	private Map<String, UAVMissionPlan> uavMissionPlans;
	private SynchronizationManager synchPointMgr;

	private IMissionPlan instructions;

	private UAVMappingInfo mapping;

	/**
	 * Constructs the CoordinatedMission instance. A mission consists of one or more
	 * UAVs, each of which has a set of assigned tasks and synchronization points.
	 * 
	 * @param instructions
	 * 
	 * @param mission
	 */
	FullMissionPlan2(IMissionPlan instructions) {
		this.instructions = instructions;
		uavMissionPlans = new HashMap<>();
		synchPointMgr = SynchronizationManager.getInstance();

	}

	/**
	 * Adds an additional UAV to the mission plan. Creates the
	 * <code>UAVMissionTasks</code> instance and passes it a reference to the
	 * <code>synchPointMgr</code>
	 * 
	 * @param uavID
	 *            the ID of the UAV
	 * @return
	 * @throws MissionExecutionException
	 */
	public UAVMissionPlan addUAV(String uavID) throws MissionExecutionException {
		LOGGER.info(""Adding UAV: "" + uavID);
		UAVMissionPlan plan = new UAVMissionPlan(uavID, synchPointMgr);
		if (uavMissionPlans.containsKey(uavID)) {
			throw new MissionExecutionException(""Mission Plan for UAV '"" + uavID + ""' already defined"");
		}
		uavMissionPlans.put(uavID, plan);
		return plan;
	}

	public void removeUAV(String uavID) {
		uavMissionPlans.remove(uavID);
	}

	/**
	 * Assigns a task to a specific UAV
	 * 
	 * @param uavID
	 *            UAV Identifier
	 * @param task
	 *            Task to perform (e.g., Route, Waypoint, Synchronize,
	 *            FlightPattern)
	 * @param taskID
	 *            Task specifics (e.g., specific waypoint, route name etc)
	 * @throws MissionExecutionException
	 */
	public void addTask(String uavID, String task, String taskID, Map<String, Serializable> params)
			throws MissionExecutionException {
		LOGGER.info(""Adding Task to uav ':"" + uavID + ""' -- "" + task + "" -- "" + taskID);
		for (UAVMissionPlan plan : uavMissionPlans.values()) {
			if (plan.getUavID().equals(uavID)) {
				plan.addTask(TaskFactory.getTask(task, uavID, taskID, params), synchPointMgr);
				return;
			}
		}
		throw new MissionExecutionException(""UAVMissionPlan '"" + uavID + ""' not available!"");
	}

	@Override
	public boolean isMissionActive() {
		for (UAVMissionPlan plan : uavMissionPlans.values()) {
			if (plan.hasTasks()) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Build all synch points
	 */
	private void buildAllSynchPoints() {
		uavMissionPlans.forEach((uavId, plan) -> {
			plan.buildSynchPoints();
		});
	}

	/**
	 * Activates next task in each UAV mission, if there is no unfinished active
	 * task
	 * 
	 * @throws MissionExecutionException
	 */
	@Override
	public void checkAndActivateTask() throws MissionExecutionException {
		for (UAVMissionPlan plan : uavMissionPlans.values()) {
			if (!plan.hasActiveTask()) {
				plan.activateNextTask();
			}
		}
	}

	/**
	 * Expands flight pattern tasks (e.g., coordinatedTakeOff or coordinatedLanding)
	 * 
	 * @throws MissionExecutionException
	 * 
	 */
	private void expandAllTasks() throws MissionExecutionException {
		for (UAVMissionPlan plan : uavMissionPlans.values()) {
			plan.expandTaskList();
		}
	}

	public void build(UAVMappingInfo mapping) throws MissionExecutionException {
		try {
			this.mapping = mapping;
			addUAVS();
			expandAllTasks();
			buildAllSynchPoints();
			synchPointMgr.activateAllSynchPoints();
			runPreChecks();
		} catch (Throwable t) {
			t.printStackTrace();
			throw t;
		}

	}

	private void addUAVS() throws MissionExecutionException {
		for (IUAVMissionDescription desc : instructions.getMissionDescriptions()) {
			createPlan(desc);
		}
	}

	private void createPlan(IUAVMissionDescription desc) throws MissionExecutionException {
		String uavid = desc.getName();
		if (mapping.getAttribute(desc.getName()) != null) {
			uavid = mapping.getAttribute(desc.getName());
		}

		UAVMissionPlan plan = addUAV(uavid);
		for (IUAVMissionTask t : desc.getTasks()) {
			addTask(plan.getUavID(), t.getType(), t.getId(), t.getParameters());
		}

	}

	private void runPreChecks() throws MissionExecutionException {
		for (Entry<String, UAVMissionPlan> e : uavMissionPlans.entrySet()) {
			checkDistance(e.getKey(), e.getValue());
		}
	}

	private void checkDistance(String uavid, UAVMissionPlan plan) throws MissionExecutionException {
		LlaCoordinate coordinate = plan.getStartingRouteWaypoint();
		IUAVProxy uav = null;
		if (coordinate == null) {
			throw new MissionExecutionException(""Error when retrieving first waypoint for uav '"" + uavid + ""'"");
		}
		try {
			uav = DroneSetupService.getInstance().getActiveUAV(uavid);
		} catch (DronologyServiceException e) {
			throw new MissionExecutionException(e.getMessage());
		}
		double distanceToFirstWaypoint = uav.getCoordinates().distance(coordinate);
		if (distanceToFirstWaypoint > DronologyConstants.MISSION_MAX_STARTING_DISTANCE) {
			throw new MissionExecutionException(
					""Distance to first waypoint exceeds maximum safety distance: "" + distanceToFirstWaypoint + ""m"");
		}
		LOGGER.info(""Precheck passed -- Distance to first waypoint: "" + distanceToFirstWaypoint);

	}

	@Override
	public void cancelMission() {
		LOGGER.missionError(""Mission cancelled!"");
		for (UAVMissionPlan plan : uavMissionPlans.values()) {
			String uavid = plan.getUavID();
			MissionUtil.stopUAV(uavid);
		}
	}

}
"
MissionHandler.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStream;

import com.vaadin.ui.Upload.Receiver;
import com.vaadin.ui.Upload.SucceededEvent;
import com.vaadin.ui.Upload.SucceededListener;

import edu.nd.dronology.services.core.info.MissionInfo;
import edu.nd.dronology.services.core.remote.IMissionPlanningRemoteService;
import edu.nd.dronology.ui.vaadin.start.MyUI;

public class MissionHandler {

	//private MissionUploader receiver;

	public MissionHandler() {
		//receiver = new MissionUploader();
	}

	public void executeMission() {
		// System.out.println(""UPLOAD!!"");
		try {
			// Upload upload = new Upload(""Upload Image Here"", receiver);
			// upload.setButtonCaption(""Select"");
			//System.out.println(""STRING:"" + missionContent);
			IMissionPlanningRemoteService missionService = (IMissionPlanningRemoteService) MyUI.getProvider()
					.getRemoteManager().getService(IMissionPlanningRemoteService.class);

			missionService.executeMissionPlan(missionContent);
		} catch (Exception e) {
			MyUI.setConnected(false);
			e.printStackTrace();
		}

	}
/*
	public MissionUploader getReceiver() {
		return receiver;
	}
*/	
	public void setMissionContent(MissionInfo info) {
		missionContent = info;
	}
	

	// Show uploaded file in this placeholder
	MissionInfo missionContent;

	// Implement both receiver that saves upload in a file and
	// listener for successful upload
	
	//class MissionUploader implements Receiver, SucceededListener {
		/**
		 * 
		 */
	/*
		private static final long serialVersionUID = -533969977302422170L;
		public File file;

		@Override
		public OutputStream receiveUpload(String filename, String mimeType) {
			System.out.println(""UPLOAD!!!!"");
			FileOutputStream fos = null; // Output stream to write to
			try {
				System.out.println(filename);

				// file = new File(""c:\\tmp\\uploads\\"" + filename);
				file = File.createTempFile(""abc"", ""tmp"");
				file.createNewFile();
				fos = new FileOutputStream(file);
			} catch (Throwable e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				return null;
			}
			// ...
			return fos;
		}

		
		@Override
		public void uploadSucceeded(SucceededEvent event) {
			try {
				missionContent = readFile(file.getAbsolutePath());
				executeMission();
			} catch (Throwable e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		public String readFile(String absolutePath) {
			StringBuilder contents = new StringBuilder();
			BufferedReader buf = getBufferedFileReader(absolutePath);
			String line;
			try {
				while (buf != null && (line = buf.readLine()) != null) {
					contents.append(line + System.lineSeparator());
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
			return contents.toString();
		}

		public BufferedReader getBufferedFileReader(String absolutePath) {
			FileReader fr = null;
			BufferedReader buf = null;
			try {
				String path = absolutePath;
				fr = new FileReader(path);
				buf = new BufferedReader(fr);
			} catch (FileNotFoundException e) {
				// OGGER.Lwarn(""Could not read file: "" + absolutePath);
				e.printStackTrace();

			}
			return buf;
		}
		
	};
	*/
}

"
UAVEquipmentTypeRegistrationPersistenceProvider.java,"package edu.nd.dronology.services.core.persistence;

import edu.nd.dronology.services.core.items.IUAVEquipmentTypeRegistration;
import edu.nd.dronology.services.core.items.IUAVRegistration;
import edu.nd.dronology.services.core.persistence.internal.UAVEquipmentTypeRegistrationXStreamPersistor;


/**
 * Provider implementation for {@link IUAVRegistration}.<br>
 * Details see {@link AbstractItemPersistenceProvider}
 * 
 * @author Michael Vierhauser
 * 
 */
public class UAVEquipmentTypeRegistrationPersistenceProvider extends AbstractItemPersistenceProvider<IUAVEquipmentTypeRegistration> {

	public UAVEquipmentTypeRegistrationPersistenceProvider() {
		super();
	}

	@Override
	protected void initPersistor() {
		PERSISTOR = new UAVEquipmentTypeRegistrationXStreamPersistor();

	}

	@Override
	protected void initPersistor(String type) {
		initPersistor();
	}

	public static UAVEquipmentTypeRegistrationPersistenceProvider getInstance() {
		return new UAVEquipmentTypeRegistrationPersistenceProvider();
	}

}
"
UAVMonitorableMessage.java,"package edu.nd.dronology.core.monitoring.messages;

import java.io.Serializable;
import java.text.DateFormat;

import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import edu.nd.dronology.core.monitoring.ArtifactIdentifier;
import edu.nd.dronology.core.monitoring.IMonitorableMessage;
import edu.nd.dronology.core.util.FormatUtil;
import edu.nd.dronology.core.util.PreciseTimestamp;

/**
 * 
 * Base class for all monitorable messages.
 * 
 * @author Michael Vierhauser
 *
 */
public class UAVMonitorableMessage implements IMonitorableMessage {

	/**
	 * 
	 */
	private static final long serialVersionUID = -9170213896841874463L;
	static final transient Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()
			.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).setVersion(1.0)
			.serializeSpecialFloatingPointValues().create();

	public enum MessageType {
		COMMAND, STATE_CHANGE, PLAN_ACTIVATED, GCS_MONITORING, WAYPOINT_REACHED, PLAN_COMPLETE, VIRTUAL_UAV_ACTIVATED, PHYSICAL_UAV_ACTIVATED, PHYSICAL_UAV_DEACTIVATED, FENCE_BREACH, FENCE_CHECK, MISSION_WAYPOINT, COLLISION
	}

	private final MessageType type;
	private final PreciseTimestamp timestamp;
	private final ArtifactIdentifier id;
	private String uavid;
	private String data;
	private String datatype;

	public UAVMonitorableMessage(MessageType type, String uavid) {
		this(type, uavid, null);
	}

	public UAVMonitorableMessage(MessageType type, String uavid, Serializable data) {
		timestamp = PreciseTimestamp.create();
		this.type = type;
		this.uavid = uavid;
		this.id = new ArtifactIdentifier(ArtifactIdentifier.ROOT, ""INTERNAL"", type.toString(), uavid);
		if (data != null) {
			this.data = GSON.toJson(data);
			this.datatype = data.getClass().getSimpleName();
		}
	}

	@Override
	public MessageType getType() {
		return type;
	}

	@Override
	public PreciseTimestamp getTimestamp() {
		return timestamp;
	}

	@Override
	public String getUavid() {
		return uavid;
	}

	@Override
	public String getData() {
		return data;
	}

	@Override
	public ArtifactIdentifier<?> getIdentifier() {
		return id;

	}

	public String getDataType() {
		return datatype;
	}

	@Override
	public String toString() {
		return FormatUtil.formatTimestamp(timestamp) + "" [Message: "" + type + "" | uav:"" + uavid + "" | "" + data + "" ]"";

	}

}
"
IStartstrategy.java,"package edu.nd.dronology.core.vehicle.uav;

public interface IStartstrategy {

}
"
AssignedDrone.java,"package edu.nd.dronology.services.core.items;

import edu.nd.dronology.core.CoordinateChange;
import edu.nd.dronology.core.coordinate.LlaCoordinate;

public class AssignedDrone {

	public final String droneName;
	public LlaCoordinate startCoordinate = new LlaCoordinate(0, 0, 0);

	public AssignedDrone(String droneName) {
		super();
		this.droneName = droneName;
	}

	public LlaCoordinate getStartCoordinate() {
		return startCoordinate;
	}

	@CoordinateChange
	public void setStartCoordinate(double latitude, double longitude, double altitude) {
		startCoordinate = new LlaCoordinate(latitude, longitude, altitude);

	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((droneName == null) ? 0 : droneName.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		AssignedDrone other = (AssignedDrone) obj;
		if (droneName == null) {
			if (other.droneName != null)
				return false;
		} else if (!droneName.equals(other.droneName))
			return false;
		return true;
	}

	public String getName() {
		return droneName;
	}

}
"
MapNode.java,"package edu.nd.dronology.services.extensions.areamapping.internal;



//Class defining nodes along the riverbanks
public class MapNode {
  double _latitude;
  double _longitude;
  int _riverSide;

  public MapNode(double latitude, double longitude, int riverside){
      _latitude = latitude;
      _longitude = longitude;
      _riverSide = riverside;
  }

  public double getLatitude() {
      return _latitude;
  }
  public double getLongitude(){
      return _longitude;
  }
  public int get_riverSide(){
      return _riverSide;
  }
}

"
TreeNode.java,"package edu.nd.dronology.monitoring.tree;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

import edu.nd.dronology.core.monitoring.ArtifactIdentifier;
import edu.nd.dronology.util.Immutables;
import edu.nd.dronology.util.NullUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * A tree node which can hold elements at a node (a set of ArtifactIdentifier)
 * and<br/>
 * have some children identified by ArtifactIdentifier.
 * 
 * 
 */

public class TreeNode {
	private static final ILogger LOGGER = LoggerProvider.getLogger(TreeNode.class);

	private final ArtifactIdentifier artifactIdentifier;

	private final Set<ArtifactIdentifier> elements = new HashSet<>();

	private final WeakHashMap<ArtifactIdentifier, TreeNode> children = new WeakHashMap<>();

	private TreeNode parent;

	public TreeNode(ArtifactIdentifier id) {
		NullUtil.checkNull(id);
		this.artifactIdentifier = id;
	}

	public synchronized ArtifactIdentifier getArtifactIdentifier() {
		return artifactIdentifier;
	}

	/**
	 * Returns an existing child or creates a new one, if none present.
	 * 
	 * @param id
	 * @return The child with the given identifier.
	 */
	public synchronized TreeNode getChild(final ArtifactIdentifier id) {
		if (id == null) {
			throw new IllegalArgumentException(""Parameter id can't be null!"");
		}
		if (children.containsKey(id)) {
			return children.get(id);
		}
		TreeNode node = new TreeNode(id);
		children.put(id, node);
		node.setParent(this);
		return node;
	}

	private void setParent(TreeNode treeNode) {
		this.parent = treeNode;

	}

	public synchronized boolean addElement(ArtifactIdentifier id) {
		if (elements.contains(id)) {
			for (ArtifactIdentifier elem : elements) {
				if (elem.equals(id)) {
					elem.attachItems(id.getAttachedItems());
					return true;
				}
			}
		}
		return elements.add(id);
	}

	public synchronized Set<ArtifactIdentifier> getElements() {
		return Immutables.hashSetCopy(elements);
	}

	public synchronized Map<ArtifactIdentifier, TreeNode> getChildren() {
		return Immutables.hashMapCopy(children);
	}

	/**
	 * Remove all children and elements.
	 */
	public synchronized void clear() {
		children.clear();
		elements.clear();
	}

	@Override
	public synchronized int hashCode() {
		final int prime = 31;
		int result = 1;
		result = (prime * result) + ((artifactIdentifier == null) ? 0 : artifactIdentifier.hashCode());
		return result;
	}

	@Override
	public synchronized boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		TreeNode other = (TreeNode) obj;
		if (artifactIdentifier == null) {
			if (other.artifactIdentifier != null) {
				return false;
			}
		} else if (!artifactIdentifier.equals(other.artifactIdentifier)) {
			return false;
		}
		return true;
	}

	@Override
	public synchronized String toString() {
		return ""TreeNode [artifactIdentifier="" + artifactIdentifier + "", children="" + children + "", elems="" + elements
				+ ""]"";
	}

	/**
	 * Debug-only diagnostic output.
	 */
	public synchronized void toLog() {
		LOGGER.debug(""artifactIdentifier="" + artifactIdentifier);
		LOGGER.debug(""elems="" + elements);
		for (Map.Entry<ArtifactIdentifier, TreeNode> childEntries : children.entrySet()) {
			LOGGER.debug(""---"");
			LOGGER.debug(""child '"" + childEntries.getKey() + ""':"");
			LOGGER.debug(childEntries.getValue());
		}

	}

	public TreeNode getParent() {
		return parent;
	}

	public void remove(TreeNode node) {
		children.remove(node.getArtifactIdentifier());
	}
}
"
SourcePoints.java,"package edu.nd.dronology.services.extensions.areamapping.internal;

import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class SourcePoints {
	private List<Point2D.Double> sourcePoints;
	private int weight;
	
	public SourcePoints() {
		this(0);
	}
	
	public SourcePoints(int weight) {
		sourcePoints = new ArrayList<>();
		this.weight = weight;
	}
	
	public List<Point2D.Double> getSourcePoints(){
		return Collections.unmodifiableList(sourcePoints);
	}
	
	public Point2D.Double getSourcePoint(int index){
		return sourcePoints.get(index);
	}
	
	public void setSourcePoints(List<Point2D.Double> points) {
		sourcePoints = points;
	}
	
	public void setSourcePoint(int index, Point2D.Double point) {
		sourcePoints.set(index, point);
	}
	
	public void addSourcePoint(Point2D.Double point) {
		sourcePoints.add(point);
	}
	
	public int size() {
		return sourcePoints.size();
	}
	
	public int getWeight() {
		return weight;
	}
}
"
CommandExecutor.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal;

public interface CommandExecutor {
    void process();
    boolean isFinished();
}
"
IRouteCreator.java,"package edu.nd.dronology.services.extensions.areamapping.creation;

import java.awt.geom.Path2D.Double;
import java.util.List;

import edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;

public interface IRouteCreator {

	List<RoutePrimitive> generateRoutePrimitives();

	List<RiverBank> getBankList();

	Double getTotalRiverSegment();

	double getAverageLatitude();

}
"
IPlanStatusChangeListener.java,"package edu.nd.dronology.core.flight;

public interface IPlanStatusChangeListener {

	void notifyPlanChange(IFlightPlan changedPlan);

}
"
UAVRegistration.java,"package edu.nd.dronology.services.core.items;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class UAVRegistration implements IUAVRegistration {

	private String id;
	private String name;
	private String description;
	private String type = ""Default"";
	private Map<String, Serializable> attributes;
	private byte[] image;

	public UAVRegistration() {
		id = UUID.randomUUID().toString();
		attributes = new HashMap<>();
	}

	@Override
	public String getName() {
		// TODO Auto-generated method stub
		return name;
	}

	@Override
	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String getId() {
		return id;
	}

	@Override
	public String getDescription() {
		return description;
	}

	@Override
	public void setType(String type) {
		this.type = type;

	}

	@Override
	public void setDescription(String description) {
		this.description = description;

	}

	@Override
	public String getType() {
		return type;
	}

	@Override
	public Serializable getAttribute(String key) {
		return attributes.get(key);
	}

	@Override
	public void addAttribute(String key, Serializable value) {
		attributes.put(key, value);
	}

	@Override
	public void setUAVImage(byte[] image) {
		this.image = image;
	}

	@Override
	public byte[] getImage() {
		return image;
	}
}
"
JsonTester.java,"package edu.nd.dronology.misc.gcs;

import java.text.DateFormat;

import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;

public class JsonTester {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//
		// System.out.println(new TakeoffCommand(""1"", 20).toJsonString());
		// System.out.println(new SetModeCommand(""1"", ""LAND"").toJsonString());
		// System.out.println(new GoToCommand(""1"", new LlaCoordinate(41.732957,
		// -86.180883, 20)).toJsonString());
		// System.out.println(new TakeoffCommand(""1"", 20).toJsonString());

		final Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()
				.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)
				.setVersion(1.0).serializeSpecialFloatingPointValues().create();

		UAVMonitoringMessage mm = new UAVMonitoringMessage(""Drone1"", ""FAKE"", ""Drone1"");

		mm.setType(""MonitoringMessage"");
		// mm.setuavid(""DRONE1"");
		mm.addPropery(""NR_SATELITES"", ""5"");
		mm.addPropery(""GPS_BIAS"", ""3.125"");
		mm.addPropery(""CURRENT_SPEED"", ""5.25"");

		System.out.println(GSON.toJson(mm));

	}

}
"
VirtualDroneFleetFactory.java,"package edu.nd.dronology.core.fleet;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.monitoring.DronologyMonitoringManager;
import edu.nd.dronology.core.monitoring.MessageMarshaller;
import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;
import edu.nd.dronology.core.vehicle.IDrone;
import edu.nd.dronology.core.vehicle.ManagedDrone;
import edu.nd.dronology.core.vehicle.internal.VirtualDrone;
/**
 * Factory class for initializing a new {@link VirtualDrone} instance.
 * 
 * @author Jane Cleland-Huang 
 *
 */
public class VirtualDroneFleetFactory extends AbstractDroneFleetFactory {

	protected VirtualDroneFleetFactory() {

	} 

	private static volatile VirtualDroneFleetFactory INSTANCE = null;

	public static VirtualDroneFleetFactory getInstance() {
		if (INSTANCE == null) {
			synchronized (VirtualDroneFleetFactory.class) {
				if (INSTANCE == null) {
					INSTANCE = new VirtualDroneFleetFactory();
				}
			}
		}
		return INSTANCE; 
	}

	@Override
	public ManagedDrone initializeDrone(String droneID, String droneType, double latitude, double longitude,
			double altitude) throws DroneException {
		IDrone drone = new VirtualDrone(createDroneID(droneID));
		ManagedDrone managedDrone = new ManagedDrone(drone);

		drone.setManagedDrone(managedDrone);
		LlaCoordinate currentPosition = new LlaCoordinate(latitude, longitude, altitude);
		drone.setBaseCoordinates(currentPosition);
		drone.setCoordinates(currentPosition.getLatitude(), currentPosition.getLongitude(),
				currentPosition.getAltitude());
		managedDrone.start(); 
		DroneFleetManager.getInstance().addDrone(managedDrone);
		DronologyMonitoringManager.getInstance().publish(MessageMarshaller
				.createMessage(MessageType.VIRTUAL_UAV_ACTIVATED, drone.getDroneName(), currentPosition));

		return managedDrone;
	}

}
"
DefaultAction.java,"package edu.nd.dronology.core.collisionavoidance.strategy.onionbackend;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;
import edu.nd.dronology.core.collisionavoidance.strategy.StopEveryone;
import edu.nd.dronology.core.goal.WaypointGoalSnapshot;

public class DefaultAction implements IAction {

	@Override
	public void applyAction(DroneSnapshot snapshot) {
        WaypointGoalSnapshot goal = StopEveryone.findActiveWaypointGoal(snapshot.getGoals());
        if (goal != null) {
            StopEveryone.flyToGoalIfNotAlready(snapshot, goal);
        }
	}

}"
DistanceChecker.java,"package edu.nd.dronology.monitoring.simplechecker.checker;

import java.util.ArrayList;
import java.util.List;
import java.util.Map.Entry;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.monitoring.DronologyMonitoringManager;
import edu.nd.dronology.core.monitoring.IMonitorableMessage;
import edu.nd.dronology.core.monitoring.MessageMarshaller;
import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;
import edu.nd.dronology.core.util.ManagedHashTableList;
import edu.nd.dronology.gstation.connector.messages.UAVStateMessage;
import edu.nd.dronology.util.Pair;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class DistanceChecker {
	private static final transient ILogger LOGGER = LoggerProvider.getLogger(DistanceChecker.class);

	private static final double MIN_DIST = 5;

	public DistanceChecker() {
		Timer timer = new Timer();
		timer.schedule(new CheckTask(), 0, 1500);
	}

	private static transient DistanceChecker INSTANCE;

	private BlockingQueue<UAVStateMessage> messageQueue = new ArrayBlockingQueue<>(100);

	private transient ManagedHashTableList<String, Pair> dataMap = new ManagedHashTableList<>();

	public static DistanceChecker getInstance() {
		if (INSTANCE == null) {
			synchronized (SimpleChecker.class) {
				if (INSTANCE == null) {
					INSTANCE = new DistanceChecker();
				}
			}
		}
		return INSTANCE;
	}

	public void notify(IMonitorableMessage message) {
		messageQueue.offer((UAVStateMessage) message);

	}

	private class CheckTask extends TimerTask {
		@Override
		public void run() {
			List<UAVStateMessage> toCheck = new ArrayList<>();
			messageQueue.drainTo(toCheck);
			// System.out.println(""RUN DISTANCE CHECK!"" + dataMap.size());
			calculateDistance(toCheck);
			calculateDistance();
		}

	}

	public void processMessage(UAVStateMessage msg) {
		try {

			double xVal = msg.getLocation().getLatitude();
			double yVal = msg.getLocation().getLongitude();
			double zVal = msg.getLocation().getAltitude();

			LlaCoordinate cord = new LlaCoordinate(xVal, yVal, zVal);
			// System.out.println(event.getSource()+"":::""+cord);

			dataMap.add(msg.getUavid(), Pair.create(msg.getSendtimestamp(), cord));

			// setLastValidState(Boolean.parseBoolean(value.toString()));
		} catch (Throwable e) {
			LOGGER.error(e);
		}
	}

	public void calculateDistance() {
		try {
			ManagedHashTableList<String, Pair> checkMap = new ManagedHashTableList<>();
			synchronized (dataMap) {
				for (Entry<String, List<Pair>> e : dataMap.entrySet()) {
					checkMap.put(e.getKey(), e.getValue());
				}
				dataMap.clear();
			}

			for (Entry<String, List<Pair>> e : checkMap.entrySet()) {
				String id = e.getKey();
				List<Pair> cords = e.getValue();

				for (Pair corrd : cords) {
					for (Entry<String, List<Pair>> f : checkMap.entrySet()) {
						String fid = f.getKey();
						if (id.equals(fid)) {
							continue;
						}
						List<Pair> fcords = f.getValue();
						for (Pair fcoord : fcords) {

							// System.out.println(id + ""-"" + fid + ""DISTANCE:"" + corrd.distance(fcoord));

							LlaCoordinate c1 = (LlaCoordinate) Pair.cast(corrd).getSecond();
							LlaCoordinate c2 = (LlaCoordinate) Pair.cast(fcoord).getSecond();

							long ts1 = (long) Pair.cast(corrd).getFirst();
							long ts2 = (long) Pair.cast(fcoord).getFirst();
							long dif = Math.abs(ts1 - ts2);
							// System.out.println(Math.abs(ts1.getTimestamp() - ts2.getTimestamp()));
							if (dif > 500) {

								continue;
							}

							double distance = (c1.distance(c2));

							if (distance < MIN_DIST) {
								LOGGER.error(""COLLISION!!!"");
								DronologyMonitoringManager.getInstance().publish(MessageMarshaller.createMessage(
										MessageType.COLLISION, id, new CollisionInfo(id, fid, distance)));
							}
						}

					}
				}
			}
		} catch (Throwable t) {
			t.printStackTrace();
		}

	}

	public void calculateDistance(List<UAVStateMessage> toCheck) {
		toCheck.forEach(m -> {
			processMessage(m);
		});

	}

}
"
UAVMissionPlan.java,"package edu.nd.dronology.services.extensions.missionplanning.plan;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.services.core.info.FlightInfo;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;
import edu.nd.dronology.services.extensions.missionplanning.patterns.IFlightPattern;
import edu.nd.dronology.services.extensions.missionplanning.patterns.PatternFactory;
import edu.nd.dronology.services.extensions.missionplanning.patterns.PatternFactory.PatternType;
import edu.nd.dronology.services.extensions.missionplanning.patterns.TaskList;
import edu.nd.dronology.services.extensions.missionplanning.sync.SynchronizationManager;
import edu.nd.dronology.services.extensions.missionplanning.tasks.DelayTask;
import edu.nd.dronology.services.extensions.missionplanning.tasks.IMissionTask;
import edu.nd.dronology.services.extensions.missionplanning.tasks.LandTask;
import edu.nd.dronology.services.extensions.missionplanning.tasks.PatternTask;
import edu.nd.dronology.services.extensions.missionplanning.tasks.RouteTask;
import edu.nd.dronology.services.extensions.missionplanning.tasks.SyncTask;
import edu.nd.dronology.services.extensions.missionplanning.tasks.TakeoffTask;
import edu.nd.dronology.services.extensions.missionplanning.tasks.WaypointTask;
import edu.nd.dronology.services.instances.flightmanager.FlightManagerService;
import edu.nd.dronology.services.instances.flightroute.FlightRouteplanningService;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * Mission plan for an individual UAV. Part of an {@link IExecuteableMissionPlan}.
 * 
 * @author Jane Cleland-Huang
 *
 */
public class UAVMissionPlan {

	private static final ILogger LOGGER = LoggerProvider.getLogger(UAVMissionPlan.class);
 
	private IMissionTask activeTask = null;
	private final String uavid;
	private List<IMissionTask> taskList;
	private LlaCoordinate homeLocation;
	private LlaCoordinate firstWaypointLocation;

	private int coordinationAltitude = 0;
	private final transient SynchronizationManager synchMgr;

	public UAVMissionPlan(String uavID, SynchronizationManager synchMgr) {
		this.uavid = uavID;
		taskList = new LinkedList<>();
		this.synchMgr = synchMgr;
	}

	/**
	 * Check if task if finished
	 * 
	 * @return
	 * @throws MissionExecutionException
	 */
	private boolean isExecutingTask() throws MissionExecutionException {
		FlightInfo info;
		try {
			info = FlightManagerService.getInstance().getFlightInfo(uavid);
		} catch (DronologyServiceException e) {
			LOGGER.error(e);
			throw new MissionExecutionException(e.getMessage());
		}
		return info.getCurrentFlights() != null;

	}

	/**
	 * Needs to actually activate the flight route. NOTE: Needs to handle ROUTE, WAYPOINT, TAKEOFF, and LAND (Synch is done internally and shouldn't need any extra coordination).
	 * 
	 * @throws Exception
	 */
	public void activateNextTask() throws MissionExecutionException {
		activeTask = null;
		if (!taskList.isEmpty()) {
			activeTask = taskList.get(0);
			taskList.remove(0);

			// Now execute the task. This will depend on whether it is a waypoint, entire
			// route, or synch point
			if (activeTask instanceof SyncTask) {
				LOGGER.missionInfo(""UAV "" + uavid + "" waiting at SYNCH POINT: "" + activeTask.getTaskName());
				synchMgr.uavVisitedSynchPoint(uavid, activeTask.getTaskName()); // Marks this uav as synched

				if (synchMgr.isFullySynched(activeTask.getTaskName())) {
					LOGGER.missionInfo(""All UAVs released from "" + activeTask.getTaskName());
					activeTask = null; // Free to move on.
				}

			} else if (activeTask instanceof RouteTask) {
				MissionUtil.activateRoute(activeTask);
			} else if (activeTask instanceof DelayTask) { 
				((DelayTask) activeTask).startDelayTask();
			} else if (activeTask instanceof WaypointTask || activeTask instanceof TakeoffTask
					|| activeTask instanceof LandTask) {
				LOGGER.missionInfo(""ACTIVATED FLIGHT TO WAYPOINT: "" + uavid + "" "" + activeTask.getTaskName());
				MissionUtil.activateWaypoint(activeTask);
			} else {
				throw new UnsupportedOperationException(""Task '"" + activeTask.getClass() + ""' not supported"");
			}

		}

	}

	public String getUavID() {
		return uavid;
	}

	public void setCoordinationAltitude(int alt) {
		coordinationAltitude = alt;
	}

	public int getCoordinationAltitude() {
		return coordinationAltitude; // Add error if null.
	}

	public boolean hasActiveTask() throws MissionExecutionException {
		if (activeTask == null) {
			return false;
		}
		if (activeTask instanceof SyncTask) {
			String synchName = activeTask.getTaskName();
			if (!synchMgr.synchPointExists(synchName)) {
				LOGGER.missionError(""Missing synch point"");
				return false;
			} else if (synchMgr.isFullySynched(synchName)) {
				return false;
			}
			return true;

		} else if (activeTask instanceof DelayTask) {
			return !((DelayTask) activeTask).isFinished();
		} else {// Waypoint or Route
			return isExecutingTask();
		}
	}

	public void addTask(IMissionTask task, SynchronizationManager synchMgr) throws MissionExecutionException { // Remove
		// SynchMgr
		taskList.add(task);
		if (firstWaypointLocation == null && task instanceof RouteTask) {
			firstWaypointLocation = MissionUtil.getFirstWayPoint(task.getTaskName());
		}
	}

	public void buildSynchPoints() {
		taskList.forEach(task -> {
			if (task instanceof SyncTask) {
				synchMgr.createSynchronizationPoint(task.getTaskName());
				synchMgr.addSynchItem(task.getUAVId(), task.getTaskName());
			}
		});
	}

	public boolean hasTasks() {
		return activeTask != null || taskList.size() > 0;

	}

	public int taskCount() {
		return taskList.size();
	}

	/**
	 * Expand the task list with PATTERNS. Currently supports two different patterns ""SynchronizedTakeoff"" and ""SynchronizedLanding"" Assumptions: SynchronizedTakeoff has a ROUTE definied immediately
	 * after. SynchronizedLanding has a ROUTE defined immediately prior.
	 * 
	 * @throws MissionExecutionException
	 */
	public void expandTaskList() throws MissionExecutionException {
		List<IMissionTask> allTasks = new ArrayList<>();
		for (IMissionTask task : taskList) {
			homeLocation = MissionUtil.getHome(task.getUAVId());
			if (task instanceof PatternTask) {
				if (task.getTaskName().equals(""SynchronizedTakeoff"")) {
					IFlightPattern pattern = PatternFactory.getPattern(PatternType.COORDINATED_TAKEOFF);
					pattern.initialize(synchMgr);
					if (firstWaypointLocation != null) // Currently it only expands IF we have at least one ROUTE. It
						// treats the first waypoint as the target waypoint.
						pattern.expandFlightPattern(this, homeLocation, firstWaypointLocation);
					TaskList list = pattern.getTaskList();
					allTasks.addAll(list.getTasks());
				} else if (task.getTaskName().equals(""SynchronizedLanding"")) {
					IFlightPattern pattern = PatternFactory.getPattern(PatternType.COORDINATED_LANDING);
					pattern.initialize(synchMgr);
					LlaCoordinate currentFinalWaypoint;
					currentFinalWaypoint = MissionUtil.getFinalWaypoint(allTasks);
					pattern.expandFlightPattern(this, currentFinalWaypoint, homeLocation);
					TaskList list = pattern.getTaskList();
					allTasks.addAll(list.getTasks());

				}
			} else {
				allTasks.add(task);
			}
		}
		taskList = allTasks;
	}

	@Override
	public boolean equals(Object o) {
		// self check
		if (this == o)
			return true;
		// null check
		if (o == null)
			return false;
		// type check and cast
		if (getClass() != o.getClass())
			return false;
		UAVMissionPlan that = (UAVMissionPlan) o;
		return this.uavid.equals(that.uavid);
	}

	@Override
	public int hashCode() {
		int prime = 31;
		int result = 1;
		result = prime * result + ((uavid == null) ? 0 : uavid.hashCode());
		return result;
	}

	public LlaCoordinate getStartingRouteWaypoint() throws MissionExecutionException {
		for (IMissionTask t : taskList) {
			if (t instanceof RouteTask) {
				try {
					FlightRouteInfo route = FlightRouteplanningService.getInstance().getRouteByName(t.getTaskName());
					LlaCoordinate coord = route.getWaypoints().get(0).getCoordinate();
					return coord;
				} catch (DronologyServiceException e) {
					throw new MissionExecutionException(""Error when getting initial waypoint for '"" + t.getTaskName() + ""'"");
				}

			}
		}
		LOGGER.error(""No RouteTask found in Mission"");
		return taskList.get(0).getWaypoint();

	}

}"
CollisionAvoidanceUtil.java,"package edu.nd.dronology.core.collisionavoidance;

import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.math3.util.CombinatoricsUtils;

public class CollisionAvoidanceUtil {

    private static class DronePairIterator implements Iterator<DronePair> {

        Iterator<int[]> indices;
        List<DroneSnapshot> snapshots;

        DronePairIterator(List<DroneSnapshot> snapshots, Iterator<int[]> indices) {
            this.snapshots = snapshots;
            this.indices = indices;
        }

		@Override
		public boolean hasNext() {
			return indices.hasNext();
		}

		@Override
		public DronePair next() {
            int[] nextIndices = indices.next();
            int indexA = nextIndices[0];
            int indexB = nextIndices[1];
            return new DronePair(snapshots.get(indexA), snapshots.get(indexB));
		}

    }

    private static Iterator<DronePair> pairs(List<DroneSnapshot> snapshots) {
        if (snapshots.size() >= 2) {
            Iterator<int[]> indices = CombinatoricsUtils.combinationsIterator(snapshots.size(), 2);
            return new DronePairIterator(snapshots, indices);
        } else {
            return Collections.emptyIterator();
        }
    }

    public static Iterable<DronePair> findPairs(final List<DroneSnapshot> snapshots) {
        return new Iterable<DronePair>(){
        
            @Override
            public Iterator<DronePair> iterator() {
                return pairs(snapshots);
            }
            
        };
    }

}"
WaypointExecutor.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal;

import edu.nd.dronology.core.DronologyConstants;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand;
import edu.nd.dronology.core.vehicle.IDrone;
import edu.nd.dronology.core.vehicle.ManagedDrone;

public class WaypointExecutor implements CommandExecutor {

    enum WaypointExecutionState {
        RADIOING,
        SENSING,
        FINISHED;
    }

    private IDrone drone;
    WaypointExecutionState state = WaypointExecutionState.RADIOING;
    WaypointCommand data;

    public WaypointExecutor(IDrone drone, WaypointCommand data) {
        this.drone = drone;
        this.data = data;
    }

    @Override
    public void process() {
        switch (this.state) {
            case RADIOING:
                radioDrone();
                break;

            case SENSING:
                senseDrone();
                break;

            case FINISHED:
            default:
                // Do nothing.
                break;
        }
    }

    @Override
    public boolean isFinished() {
        return this.state == WaypointExecutionState.FINISHED;
    }

    private void radioDrone() {
        drone.flyTo(this.data.getDestination(), this.data.getSpeed());
        this.state = WaypointExecutionState.SENSING;
    }

    private void senseDrone() {
        double targetDistance = drone.getCoordinates().distance(data.getDestination());
        if (targetDistance < DronologyConstants.THRESHOLD_WAYPOINT_DISTANCE) {
            this.state = WaypointExecutionState.FINISHED;
        }
    }
}
"
FlightManagerService.java,"package edu.nd.dronology.services.instances.flightmanager;

import java.util.Collection;
import java.util.List;

import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.services.core.base.AbstractServerService;
import edu.nd.dronology.services.core.info.FlightInfo;
import edu.nd.dronology.services.core.info.FlightPlanInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

/**
 * 
 * Service for handling UAV flights<br>
 * Allows assigning flight plans to UAVs <br>
 * Allows sending flight related commands to UAVs (take-off, return to home...).
 * 
 *  
 * @author Michael Vierhauser
 *
 */
public class FlightManagerService extends AbstractServerService<IFlightManagerServiceInstance> {

	private static volatile FlightManagerService INSTANCE;

	protected FlightManagerService() {
	}

	/**
	 * @return The singleton ConfigurationService instance
	 */
	public static FlightManagerService getInstance() {
		if (INSTANCE == null) {
			synchronized (FlightManagerService.class) {
				if (INSTANCE == null) {
					INSTANCE = new FlightManagerService();
				}
			}
		}
		return INSTANCE;
	}

	@Override
	protected IFlightManagerServiceInstance initServiceInstance() {
		return new FlightManagerServiceInstance();
	}

	public FlightInfo getFlightInfo(String uavId) throws DronologyServiceException {
		return serviceInstance.getFlightInfo(uavId);

	}

	public void planFlight(String uavid, String planName, List<Waypoint> waypoints) throws Exception {
		serviceInstance.planFlight(uavid, planName, waypoints);

	}

	public void planFlight(String planName, List<Waypoint> waypoints) throws Exception {
		serviceInstance.planFlight(planName, waypoints);

	}

	public void returnToHome(String uavid) throws Exception {
		serviceInstance.returnToHome(uavid);

	} 

	public void pauseFlight(String uavid) throws Exception {
		serviceInstance.pauseFlight(uavid);

	}

	public Collection<FlightPlanInfo> getCurrentFlights() {
		return serviceInstance.getCurrentFlights();
	}

	public void cancelPendingFlights(String uavid) throws Exception {
		serviceInstance.cancelPendingFlights(uavid);
	}

	public void takeoff(String uavid, double altitude) throws DronologyServiceException {
		serviceInstance.takeoff(uavid, altitude);

	}

	public void emergencyStop(String uavid) throws DronologyServiceException {
		serviceInstance.emergencyStop(uavid);

	}

}
"
IFlightPattern.java,"package edu.nd.dronology.services.extensions.missionplanning.patterns;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;
import edu.nd.dronology.services.extensions.missionplanning.plan.UAVMissionPlan;
import edu.nd.dronology.services.extensions.missionplanning.sync.SynchronizationManager;
import edu.nd.dronology.services.extensions.missionplanning.tasks.IMissionTask;

/**
 * Interface for all flight pattern implementations that can be expanded into several different {@link IMissionTask}.
 * 
 * @author Michael Vierhauser
 *
 */
public interface IFlightPattern {

	void initialize(SynchronizationManager synchMgr);

	/**
	 * Coordinates the flight of multiple UAVs across a potentially overlapping space consisting of a currentLocation and a targetLocation for each UAV. FOR NOW: We assume that currentCoordinates and
	 * targetWayPoints for all UAVs are unique and sufficiently separated from each other. Paths to move from current to target positions may overlap. We should add this check in later on.
	 * 
	 * @param uavMission
	 *          The mission plan the pattern belongs to.
	 * @param currentLocation
	 *          The current location from which the pattern starts.
	 * @param targetLocation
	 *          The target location when the pattern is completed.
	 * @throws MissionExecutionException
	 */
	public void expandFlightPattern(UAVMissionPlan uavMission, LlaCoordinate currentLocation,
			LlaCoordinate targetLocation) throws MissionExecutionException;

	/**
	 * 
	 * @return A {@link TaskList } containing the tasks part of that pattern.
	 */
	public TaskList getTaskList();

}
"
LogCleaner.java,"package edu.nd.dronology.services.supervisor;

import java.io.File;
import java.util.Map;

import org.apache.commons.io.FilenameUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.core.Appender;
import org.apache.logging.log4j.core.LoggerContext;
import org.apache.logging.log4j.core.appender.RollingFileAppender;

import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class LogCleaner {

	/**
	 * 30 days = 720 hours
	 */
	private static final int DELTE_TRESHOLD = 720;
	private static final ILogger LOGGER = LoggerProvider.getLogger(LogCleaner.class);

	public static void run() {
		try {

			LoggerContext ctx = (LoggerContext) LogManager.getContext(false);
			System.out.println(""Using logger config:"" + ctx.getConfiguration().getConfigurationSource().getLocation());

			Map<String, Appender> appenders = ctx.getRootLogger().getAppenders();
			for (Appender app : appenders.values()) {
				if (app instanceof RollingFileAppender) {
					checkPath(((RollingFileAppender) app).getFileName().substring(0,
							((RollingFileAppender) app).getFileName().lastIndexOf(""/"")));
					return;
				}
			}
		} catch (Throwable t) {
			t.printStackTrace();
		}
	}

	private static void checkPath(String substring) {
		
		File logFolder = new File(substring);
		File[] logFiles = logFolder.listFiles();
		LOGGER.info(""Cleaning up log file directory: '"" + logFolder.getAbsolutePath() + ""'"");
		for (File f : logFiles) {
			try {
				double lastModifified = (System.currentTimeMillis() - f.lastModified()) / 1000 / 60 / 60;

				if (lastModifified > DELTE_TRESHOLD && FilenameUtils.getExtension(f.getName()).equals(""log"")) {
					f.delete();
					LOGGER.info(""Deleting log file older than "" + (DELTE_TRESHOLD / 24) + "" days:"" + f.getAbsolutePath());
				}
			} catch (Throwable e) {
				e.printStackTrace();
			}
		}

	}

}
"
UnassignFlightMessage.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal.message;

public class UnassignFlightMessage extends AbstractMessage {

}
"
DroneSnapshotOption.java,"package edu.nd.dronology.core.collisionavoidance;

public class DroneSnapshotOption {
    public final DroneSnapshot snapshot;
    public final String droneName;
    public DroneSnapshotOption(DroneSnapshot snapshot, String droneName) {
        this.snapshot = snapshot;
        this.droneName = droneName;
    }
}
"
MappedItem.java,"package edu.nd.dronology.services.core.items;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

public abstract class MappedItem implements IMappedItem, Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = -2076504393371550022L;

	public MappedItem(String id) {
		this.id = id;
	}

	private String type;
	private String id;
	private String description;
	private Integer importance;
	private List<LlaCoordinate> coordinates = new ArrayList<>();

	
	@Override
	public String getDescription() {
		return description;
	}

	@Override
	public void setDescription(String description) {
		this.description = description;
	}

	@Override
	public String getId() {
		return id;
	}

	@Override
	public void setId(String id) {
		this.id = id;
	}

	@Override
	public String getType() {
		return type;
	}
	@Override
	public void setType(String type) {
		this.type = type;
	}
	@Override
	public void setImportance(Integer importance) {
		this.importance = importance;
	}
	@Override
	public Integer getImportance() {
		return importance;
	} 
	@Override
	public void addCoordinate(LlaCoordinate coord) {
		coordinates.add(coord);
	}
	@Override
	public void setCoordinates(List<LlaCoordinate> coords) {
		coordinates = coords;
	}
	@Override
	public void removeCoodinate(LlaCoordinate coord) {
		coordinates.remove(coord);
	}
	@Override
	public List<LlaCoordinate> getCoordinates() {
		return Collections.unmodifiableList(coordinates);
	}
}
"
RouteSelector.java,"package edu.nd.dronology.services.extensions.areamapping.unused;
//package edu.nd.dronology.services.extensions.areamapping;
//
//import java.awt.geom.Path2D;
//import java.awt.geom.Point2D;
//import java.util.ArrayList;
//import java.util.Collection;
//import java.util.Collections;
//import java.util.HashSet;
//import java.util.List;
//import java.util.Set;
//
//import edu.nd.dronology.core.coordinate.LlaCoordinate;
//import edu.nd.dronology.core.vehicle.IUAVProxy;
//import edu.nd.dronology.services.core.areamapping.MetricsStatistics;
//import edu.nd.dronology.services.extensions.areamapping.internal.Geometry;
//import edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;
//import edu.nd.dronology.services.extensions.areamapping.metrics.AllocationInformation;
//import edu.nd.dronology.services.extensions.areamapping.metrics.Drone;
//import edu.nd.dronology.services.extensions.areamapping.metrics.MetricsRunner;
//import edu.nd.dronology.services.extensions.areamapping.metrics.MetricsUtilities;
//import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;
//import edu.nd.dronology.services.extensions.areamapping.util.Utilities;
//
//public class RouteSelector  {
//
//	private static final double APERATURE_WIDTH = 10;
//	private static final double APERATURE_HEIGHT= 0.8* APERATURE_WIDTH;
//	private static final double OVERLAP_FACTOR = 0.7;
//	private double avgLatitude;
//	private int availableDrones;
//	private List<RoutePrimitive> routePrimitives;
//	private MetricsRunner metricsRunner;
//	private List<IUAVProxy> uavs;
//
//	
//	public void initialize(List<RoutePrimitive>routePrimitives, List<RiverBank> bankList, Path2D.Double totalRiverSegment, int availableDrones, double avgLatitude, Collection<IUAVProxy> uavs) {
//		// TODO Auto-generated method stub
//		routePrimitives = Utilities.splitRoutePrimitives(routePrimitives, 4, APERATURE_HEIGHT, OVERLAP_FACTOR);
//		this.routePrimitives = routePrimitives;
//		this.availableDrones = availableDrones;
//		this.avgLatitude = avgLatitude;
//		this.uavs = new ArrayList<>(uavs);
//		metricsRunner = new MetricsRunner(routePrimitives, totalRiverSegment, bankList, APERATURE_WIDTH, APERATURE_HEIGHT, uavs.size());
//	}
//	
//	//GeneratedRouteAssignment....
//	private List<Drone> generateRandomAssingments(){
//		Set<Integer> assignedRoutes = new HashSet<>();
//		availableDrones = uavs.size();
//		int droneNum;
//		int routeNum;
//	
//		int routeAssignmentNum = MetricsUtilities.generateRandomNumber(routePrimitives.size()-1, 1);
//		List<Drone> droneList = new ArrayList<>();
//		for(int i = 0; i < availableDrones; i++) {
//			droneList.add(new Drone());
//			LlaCoordinate home = uavs.get(i).getHomeLocation();
//			LlaCoordinate currentLocation = uavs.get(i).getCoordinates();
//			droneList.get(i).setDroneHomeLocation(Geometry.gpsToCartesian(new Point2D.Double(home.getLatitude(),home.getLongitude()), avgLatitude));
//			droneList.get(i).setDroneStartPoint(Geometry.gpsToCartesian(new Point2D.Double(currentLocation.getLatitude(),currentLocation.getLongitude()), avgLatitude));
//			droneList.get(i).setUAVId(uavs.get(i).getID());
//		}
//		while(assignedRoutes.size() < routeAssignmentNum) {
//			//assign drone routes in here
//			droneNum = MetricsUtilities.generateRandomNumber(availableDrones-1,0);
//			routeNum = MetricsUtilities.generateRandomNumber(routeAssignmentNum, 0);
//			while(assignedRoutes.contains(routeNum)) {
//				routeNum = MetricsUtilities.generateRandomNumber(routeAssignmentNum, 0);
//			}
//			droneList.get(droneNum).getDroneRouteAssignment().add(routePrimitives.get(routeNum));
//			assignedRoutes.add(routeNum);
//		}
//		return droneList;
//	}
//	
//	private MetricsStatistics generateMetricsStatistics(List<Drone> drones) {
//		metricsRunner.setDroneAssignments(drones);
//		return metricsRunner.runMetrics();
//	}
//	
//	//use a loop to pick best route
//	//return wrapper for list<drone> and metrics
//	public List<AllocationInformation> generateAssignments() {
//		// loop to create assignments and check for best assignment
//		List<AllocationInformation> allAllocations = new ArrayList<>();
//		AllocationInformation finalAllocation = new AllocationInformation();
//		/*List<Drone> assignment = generateRandomAssingments();
//		finalAllocation.setDroneAllocations(assignment);
//		finalAllocation.setMetricsStatistics(generateMetricsStatistics(assignment));
//		allAllocations.add(finalAllocation);*/
//		for(int i = 0; i < 100; i++) {
//			List<Drone> assignments = generateRandomAssingments();
//			AllocationInformation currentAllocation = new AllocationInformation();
//			currentAllocation.setDroneAllocations(assignments);
//			currentAllocation.setMetricsStatistics(generateMetricsStatistics(assignments));
//			allAllocations.add(currentAllocation);
//			/*boolean added = false;
//			for(int j = 0; j < top5Allocations.size(); j++) {
//				//allows 0 collisions
//				if(top5Allocations.get(j).getMetricStatistics().getAllocationScore() < currentAllocation.getMetricStatistics().getAllocationScore() && currentAllocation.getMetricStatistics().getCollisions() == 0) {
//					top5Allocations.add(j, currentAllocation);
//					added = true;
//					if(top5Allocations.size() > 5) {
//						top5Allocations.remove(top5Allocations.size()-1);
//					}
//					break;
//				}
//			}
//			//allows 0 collisions
//			if(top5Allocations.size() < 5 && !added && currentAllocation.getMetricStatistics().getCollisions() == 0) {
//				top5Allocations.add(currentAllocation);
//			}*/
//			
//		}
//		Collections.sort(allAllocations);
//	/*	for(AllocationInformation entry : top5Allocations) {
//			List<Drone> routeAssignments = new ArrayList<>();
//			routeAssignments = entry.getDroneAllocations();
//			for(Drone drone : routeAssignments) {
//				drone.cartesianToGps(avgLatitude);
//			}
//			entry.setDroneAllocations(routeAssignments);
//		}*/
//		for(RoutePrimitive route : routePrimitives) {
//			route = Utilities.cartesianRouteToGpsRoute(route, avgLatitude);
//		}
//		//are home and start locations converted back?
//		return allAllocations;
//	}
//	
//
//}
"
FlightPlanInfo.java,"package edu.nd.dronology.services.core.info;

import java.util.ArrayList;
import java.util.List;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.util.Waypoint;

public class FlightPlanInfo extends RemoteInfoObject {

	

	/**
	 * 
	 */
	private static final long serialVersionUID = 256865471183839829L;
	private String droneId;
	private List<Waypoint> waypoints = new ArrayList<>();
	private LlaCoordinate startLocation;
	private long startTime;
	private long endTime;

	public String getDroneId() {
		return droneId;
	}

	public List<Waypoint> getWaypoints() {
		return waypoints;
	}

	public LlaCoordinate getStartLocation() {
		return startLocation;
	}

	public long getStartTime() {
		return startTime;
	}

	public long getEndTime() {
		return endTime;
	}

	public FlightPlanInfo(String name, String id) {
		super(name, id);
	}

	public void setDroneId(String droneId) {
		this.droneId = droneId;

	}

	public void setWaypoints(List<Waypoint> waypoints) {
		this.waypoints.clear();
		this.waypoints.addAll(waypoints);

	}

	public void setStartLocation(LlaCoordinate startLocation) {
		this.startLocation = startLocation;

	}

	public void setStartTime(long startTime) {
		this.startTime = startTime;

	}

	public void setEndTime(long endTime) {
		this.endTime = endTime;

	}

	
}
"
IUAVProxy.java,"package edu.nd.dronology.core.vehicle;

import java.io.Serializable;
import java.util.Map;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

public interface IUAVProxy extends Serializable {

	String getID();

	String getStatus();

	double getLongitude();

	double getLatitude();

	double getAltitude();

	double getBatteryLevel();

	double getVelocity();

	Map<String, String> getInfo();

	LlaCoordinate getCoordinates();

	LlaCoordinate getHomeLocation();

	String getGroundstationId();

}"
WaypointGoal.java,"package edu.nd.dronology.core.goal;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;
import edu.nd.dronology.core.coordinate.AbstractPosition;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.core.vehicle.internal.PhysicalDrone;

import java.util.Observable;


public class WaypointGoal extends AbstractGoal {

    // The distance threshold (meters) for determining when a waypoint has been reached
    private double dThresh = 2.0;

    private final AbstractPosition position;
    private final double speed;

    public WaypointGoal(Waypoint waypoint) {
        this.position = waypoint.getCoordinate();
        this.speed = waypoint.getApproachingspeed();
    }

    public WaypointGoal(AbstractPosition position, double speed) {
        this.position = position;
        this.speed = speed;
    }

    public WaypointGoal(Waypoint waypoint, double dThresh) {
        this.position = waypoint.getCoordinate();
        this.speed = waypoint.getApproachingspeed();
        this.dThresh = dThresh;
    }


    public AbstractPosition getPosition() {
        return position;
    }

    public double getSpeed() {
        return speed;
    }

    @Override
    public void update(Observable observable, Object o) {
        GoalState curState = getState();

        if (observable instanceof PhysicalDrone) {
            if (curState == GoalState.ACTIVE) {
                DroneSnapshot snapshot = ((PhysicalDrone) observable).getLatestDroneSnapshot();
                double dist = position.distance(snapshot.getPosition());

                if (dist <= dThresh) {
                    setCompleted();
                }
            }
        }
        else if (observable instanceof AbstractGoal) {
            if (curState == GoalState.PENDING) {
                GoalState state = ((AbstractGoal) observable).getState();

                if (state == GoalState.COMPLETE) {
                    setActive();
                }
            }
        }
    }

    @Override
    public IGoalSnapshot buildSnapshot() {
        return new WaypointGoalSnapshot(this.getPosition(), this.getSpeed(), this.getState());
    }
}
"
IMonitorableMessage.java,"package edu.nd.dronology.core.monitoring;

import java.io.Serializable;

import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;
import edu.nd.dronology.core.util.PreciseTimestamp;

/**
 *  Interface for all messages that shall be subscribeable via the monitoring API.
 * 
 * 
 * @author Michael Vierhauser
 *
 */
public interface IMonitorableMessage extends Serializable{

	ArtifactIdentifier<?> getIdentifier();

	String getUavid();

	String getData();

	PreciseTimestamp getTimestamp();

	MessageType getType();

}
"
IFlightRoute.java,"package edu.nd.dronology.services.core.items;

import java.util.List;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.util.Waypoint;

public interface IFlightRoute extends IPersistableItem {
	String getDescription();

	void setDescription(String description);

	void setCategory(String category);

	String getCategory();

	List<Waypoint> getWaypoints();

	void addWaypoint(Waypoint waypoint);

	void setTakeoffAltitude(double altitude);

	void addWaypoint(Waypoint waypoint, int index);

	int removeWaypoint(Waypoint waypoint);

	Waypoint removeWaypoint(int index);

}
"
DroneRouteAssignment.java,"package edu.nd.dronology.services.extensions.areamapping.metrics;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.rmi.CORBA.Util;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;
import edu.nd.dronology.services.extensions.areamapping.util.Utilities;

public class DroneRouteAssignment {

	List<RoutePrimitive> droneRoute;
	
	public DroneRouteAssignment() {
		droneRoute = new ArrayList<>();
	}
	
	public void add(RoutePrimitive routePrimitive) {
		droneRoute.add(routePrimitive);
	}
	
	public List<RoutePrimitive> get(){
		return Collections.unmodifiableList(droneRoute);
	}
	
	public RoutePrimitive get(int entry) {
		return droneRoute.get(entry);
	}
	
	public void set(int index, RoutePrimitive entry) {
		droneRoute.set(index, entry);
	}
	
	public void setDroneRouteAssignment(List<RoutePrimitive> assignment) {
		droneRoute = assignment;
	}
}
"
CoordinatedLandingPattern.java,"package edu.nd.dronology.services.extensions.missionplanning.patterns;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.monitoring.DronologyMonitoringManager;
import edu.nd.dronology.core.monitoring.MessageMarshaller;
import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;
import edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;
import edu.nd.dronology.services.extensions.missionplanning.plan.UAVMissionPlan;
import edu.nd.dronology.services.extensions.missionplanning.sync.SyncConstants;
import edu.nd.dronology.services.extensions.missionplanning.tasks.PatternTask;
import edu.nd.dronology.services.extensions.missionplanning.tasks.TaskFactory;
import edu.nd.dronology.services.extensions.missionplanning.v1.FullMissionPlan;

/**
 * 
 * Predefined pattern for coordinated landing that is expanded as part of a {@link PatternTask} in a {@link FullMissionPlan}.<br>
 * 
 * @author Michael Vierhauser
 *
 */
public class CoordinatedLandingPattern extends AbstractFlightPattern implements IFlightPattern {
	CoordinatedLandingPattern() {

	}

	@Override
	public void expandFlightPattern(UAVMissionPlan uavMission, LlaCoordinate currentLocation,
			LlaCoordinate targetLocation) throws MissionExecutionException {

		if (uavMission.getCoordinationAltitude() == 0) {
			uavMission.setCoordinationAltitude(synchPointMgr.getNextAltitude());
		}

		LlaCoordinate targetWaypoint1 = new LlaCoordinate(currentLocation.getLatitude(), currentLocation.getLongitude(),
				uavMission.getCoordinationAltitude());
		DronologyMonitoringManager.getInstance()
				.publish(MessageMarshaller.createMessage(MessageType.MISSION_WAYPOINT, uavMission.getUavID(), targetWaypoint1));

		LlaCoordinate targetWaypoint2 = new LlaCoordinate(targetLocation.getLatitude(), targetLocation.getLongitude(),
				uavMission.getCoordinationAltitude());
		DronologyMonitoringManager.getInstance()
				.publish(MessageMarshaller.createMessage(MessageType.MISSION_WAYPOINT, uavMission.getUavID(), targetWaypoint2));

		LlaCoordinate landWaypoint = new LlaCoordinate(targetLocation.getLatitude(), targetLocation.getLongitude(),
				targetLocation.getAltitude());
		DronologyMonitoringManager.getInstance()
				.publish(MessageMarshaller.createMessage(MessageType.MISSION_WAYPOINT, uavMission.getUavID(), landWaypoint));

		addTask(TaskFactory.getTask(TaskFactory.WAYPOINT, uavMission.getUavID(), targetWaypoint1));
		addTask(TaskFactory.getTask(TaskFactory.SYNC, uavMission.getUavID(), SyncConstants.LANDING_ASC_REACHED));

		addTask(TaskFactory.getTask(TaskFactory.WAYPOINT, uavMission.getUavID(), targetWaypoint2));
		addTask(TaskFactory.getTask(TaskFactory.SYNC, uavMission.getUavID(), SyncConstants.LANDING_LONLAT_REACHED));

		addTask(TaskFactory.getTask(TaskFactory.LAND, uavMission.getUavID(), landWaypoint));
		addTask(TaskFactory.getTask(TaskFactory.SYNC, uavMission.getUavID(), SyncConstants.LANDING_HOME_REACHED));

	}

	@Override
	protected void doCreateSyncPoints() {
		addSyncPoint(""SP-TakeOff-AscentTargetReached"");
		addSyncPoint(""SP-TakeOff-LonLatReached"");
		addSyncPoint(""SP-TakeOff-FirstWayPointReached"");

	}

}
"
UAVRegistrationXStreamPersistor.java,"package edu.nd.dronology.services.core.persistence.internal;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.XppDriver;

import edu.nd.dronology.services.core.items.IUAVRegistration;
import edu.nd.dronology.services.core.persistence.DronologyPersistenceUtil;
import edu.nd.dronology.services.core.persistence.IPersistenceManager;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class UAVRegistrationXStreamPersistor implements IPersistenceManager<IUAVRegistration> {

	private static final XStream xstream = new XStream(new XppDriver());
	private static ILogger LOGGER = LoggerProvider.getLogger(UAVRegistrationXStreamPersistor.class);

	static final boolean useCompression = false;

	@Override
	public IUAVRegistration open(InputStream fin) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
	//	 xstream.setMode(XStream.);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");
		
		if (useCompression) {
			return loadedCompressedStream(fin);
		} else {
			return loadUncompressedStream(fin);
		}
	}

	private IUAVRegistration loadUncompressedStream(InputStream fin) throws PersistenceException {
		try {
			InputStreamReader reader = new InputStreamReader(new BufferedInputStream(fin), Charset.forName(""UTF-8""));
			Object model = xstream.fromXML(reader);
			return (IUAVRegistration) model;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (fin != null) {
					fin.close();
				}
			} catch (Exception e) {
				LOGGER.error(e);
			}
		}
	}

	private IUAVRegistration loadedCompressedStream(InputStream fin) throws PersistenceException {
		InputStream zIn = null;
		try {
			zIn = new GZIPInputStream(fin);
			Object model = xstream.fromXML(new BufferedReader(new InputStreamReader(zIn, ""UTF-8"")));

			return (IUAVRegistration) model;
		} catch (IOException e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (zIn != null) {
					zIn.close();
				}
				if (fin != null) {
					fin.close();
				}
			} catch (Exception e) {
				LOGGER.error(e);
			}

		}
	}
 
	@Override
	public boolean save(IUAVRegistration o, OutputStream fout) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
		// xstream.setMode(XStream.ID_REFERENCES);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");
		// xstream.addImplicitMap(ImplMEEvent.class, ""relatedEvents"", ImplMEEvent.class, ""relatedEvents"");

		if (useCompression) {
			return saveCompressedStream(o, fout);
		} else {
			return saveUncompressedStream(o, fout);
		}

	}

	private boolean saveUncompressedStream(IUAVRegistration o, OutputStream fout) throws PersistenceException {
		OutputStreamWriter writer = null;
		try {
			writer = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(""UTF-8""));
			xstream.toXML(o, writer);
			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (writer != null) {
					writer.close();
				}
				if (fout != null) {
					fout.close();
				}
			} catch (IOException e) {
				LOGGER.error(e);
			}
		}

	}

	private boolean saveCompressedStream(IUAVRegistration o, OutputStream fout) throws PersistenceException {
		try {
			GZIPOutputStream zOut = new GZIPOutputStream(fout);
			xstream.toXML(o, new BufferedWriter(new OutputStreamWriter(zOut, ""UTF-8"")));

			zOut.close();
			fout.close();

			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		}
	}

}
"
AMMapComponent.java,"package edu.nd.dronology.ui.vaadin.areamapping;

import java.io.ByteArrayInputStream;
import java.rmi.RemoteException;
import java.util.List;
import java.util.Vector;

import org.vaadin.addon.leaflet.LMap;
import org.vaadin.addon.leaflet.shared.Point;

import com.vaadin.ui.AbsoluteLayout;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.AbsoluteLayout.ComponentPosition;

import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.services.core.areamapping.EdgeLla;
import edu.nd.dronology.services.core.info.AreaMappingInfo;
import edu.nd.dronology.services.core.items.IAreaMapping;
import edu.nd.dronology.services.core.persistence.AreaMappingPersistenceProvider;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import edu.nd.dronology.services.core.remote.IAreaMappingRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.ui.vaadin.areamapping.windows.AMDeleteWayPointConfirmation;
import edu.nd.dronology.ui.vaadin.areamapping.windows.AMWayPointPopupView;
import edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;
import edu.nd.dronology.ui.vaadin.map.LeafletmapFactory;
import edu.nd.dronology.ui.vaadin.start.MyUI;
import edu.nd.dronology.ui.vaadin.utils.WaypointReplace;

/**
 * This is the map component for area mapping. It holds most of the visual elements, and is largely controlled by AMMapMarkerUtilities
 * 
 * @author Andrew Slavin
 */

public class AMMapComponent extends CustomComponent{
	
	private static final long serialVersionUID = 8009738721123823238L;
	private AMMainLayout mainLayout;
	private AMMapMarkerUtilities utilities;
	
	private AMWayPointPopupView waypointPopupView;
	private AMDeleteWayPointConfirmation deleteWayPointConfirmation = new AMDeleteWayPointConfirmation(this);
	
	private VerticalLayout content = new VerticalLayout();
	private AbsoluteLayout mapAndComponentsLayout = new AbsoluteLayout();
	
	private AMEditSidesController editSidesController = new AMEditSidesController(this);
	private AMEditPrioritiesController editPrioritiesController = new AMEditPrioritiesController(this);
	private AMSubMapController subMapController = new AMSubMapController(this);
	private AMMetaInfo metaInfo = new AMMetaInfo(this);
	private LMap leafletMap;
	
	public AMMapComponent(AMMainLayout mainLayout) {
		this.mainLayout = mainLayout;
		this.setWidth(""100%"");
		leafletMap = LeafletmapFactory.generateMap();
		
		// create a popup when user mouses over waypoint via listener
		waypointPopupView = new AMWayPointPopupView(this);
		
		mapAndComponentsLayout.addComponents(waypointPopupView, leafletMap, subMapController, editSidesController, editPrioritiesController);
		content.addComponents(metaInfo, mapAndComponentsLayout);
		setCompositionRoot(content);		
		
		this.addStyleName(""map_component"");
		this.addStyleName(""am_map_component""); 
		mapAndComponentsLayout.addStyleName(""am_mapabsolute_layout"");
		leafletMap.addStyleName(""am_leaflet_map"");
		leafletMap.addStyleName(""bring_back"");
		
		editSidesController.addStyleName(""bring_front"");
		editSidesController.setVisible(false);
		editPrioritiesController.addStyleName(""bring_front"");
		editPrioritiesController.setVisible(false);
		subMapController.addStyleName(""bring_front"");
		subMapController.setVisible(false);
		
		utilities = new AMMapMarkerUtilities(this);
	}
	
		// Displays with the map. Called when a mapping is deleted so that
		// its waypoints are no longer displayed.
		public void displayNoMapping() {
			metaInfo.showInfoWhenNoMappingIsSelected();
			utilities.removeAllPins();
			updateLinesAndGrid();
		}
		
		@WaypointReplace
		public void displayAreaMapping(AreaMappingInfo info) {
			metaInfo.showInfoForSelectedMapping(info);

			// Removes old pins and show the new pins
			utilities.removeAllPins();
			for (EdgeLla coordinate : info.getCoordinates(0)) {
				Waypoint waypoint = new Waypoint(coordinate);
				UIEdgePoint way = new UIEdgePoint(waypoint, 0);
				utilities.addNewPin(way, -1);
			}
			for (EdgeLla coordinate : info.getCoordinates(1)) {
				Waypoint waypoint = new Waypoint(coordinate);
				UIEdgePoint way = new UIEdgePoint(waypoint, 1);
				utilities.addNewPin(way, -1);
			}

			// redraw the lines and priorities to the map
			utilities.getAllPriorityLines().clear();
			utilities.getAllPrioritySides().clear();
			utilities.getNewPrioritySideLines().clear();
			updateLinesAndGrid();
			utilities.drawPriorities();
			utilities.highlightUpstream();
			setMappingCenter();
		}
	
		// Displays the waypoints in edit mode depending on whether or not the route is new.
		public void updateWayPointCount(AMMapMarkerUtilities mapUtilities) {
			metaInfo.setNumWaypoints(mapUtilities.getOrderedWayPoints().get(0).size(), mapUtilities.getOrderedWayPoints().get(1).size());
		}

		// Gets the mapping description using the currently selected mapping stored by
		// ""selectedMapping"".
		public String getMappingDescription() {
			AreaMappingPersistenceProvider mappingPersistor = AreaMappingPersistenceProvider.getInstance();
			ByteArrayInputStream inStream;
			IAreaMapping amapping;

			IAreaMappingRemoteService service;
			BaseServiceProvider provider = MyUI.getProvider();

			String description = null;
			// Sends the information to dronology to be saved.
			try {
				service = (IAreaMappingRemoteService) provider.getRemoteManager()
						.getService(IAreaMappingRemoteService.class);

				String id = this.getMainLayout().getControls().getInfoPanel().getHighlightedAMInfoBox().getId();

				byte[] information = service.requestFromServer(id);
				inStream = new ByteArrayInputStream(information);
				amapping = mappingPersistor.loadItem(inStream);

				description = amapping.getDescription();
				if (description == null) {
					description = ""No Description"";
				}
			} catch (DronologyServiceException | RemoteException e1) {
				MyUI.setConnected(false);
				e1.printStackTrace();
			} catch (PersistenceException e1) {
				e1.printStackTrace();
			}
			return description;
		}

		// Sets the center of the route based on the stored waypoints such that the map
		// is as visible as possible.
		public void setMappingCenter() {
			if (metaInfo.isAutoZoomingChecked()) {
				// Calculates the mean point and sets the route.
				double meanLat = 0;
				double meanLon = 0;
				int numberPoints;
				double farthestLat = 0;
				double farthestLon = 0;
				double zoom;

				Vector<List<UIEdgePoint>> currentWayPoints = utilities.getOrderedWayPoints();
				numberPoints = currentWayPoints.get(0).size() + currentWayPoints.get(1).size();

				for (UIEdgePoint p : currentWayPoints.get(0)) {
					meanLat += Double.valueOf(p.getLatitude());
					meanLon += Double.valueOf(p.getLongitude());
				}
				for (UIEdgePoint p : currentWayPoints.get(1)) {
					meanLat += Double.valueOf(p.getLatitude());
					meanLon += Double.valueOf(p.getLongitude());
				}

				meanLat /= (numberPoints * 1.0);
				meanLon /= (numberPoints * 1.0);

				// Finds farthest latitude and longitude from mean.
				for (UIEdgePoint p : currentWayPoints.get(0)) {
					if ((Math.abs(Double.valueOf(p.getLatitude()) - meanLat) > farthestLat)) {
						farthestLat = (Math.abs((Double.valueOf(p.getLatitude())) - meanLat));
					}
					if ((Math.abs(Double.valueOf(p.getLongitude()) - meanLon) > farthestLon)) {
						farthestLon = (Math.abs((Double.valueOf(p.getLongitude()) - meanLon)));
					}
				}
				for (UIEdgePoint p : currentWayPoints.get(1)) {
					if ((Math.abs(Double.valueOf(p.getLatitude()) - meanLat) > farthestLat)) {
						farthestLat = (Math.abs((Double.valueOf(p.getLatitude())) - meanLat));
					}
					if ((Math.abs(Double.valueOf(p.getLongitude()) - meanLon) > farthestLon)) {
						farthestLon = (Math.abs((Double.valueOf(p.getLongitude()) - meanLon)));
					}
				}

				// Used to calculate zoom level.
				Point centerPoint = new Point(meanLat, meanLon);
				if (farthestLat == 0 && farthestLon == 0) {
					zoom = 17;
				} else {
					zoom = Math.floor(Math.log10(180.0 / Math.max(farthestLat, farthestLon)) / Math.log10(2));
				}

				leafletMap.setCenter(centerPoint, zoom + 1);
			}
		}

		// Refreshes the map and grid by removing lines, redrawing them, and then
		// setting the map again.
		public void updateLinesAndGrid() {
			utilities.redrawAllLines(false);
			// if deleting a polygon, don't try to redraw polygons
			if (this.getMainLayout().getDeletingMapping()) {
				utilities.removeAllPriorityAreas();
				this.getMainLayout().setDeletingMapping(false);
				return;
			}
		}

		public ComponentPosition getWaypointPopupViewPosition() {
			return mapAndComponentsLayout.getPosition(waypointPopupView);
		}

		public void setWaypointPopupViewPosition(ComponentPosition position) {
			mapAndComponentsLayout.setPosition(waypointPopupView, position);
		}

		// Gets the class that represents the utilities.
		public AMMapMarkerUtilities getMapUtilities() {
			return utilities;
		}

		public LMap getMap() {
			return leafletMap;
		}

		// Gets the main layout (passed into constructor).
		public AMMainLayout getMainLayout() {
			return mainLayout;
		}

		// Gets the route information bar above the map.
		public AMMetaInfo getMetaInfo() {
			return metaInfo;
		}
	 
		public AMEditSidesController getEditSidesController() {
			return editSidesController;
		}
		
		public AMEditPrioritiesController getEditPrioritiesController() {
			return editPrioritiesController;
		}
		
		public AMSubMapController getSubMapController() {
			return subMapController;
		}

		public AMWayPointPopupView getWaypointPopupView() {
			return waypointPopupView;
		}

		public AMDeleteWayPointConfirmation getDeleteWayPointConfirmation() {
			return deleteWayPointConfirmation;
		}
		
}
"
Command.java,"package edu.nd.dronology.core.collisionavoidance.guidancecommands;

public abstract class Command {
}
"
DroneSnapshotInternal.java,"package edu.nd.dronology.core.collisionavoidance;

import edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.goal.AbstractGoal;
import edu.nd.dronology.core.goal.IGoalSnapshot;
import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

/**
 *
 * 
 */
public class DroneSnapshotInternal implements DroneSnapshot {

    private String name;
    private final LlaCoordinate position;
    private final Vector3D velocity;
    private final Vector3D attitude;
    private String state;
    private Set<IGoalSnapshot> goals;


    private final ArrayList<Command> commands;

    public DroneSnapshotInternal(String name, LlaCoordinate position, Vector3D velocity, Vector3D attitude) {
        this.name = name;
        this.position = position;
        this.velocity = velocity;
        this.attitude = attitude;
        this.commands = new ArrayList<>();
        this.goals = new HashSet<>();
    }

    @Override
    public LlaCoordinate getPosition() {
        return this.position;
    }

    @Override
    public ArrayList<Command> getCommands() {
        return commands;
    }

    @Override
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public Vector3D getVelocity() {
        return velocity;
    }

    @Override
    public Vector3D getAttitude() {
        return attitude;
    }

    @Override
    public String getState() {
        return this.state;
    }

    @Override
    public Set<IGoalSnapshot> getGoals() {
        return goals;
    }

    public void setState(String state) {
        this.state = state;
    }

    public void setGoals(Set<IGoalSnapshot> goals) {
        this.goals = goals;
    }
}
"
IMissionPlan.java,"package edu.nd.dronology.services.core.items;

import java.util.List;

public interface IMissionPlan extends IPersistableItem{

	String getDescription();

	void setDescription(String description);

	List<IUAVMissionDescription> getMissionDescriptions();

	void addMissionDescription(IUAVMissionDescription description);



}
"
DroneSafetyStateManager.java,"package edu.nd.dronology.core.vehicle;

/**
 * Associates a drone safety state object with a drone. ONLY set this in the drone constructor. NEVER interchange at runtime - otherwise drone state will be incorrectly changed.
 * 
 * @author Jane Cleland-Huang
 * @version 0.01
 *
 */
public class DroneSafetyStateManager {

	private enum SafetyMode {
		DIVERTED, HALTED, NORMAL
	}

	private SafetyMode safetyMode;

	/**
	 * Constructor States for both FlightMode and SafetyMode set to initial state
	 */
	public DroneSafetyStateManager() {
		safetyMode = SafetyMode.NORMAL;
	}

	// Setters
	public void setSafetyModeToNormal() {
		safetyMode = SafetyMode.NORMAL;
	}

	public void setSafetyModeToDiverted() {
		safetyMode = SafetyMode.DIVERTED;
	}

	public void setSafetyModeToHalted() {
		safetyMode = SafetyMode.HALTED;
	}

	public boolean isSafetyModeNormal() {
		return safetyMode == SafetyMode.NORMAL;
	}

	public boolean isSafetyModeDiverted() {
		return safetyMode == SafetyMode.DIVERTED;

	}

	public boolean isSafetyModeHalted() {
		return safetyMode == SafetyMode.HALTED;

	}

	public String getSafetyStatus() {
		return safetyMode.toString();
	}

}
"
IDroneSimulatorServiceInstance.java,"package edu.nd.dronology.services.instances.dronesimulator;

import java.util.Collection;
import java.util.List;

import edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;
import edu.nd.dronology.services.core.info.SimulatorScenarioCategoryInfo;
import edu.nd.dronology.services.core.info.SimulatorScenarioInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public interface IDroneSimulatorServiceInstance extends IFileTransmitServiceInstance<SimulatorScenarioInfo> {

	void activateScenario(SimulatorScenarioInfo scenario) throws DronologyServiceException;

	Collection<SimulatorScenarioCategoryInfo> getCategories();


}
"
AMEditSidesController.java,"package edu.nd.dronology.ui.vaadin.areamapping;

import java.util.ArrayList;
import java.util.List;

import com.vaadin.ui.Button;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Label;
import com.vaadin.ui.Notification;
import com.vaadin.ui.RadioButtonGroup;
import com.vaadin.ui.UI;
import com.vaadin.ui.themes.ValoTheme;

import edu.nd.dronology.ui.vaadin.areamapping.windows.AMSaveAreaWithoutFinishWindow;

/**
 * This allows the user to create and edit mappings. However, it is primarily a shell with the necessary buttons.
 * The save button and cancel button functionality is primarily carried out by saveClick and cancelClick in the areas controller.
 * 
 * @author Andrew Slavin
 *
 */

public class AMEditSidesController extends CustomComponent {
	/**
	 *  
	 */
	private static final long serialVersionUID = 212323831233690123L;
	private AMMapComponent mapComponent;
	private HorizontalLayout totalLayout = new HorizontalLayout();
	private Button cancelButton = new Button(""Cancel"");
	private Button saveButton = new Button(""Save"");
	private Button editPrioritiesButton = new Button(""Priorities"");
	private Button editSidesButton = new Button(""Sides"");
	private RadioButtonGroup<String> group = new RadioButtonGroup<>();
	private Label smallText = new Label(""Left click to add a side coordinate. Drag waypoints to move."");
	
	private List<UIEdgePoint> storedPoints0 = new ArrayList<>();
	private List<UIEdgePoint> storedPoints1 = new ArrayList<>();
	private Boolean sideA = false;

	public AMEditSidesController(AMMapComponent mapComponent) {
		this.mapComponent = mapComponent;

		setStyleName(""am_edit_bar"");
		smallText.setStyleName(""small_text"");

		cancelButton.setHeight(""25px"");
		saveButton.setHeight(""25px"");
		editPrioritiesButton.setHeight(""35px"");
		editSidesButton.setHeight(""30px"");
		editSidesButton.addStyleName(""sides_button"");
		editSidesButton.setEnabled(false);
		editSidesButton.addStyleName(""toggle_button"");
		editPrioritiesButton.addStyleName(""toggle_button"");
		group.setHeight(""10px"");
		group.setItems(""Side A"", ""Side B"");
		group.addStyleName(ValoTheme.OPTIONGROUP_HORIZONTAL);
		group.setSelectedItem(""Side A"");
		totalLayout.addComponents(editSidesButton, editPrioritiesButton, smallText, group, cancelButton, saveButton);
		setCompositionRoot(totalLayout);

		// Click listeners for the cancel and saves buttons on edit bar
		cancelButton.addClickListener(e -> {
			exitEditMode();
			mapComponent.getEditPrioritiesController().cancelClick();
		});
		saveButton.addClickListener(e -> {
			
			// if the user hasn't selected upstream yet, prompt them to do so
			if (mapComponent.getMapUtilities().getUpstream() == null) {
				Notification.show(""Please select the most upstream side A coordinate."", Notification.Type.ERROR_MESSAGE);
				mapComponent.getEditPrioritiesController().setSelectingUpstream(true);
				return;
			}
			
			// reset buttons and check that area is correct number of sides
			mapComponent.getEditPrioritiesController().getDrawAreaButton().setEnabled(true);
			mapComponent.getEditPrioritiesController().getDrawSideButton().setEnabled(true);
			if (mapComponent.getEditPrioritiesController().getDrawingArea()) {
				if (mapComponent.getMapUtilities().getPolygonVertices().size() < 3) {
					Notification.show(""Please finish your unfinished priority area."", Notification.Type.ERROR_MESSAGE);
					return;
				}
				UI.getCurrent().addWindow(new AMSaveAreaWithoutFinishWindow(mapComponent.getEditPrioritiesController()));
			}
			else if (mapComponent.getEditPrioritiesController().getDrawingSide()) {
				if (mapComponent.getMapUtilities().getNewPrioritySideLines().size() == 0) {
					Notification.show(""Please finish your unfinished priority area."", Notification.Type.ERROR_MESSAGE);
				}
				UI.getCurrent().addWindow(new AMSaveAreaWithoutFinishWindow(mapComponent.getEditPrioritiesController()));
			}
			else {
				mapComponent.getEditPrioritiesController().saveClick();
				exitEditMode();
			}
		});
		
		// if radio button is switched, change side of mapping
		group.addValueChangeListener(e -> {
			sideA = !sideA;
		});
		
		editPrioritiesButton.addClickListener(e -> {
			exitEditMode();
			mapComponent.getEditPrioritiesController().enterEditMode();
		});
		
	}


	// Enables editing, adds the edit bar, and calls the enableMappingEditing function
	// from MapMarkerUtilities.
	public void enterEditMode() {
		storedPoints0 = mapComponent.getMapUtilities().getOrderedWayPoints().get(0);
		storedPoints1 = mapComponent.getMapUtilities().getOrderedWayPoints().get(1);

		mapComponent.getMapUtilities().setSidesAreEditable(true);
		mapComponent.getMapUtilities().setPrioritiesAreEditable(false);

		this.setVisible(true);

		mapComponent.getMap().addStyleName(""fr_leaflet_map_edit_mode"");
	}

	// Disables editing, removes the edit bar, and changes the component styles
	// accordingly.
	public void exitEditMode() {
		storedPoints0.clear();
		storedPoints1.clear();

		mapComponent.getMapUtilities().setSidesAreEditable(false);
		this.setVisible(false);

		mapComponent.getMap().removeStyleName(""fr_leaflet_map_edit_mode"");
	}
	public Boolean getSideA() {
		return sideA;
	}
	
	public void setSideA() {
		group.setSelectedItem(""Side A"");
	}
	
	public Button getSaveButton() {
		return saveButton;
	}
	
}
"
FollowTheLeaderNed.java,"package edu.nd.dronology.core.collisionavoidance.strategy;

import java.util.ArrayList;

import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;

import edu.nd.dronology.core.collisionavoidance.CollisionAvoider;
import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.NedCommand;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.goal.WaypointGoalSnapshot;

public class FollowTheLeaderNed implements CollisionAvoider {

    private static final double THRESHOLD_DISTANCE = 1.0;
    private static final double FOLLOW_DISTANCE = 10.0;
    private static final Vector3D NED_OFFSET = new Vector3D(0, 0, -FOLLOW_DISTANCE);

	@Override
	public void avoid(ArrayList<DroneSnapshot> drones) {
        DroneSnapshot leader = findLeader(drones);
        DroneSnapshot follower = findFollower(drones);

        if (leader != null) {
            WaypointGoalSnapshot wp = StopEveryone.findActiveWaypointGoal(leader.getGoals());
            if (wp != null) {
                StopEveryone.flyToGoalIfNotAlready(leader, wp);
            }

            if (follower != null) {
                Vector3D ned = findFollowVelocity(leader.getPosition(), follower.getPosition());
                follower.getCommands().clear();
                follower.getCommands().add(new NedCommand(ned.getX(), ned.getY(), ned.getZ(), 2.0));
            }
        } else if (follower != null) {
            WaypointGoalSnapshot wp = StopEveryone.findActiveWaypointGoal(follower.getGoals());
            if (wp != null) {
                StopEveryone.flyToGoalIfNotAlready(follower, wp);
            }   
        }
    }

    Vector3D findFollowVelocity(LlaCoordinate leader, LlaCoordinate follower) {
        LlaCoordinate followPoint = leader.findLla(NED_OFFSET);
        double distance = followPoint.distance(follower);
        if (distance > THRESHOLD_DISTANCE) {    
            double speed = Math.min(distance, 7.0);
            Vector3D arrow = follower.findNed(followPoint);
            return arrow.normalize().scalarMultiply(speed);
        }
        return Vector3D.ZERO;
    }
    
    static DroneSnapshot findLeader(ArrayList<DroneSnapshot> drones) {
        for (DroneSnapshot drone: drones) {
            if (""LEADER"".equals(drone.getName())) {
                return drone;
            }
        }
        return null;
    }

    static DroneSnapshot findFollower(ArrayList<DroneSnapshot> drones) {
        for (DroneSnapshot drone: drones) {
            if (!""LEADER"".equals(drone.getName())) {
                return drone;
            }
        }
        return null;
     }
}"
DroneSimulatorServiceRemoteFacade.java,"package edu.nd.dronology.services.facades;

import java.rmi.RemoteException;
import java.util.Collection;

import edu.nd.dronology.services.core.info.SimulatorScenarioCategoryInfo;
import edu.nd.dronology.services.core.info.SimulatorScenarioInfo;
import edu.nd.dronology.services.core.listener.IItemChangeListener;
import edu.nd.dronology.services.core.remote.IDroneSimulatorRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.instances.dronesimulator.DroneSimulatorService;
import edu.nd.dronology.services.remote.AbstractRemoteFacade;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class DroneSimulatorServiceRemoteFacade extends AbstractRemoteFacade implements IDroneSimulatorRemoteService {
	/**
	 * 
	 */
	private static final long serialVersionUID = -4580658378477037955L;
	private static final ILogger LOGGER = LoggerProvider.getLogger(DroneSimulatorServiceRemoteFacade.class);
	private static volatile DroneSimulatorServiceRemoteFacade INSTANCE;

	protected DroneSimulatorServiceRemoteFacade() throws RemoteException {
		super(DroneSimulatorService.getInstance());
	}

	public static IDroneSimulatorRemoteService getInstance() throws RemoteException {
		if (INSTANCE == null) {
			synchronized (DroneSimulatorServiceRemoteFacade.class) {
				try {
					if (INSTANCE == null) {
						INSTANCE = new DroneSimulatorServiceRemoteFacade();
					}
				} catch (RemoteException e) {
					LOGGER.error(e);
				}
			}
		}
		return INSTANCE;

	}

	@Override
	public byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException {
		return DroneSimulatorService.getInstance().requestFromServer(id);
	}

	@Override
	public void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException {
		DroneSimulatorService.getInstance().transmitToServer(id, content);

	}

	@Override
	public boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException {
		return DroneSimulatorService.getInstance().addItemChangeListener(listener);
	}

	@Override
	public boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException {
		return DroneSimulatorService.getInstance().removeItemChangeListener(listener);
	}

	@Override
	public Collection<SimulatorScenarioInfo> getItems() throws RemoteException {
		return DroneSimulatorService.getInstance().getItems();
	}

	@Override
	public SimulatorScenarioInfo createItem() throws RemoteException, DronologyServiceException {
		return DroneSimulatorService.getInstance().createItem();
	}

	@Override
	public void deleteItem(String itemid) throws RemoteException, DronologyServiceException {
		DroneSimulatorService.getInstance().deleteItem(itemid);

	}

	@Override
	public void activateScenario(SimulatorScenarioInfo scenario) throws RemoteException, DronologyServiceException {
		DroneSimulatorService.getInstance().activateScenario(scenario);
		
	}

	@Override
	public Collection<SimulatorScenarioCategoryInfo> getCategories() throws RemoteException {
		return DroneSimulatorService.getInstance().getCategories();
		
	}
}"
RouteAssignmentDemoScript.java,"package edu.nd.dronology.misc.scripts;

import java.rmi.Naming;
import java.util.ArrayList;
import java.util.List;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;
import edu.nd.dronology.services.core.remote.IRemoteManager;

public class RouteAssignmentDemoScript {

	private static final String ADDRESS_SCHEME = ""rmi://%s:%s/Remote"";

	public static void main(String[] args) {
		try {

			IRemoteManager manager = (IRemoteManager) Naming.lookup(String.format(ADDRESS_SCHEME, ""127.0.0.1"", 9779));

			IFlightManagerRemoteService managerService = (IFlightManagerRemoteService) manager
					.getService(IFlightManagerRemoteService.class);

			List<Waypoint> route1 = new ArrayList<>();
			double lat = -43.123;
			double lon= 23.4123;
			double alt = 10;
			route1.add(new Waypoint(new LlaCoordinate(lat, lon, alt)));

			managerService.planFlight(""UAV1"", ""TestRoute1"", route1);

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

}
"
RiverList.java,"package edu.nd.dronology.services.extensions.areamapping.internal;

//Class used for automatic parsing of JSON file with GSON library

import java.util.ArrayList;
import java.util.List;

public class RiverList{
  private List<MapNode> nodes;
  public RiverList(){
      nodes = new ArrayList<MapNode>();
  }
  public List<MapNode> getNodes(){
      return nodes;
  }
}
"
MetricsUtilities.java,"package edu.nd.dronology.services.extensions.areamapping.metrics;

import java.awt.Point;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Vector;

import edu.nd.dronology.services.extensions.areamapping.internal.Geometry;
import edu.nd.dronology.services.extensions.areamapping.internal.ImageWaypoint;
import edu.nd.dronology.services.extensions.areamapping.internal.ImageWaypoints;
import edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive.RouteType;

public class MetricsUtilities {
	/**
	 * This function generates circular ellipses for each image waypoint.
	 * 
	 * @param route
	 * @param APERATURE_WIDTH
	 * @return vector of circular Ellipse2D.Double
	 */
	public static Vector<Ellipse2D.Double> generateIWPCircles(RoutePrimitive route, double APERATURE_WIDTH) {
		Vector<Ellipse2D.Double> circles = new Vector<>();
		ImageWaypoints imageWaypoints = route.getIWP();
		for (ImageWaypoint entry : imageWaypoints.get()) {
			Ellipse2D.Double newCircle = new Ellipse2D.Double(entry.getWaypoint().getX() - APERATURE_WIDTH / 2,
					entry.getWaypoint().getY() - APERATURE_WIDTH / 2, APERATURE_WIDTH, APERATURE_WIDTH);
			circles.add(newCircle);
		}
		return circles;
	}

	public static Vector<Path2D.Double> generateIWPRectangles(RoutePrimitive route, double APERATURE_WIDTH,
			double APERATURE_HEIGHT) {
		Vector<Path2D.Double> coverageRectangles = new Vector<>();
		for (ImageWaypoint entry : route.getIWP().get()) {
			coverageRectangles.add(generateIWPRectangle(entry, APERATURE_WIDTH, APERATURE_HEIGHT));
		}
		return coverageRectangles;
	}

	private static Path2D.Double generateIWPRectangle(ImageWaypoint imagePoint, double APERATURE_WIDTH,
			double APERATURE_HEIGHT) {
		Path2D.Double coverageRectangle = new Path2D.Double();
		Point2D.Double midpoint1 = new Point2D.Double();
		Point2D.Double midpoint2 = new Point2D.Double();
		Point2D.Double corner1 = new Point2D.Double();
		Point2D.Double corner2 = new Point2D.Double();
		Point2D.Double corner3 = new Point2D.Double();
		Point2D.Double corner4 = new Point2D.Double();
		double dxHeight = APERATURE_HEIGHT / 2 * Math.cos(imagePoint.getOrientationAngle());
		double dyHeight = APERATURE_HEIGHT / 2 * Math.sin(imagePoint.getOrientationAngle());
		double dxWidth = APERATURE_WIDTH / 2 * Math.cos(imagePoint.getOrientationAngle() + Math.PI / 2);
		double dyWidth = APERATURE_WIDTH / 2 * Math.sin(imagePoint.getOrientationAngle() + Math.PI / 2);
		midpoint1.setLocation(imagePoint.getWaypoint().getX() + dxHeight, imagePoint.getWaypoint().getY() + dyHeight);
		midpoint2.setLocation(imagePoint.getWaypoint().getX() - dxHeight, imagePoint.getWaypoint().getY() - dyHeight);
		corner1.setLocation(midpoint1.getX() + dxWidth, midpoint1.getY() + dyWidth);
		corner2.setLocation(midpoint1.getX() - dxWidth, midpoint1.getY() - dyWidth);
		corner3.setLocation(midpoint2.getX() - dxWidth, midpoint2.getY() - dyWidth);
		corner4.setLocation(midpoint2.getX() + dxWidth, midpoint2.getY() + dyWidth);
		coverageRectangle.moveTo(corner1.getX(), corner1.getY());
		coverageRectangle.lineTo(corner2.getX(), corner2.getY());
		coverageRectangle.lineTo(corner3.getX(), corner3.getY());
		coverageRectangle.lineTo(corner4.getX(), corner4.getY());
		coverageRectangle.closePath();
		return coverageRectangle;
	}

	static Random random = new Random();

	public static int generateRandomNumber(int max, int min) {

		return random.nextInt((max - min) + 1) + min;
	}

	/**
	 * This function generates a pseudorandom point.
	 * 
	 * @param minPoint
	 * @param maxPoint
	 * @return Point2D.Double pseudorandom point
	 */
	public static Point2D.Double generateRandomPoint(Point2D.Double minPoint, Point2D.Double maxPoint) {
		Point2D.Double newPoint = new Point2D.Double();
		double minLat = minPoint.getX();
		double maxLat = maxPoint.getX();
		double minLong = minPoint.getY();
		double maxLong = maxPoint.getY();
		Random random = new Random();
		double newX = (random.nextDouble() * (maxLat + 1 - minLat)) + minLat;
		double newY = (random.nextDouble() * (maxLong + 1 - minLong)) + minLong;
		newPoint.setLocation(newX, newY);
		return newPoint;
	}

	// assumes drone startPoint and home location are stored in cartesian coordinates
	public static double totalDroneDistance(Drone drone) {
		double totalDistance = 0;
		DroneRouteAssignment routeAssignment = drone.getDroneRouteAssignment();
		Point2D.Double startPoint = drone.getDroneStartPoint();
		for (RoutePrimitive route : routeAssignment.get()) {
			totalDistance += Geometry.findCartesianDistance(startPoint, route.getRouteStartPoint());
			totalDistance += route.getRouteDistance();
			startPoint = route.getRouteEndPoint();
		}
		totalDistance += Geometry.findCartesianDistance(startPoint, drone.getDroneHomeLocation());
		return totalDistance;
	}
	
	public static double totalBatteryDistance(Drone drone) {
		double totalDistance = 0;
		DroneRouteAssignment routeAssignment = drone.getDroneRouteAssignment();
		Point2D.Double startPoint = drone.getDroneStartPoint();
		for (RoutePrimitive route : routeAssignment.get()) {
			if(route.getRouteType() == RouteType.HOME) {
				totalDistance += route.getRouteDistance();
				if(totalDistance / 1000 > 10) {
					return totalDistance;
				}
				totalDistance = 0;
			} else {
				totalDistance += Geometry.findCartesianDistance(startPoint, route.getRouteStartPoint());
				totalDistance += route.getRouteDistance();
				startPoint = route.getRouteEndPoint();
			}
		}
		totalDistance += Geometry.findCartesianDistance(startPoint, drone.getDroneHomeLocation());
		return totalDistance;
	}
	
	public static double totalAllocationDistance(List<Drone> drones) {
		double totalDistance = 0;
		for(Drone drone : drones) {
			totalDistance += totalDroneDistance(drone);
		}
		return totalDistance;
	}
	
	public static List<Double> calculateDroneDistances(List<Drone> drones){
		List<Double> droneDistances = new ArrayList<>();
		for(Drone drone : drones) {
			droneDistances.add(totalDroneDistance(drone));
		}
		return droneDistances;
	}

	public static double equalityOfTasks(List<Drone> drones) {
		double maxDistance = -Double.MAX_VALUE;
		double minDistance = Double.MAX_VALUE;
		double distance;
		for (Drone drone : drones) {
			distance = totalDroneDistance(drone);
			if (distance < minDistance) {
				minDistance = distance;
			}
			if (maxDistance < distance) {
				maxDistance = distance;
			}
		}
		return minDistance / maxDistance;
	}
	
	private static List<Point2D.Double> generateRandomRiverCoveragePoints(List<RiverBank> bankList, Path2D.Double totalRiverSegment) {
		Point2D.Double minBound = new Point2D.Double();
		Point2D.Double maxBound = new Point2D.Double();
		Vector<Point2D.Double> bounds = Geometry.simpleRiverBoundingRectangle(bankList);
		List<Point2D.Double> coveragePoints = new ArrayList<>();
		minBound = bounds.get(0);
		maxBound = bounds.get(1);
		for (int i = 0; i < 1000; i++) {
			Point2D.Double newPoint = MetricsUtilities.generateRandomPoint(minBound, maxBound);
			while (!totalRiverSegment.contains(newPoint)) {
				newPoint = MetricsUtilities.generateRandomPoint(minBound, maxBound);
			}
			coveragePoints.add(newPoint);
		}
		return coveragePoints;
	}

	/**
	 * This function calculates coverage statistics for the chosen RoutePrimitive objects.
	 * 
	 * @param routes
	 * @param coveragePoints
	 * @param APERATURE_WIDTH
	 * @return CoverageStatistics
	 */
	public static double calculateRouteCoverage(List<Drone> drones, Path2D.Double totalRiverSegment,
			List<RiverBank> bankList, double APERATURE_WIDTH, double APERATURE_HEIGHT) {
		List<Point2D.Double> coveragePoints = generateRandomRiverCoveragePoints(bankList, totalRiverSegment);
		double coverageFraction;
		double missedPoints = 0;
		boolean covered = false;
		List<RoutePrimitive> routes = new ArrayList<>();
		for (Drone drone : drones) {
			routes.addAll(drone.getDroneRouteAssignment().get());
		}
		Vector<Path2D.Double> imageWaypointRectangles = new Vector<>();
		for (RoutePrimitive route : routes) {
			if(route.getRouteType() != RoutePrimitive.RouteType.HOME) {
				imageWaypointRectangles.addAll(generateIWPRectangles(route, APERATURE_WIDTH, APERATURE_HEIGHT));
			}
		}
		for (Point2D.Double coveragePoint : coveragePoints) {
			for (Path2D.Double rectangle : imageWaypointRectangles) {
				if (rectangle.contains(coveragePoint)) {
					covered = true;
					break;
				}
			}
			if (!covered) {
				missedPoints += 1;
			}
			covered = false;
		}
		coverageFraction = 1 - missedPoints / coveragePoints.size();
		return coverageFraction;
	}

	public static double calculateDownstreamRatio(List<Drone> drones) {
		double downstreamRoutes = 0;
		double upstreamRoutes = 0;
		DroneRouteAssignment droneRoute;
		for (Drone drone : drones) {
			droneRoute = drone.getDroneRouteAssignment();
			for (RoutePrimitive route : droneRoute.get()) {
				if (route.getDownstreamDirection()) {
					downstreamRoutes += 1;
				} else {
					upstreamRoutes += 1;
				}
			}
		}
		return downstreamRoutes / (downstreamRoutes + upstreamRoutes);
	}
	
	private static double calculateDronePriorityCoverage(Drone drone) {
		double coverage = 0;
		double primitivePosition = 1;
		for(RoutePrimitive routePrimitive : drone.getDroneRouteAssignment().get()) {
			coverage += routePrimitive.getRouteWeight() * (1 / primitivePosition);
			primitivePosition++;
		}
		return coverage;
	}
	
	public static double calculateAllocationPriorityCoverage(List<Drone> drones) {
		double allocationCoverage = 0;
		for(Drone drone : drones) {
			allocationCoverage += calculateDronePriorityCoverage(drone);
		}
		return allocationCoverage;
	}

	public static boolean batteryFailure(Drone drone) {
		if (totalBatteryDistance(drone) / 1000 > 10) {
			return true;
		} else {
			return false;
		}
	}

	public static int collisionCheck(List<Drone> drones) {
		int collisions = 0;
		for (int i = 0; i < drones.size() - 1; i++) {
			List<Point2D.Double> currRoute = drones.get(i).getDroneFullRoute();
			for (int d = i + 1; d < drones.size(); d++) {
				List<Point2D.Double> otherRoute = drones.get(d).getDroneFullRoute();
				double currDistance = 0;
				for (int r = 0; r < currRoute.size() - 1; r++) {
					Line2D.Double currLineSeg = new Line2D.Double(currRoute.get(r), currRoute.get(r + 1));
					double otherDistance = 0;
					for (int r2 = 0; r2 < otherRoute.size() - 1; r2++) {
						Line2D.Double otherLineSeg = new Line2D.Double(otherRoute.get(r2), otherRoute.get(r2 + 1));
						if (currLineSeg.intersectsLine(otherLineSeg)) {
							Point2D.Double intersectionPoint = Geometry.findLineIntersection(currLineSeg, otherLineSeg);
							if (Math.abs((currDistance + Geometry.findCartesianDistance(
									new Point2D.Double(currLineSeg.getX1(), currLineSeg.getY1()), intersectionPoint))
									- (otherDistance + Geometry.findCartesianDistance(
											new Point2D.Double(otherLineSeg.getX1(), otherLineSeg.getY1()), intersectionPoint))) < 10) {
								/*
								 * System.out.println(Geometry.findLineIntersection(currLineSeg, otherLineSeg)); System.out.println(""currLineSeg: "" + ""["" + currLineSeg.getX1() + "", "" + currLineSeg.getX2() + ""] ["" +
								 * currLineSeg.getY1() + "", "" + currLineSeg.getY2() +""]""); System.out.println(""otherLineSeg: "" + ""["" + otherLineSeg.getX1() + "", "" + otherLineSeg.getX2() + ""] ["" + otherLineSeg.getY1()
								 * + "", "" + otherLineSeg.getY2() +""]""); System.out.println(""currDistance: "" + currDistance); System.out.println(""otherDistance: "" + otherDistance);
								 */
								collisions += 1;
							}
						}
						otherDistance += Geometry.findCartesianDistance(otherRoute.get(r2), otherRoute.get(r2 + 1));
					}

					currDistance += Geometry.findCartesianDistance(currRoute.get(r), currRoute.get(r + 1));
				}
			}
		}
		return collisions;
	}

	public static boolean routeAssignmentOutsideRiver(DroneRouteAssignment assignment, Path2D.Double riverSegment,
			double APERATURE_HEIGHT) {
		boolean outsideRiver = false;
		for (int i = 0; i < assignment.get().size() - 1; i++) {
			Point2D.Double startPoint = assignment.get(i).getRouteEndPoint();
			Point2D.Double endPoint = assignment.get(i + 1).getRouteStartPoint();
			outsideRiver = transitionOutsideRiver(startPoint, endPoint, riverSegment, APERATURE_HEIGHT);
			if (outsideRiver) {
				break;
			}
		}
		return outsideRiver;
	}

	// assumes it will never be going outside the river if the transition is less than an APERATURE_HEIGHT in length

	private static boolean transitionOutsideRiver(Point2D.Double startPoint, Point2D.Double endPoint,
			Path2D.Double riverSegment, double APERATURE_HEIGHT) {
		boolean outsideRiver = false;
		double totalDistance = Geometry.findCartesianDistance(startPoint, endPoint);
		double distanceRatio = APERATURE_HEIGHT / totalDistance;
		if (totalDistance < APERATURE_HEIGHT) {
			return outsideRiver;
		}
		while (APERATURE_HEIGHT < totalDistance) {
			Point2D.Double newPoint = Geometry.findOffsetPoint(startPoint, endPoint, distanceRatio);
			if (!riverSegment.contains(newPoint)) {
				return true;
			}
			startPoint = newPoint;
			totalDistance = totalDistance - APERATURE_HEIGHT;
		}
		return outsideRiver;
	}
}
"
IFlightRouteplanningServiceInstance.java,"package edu.nd.dronology.services.instances.flightroute;

import java.util.Collection;

import edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;
import edu.nd.dronology.services.core.info.FlightRouteCategoryInfo;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public interface IFlightRouteplanningServiceInstance extends IFileTransmitServiceInstance<FlightRouteInfo> {

	Collection<FlightRouteCategoryInfo> getFlightPathCategories();

	FlightRouteInfo getRouteByName(String routeName) throws DronologyServiceException;

}
"
IFileTransmitServiceInstance.java,"package edu.nd.dronology.services.core.api;

import java.util.Collection;

import edu.nd.dronology.services.core.listener.IItemChangeListener;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public interface IFileTransmitServiceInstance<ITEM_TYPE> extends IServiceInstance{

	byte[] requestFromServer(String id) throws DronologyServiceException;

	void transmitToServer(String id, byte[] content) throws DronologyServiceException;

	public boolean addItemChangeListener(IItemChangeListener listener);
	
	public boolean removeItemChangeListener(IItemChangeListener listener);
	
	Collection <ITEM_TYPE> getItems();
	
	ITEM_TYPE getItem(String id) throws DronologyServiceException;
	
	ITEM_TYPE createItem() throws  DronologyServiceException;

	void deleteItem(String itemid) throws  DronologyServiceException;
	
	
}
"
CollisionAvoidanceBackend.java,"package edu.nd.dronology.core.collisionavoidance;

import edu.nd.dronology.core.collisionavoidance.backendmessage.*;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.vehicle.ManagedDrone;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;
import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;

import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * <p>
 * The CollisionAvoidanceBackend is responsible for running the CollisionAvoider. Observes are registered in
 * ManagedDrone(s) and PhysicalDrone(s). These Observes pass along state. In the case of ManagedDrone, that state is the
 * set of active goals and the commandQueue. For PhysicalDrone, it's the drone's sensed state (its position, velocity
 * etc.). The data from both is combined to create DroneSnapshot(s) so that CollisionAvoider.avoid() can be called.
 * </p>
 *
 * <h2>implementation details (subject to change)</h2>
 * <p>
 * The idea behind CollisionAvoidanceBackend is to create an actor inspired object that only does work in response to
 * messages coming into its mailbox. CollisionAvoidanceBackend can do four things:
 * <ul>
 *     <li>Run CollisionAvoider.avoid() and disperse guidance to the managed drones. This class expects a stand-alone
 *     timer task to send this message periodically.</li>
 *
 *     <li>Receive an update message from a managed drone. This message includes a snapshot of the active goals as well
 *     as the queue of commands currently being executed. Messages of this type come in when the set of active goals
 *     changes or when the queue of commands changes. This happens when a goal or command is completed, for example.
 *     </li>
 *
 *     <li>Receive an update message from a physical drone. This message contains data sensed by a drones (its position,
 *     velocity, etc.). Messages of this type come in when new data is received from the drone.</li>
 *
 *     <li>Receive a stop command. This message should come in when the program is shutting down. This message causes
 *     the thread to gracefully stop.</li>
 * </ul>
 * </p>
 *
 *  <p>
 *     The {@link CollisionAvoidanceMessenger} object returned by {@link #getMessenger()} takes care of
 *     converting method calls into messages and delivering them to CollisionAvoidanceBackend's mailbox. All the
 *     functionality offered by this class is made accessible by the CollisionAvoidanceMessenger.
 * </p>
 * @see CollisionAvoidanceMessenger
 */
public class CollisionAvoidanceBackend implements Runnable {
    private static final ILogger LOGGER = LoggerProvider.getLogger(CollisionAvoidanceBackend.class);
    private static final boolean FIFO_MAILBOX = true;
    // TODO get this value, MAX_UAVS, from a configuration file
    private static final int MAX_UAVS = 10;
    // TODO get this value, UAV_REPORTS_PER_SECOND, from a configuration file
    private static final int UAV_REPORTS_PER_SECOND = 1;
    private static final int MAILBOX_BUFFER_FACTOR = 2;
    private static final int MAILBOX_CAPACITY = MAX_UAVS * UAV_REPORTS_PER_SECOND * MAILBOX_BUFFER_FACTOR;

    private final ArrayBlockingQueue<AbstractMessage> mailbox = new ArrayBlockingQueue<>(MAILBOX_CAPACITY, FIFO_MAILBOX);
    private final CollisionAvoider avoiderStrategy;
    private final CollisionAvoidanceMessenger messenger;
    private final Map<String, PhysicalDroneUpdateMessage> droneStates = new HashMap<>();
    private final Map<String, ManagedDroneUpdateMessage> droneControls = new HashMap<>();

    private boolean running = true;

    public CollisionAvoidanceBackend(CollisionAvoider avoiderStrategy) {
        this.avoiderStrategy = avoiderStrategy;
        this.messenger = new CollisionAvoidanceMessenger(this.mailbox);
    }

    public CollisionAvoidanceMessenger getMessenger() {
        return this.messenger;
    }

    private void stop() {
        running = false;
    }

    public void run() {
        int timeoutCount = 0;
        while(running) {
            try {
                AbstractMessage message = mailbox.poll(1000, TimeUnit.MILLISECONDS);

                if (message == null) {
                    timeoutCount = timeoutCount + 1;
                    if (timeoutCount > 2) {
                        LOGGER.warn(""has not received any messages for "" + timeoutCount + "" seconds"");
                    }
                } else {
                    timeoutCount = 0;
                    if (message instanceof  PhysicalDroneUpdateMessage) {
                        updatePhysicalDrone((PhysicalDroneUpdateMessage) message);
                    } else if (message instanceof  ManagedDroneUpdateMessage) {
                        updateManagedDrone((ManagedDroneUpdateMessage) message);
                    } else if (message instanceof CheckerTaskMessage) {
                        runAvoid();
                    } else if (message instanceof StopMessage) {
                        stop();
                    } else {
                        LOGGER.warn(""UNKNOWN MESSAGE TYPE "" + message);
                    }
                }
            } catch (InterruptedException e) {
                LOGGER.warn(""CollisionAvoidanceBackend interrupted"");
                LOGGER.trace(e);
            }
        }
    }

    private void updatePhysicalDrone(PhysicalDroneUpdateMessage msg) {
        droneStates.put(msg.name, msg);
    }

    private void updateManagedDrone(ManagedDroneUpdateMessage msg) {
        droneControls.put(msg.name, msg);

    }

    private void runAvoid() {
        ArrayList<DroneSnapshot> droneSnapshots = makeDroneSnapshots();
        avoiderStrategy.avoid(droneSnapshots);
        updateManagedDroneGuidance(droneSnapshots);
    }

    private ArrayList<DroneSnapshot> makeDroneSnapshots() {
        ArrayList<DroneSnapshot> snapshots = new ArrayList<>(droneStates.size());
        List<String> droneNames = droneStates.keySet().stream()
                .filter(droneName -> droneStates.containsKey(droneName) && droneControls.containsKey(droneName))
                .collect(Collectors.toList());
        for(String droneName : droneNames) {
            PhysicalDroneUpdateMessage droneState = droneStates.get(droneName);
            ManagedDroneUpdateMessage droneControl = droneControls.get(droneName);
            DroneSnapshotInternal snapshot = new DroneSnapshotInternal(droneName,
                    droneState.position, droneState.velocity, droneState.attitude);
            snapshot.getCommands().addAll(droneControl.commandQueue);
            snapshot.setState(droneControl.state);
            snapshot.setGoals(droneControl.goals);
            snapshots.add(snapshot);
        }
        return snapshots;
    }

    private void updateManagedDroneGuidance(ArrayList<DroneSnapshot> snapshots) {
        for (DroneSnapshot snapshot : snapshots) {
            droneControls.get(snapshot.getName()).managedDrone.getMessenger().updateGuidance(snapshot.getCommands());
        }
    }
}
"
MissionPlanningXStreamPersistor.java,"package edu.nd.dronology.services.core.persistence.internal;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.XppDriver;

import edu.nd.dronology.services.core.items.IMissionPlan;
import edu.nd.dronology.services.core.persistence.DronologyPersistenceUtil;
import edu.nd.dronology.services.core.persistence.IPersistenceManager;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class MissionPlanningXStreamPersistor implements IPersistenceManager<IMissionPlan> {

	private static final XStream xstream = new XStream(new XppDriver());
	private static ILogger LOGGER = LoggerProvider.getLogger(MissionPlanningXStreamPersistor.class);

	static final boolean useCompression = false;

	@Override
	public IMissionPlan open(InputStream fin) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
	//	 xstream.setMode(XStream.);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");
		
		if (useCompression) {
			return loadedCompressedStream(fin);
		} else {
			return loadUncompressedStream(fin);
		}
	}

	private IMissionPlan loadUncompressedStream(InputStream fin) throws PersistenceException {
		try {
			InputStreamReader reader = new InputStreamReader(new BufferedInputStream(fin), Charset.forName(""UTF-8""));
			Object model = xstream.fromXML(reader);
			return (IMissionPlan) model;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (fin != null) {
					fin.close();
				}
			} catch (Exception e) {
				LOGGER.error(e);
			}
		}
	}

	private IMissionPlan loadedCompressedStream(InputStream fin) throws PersistenceException {
		InputStream zIn = null;
		try {
			zIn = new GZIPInputStream(fin);
			Object model = xstream.fromXML(new BufferedReader(new InputStreamReader(zIn, ""UTF-8"")));

			return (IMissionPlan) model;
		} catch (IOException e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (zIn != null) {
					zIn.close();
				}
				if (fin != null) {
					fin.close();
				}
			} catch (Exception e) {
				LOGGER.error(e);
			}

		}
	}
 
	@Override
	public boolean save(IMissionPlan o, OutputStream fout) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
		// xstream.setMode(XStream.ID_REFERENCES);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");
		// xstream.addImplicitMap(ImplMEEvent.class, ""relatedEvents"", ImplMEEvent.class, ""relatedEvents"");

		if (useCompression) {
			return saveCompressedStream(o, fout);
		} else {
			return saveUncompressedStream(o, fout);
		}

	}

	private boolean saveUncompressedStream(IMissionPlan o, OutputStream fout) throws PersistenceException {
		OutputStreamWriter writer = null;
		try {
			writer = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(""UTF-8""));
			xstream.toXML(o, writer);
			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (writer != null) {
					writer.close();
				}
				if (fout != null) {
					fout.close();
				}
			} catch (IOException e) {
				LOGGER.error(e);
			}
		}

	}

	private boolean saveCompressedStream(IMissionPlan o, OutputStream fout) throws PersistenceException {
		try {
			GZIPOutputStream zOut = new GZIPOutputStream(fout);
			xstream.toXML(o, new BufferedWriter(new OutputStreamWriter(zOut, ""UTF-8"")));

			zOut.close();
			fout.close();

			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		}
	}

}
"
FlightSimulator.java,"package edu.nd.dronology.core.simulator.simplesimulator;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.util.DistanceUtil;
import edu.nd.dronology.core.vehicle.internal.VirtualDrone;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * Computes the current position of a virtual drone as it moves during flight. Serves as a lightweight SITL for a drone.
 * 
 * @author Jane Cleland-Huang
 */
public class FlightSimulator {

	private static final ILogger LOGGER = LoggerProvider.getLogger(FlightSimulator.class);

	private LlaCoordinate currentPosition;
	private LlaCoordinate targetPosition;
	private Long previousDistance = 0L;

	private boolean reached = false;

	private VirtualDrone drone;

	/**
	 * Creates a flight simulator object for a single virtual drone
	 * 
	 * @param drone
	 */
	protected FlightSimulator(VirtualDrone drone) {
		this.drone = drone;
	}

	/**
	 * Sets current flight path from current position to a targeted position
	 * 
	 * @param currentPos
	 *          Coordinates of current position
	 * @param targetPos
	 *          Coordinates of target position
	 */
	public void setFlightPath(LlaCoordinate currentPos, LlaCoordinate targetPos) {
		if (currentPosition == null || reached) {

			this.currentPosition = currentPos;
			reached = false;
		} 

		this.targetPosition = targetPos;
		previousDistance = getRemainingDistance();
	}

	/**
	 * Computes the distance between current position and target position
	 * 
	 * @return distance remaining in degree points.
	 */
	public long getRemainingDistance() {
		return (long) Math.sqrt((Math.pow(computeLongitudeDelta(), 2)) + Math.pow(computeLatitudeDelta(), 2));
	}

	/**
	 * Computes the delta between the drones current latitude and its target latitude.
	 * 
	 * @return
	 */
	private double computeLatitudeDelta() {
		return (currentPosition.getLatitude() - targetPosition.getLatitude()) * 1000000;
	}

	/**
	 * Computes the delta between the drones current longitude and its target longitude
	 * 
	 * @return
	 */
	private double computeLongitudeDelta() {
		return (currentPosition.getLongitude() - targetPosition.getLongitude()) * 1000000;
	}

	/**
	 * Computes the angle at which a drone is flying with respect to the vertical
	 * 
	 * @return
	 */
	private double computeAngle() {
		double height = computeLatitudeDelta(); // opposite
		// double width = (computeLongitudeDelta());
		double hypotenuse = getRemainingDistance();
		double sinTheta = height / hypotenuse;
		double angle = Math.asin(sinTheta) * 180 / Math.PI;
		return Double.isNaN(angle) ? 1 : angle;
	}

	/**
	 * Computes the position of the drone following one step. Checks if destination has been reached.
	 * 
	 * @param step
	 *          : Distance in degree points to move per iteration
	 * @return isStillMoving?
	 */
	public boolean move(double step) {
		try {
			// First determine which relative quadrant the target is in -- in relation to current position at the origin of X,Y axes

			double theta = computeAngle();
			double heightIncrement = Math.abs((long) (Math.sin(theta) * step));
			double widthIncrement = Math.abs((long) (Math.cos(theta) * step));

			double scaleFactor = 0.1;

			widthIncrement *= scaleFactor;
			heightIncrement *= scaleFactor;
			double newLongit = 0;
			double newLatid = 0;

			// Latitude delta
			if (currentPosition.getLatitude() < targetPosition.getLatitude()) {
				// currentPosition.setLatitude(currentPosition.getLatitude() + heightIncrement); // Drone is south of Target
				newLatid = (currentPosition.getLatitude() * 1000000) + heightIncrement;
			} else {
				// currentPosition.setLatitude(currentPosition.getLatitude() - heightIncrement); // Drone is North (or same) as target
				newLatid = (currentPosition.getLatitude() * 1000000) - heightIncrement;
			}
			// Longitude delta
			if (currentPosition.getLongitude() < targetPosition.getLongitude()) {
				// currentPosition.setLongitude(currentPosition.getLongitude() + widthIncrement); // Drone is to the left/west of target
				newLongit = (currentPosition.getLongitude() * 1000000) + widthIncrement;
			} else {
				// currentPosition.setLongitude(currentPosition.getLongitude() - widthIncrement); // Drone is to the right/east of target
				newLongit = (currentPosition.getLongitude() * 1000000) - widthIncrement;
			}
			// double distanceMoved = Math.sqrt(Math.pow(heightIncrement,2)+Math.pow(widthIncrement,2));

			newLatid = newLatid / 1000000;
			newLongit = newLongit / 1000000;

			currentPosition = new LlaCoordinate(newLatid, newLongit, currentPosition.getAltitude());
			LOGGER.trace(""Remaining Dinstance: "" + DistanceUtil.distance(currentPosition, targetPosition));
			// if (previousDistance <= getRemainingDistance() && getRemainingDistance() < 200) {
			drone.setCoordinates(currentPosition);
			if (DistanceUtil.distance(currentPosition, targetPosition) < 2) {
				previousDistance = getRemainingDistance();
				// LOGGER.info(drone.getDroneName() + "" ==> Waypoint reached"");
				reached = true;
				return false;
			} else {
				previousDistance = getRemainingDistance();
				return true;
			}
		} catch (Exception e) {
			LOGGER.error(e);
		}
		return false;

	}

	/**
	 * Checks if a drone has reached its target destination.
	 * 
	 * @param distanceMovedPerTimeStep
	 *          Checks location with respect to target position.
	 * @return true if target position is reached.
	 */
	public boolean isDestinationReached(double distanceMovedPerTimeStep) {
		double latDistance = Math.abs(currentPosition.getLatitude() - targetPosition.getLatitude());
		double lonDistance = Math.abs(currentPosition.getLongitude() - targetPosition.getLongitude());
		return lonDistance <= distanceMovedPerTimeStep && latDistance <= distanceMovedPerTimeStep;
	}

}
"
IDronologyChangeListener.java,"package edu.nd.dronology.core.status;

public interface IDronologyChangeListener {

	void notifyUAVRemoved(String uavid);

	void notifyGCSShutdown(String groundstationid);

}
"
Discuss.java,"package edu.nd.dronology.core;
/**
 * Marker annotation for things we need to talk about!
 * @author Michael
 *
 */

public @interface Discuss {
	
	   String discuss();
	 

}
"
IUAVTypeRegistrationRemoteService.java,"package edu.nd.dronology.services.core.remote;

import edu.nd.dronology.services.core.info.UAVTypeRegistrationInfo;

public interface IUAVTypeRegistrationRemoteService extends IRemoteableService, IFileTransmitRemoteService<UAVTypeRegistrationInfo> {

	
	
}
"
DroneMonitoringService.java,"package edu.nd.dronology.monitoring.service;

import java.util.Set;

import edu.nd.dronology.core.monitoring.ArtifactIdentifier;
import edu.nd.dronology.monitoring.IRemoteMonitoringMessageHandler;
import edu.nd.dronology.services.core.base.AbstractServerService;



/**
 * 
 * Service for UAV monitoring messages<br>
 * Allows registering {@link IRemoteMonitoringMessageHandler} to subscribe to certain message types or topics<br>
 * 
 *  
 * @author Michael Vierhauser
 *
 */ 
public class DroneMonitoringService extends AbstractServerService<IDroneMonitoringServiceInstance> {

	private static volatile DroneMonitoringService INSTANCE;

	protected DroneMonitoringService() {
	}

	/**
	 * @return The singleton DroneMonitoringService instance
	 */
	public static DroneMonitoringService getInstance() {
		if (INSTANCE == null) {
			synchronized (DroneMonitoringService.class) {
				if (INSTANCE == null) {
					INSTANCE = new DroneMonitoringService();
				}
			}
		}
		return INSTANCE;
	}

	@Override
	protected IDroneMonitoringServiceInstance initServiceInstance() {
		return new DroneMonitoringServiceInstance();
	}

	public void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler) {
		serviceInstance.registerMonitoringMessageHandler(handler);
	}

	public void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler,
			ArtifactIdentifier identifier) {
		serviceInstance.registerMonitoringMessageHandler(handler, identifier);
	}

	protected void setMonitoringFrequency(String uavid, Double frequency) {

	}

	public Set<IRemoteMonitoringMessageHandler> getSubscribedHandler(ArtifactIdentifier identifier) {
		return serviceInstance.getSubscribedHandler(identifier);

	}

	public void unsubscribeHandler(IRemoteMonitoringMessageHandler handler) {
		serviceInstance.unsubscribeHandler(handler);
	}

}
"
IDroneSimulatorRemoteService.java,"package edu.nd.dronology.services.core.remote;

import java.rmi.RemoteException;
import java.util.Collection;

import edu.nd.dronology.services.core.info.SimulatorScenarioCategoryInfo;
import edu.nd.dronology.services.core.info.SimulatorScenarioInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;
/**
 * Meta-Model Service Interface: Handling artifact  models.<br>
 * Extends {@link IFileTransmitRemoteService} and provides methods for retrieving and saving models from the server.
 * 
 * @author Michael Vierhauser
 * 
 */
public interface IDroneSimulatorRemoteService extends IRemoteableService, IFileTransmitRemoteService<SimulatorScenarioInfo> {

	
	public void activateScenario(SimulatorScenarioInfo scenario) throws RemoteException, DronologyServiceException;
	
	public Collection<SimulatorScenarioCategoryInfo> getCategories() throws RemoteException;
	
}
"
StateMessageTypeAdapter.java,"package edu.nd.dronology.gstation.connector.messages;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.gstation.connector.messages.UAVStateMessage.BatteryStatus;
import edu.nd.dronology.gstation.connector.messages.UAVStateMessage.DroneMode;
import edu.nd.dronology.gstation.connector.messages.UAVStateMessage.DroneStatus;
import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class StateMessageTypeAdapter implements JsonDeserializer<Map> {

	private static final ILogger LOGGER = LoggerProvider.getLogger(StateMessageTypeAdapter.class);

	@Override
	public Map deserialize(JsonElement element, Type mapType, JsonDeserializationContext arg2)
			throws JsonParseException {
		Map<String, Object> dataMap = new HashMap<>();
		JsonObject mapObject = element.getAsJsonObject();

		LlaCoordinate location = deserializeLLACoordinate(mapObject, UAVStateMessage.LOCATION);
		dataMap.put(UAVStateMessage.LOCATION, location);

		Vector3D attitude = deserializeVector3D(mapObject, UAVStateMessage.ATTITUDE);
		dataMap.put(UAVStateMessage.ATTITUDE, attitude);

		Vector3D velocity = deserializeVector3D(mapObject, UAVStateMessage.VELOCITY);
		dataMap.put(UAVStateMessage.VELOCITY, velocity);

		String statusString = mapObject.get(UAVStateMessage.STATUS).getAsString();
		String modeString = mapObject.get(UAVStateMessage.MODE).getAsString();

		dataMap.put(UAVStateMessage.STATUS, DroneStatus.valueOf(statusString));
		dataMap.put(UAVStateMessage.MODE, DroneMode.valueOf(modeString));

		boolean armedValue = mapObject.get(UAVStateMessage.ARMED).getAsBoolean();
		dataMap.put(UAVStateMessage.ARMED, Boolean.valueOf(armedValue));

		boolean armableValue = mapObject.get(UAVStateMessage.ARMABLE).getAsBoolean();
		dataMap.put(UAVStateMessage.ARMABLE, Boolean.valueOf(armableValue));

		double groundspeed = mapObject.get(UAVStateMessage.GROUNDSPEED).getAsDouble();
		dataMap.put(UAVStateMessage.GROUNDSPEED, Double.valueOf(groundspeed));

		BatteryStatus batteryStatus = deserializeBatteryStatus(mapObject, UAVStateMessage.BATTERYSTATUS);
		dataMap.put(UAVStateMessage.BATTERYSTATUS, batteryStatus);

		// TODO Auto-generated method stub
		return dataMap;
	}

	private BatteryStatus deserializeBatteryStatus(JsonObject mapObject, String itemname) {
		JsonElement locationElem = mapObject.get(itemname);
		JsonObject locObject = locationElem.getAsJsonObject();

		double bcurrent = -1;
		if (locObject.has(""current"")) {
			try {
				JsonPrimitive level = locObject.getAsJsonPrimitive(""current"");
				bcurrent = level.getAsDouble();
			} catch (ClassCastException e) {
				LOGGER.error(""Current not a value"");
			} catch (Exception e) {
				LOGGER.error(e);
			}
		}

		double blevel = -1;
		if (locObject.has(""level"")) {
			try {
				JsonPrimitive level = locObject.getAsJsonPrimitive(""level"");
				blevel = level.getAsDouble();
			} catch (ClassCastException e) {
				LOGGER.error(""Level not a value"");
			} catch (Exception e) {
				LOGGER.error(e);
			}

		}

		double bvoltage = -1;
		if (locObject.has(""voltage"")) {
			try {
				JsonPrimitive volt = locObject.getAsJsonPrimitive(""voltage"");
				bvoltage = volt.getAsDouble();
			} catch (ClassCastException e) {
				LOGGER.error(""Voltage not a value"");
			} catch (Exception e) {
				LOGGER.error(e);
			}
		}
		return new BatteryStatus(bcurrent, bvoltage, blevel);
	}

	private LlaCoordinate deserializeLLACoordinate(JsonObject mapObject, String itemname) {
		JsonElement locationElem = mapObject.get(itemname);
		JsonObject locObject = locationElem.getAsJsonObject();

		JsonPrimitive latitude = locObject.getAsJsonPrimitive(""x"");
		JsonPrimitive longitude = locObject.getAsJsonPrimitive(""y"");
		JsonPrimitive altitude = locObject.getAsJsonPrimitive(""z"");

		return new LlaCoordinate(latitude.getAsDouble(), longitude.getAsDouble(), altitude.getAsDouble());

	}

	private Vector3D deserializeVector3D(JsonObject mapObject, String itemname) {
		JsonElement locationElem = mapObject.get(itemname);
		JsonObject locObject = locationElem.getAsJsonObject();

		JsonPrimitive x = locObject.getAsJsonPrimitive(""x"");
		JsonPrimitive y = locObject.getAsJsonPrimitive(""y"");
		JsonPrimitive z = locObject.getAsJsonPrimitive(""z"");

		return new Vector3D(x.getAsDouble(), y.getAsDouble(), z.getAsDouble());
	}

}
"
AbstractFileTransmitServerService.java,"package edu.nd.dronology.services.core.base;

import java.rmi.RemoteException;
import java.util.Collection;

import edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;
import edu.nd.dronology.services.core.listener.IItemChangeListener;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Abstract base class for all services that can handle files.
 * 
 * @author Michael Vierhauser 
 *
 * @param <S>
 *          The service instance.
 * @param <T>
 *          The type of file that is supported.
 */
public abstract class AbstractFileTransmitServerService<S extends IFileTransmitServiceInstance<T>, T>
		extends AbstractServerService<S> {

	private static final ILogger LOGGER = LoggerProvider.getLogger(AbstractFileTransmitServerService.class);

	public AbstractFileTransmitServerService() {
		super();
	}

	public byte[] requestFromServer(String id) throws DronologyServiceException {
		return serviceInstance.requestFromServer(id);
	}

	public void transmitToServer(String id, byte[] content) throws DronologyServiceException {
		serviceInstance.transmitToServer(id, content);
	}

	public boolean addItemChangeListener(IItemChangeListener listener) {
		return serviceInstance.addItemChangeListener(listener);
	}

	public boolean removeItemChangeListener(IItemChangeListener listener) {
		return serviceInstance.removeItemChangeListener(listener);
	}

	public Collection<T> getItems() throws RemoteException {
		return serviceInstance.getItems();
	}
	
	public T getItems(String id) throws RemoteException, DronologyServiceException {
		return serviceInstance.getItem(id);
	}

	public T createItem() throws RemoteException, DronologyServiceException {
		return serviceInstance.createItem();
	}

	public void deleteItem(String itemid) throws DronologyServiceException {
		serviceInstance.deleteItem(itemid);

	}

}
"
NVECSimulator.java,"package edu.nd.dronology.core.simulator.nvecsimulator;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.coordinate.NVector;
import edu.nd.dronology.core.simulator.IFlightSimulator;
import edu.nd.dronology.core.simulator.simplesimulator.DroneVoltageSimulator;
import edu.nd.dronology.core.simulator.simplesimulator.FlightSimulator;
import edu.nd.dronology.core.vehicle.internal.VirtualDrone;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class NVECSimulator implements IFlightSimulator {
	private static final ILogger LOGGER = LoggerProvider.getLogger(FlightSimulator.class);
	private VirtualDrone drone;
	private NVector currentPosition;
	private NVector targetPosition;
	private DroneVoltageSimulator voltageSimulator;

	public NVECSimulator(VirtualDrone drone) {
		this.drone = drone;
		voltageSimulator = new DroneVoltageSimulator();
	}

	@Override
	public boolean isDestinationReached(double distanceMovedPerTimeStep) {
		return NvecInterpolator.move(currentPosition, targetPosition, distanceMovedPerTimeStep).equals(targetPosition);
	}

	@Override
	public boolean move(double i) {
		currentPosition = NvecInterpolator.move(currentPosition, targetPosition, i);
		drone.setCoordinates(currentPosition.toLlaCoordinate());
		LOGGER.trace(""Remaining Dinstance: "" + NVector.travelDistance(currentPosition, targetPosition));
		return !currentPosition.equals(targetPosition);
	}

	@Override
	public void setFlightPath(LlaCoordinate currentPosition, LlaCoordinate targetCoordinates) {
		this.currentPosition = currentPosition.toNVector();
		this.targetPosition = targetCoordinates.toNVector();

	}

	@Override
	public void startBatteryDrain() {
		voltageSimulator.startBatteryDrain();
	}

	@Override
	public void stopBatteryDrain() {
		voltageSimulator.startBatteryDrain();

	}

	@Override
	public double getVoltage() {
		return voltageSimulator.getVoltage();
	}

	@Override
	public void checkPoint() {
		voltageSimulator.checkPoint();

	}

}
"
RiverSubsegment.java,"package edu.nd.dronology.services.extensions.areamapping.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;

public class RiverSubsegment {
	private List<RiverBank> riverSubsegment;
	
	public RiverSubsegment() {
		riverSubsegment = new ArrayList<>();
	}
	
	public RiverSubsegment(RiverBank bank1, RiverBank bank2) {
		riverSubsegment = new ArrayList<>();
		riverSubsegment.add(bank1);
		riverSubsegment.add(bank2);
	}
	
	public void add(RiverBank riverBank) {
		riverSubsegment.add(riverBank);
	}
	
	public List<RiverBank> get(){
		return Collections.unmodifiableList(riverSubsegment);
	}
	
	public RiverBank get(int entry) {
		return riverSubsegment.get(entry);
	}
	
	public void set(int index, RiverBank entry) {
		riverSubsegment.set(index, entry);
	}
	
	
}
"
AMMetaInfo.java,"package edu.nd.dronology.ui.vaadin.areamapping;

import java.io.File;

import com.vaadin.event.LayoutEvents.LayoutClickEvent;
import com.vaadin.event.LayoutEvents.LayoutClickListener;
import com.vaadin.server.FileResource;
import com.vaadin.server.VaadinService;
import com.vaadin.ui.Button;
import com.vaadin.ui.CheckBox;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Label;
import com.vaadin.ui.TextField;
import com.vaadin.ui.UI;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.themes.ValoTheme;

import edu.nd.dronology.services.core.info.AreaMappingInfo;
import edu.nd.dronology.ui.vaadin.areamapping.windows.AMGenerateRouteDroneWindow;
import edu.nd.dronology.ui.vaadin.areamapping.windows.AMUnsavedChangesConfirmation.ChangeType;

/**
 * Implements the top panel, which displays information about the name of the mapping and the number of coordinates on each side.
 * 
 * @author Andrew Slavin
 *
 */


public class AMMetaInfo extends CustomComponent {
	/** 
	 * 
	 */
	private static final long serialVersionUID = -1112368712373412381L;
	private Label nameLabel;
	private Label sideANumLabel;
	private Label sideBNumLabel;
	private Label descriptionLabel;
	private Button generateRouteButton;
	private AreaMappingInfo mappingInfo;
	private int num0;
	private int num1;
	
	private HorizontalLayout allContent;
	private VerticalLayout leftSide;
	private VerticalLayout rightSide;
	private CheckBox autoZoomingCheckBox;
	
	private AMGenerateRouteDroneWindow generateRouteDroneWindow;

	public AMMetaInfo(AMMapComponent map) {
		
		sideANumLabel = new Label("""");
		sideBNumLabel = new Label("""");
		nameLabel = new Label(""No Mapping Selected"");

		// The two labels are initialized separately so that they can be changed
		// independently later.
		HorizontalLayout labels = new HorizontalLayout();
		labels.addComponents(nameLabel, sideANumLabel, sideBNumLabel);

		autoZoomingCheckBox = new CheckBox(""Zoom to Route"");
		autoZoomingCheckBox.setValue(true);

		String basepath = VaadinService.getCurrent().getBaseDirectory().getAbsolutePath();

		FileResource editIcon = new FileResource(new File(basepath + ""/VAADIN/img/editButtonFull.png""));
		Button editButton = new Button(""Edit"");
		editButton.setIcon(editIcon);
		editButton.addStyleName(ValoTheme.BUTTON_ICON_ONLY);

		FileResource deleteIcon = new FileResource(new File(basepath + ""/VAADIN/img/deleteButtonFull.png""));
		Button deleteButton = new Button(""Delete"");
		deleteButton.setIcon(deleteIcon);
		deleteButton.addStyleName(ValoTheme.BUTTON_ICON_ONLY);
		
		generateRouteButton = new Button(""Generate Route"");
		generateRouteButton.setWidth(""150px"");

		// A layout is used to hold the description label so that a LayoutClickListener
		// can be added later.
		HorizontalLayout descriptionHolder = new HorizontalLayout();
		descriptionLabel = new Label("""");
		descriptionHolder.addComponent(descriptionLabel);

		HorizontalLayout buttons = new HorizontalLayout();
		buttons.addComponents(generateRouteButton, editButton, deleteButton);

		HorizontalLayout checkboxes = new HorizontalLayout();
		checkboxes.addComponents(autoZoomingCheckBox);

		leftSide = new VerticalLayout();
		leftSide.addComponents(labels, descriptionHolder);

		rightSide = new VerticalLayout();
		rightSide.addComponents(buttons, checkboxes);

		// ""leftSide"" includes the labels and description, while ""rightSide"" includes
		// the buttons and checkboxes.
		allContent = new HorizontalLayout();
		allContent.setStyleName(""fr_route_meta_info"");
		allContent.addStyleName(""has_route"");
		
		// only add left side when initialized, right side is added when a route is
		// selected
		allContent.addComponent(leftSide);

		rightSide.addStyleName(""route_meta_controls"");
		leftSide.addStyleName(""route_meta_label_description"");

		TextField nameEditField = new TextField();
		TextField descriptionEditField = new TextField();

		nameEditField.setStyleName(""name_edit_field"");
		descriptionEditField.setStyleName(""description_edit_field"");
		nameLabel.setStyleName(""name_lable"");
		sideANumLabel.setStyleName(""waypoint_num_lable"");
		sideBNumLabel.setStyleName(""waypoint_num_lable"");
		descriptionLabel.setStyleName(""description_lable"");

		// Click listeners for the edit and delete buttons.
		editButton.addClickListener(e -> {
			map.getEditSidesController().enterEditMode();
		});
		
		// prompt user to confirm that they want to delete the mapping
		deleteButton.addClickListener(e -> {
			if (map.getMapUtilities().getSidesAreEditable() || map.getMapUtilities().getPrioritiesAreEditable()) {
				map.getMainLayout().getUnsavedChangesConfirmation().showWindow(map.getMainLayout().getControls()
						.getInfoPanel().getHighlightedAMInfoBox().getAreaMappingInfo().getName(),
						ChangeType.DELETE_MAPPING, e);
			} else {
				map.getMainLayout().getDeleteMappingConfirmation().showWindow(
						map.getMainLayout().getControls().getInfoPanel().getHighlightedAMInfoBox().getAreaMappingInfo(),
						e);
			}
		});
		
		// click listener for the generate route button
		// brings up a window to select drones
		generateRouteButton.addClickListener(e -> {
			generateRouteDroneWindow = new AMGenerateRouteDroneWindow(map);
			UI.getCurrent().addWindow(generateRouteDroneWindow);
			generateRouteDroneWindow.closeIfNoDrones();
		});

		// Double click allows user to edit label by turning it into a textbox.
		labels.addLayoutClickListener(new LayoutClickListener() {
			private static final long serialVersionUID = 1L;

			@Override
			public void layoutClick(LayoutClickEvent event) {
				if (!map.getMapUtilities().getSidesAreEditable() && !map.getMapUtilities().getPrioritiesAreEditable())
					return;
				if (event.getClickedComponent() == nameLabel) {
					if (event.isDoubleClick()) {
						// Change layout to accommodate for the textfield.
						allContent.removeAllComponents();

						HorizontalLayout nameArea = new HorizontalLayout();
						nameEditField.setValue(nameLabel.getValue());
						nameArea.addComponents(nameEditField, sideANumLabel, sideANumLabel);

						VerticalLayout textLayout = new VerticalLayout();
						textLayout.addComponents(nameArea, descriptionHolder);
						textLayout.addStyleName(""mapping_meta_label_description"");

						allContent.addComponents(textLayout, rightSide);
					}
				}
			}
		});
		// Double click allows user to edit description by turning it into a textbox.
		descriptionHolder.addLayoutClickListener(new LayoutClickListener() {
			private static final long serialVersionUID = 1L;

			@Override
			public void layoutClick(LayoutClickEvent event) {
				if (!map.getMapUtilities().getSidesAreEditable() && !map.getMapUtilities().getPrioritiesAreEditable())
					return;
				if (event.getClickedComponent() == descriptionLabel) {
					if (event.isDoubleClick()) {
						// Change layout to accommodate for the textfield.
						allContent.removeAllComponents();
						labels.removeAllComponents();

						VerticalLayout textLayout = new VerticalLayout();
						textLayout.addStyleName(""mapping_meta_label_description"");
						labels.addComponents(nameLabel, sideANumLabel, sideBNumLabel);

						descriptionEditField.setValue(descriptionLabel.getValue());
						textLayout.addComponents(labels, descriptionEditField);
						allContent.addComponents(textLayout, rightSide);
					}
				}
			}
		});
		// Textfield turns back into the correct label once the user clicks away.
		nameEditField.addBlurListener(e -> {
			nameLabel.setValue(nameEditField.getValue());

			labels.removeAllComponents();
			labels.addComponents(nameLabel, sideANumLabel, sideBNumLabel);

			leftSide.removeAllComponents();
			leftSide.addComponents(labels, descriptionHolder);

			allContent.removeAllComponents();
			allContent.addComponents(leftSide, rightSide);

			rightSide.addStyleName(""route_meta_controls"");
		});
		// Once the user clicks away from the description field, the correct label is
		// shown.
		descriptionEditField.addBlurListener(e -> {
			descriptionLabel.setValue(descriptionEditField.getValue());

			labels.removeAllComponents();
			labels.addComponents(nameLabel, sideANumLabel, sideBNumLabel);

			leftSide.removeAllComponents();
			leftSide.addComponents(labels, descriptionHolder);

			allContent.removeAllComponents();
			allContent.addComponents(leftSide, rightSide);

			rightSide.addStyleName(""route_meta_controls"");
		});

		setCompositionRoot(allContent);
	}

	public String getMappingName() {
		return nameLabel.getValue();
	}

	public void setMappingName(String name) {
		nameLabel.setValue(name);
	}

	public String getMappingDescription() {
		return descriptionLabel.getValue();
	}

	public void setMappingDescription(String description) {
		descriptionLabel.setValue(description);
	}

	public void showInfoForSelectedMapping(AreaMappingInfo info) {
		mappingInfo = info;
		nameLabel.setValue(info.getName());
		descriptionLabel.setValue(info.getDescription());
		setNumWaypoints(info.getCoordinates(0).size(), info.getCoordinates(1).size());

		allContent.addComponent(rightSide);
	}

	public void showInfoWhenNoMappingIsSelected() {
		nameLabel.setValue(""No Mapping Selected"");
		descriptionLabel.setValue("""");
		sideANumLabel.setValue("""");
		sideBNumLabel.setValue("""");
		allContent.removeComponent(rightSide);
	}

	// Ensures that the correct description of coordinates is shown.
	public void setNumWaypoints(int num0, int num1) {
		if (num0 == 1) {
			sideANumLabel.setValue(""("" + num0 + "" Side A coordinate)"");
			this.num0 = num0;
		} else {
			sideANumLabel.setValue(""("" + num0 + "" Side A coordinates)"");
			this.num0 = num0;
		}
		if (num1 == 1) {
			sideBNumLabel.setValue(""("" + num1 + "" Side B coordinate)"");
			this.num1 = num1;
		} else {
			sideBNumLabel.setValue(""("" + num1 + "" Side B coordinates)"");
			this.num1 = num1;
		}
	}


	public boolean isAutoZoomingChecked() {
		return autoZoomingCheckBox.getValue() == true;
	}
	
	public AreaMappingInfo getMappingInfo() {
		return mappingInfo;
	}
	
	public int getNum0() {
		return num0;
	}
	
	public int getNum1() {
		return num1;
	}
	
}"
UAVStateMessage.java,"package edu.nd.dronology.gstation.connector.messages;

import java.io.Serializable;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;

/**
 * State message received from the GCS for a specific UAV.
 * 
 * @author Michael Vierhauser
 *
 */
public class UAVStateMessage extends AbstractUAVMessage<Object> implements Serializable {

	private static final long serialVersionUID = -5703232763831907307L;
	public static final String MESSAGE_TYPE = ""state"";

	public static final transient String LOCATION = ""location"";
	public static final transient String ATTITUDE = ""attitude"";
	public static final transient String VELOCITY = ""velocity"";

	public static final transient String MODE = ""mode"";
	public static final transient String STATUS = ""status"";

	public static final transient String ARMED = ""armed"";
	public static final transient String ARMABLE = ""armable"";

	public static final transient String GROUNDSPEED = ""groundspeed"";
	public static final transient String BATTERYSTATUS = ""batterystatus"";

	public enum DroneMode {
		GUIDED, INIT, LAND, RTL, POSHOLD, OF_LOITER, STABILIZE, AUTO, THROW, DRIFT, FLIP, AUTOTUNE, ALT_HOLD, BRAKE, LOITER, AVOID_ADSB, POSITION, CIRCLE, SPORT, ACRO;
	}

	public enum DroneStatus {
		STANDBY, UNINIT, BOOT, CALIBRATING, ACTIVE, CRITICAL, EMERGENCY, POWEROFF, INIT;
	}

	public UAVStateMessage(String message, String groundstationid, String uavid) {
		super(message, groundstationid, uavid);
	}

	public LlaCoordinate getLocation() {
		return (LlaCoordinate) data.get(LOCATION);
	}

	public Vector3D getAttitude() {
		return (Vector3D) data.get(ATTITUDE);
	}

	public Vector3D getVelocity() {
		return (Vector3D) data.get(VELOCITY);
	}

	public boolean isArmable() {
		return (Boolean) data.get(ARMABLE);
	}

	public double getGroundspeed() {
		return (Double) data.get(GROUNDSPEED);
	}

	public DroneStatus getStatus() {
		return (DroneStatus) data.get(STATUS);
	}

	public boolean isArmed() {
		return (Boolean) data.get(ARMED);
	}

	public DroneMode getMode() {
		return (DroneMode) data.get(MODE);
	}

	public BatteryStatus getBatterystatus() {
		return (BatteryStatus) data.get(BATTERYSTATUS);
	}

	@Override
	public String toString() {
		return ""armed="" + isArmed() + ""| mode "" + getMode() + "" | Coordinate[""
				+ Double.toString(getLocation().getLatitude()) + "","" + Double.toString(getLocation().getLongitude()) + "",""
				+ Double.toString(getLocation().getAltitude()) + ""]"";
	}

	public static class BatteryStatus implements Serializable{
		/**
		 * 
		 */
		private static final long serialVersionUID = -7752170927927875169L;
		private double current;
		private double voltage;
		private double level;

		public BatteryStatus(double current, double voltage, double level) {
			this.current = current;
			this.voltage = voltage;
			this.level = level;
		}

		public double getBatteryLevel() {
			return level;
		}

		public double getBatteryCurrent() {
			return current;
		}

		public double getBatteryVoltage() {
			return voltage;
		}
	}
}
"
Runner.java,"package edu.nd.dronology.misc.scripts;

import java.net.MalformedURLException;
import java.rmi.Naming;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;
import edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;
import edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;
import edu.nd.dronology.services.core.remote.IRemoteManager;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public class Runner {

	private static final String ADDRESS_SCHEME = ""rmi://%s:%s/Remote"";

	public static void main(String[] args) {
		try {

			IRemoteManager manager = (IRemoteManager) Naming.lookup(String.format(ADDRESS_SCHEME, ""localhost"", 9898));

			IDroneSetupRemoteService service = (IDroneSetupRemoteService) manager.getService(IDroneSetupRemoteService.class);

			IFlightManagerRemoteService managerService = (IFlightManagerRemoteService) manager
					.getService(IFlightManagerRemoteService.class);

			IFlightRouteplanningRemoteService planningService = (IFlightRouteplanningRemoteService) manager
					.getService(IFlightRouteplanningRemoteService.class);

			List<FlightRouteInfo> allRoutes = new ArrayList<>(planningService.getItems());
			// int NUM_DRONES = 0;
			// for (int i = 0; i < NUM_DRONES; i++) {
			// double coordofset = (double) i / 10000;
			// LlaCoordinate coord = new LlaCoordinate((41.519400 + coordofset), -86.239927, 0);
			// DroneInitializationInfo dr = new DroneInitializationInfo(""Sim-Drone"" + i, DroneMode.MODE_VIRTUAL,
			// ""IRIS+"", coord);
			//
			// service.initializeDrones(dr);
			// }

			// for (DroneStatus dr : service.getDrones().values()) {
			// FlightRouteInfo inf = getRandomRoute(allRoutes);
			//
			// managerService.planFlight(dr.getID(), ""randplan"", inf.getWaypoints());
			//
			// }
			FlightRouteInfo inf = allRoutes.remove(0);
			for (IUAVProxy dr : service.getActiveUAVs()) {

				managerService.planFlight(dr.getID(), ""randplan"", inf.getWaypoints());

			}

		} catch (RemoteException | DronologyServiceException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NotBoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	static Random rand = new Random();

	private static FlightRouteInfo getRandomRoute(List<FlightRouteInfo> allRoutes) {
		int routeSize = allRoutes.size();

		int randomNumber = rand.nextInt(routeSize);

		return allRoutes.get(randomNumber);

	}

}
"
AbstractDrone.java,"package edu.nd.dronology.core.vehicle;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.exceptions.FlightZoneException;
import edu.nd.dronology.core.vehicle.proxy.UAVProxy;
import edu.nd.dronology.core.vehicle.proxy.UAVProxyManager;
import edu.nd.dronology.util.NullUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

import java.util.Observable;

/**
 * Abstract Base class for both virtual and physical drones
 * 
 * 
 * @author Michael
 *
 */
public abstract class AbstractDrone extends Observable implements IDrone {

	private static final ILogger LOGGER = LoggerProvider.getLogger(AbstractDrone.class);

	private LlaCoordinate basePosition; // In current version drones always return to base at the end of their flights.
	protected volatile LlaCoordinate currentPosition;
	protected final String droneName;
	protected UAVProxy droneStatus; // PHY

	private ManagedDrone mgdDrone;

	protected AbstractDrone(String drnName) {
		NullUtil.checkNull(drnName);
		this.droneName = drnName;
		currentPosition = null;
		droneStatus = new UAVProxy(drnName, 0, 0, 0, 0.0, 0.0); // Not initialized yet //PHYS
		UAVProxyManager.getInstance().addDrone(droneStatus); // PHYS
	}

	@Override
	public void setCoordinates(double lat, double lon, double alt) { // For physical drone this must be set by reading position
		currentPosition = new LlaCoordinate(lat, lon, alt);
		droneStatus.updateCoordinates(lat, lon, alt);
	}

	@Override
	public void setCoordinates(LlaCoordinate coordinate) { // For physical drone this must be set by reading position
		currentPosition = coordinate;
		droneStatus.updateCoordinates(currentPosition.getLatitude(), currentPosition.getLongitude(),
				currentPosition.getAltitude());
	}

	@Override
	public double getLatitude() {
		return currentPosition.getLatitude();
	}

	@Override
	public double getLongitude() {
		return currentPosition.getLongitude();
	}

	@Override
	public double getAltitude() {
		return currentPosition.getAltitude();
	}

	@Override
	public LlaCoordinate getCoordinates() {
		return currentPosition;
	}

	@Override
	public String getDroneName() {
		return droneName;
	}

	@Override
	public UAVProxy getDroneStatus() {
		return droneStatus;
	}

	/**
	 * Set base coordinates for the drone
	 * 
	 * @param basePosition
	 */
	@Override
	public void setBaseCoordinates(LlaCoordinate basePosition) {

		this.basePosition = new LlaCoordinate(basePosition.getLatitude(), basePosition.getLongitude(),
				basePosition.getAltitude());
		droneStatus.setHomeLocation(basePosition);
		LOGGER.info(""Base Coordinate of Drone '"" + droneName + "" set to '"" + basePosition.toString());
	}

	/**
	 * Get unique base coordinates for the drone
	 * 
	 * @return base coordinates
	 */
	@Override
	public LlaCoordinate getBaseCoordinates() {
		return basePosition;
	}

	public void setVelocity(double velocity) {
		droneStatus.updateVelocity(velocity);

	}

	public void updateBatteryLevel(double batteryLevel) {
		droneStatus.updateBatteryLevel(batteryLevel);

	}

	public void setUserControlled() {
		try {
			mgdDrone.getFlightModeState().setModeToUserControlled();
		} catch (FlightZoneException e) {
			LOGGER.error(e);
		}

	}

	@Override
	public void setManagedDrone(ManagedDrone mgdDrone) {
		this.mgdDrone = mgdDrone;
	}

}

"
MonitoringFrequencyAdaptor.java,"package edu.nd.dronology.monitoring;
//package edu.nd.dronology.gstation.connector.monitoring;
//
//import java.util.HashMap;
//import java.util.List;
//import java.util.Map;
//import java.util.concurrent.ConcurrentHashMap;
//import java.util.concurrent.atomic.AtomicBoolean;
//
//import com.google.common.util.concurrent.RateLimiter;
//
//import edu.nd.dronology.core.exceptions.DroneException;
//import edu.nd.dronology.core.fleet.DroneFleetManager;
//import edu.nd.dronology.core.vehicle.ManagedDrone;
//import edu.nd.dronology.core.vehicle.commands.SetMonitoringFrequencyCommand;
//import edu.nd.dronology.validation.trust.TrustManager;
//import edu.nd.dronology.validation.util.BenchmarkLogger;
//import edu.nd.dronology.validation.validation.MonitoringValidator;
//import net.mv.logging.ILogger;
//import net.mv.logging.LoggerProvider;
//
//public class MonitoringFrequencyAdaptor implements Runnable {
//
//	RateLimiter limiter = RateLimiter.create(0.2);
//	private static final ILogger LOGGER = LoggerProvider.getLogger(MonitoringFrequencyAdaptor.class);
//	private AtomicBoolean cont = new AtomicBoolean(true);
//	private Map<String, Double> frequencies = new ConcurrentHashMap<>();
//	private Map<String, Double> means = new HashMap<>();
//
//	public MonitoringFrequencyAdaptor() {
//
//	}
//
//	@Override
//	public void run() {
//
//		while (cont.get()) {
//			limiter.acquire();
//			try {
//				// LOGGER.info(""Recalculating monitoring frequencies..."");
//				for (MonitoringValidator validator : UAVMonitoringManager.getInstance().getValidators()) {
//					String vid = validator.getUavId();
//					updateMeanDistance(vid);
//					double currentReputation = TrustManager.getInstance().getReputationRating(vid);
//					double newFrequency = calculateFrequency(
//							means.get(vid) != null ? means.get(vid) : 1 / DISTANCE_FACTOR, currentReputation);
//					Double oldFrequncy = frequencies.get(vid);
//					if (oldFrequncy == null || oldFrequncy != newFrequency) {
//						LOGGER.info(""Updating monitoring frequncy for '"" + vid + "" from:"" + oldFrequncy + "" to: ""
//								+ newFrequency);
//						BenchmarkLogger.reportFrequency(vid, newFrequency);
//						frequencies.put(vid, Double.valueOf(newFrequency));
//						updateFrequency(vid, newFrequency);
//					}
//				}
//
//			} catch (Exception e) {
//				LOGGER.error(e);
//			}
//
//		}
//	}
//
//	private void updateMeanDistance(String vid) throws DroneException {
//		long start = System.currentTimeMillis();
//		double dist = 0;
//		int count = 0;
//		ManagedDrone drone = DroneFleetManager.getInstance().getRegisteredDrone(vid);
//		List<ManagedDrone> drns = DroneFleetManager.getInstance().getRegisteredDrones();
//		for (ManagedDrone toCheck : drns) {
//			if (toCheck == drone) {
//				continue;
//			}
//			if (true || toCheck.getFlightModeState().isFlying() || toCheck.getFlightModeState().isInAir()) {
//				dist += Math.abs(drone.getCoordinates().distance(toCheck.getCoordinates()));
//			}
//			count++;
//		}
//		double mean = dist / (count - 1);
//		long duration = System.currentTimeMillis() - start;
//
//		mean = mean / Math.pow((Math.sqrt(ZONE_WIDHT) + Math.sqrt(ZONE_HEIGHT)), 2);
//		//LOGGER.info(""Mean Distance: "" + mean + ""("" + duration + ""ms)"");
//		if (mean > 0) {
//			means.put(drone.getDroneName(), mean);
//		}
//	}
//
//	private void updateFrequency(String vid, double frequency) {
//		ManagedDrone drone;
//		try {
//			drone = DroneFleetManager.getInstance().getRegisteredDrone(vid);
//			drone.sendCommand(new SetMonitoringFrequencyCommand(vid, new Double(frequency).longValue() * 1000));
//		} catch (DroneException e) {
//			LOGGER.error(e);
//		}
//
//	}
//
//	private final double LOWER = 5;
//	private final double UPPER = 25;
//	private final double ZONE_WIDHT = 1000;
//	private final double ZONE_HEIGHT = 1000;
//	private final double DISTANCE_FACTOR = 2;
//
//	private double calculateFrequency(double distance, double currentReputation) {
//
//		// double frequency = (currentReputation / (distance * DISTANCE_FACTOR)) *
//		// (UPPER - LOWER) + LOWER;
//		double frequency = (currentReputation + (1 - distance) * distance) / (DISTANCE_FACTOR + 1) * (UPPER - LOWER)
//				+ LOWER;
//		return Math.floor(frequency);
//	}
//
//}
"
IRemoteConnectionServiceInstance.java,"package edu.nd.dronology.services.instances.remote;

import java.util.Collection;

import edu.nd.dronology.services.core.api.IServiceInstance;
import edu.nd.dronology.services.core.remote.IRemoteManager;
import edu.nd.dronology.services.core.remote.RemoteInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public interface IRemoteConnectionServiceInstance extends IServiceInstance{

	void register(RemoteInfo rInfo);

	Collection<RemoteInfo> getRegisteredRemoteClients();

	void unregister(RemoteInfo rInfo);

	//void logExternal(LogEventAdapter event);

	void addRemoteManager(IRemoteManager manager)  throws DronologyServiceException;

}
"
MissionPlanningPersistenceProvider.java,"package edu.nd.dronology.services.core.persistence;

import edu.nd.dronology.services.core.items.IMissionPlan;
import edu.nd.dronology.services.core.persistence.internal.MissionPlanningXStreamPersistor;


/**
 * Provider implementation for {@link IMissionPlan}.<br>
 * Details see {@link AbstractItemPersistenceProvider}
 * 
 * @author Michael Vierhauser
 * 
 */
public class MissionPlanningPersistenceProvider extends AbstractItemPersistenceProvider<IMissionPlan> {

	public MissionPlanningPersistenceProvider() {
		super();
	}

	@Override
	protected void initPersistor() {
		PERSISTOR = new MissionPlanningXStreamPersistor();

	}

	@Override
	protected void initPersistor(String type) {
		initPersistor();
	}

	public static MissionPlanningPersistenceProvider getInstance() {
		return new MissionPlanningPersistenceProvider();
	}

}
"
AFMapComponent.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import java.awt.MouseInfo;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.vaadin.addon.leaflet.LMap;
import org.vaadin.addon.leaflet.LMarker;
import org.vaadin.addon.leaflet.LeafletMouseOverEvent;
import org.vaadin.addon.leaflet.LeafletMouseOverListener;
import org.vaadin.addon.leaflet.shared.Point;

import com.vaadin.ui.AbsoluteLayout;
import com.vaadin.ui.Component;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.Label;
import com.vaadin.ui.Notification;
import com.vaadin.ui.PopupView;
import com.vaadin.ui.UI;
import com.vaadin.ui.VerticalLayout;

import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.info.FlightPlanInfo;
import edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;
import edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;
import edu.nd.dronology.ui.vaadin.map.LeafletmapFactory;
import edu.nd.dronology.ui.vaadin.start.MyUI;
import edu.nd.dronology.ui.vaadin.utils.Configuration;

/**
 * This is the map component for the Active Flights UI
 * 
 * @author Jinghui Cheng
 * 
 */
public class AFMapComponent extends CustomComponent { 
	private static final long serialVersionUID = 1L;

	private LMap leafletMap;
	// private ArrayList<LMarker> markers = new ArrayList<>();
	private Collection<IUAVProxy> drones;
	private Collection<FlightPlanInfo> currentFlights;
	private IDroneSetupRemoteService service;
	private IFlightManagerRemoteService flightManagerService;
	private BaseServiceProvider provider = MyUI.getProvider();

	private boolean follow = false;
	private boolean followZoom = false;
	private VerticalLayout content = new VerticalLayout();
	private AbsoluteLayout followLayout = new AbsoluteLayout();
	private AFFollowBar followBar;
	private AbsoluteLayout layout = new AbsoluteLayout();
	private PopupView popup;
	private PopupView dronePopup;

	private AFInfoPanel panel;
 
	private MapDrawingUtil drawingutil;

	public AFMapComponent(AFInfoPanel panel) {
		this.panel = panel;

		this.setWidth(""100%"");
		addStyleName(""map_component"");
		addStyleName(""af_map_component"");

		leafletMap = LeafletmapFactory.generateMap();
		drawingutil = new MapDrawingUtil(leafletMap, this);

		try {
			service = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);
			flightManagerService = (IFlightManagerRemoteService) provider.getRemoteManager()
					.getService(IFlightManagerRemoteService.class);
			// currentFlights = flightRouteService.getFlightDetails().getCurrentFlights();
		} catch (RemoteException | DronologyServiceException e) {
			e.printStackTrace();
			MyUI.setConnected(false);
		}
		List<String> temp = new ArrayList<>();
		drawingutil.addDroneMarkers("""", temp);
		drawingutil.addActiveFlightRoutes("""", temp);
		this.setAverageCenter();
		double screenHeight = UI.getCurrent().getPage().getBrowserWindowHeight();
		int layoutHeight = (int) Math.rint(screenHeight * 0.9);
		layout.setHeight(Integer.toString(layoutHeight) + ""px"");
		layout.addComponent(leafletMap);
		popup = createWayPointPopupView();
		dronePopup = createDronePopupView();
		layout.addComponents(popup, dronePopup);
		content.addComponent(layout);
		setCompositionRoot(content);
	}

	public void setCenter(double centerLat, double centerLon) {
		leafletMap.setCenter(centerLat, centerLon);
	}

	public void setZoomLevel(double zoomLevel) {
		leafletMap.setZoomLevel(zoomLevel);
	}

	public double getCenterLat() {
		return leafletMap.getCenter().getLat();
	}

	public double getCenterLon() {
		return leafletMap.getCenter().getLon();
	}

	public double getZoomLevel() {
		return leafletMap.getZoomLevel();
	}
 
	public LMap getMapInstance() {
		return leafletMap;
	}

	/**
	 * This function sets the center and zoom of the map to include all drones and their flight routes. It finds the average latitude and longitude first. It then finds the point farthest from the
	 * center and bases the zoom level off of that point.
	 */
	public void setAverageCenter() {
		if (content.getComponentIndex(layout) == -1) { // if coming out of follow mode
			content.removeAllComponents();
			leafletMap.removeStyleName(""af_leaflet_map_edit_mode"");
			content.addComponent(layout);
		}
		Configuration configuration = Configuration.getInstance();
		try {
			service = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);
			drones = service.getActiveUAVs();
			double avgLat = 0;
			double avgLon = 0;
			int numPoints = 0;
			for (IUAVProxy e : drones) { // finding the average latitude and longitude of the drones and flight routes
				avgLat += e.getLatitude();
				avgLon += e.getLongitude();
				numPoints++;
			}
			currentFlights = flightManagerService.getCurrentFlights();
			for (FlightPlanInfo e : currentFlights) {
				List<Waypoint> coordinates = e.getWaypoints();
				for (Waypoint coord : coordinates) {
					avgLat += coord.getCoordinate().getLatitude();
					avgLon += coord.getCoordinate().getLongitude();
					numPoints++;
				}
			}
			avgLat /= (numPoints * 1.0);
			avgLon /= (numPoints * 1.0);
			double farthestLat = 0;
			double farthestLon = 0; // finding the farthest point from the center
			for (IUAVProxy e : drones) {
				if (Math.abs(e.getLatitude() - avgLat) > farthestLat) {
					farthestLat = Math.abs(e.getLatitude() - avgLat);
				}
				if (Math.abs(e.getLongitude() - avgLon) > farthestLon) {
					farthestLon = Math.abs(e.getLongitude() - avgLon);
				}
			}
			for (FlightPlanInfo e : currentFlights) {
				List<Waypoint> coordinates = e.getWaypoints();
				for (Waypoint coord : coordinates) {
					if (Math.abs(coord.getCoordinate().getLatitude() - avgLat) > farthestLat) {
						farthestLat = Math.abs(coord.getCoordinate().getLatitude() - avgLat);
					}
					if (Math.abs(coord.getCoordinate().getLongitude() - avgLon) > farthestLon) {
						farthestLon = Math.abs(coord.getCoordinate().getLongitude() - avgLon);
					}
				}
			}
			Point point = new Point(avgLat, avgLon);
			double zoom;
			if (farthestLat == 0 && farthestLon == 0) {
				zoom = 14;
			} else { // sets the zoom based on the calculation of degrees on the map per zoom level
				zoom = Math.floor(Math.log10(180.0 / Math.max(farthestLat, farthestLon)) / Math.log10(2));
			}
			leafletMap.setCenter(point, zoom);
		} catch (RemoteException | DronologyServiceException e1) {
			MyUI.setConnected(false);
			e1.printStackTrace();
		} 
		if (drones.size() < 1) {
			Point point = new Point(configuration.getMapCenterLat(), configuration.getMapCenterLon());
			double zoom = configuration.getMapDefaultZoom();
			leafletMap.setCenter(point, zoom);
		}

	}

	/**
	 * @return follow is a boolean variable that is true when the map is following drones
	 */
	public boolean getFollow() {
		return this.follow;
	}

	public void setFollow(boolean follow) {
		this.follow = follow;
	}

	/**
	 * @return followZoom determines whether the map should zoom in on the drones in follow mode. Only happens once initially when the user clicks the button to follow the drones on the map.
	 */
	public boolean getFollowZoom() {
		return this.followZoom;
	}

	public void setFollowZoom(boolean followZoom) {
		this.followZoom = followZoom;
	}

	/**
	 * This function sets the center of the map as an average of the drones that it is following. This will constantly change as each drone flies.
	 * 
	 * @param names
	 *          The list of drone names that the map should be following
	 */
	public void followDrones(List<String> names) {
		if (names.size() < 1) {
			this.follow = false;
			if (content.getComponentIndex(layout) == -1) { // if not in follow mode
				content.removeAllComponents();
				leafletMap.removeStyleName(""af_leaflet_map_edit_mode"");
				content.addComponent(layout);
			}
			return;
		}
		if (this.follow == false) {
			if (content.getComponentIndex(layout) == -1) { // if not in follow mode
				content.removeAllComponents();
				leafletMap.removeStyleName(""af_leaflet_map_edit_mode"");
				content.addComponent(layout);
			}
			return;
		}
		try {
			service = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);
			drones = service.getActiveUAVs();
			double avgLat = 0; // finds the average latitude and longitude
			double avgLon = 0;
			int numPoints = 0;
			for (IUAVProxy e : drones) {
				for (String name : names) {
					if (e.getID().equals(name)) {
						avgLat += e.getLatitude();
						avgLon += e.getLongitude();
						numPoints++;
					}
				}
			}
			avgLat /= (numPoints * 1.0);
			avgLon /= (numPoints * 1.0);
			double farthestLat = 0; // finds the farthest point from the center
			double farthestLon = 0;
			for (IUAVProxy e : drones) {
				for (String name : names) {
					if (e.getID().equals(name)) {
						if (Math.abs(e.getLatitude() - avgLat) > farthestLat) {
							farthestLat = Math.abs(e.getLatitude() - avgLat);
						}
						if (Math.abs(e.getLongitude() - avgLon) > farthestLon) {
							farthestLon = Math.abs(e.getLongitude() - avgLon);
						}
					}
				}
			}
			Point point = new Point(avgLat, avgLon); 
			if (this.followZoom) { // if the first time after the button click, set the zoom level to fit all drones
				double zoom;
				if (farthestLat == 0 && farthestLon == 0) {
					zoom = 17;
				} else {
					zoom = Math.floor(Math.log10(180.0 / Math.max(farthestLat, farthestLon)) / Math.log10(2));
				}
				leafletMap.setCenter(point, zoom);
				this.followZoom = false;
			} else {
				leafletMap.setCenter(point);
			}
			if (content.getComponentIndex(layout) != -1) { // change the map layout to display the follow bar.
				leafletMap.addStyleName(""af_leaflet_map_edit_mode"");
				followBar = new AFFollowBar(this, names);
				followLayout.addStyleName(""af_mapabsolute_layout"");
				followBar.addStyleName(""bring_front"");
				double screenHeight = UI.getCurrent().getPage().getBrowserWindowHeight();
				int layoutHeight = (int) Math.rint(screenHeight * 0.9);
				followLayout.setHeight(Integer.toString(layoutHeight) + ""px"");
				followLayout.addComponent(layout);
				followLayout.addComponent(followBar);
				content.removeAllComponents();
				content.addComponent(followLayout); 
			} else {
				followBar.updateUAVList(names);
			}
		} catch (RemoteException | DronologyServiceException e1) {
			MyUI.setConnected(false);
			e1.printStackTrace();
		}
	}

	/**
	 * this is a listener that displays an AFInfoBox in a popup over the drone that was just hovered over
	 * 
	 * @author Patrick Falvey
	 *
	 */
	private class DroneMouseListener implements LeafletMouseOverListener {

		@Override
		public void onMouseOver(LeafletMouseOverEvent event) {
			try {
				drones = service.getActiveUAVs();
			} catch (RemoteException e) {
				e.printStackTrace();
			}

			dronePopup.setVisible(false);
			dronePopup.setPopupVisible(false);
			LMarker leafletMarker = (LMarker) event.getSource();

			VerticalLayout popupContent = (VerticalLayout) dronePopup.getContent().getPopupComponent();
			popupContent.removeAllComponents();
			for (IUAVProxy e : drones) { // change the popup content to display the right AFInfoBox
				if (e.getID().equals(leafletMarker.getId())) {
					UAVStatusWrapper status = new UAVStatusWrapper(e);
					AFInfoBox box = new AFInfoBox(false, status, false);
					box.createContents();
					box.setBoxVisible(false);
					VerticalLayout boxes = panel.getBoxes();
					int numUAVs = panel.getNumUAVS();
					for (int i = 1; i < numUAVs + 1; i++) {
						AFInfoBox panelBox = (AFInfoBox) boxes.getComponent(i);
						if (panelBox.getName().equals(box.getName())) { // get the updated information from the AFInfoPanel
							box.setIsChecked(panelBox.getIsChecked());
							box.setHoverInPlace(panelBox.getHoverInPlace());
							box.update(status);

						}
					}
					box.getRouteButton().addClickListener(click -> {
						dronePopup.setPopupVisible(false);
					});
					box.getHomeButton().addClickListener(click -> {
						dronePopup.setPopupVisible(false);
					});
					box.getHoverSwitch().addValueChangeListener(click -> {
						for (int i = 1; i < numUAVs + 1; i++) {
							AFInfoBox panelBox = (AFInfoBox) boxes.getComponent(i);
							if (panelBox.getName().equals(box.getName())) {
								panelBox.setHoverInPlace(box.getHoverInPlace());
							}
						}
					});
					box.getCheckBox().addValueChangeListener(click -> { // if checkbox clicked in popup, it will change in AFInfoPanel
						if (box.getCheckBox().getValue()) {
							for (int i = 1; i < numUAVs + 1; i++) {
								AFInfoBox panelBox = (AFInfoBox) boxes.getComponent(i);
								if (panelBox.getName().equals(box.getName())) {
									panelBox.setIsChecked(true);
								}
							}
						} else {
							for (int i = 1; i < numUAVs + 1; i++) {
								AFInfoBox panelBox = (AFInfoBox) boxes.getComponent(i);
								if (panelBox.getName().equals(box.getName())) {
									panelBox.setIsChecked(false);
								}
							}
						}
					});
					popupContent.addComponent(box);
				}
			}
			/*
			 * find the location on the screen to display the popup. Takes the absolute position of the mouse and converts that to the relative position of the mouse on the map. Uses the map dimensions and
			 * the map position within the layout
			 */
			double mapWidth = UI.getCurrent().getPage().getBrowserWindowWidth() - 366.0;
			double mapHeight = UI.getCurrent().getPage().getBrowserWindowHeight() * 0.9;

			double xDegreeDifference = -(leafletMap.getCenter().getLon() - leafletMarker.getPoint().getLon());
			double yDegreeDifference = leafletMap.getCenter().getLat() - leafletMarker.getPoint().getLat();
			double degreePerZoom = (360.0 / (Math.pow(2, leafletMap.getZoomLevel())));
			double degreePerPixel = degreePerZoom / mapWidth;
			double xPixelDifference = (xDegreeDifference / degreePerPixel) / 3.0;
			double yPixelDifference = (yDegreeDifference / degreePerPixel) / 3.0;

			xPixelDifference = xPixelDifference * 0.55;

			double pixelsToLeftBorder = (mapWidth / 2.0) + xPixelDifference;
			double pixelsToTopBorder = (mapHeight / 2.0) + yPixelDifference;
			double mouseX = MouseInfo.getPointerInfo().getLocation().getX();
			double mouseY = MouseInfo.getPointerInfo().getLocation().getY();
			double mapTopLeftX = mouseX - pixelsToLeftBorder;
			double mapTopLeftY = mouseY - pixelsToTopBorder;

			double adjustedXLocation = mouseX - mapTopLeftX;
			double adjustedYLocation = mouseY - mapTopLeftY;

			layout.addComponent(dronePopup, ""top:"" + String.valueOf((int) adjustedYLocation) + ""px;left:""
					+ String.valueOf((int) adjustedXLocation) + ""px"");

			dronePopup.setVisible(true);
			dronePopup.setPopupVisible(true);

		}
	}

	/**
	 * 
	 * @return returns the waypoint popup
	 */
	public PopupView createWayPointPopupView() {
		VerticalLayout popupContent = new VerticalLayout();
		popupContent.removeAllComponents();

		Label latitudeLabel = new Label();
		latitudeLabel.setId(""latitude"");

		Label longitudeLabel = new Label();
		longitudeLabel.setId(""longitude"");

		Label altitudeLabel = new Label();
		altitudeLabel.setId(""altitude"");

		Label transitSpeedLabel = new Label();
		transitSpeedLabel.setId(""transitSpeed"");

		popupContent.addComponent(latitudeLabel);
		popupContent.addComponent(longitudeLabel);
		popupContent.addComponent(altitudeLabel);
		popupContent.addComponent(transitSpeedLabel);

		PopupView popup = new PopupView(null, popupContent);

		popup.addStyleName(""bring_front"");
		popup.setVisible(false);
		popup.setPopupVisible(false);

		return popup;
	}

	/**
	 * 
	 * @return returns the drone popup
	 */
	public PopupView createDronePopupView() {
		VerticalLayout popupContent = new VerticalLayout();
		popupContent.removeAllComponents();

		popupContent.addComponent(new Label(""Drone Information""));
		PopupView popup = new PopupView(null, popupContent);

		popup.addStyleName(""bring_front"");
		popup.setVisible(false);
		popup.setPopupVisible(false);
		return popup;
	}

	/**
	 * This listener displays a popup of information about a certain waypoint. Virtually the same listener used in the flight routes UI.
	 * 
	 * @author Patrick Falvey
	 *
	 */
	public class WaypointMouseListener implements LeafletMouseOverListener {

		@Override
		public void onMouseOver(LeafletMouseOverEvent event) {

			popup.setVisible(false);
			popup.setPopupVisible(false);
			LMarker leafletMarker = (LMarker) event.getSource();

			VerticalLayout popupContent = (VerticalLayout) popup.getContent().getPopupComponent();
			Iterator<Component> it = popupContent.iterator(); // iterates through the popup content and updates the waypoint information
			while (it.hasNext()) {
				Component c = it.next();
				try {
					currentFlights = flightManagerService.getCurrentFlights();
					for (FlightPlanInfo e : currentFlights) {
						List<Waypoint> coordinates = e.getWaypoints();
						for (Waypoint coord : coordinates) {
							if (coord.getCoordinate().getLatitude() == leafletMarker.getPoint().getLat()
									&& coord.getCoordinate().getLongitude() == leafletMarker.getPoint().getLon()) {
								if (c.getId() != null && c.getId().equals(""latitude"")) {
									Label l = (Label) c;
									l.setValue(""Latitude: "" + coord.getCoordinate().getLatitude());
								}
								if (c.getId() != null && c.getId().equals(""longitude"")) {
									Label l = (Label) c;
									l.setValue(""Longitude: "" + coord.getCoordinate().getLongitude());
								}
								if (c.getId() != null && c.getId().equals(""altitude"")) {
									Label l = (Label) c;
									l.setValue(""Altitude: "" + coord.getCoordinate().getAltitude());
								}
								if (c.getId() != null && c.getId().equals(""transitSpeed"")) {
									Label l = (Label) c;
									l.setValue(""Transit Speed: "" + coord.getApproachingspeed());
								}
							}
						}
					}
				} catch (RemoteException e) {
					try {
						Notification.show(""Reconnecting..."");
						service = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);
						flightManagerService = (IFlightManagerRemoteService) provider.getRemoteManager()
								.getService(IFlightManagerRemoteService.class);
					} catch (RemoteException | DronologyServiceException e1) {
						MyUI.setConnected(false);
						Notification.show(""Reconnecting..."");
					}
					Notification.show(""Reconnecting..."");
				}
			}
			/*
			 * find the location on the screen to display the popup. Takes the absolute position of the mouse and converts that to the relative position of the mouse on the map. Uses the map dimensions and
			 * the map position within the layout
			 */
			double mapWidth = UI.getCurrent().getPage().getBrowserWindowWidth() - 366.0;
			double mapHeight = UI.getCurrent().getPage().getBrowserWindowHeight() * 0.9;

			double xDegreeDifference = -(leafletMap.getCenter().getLon() - leafletMarker.getPoint().getLon());
			double yDegreeDifference = leafletMap.getCenter().getLat() - leafletMarker.getPoint().getLat();
			double degreePerZoom = (360.0 / (Math.pow(2, leafletMap.getZoomLevel())));
			double degreePerPixel = degreePerZoom / mapWidth;
			double xPixelDifference = (xDegreeDifference / degreePerPixel) / 3.0;
			double yPixelDifference = (yDegreeDifference / degreePerPixel) / 3.0;

			xPixelDifference = xPixelDifference * 0.55;
			yPixelDifference = yPixelDifference * 0.6;

			double pixelsToLeftBorder = (mapWidth / 2.0) + xPixelDifference;
			double pixelsToTopBorder = (mapHeight / 2.0) + yPixelDifference;
			double mouseX = MouseInfo.getPointerInfo().getLocation().getX();
			double mouseY = MouseInfo.getPointerInfo().getLocation().getY();
			double mapTopLeftX = mouseX - pixelsToLeftBorder;
			double mapTopLeftY = mouseY - pixelsToTopBorder;

			double adjustedXLocation = mouseX - mapTopLeftX;
			double adjustedYLocation = mouseY - mapTopLeftY;

			layout.addComponent(popup, ""top:"" + String.valueOf((int) adjustedYLocation) + ""px;left:""
					+ String.valueOf((int) adjustedXLocation) + ""px"");

			popup.setVisible(true);
			popup.setPopupVisible(true);
		}
	}

	public LeafletMouseOverListener getWaypointListener() {
		return new WaypointMouseListener();
	}

	public LeafletMouseOverListener getDroneListener() { 
		return new DroneMouseListener();
	} 

	public void refresh(String focused, List<String> checkedNames) {
		drawingutil.updateDroneMarkers(focused, checkedNames); 
		drawingutil.updateActiveFlightRoutes(focused, checkedNames);
	}

}"
DronologySeriviceListener.java,"package edu.nd.dronology.services.extensions.missionplanning.service.internal;

import edu.nd.dronology.core.status.IDronologyChangeListener;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public class DronologySeriviceListener implements IDronologyChangeListener {

	@Override
	public void notifyUAVRemoved(String uavid) {
		try {
			MissionPlanningService.getInstance().removeUAV(uavid);
		} catch (DronologyServiceException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	@Override
	public void notifyGCSShutdown(String groundstationid) {
		try {
			MissionPlanningService.getInstance().cancelMission();
		} catch (DronologyServiceException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}
"
FlightManagerServiceRemoteFacade.java,"package edu.nd.dronology.services.facades;

import java.rmi.RemoteException;
import java.util.Collection;
import java.util.List;

import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.services.core.info.FlightInfo;
import edu.nd.dronology.services.core.info.FlightPlanInfo;
import edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.instances.flightmanager.FlightManagerService;
import edu.nd.dronology.services.remote.AbstractRemoteFacade;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Remote facade for handling UAV fligths<br>
 * Allows assigning flight plans to UAVs <br>
 * Allows sending flight related commands to UAVs (take-off, return to home...).
 * 
 * 
 * @author Michael Vierhauser
 *
 */
public class FlightManagerServiceRemoteFacade  extends AbstractRemoteFacade implements IFlightManagerRemoteService {
	/**
	 * 
	 */
	private static final long serialVersionUID = -4580658378477037955L;
	private static final ILogger LOGGER = LoggerProvider.getLogger(FlightManagerServiceRemoteFacade.class);
	private static volatile FlightManagerServiceRemoteFacade INSTANCE;

	protected FlightManagerServiceRemoteFacade() throws RemoteException {
		super(FlightManagerService.getInstance());
	}

	public static IFlightManagerRemoteService getInstance() throws RemoteException {
		if (INSTANCE == null) {
			try {
				synchronized (FlightManagerServiceRemoteFacade.class) {
					if (INSTANCE == null) {
						INSTANCE = new FlightManagerServiceRemoteFacade();
					}
				}

			} catch (RemoteException e) {
				LOGGER.error(e);
			}
		}
		return INSTANCE;
	}

	@Override
	public FlightInfo getFlightInfo(String uavId) throws RemoteException, Exception {
		return FlightManagerService.getInstance().getFlightInfo(uavId);
	}

	@Override
	public void planFlight(String uavid, String planName, List<Waypoint> waypoints) throws Exception {
		FlightManagerService.getInstance().planFlight(uavid, planName, waypoints);

	}

	@Override
	public void planFlight(String planName, List<Waypoint> waypoints) throws Exception {
		FlightManagerService.getInstance().planFlight(planName, waypoints);

	}

	@Override
	public void returnToHome(String uavid) throws RemoteException, Exception {
		FlightManagerService.getInstance().returnToHome(uavid);

	}

	@Override
	public void pauseFlight(String uavid) throws RemoteException, Exception {
		FlightManagerService.getInstance().pauseFlight(uavid);

	}

	@Override
	public Collection<FlightPlanInfo> getCurrentFlights() throws RemoteException {
		return FlightManagerService.getInstance().getCurrentFlights();
	}

	@Override
	public void cancelPendingFlights(String uavid) throws RemoteException, Exception {
		FlightManagerService.getInstance().cancelPendingFlights(uavid);
	}

	@Override
	public void takeoff(String uavid, double altitude) throws RemoteException, DronologyServiceException {
		FlightManagerService.getInstance().takeoff(uavid, altitude);

	}

}"
IUAVRegistrationRemoteService.java,"package edu.nd.dronology.services.core.remote;

import edu.nd.dronology.services.core.info.UAVRegistrationInfo;

public interface IUAVRegistrationRemoteService extends IRemoteableService, IFileTransmitRemoteService<UAVRegistrationInfo> {

	
	
}
"
StopEveryoneWaypoint.java,"package edu.nd.dronology.core.collisionavoidance.strategy;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand;

public class StopEveryoneWaypoint extends StopEveryone {

    public static final double STOP_SPEED = 2.0;

    public StopEveryoneWaypoint(double threshold) {
        super(threshold);
    }

    @Override
    protected void onStopTrigger(DroneSnapshot drone) {
        drone.getCommands().clear();
        drone.getCommands().add(new WaypointCommand(drone.getPosition(), STOP_SPEED));
    }

}"
GetNameMessage.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal.message;

import java.util.concurrent.SynchronousQueue;

public class GetNameMessage extends AbstractMessage {
    public final SynchronousQueue<String> returnBox = new SynchronousQueue<>();
}
"
FlightRouteXStreamPersistor.java,"package edu.nd.dronology.services.core.persistence.internal;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.XppDriver;

import edu.nd.dronology.services.core.items.IFlightRoute;
import edu.nd.dronology.services.core.persistence.DronologyPersistenceUtil;
import edu.nd.dronology.services.core.persistence.IPersistenceManager;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class FlightRouteXStreamPersistor implements IPersistenceManager<IFlightRoute> {

	private static final XStream xstream = new XStream(new XppDriver());
	private static ILogger LOGGER = LoggerProvider.getLogger(FlightRouteXStreamPersistor.class);

	static final boolean useCompression = false;

	@Override
	public IFlightRoute open(InputStream fin) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
		// xstream.setMode(XStream.);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");

		if (useCompression) {
			return loadedCompressedStream(fin);
		} else {
			return loadUncompressedStream(fin);
		}
	}

	private IFlightRoute loadUncompressedStream(InputStream fin) throws PersistenceException {
		try {
			InputStreamReader reader = new InputStreamReader(new BufferedInputStream(fin), Charset.forName(""UTF-8""));
			Object model = xstream.fromXML(reader);
			return (IFlightRoute) model;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (fin != null) {
					fin.close();
				}
			} catch (Exception e) {
				LOGGER.error(e);
			}
		}
	}

	private IFlightRoute loadedCompressedStream(InputStream fin) throws PersistenceException {
		InputStream zIn = null;
		try {
			zIn = new GZIPInputStream(fin);
			Object model = xstream.fromXML(new BufferedReader(new InputStreamReader(zIn, ""UTF-8"")));

			return (IFlightRoute) model;
		} catch (IOException e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (zIn != null) {
					zIn.close();
				}
				if (fin != null) {
					fin.close();
				}
			} catch (Exception e) {
				LOGGER.error(e);
			}

		}
	}

	@Override
	public boolean save(IFlightRoute o, OutputStream fout) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
		// xstream.setMode(XStream.ID_REFERENCES);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");
		// xstream.addImplicitMap(ImplMEEvent.class, ""relatedEvents"", ImplMEEvent.class,
		// ""relatedEvents"");

		if (useCompression) {
			return saveCompressedStream(o, fout);
		} else {
			return saveUncompressedStream(o, fout);
		}

	}
	
	public boolean save(IFlightRoute o, OutputStream fout,boolean closestream) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
		// xstream.setMode(XStream.ID_REFERENCES);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");
		// xstream.addImplicitMap(ImplMEEvent.class, ""relatedEvents"", ImplMEEvent.class,
		// ""relatedEvents"");

		if (useCompression) {
			return saveCompressedStream(o, fout);
		} else {
			return saveUncompressedStream(o, fout,closestream);
		}

	}

	private boolean saveUncompressedStream(IFlightRoute o, OutputStream fout) throws PersistenceException {
		OutputStreamWriter writer = null;
		try {
			writer = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(""UTF-8""));
			xstream.toXML(o, writer);
			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (writer != null) {
					writer.close();
				}
				if (fout != null) {
					fout.close();
				}
			} catch (IOException e) {
				LOGGER.error(e);
			}
		}

	}

	private boolean saveUncompressedStream(IFlightRoute o, OutputStream fout, boolean closestream)
			throws PersistenceException {
		OutputStreamWriter writer = null;
		try {
			writer = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(""UTF-8""));
			xstream.toXML(o, writer);
			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (writer != null && closestream) {
					writer.close();
				}
				if (fout != null && closestream) {
					fout.close();
				}
			} catch (IOException e) {
				LOGGER.error(e);
			}
		}

	}

	private boolean saveCompressedStream(IFlightRoute o, OutputStream fout) throws PersistenceException {
		try {
			GZIPOutputStream zOut = new GZIPOutputStream(fout);
			xstream.toXML(o, new BufferedWriter(new OutputStreamWriter(zOut, ""UTF-8"")));

			zOut.close();
			fout.close();

			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		}
	}

}
"
AFFollowBar.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import java.util.List;

import com.vaadin.ui.Button;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Label;

/**
 * This is the bar that indicates when the active flights UI is in follow mode
 * 
 * @author Patrick Falvey
 * 
 */
public class AFFollowBar extends CustomComponent{

	private static final long serialVersionUID = 2389713576038720628L;
	private HorizontalLayout totalLayout = new HorizontalLayout();
	private Button stopFollowingButton = new Button(""Stop Following"");
	 
	private Label textLabel = new Label(""Following UAV(s): "");
	private Label smallText = new Label();
	
	private String UAVNames;
	 
	public AFFollowBar(AFMapComponent map, List<String> uavs) {
		UAVNames = """";
		for (int i = 0; i < uavs.size() - 1; i++){
			UAVNames = UAVNames + uavs.get(i) + "", "";
		}
		UAVNames = UAVNames + uavs.get(uavs.size() - 1);
		smallText.setValue(UAVNames);
		setStyleName(""af_follow_bar"");
		textLabel.setStyleName(""large_text"");
		smallText.setStyleName(""small_text"");
		
		stopFollowingButton.setHeight(""25px"");
		totalLayout.addComponents(textLabel, smallText, stopFollowingButton);
		setCompositionRoot(totalLayout);
		
		stopFollowingButton.addClickListener(e->{
			map.setAverageCenter();
			map.setFollow(false);
		});

	}
	
	public Button getStopFollowingButton(){
		return stopFollowingButton;
	}
	
	public void updateUAVList(List<String> uavs){
		UAVNames = """";
		for (int i = 0; i < uavs.size() - 1; i++){
			UAVNames = UAVNames + uavs.get(i) + "", "";
		}
		UAVNames = UAVNames + uavs.get(uavs.size() - 1);
		smallText.setValue(UAVNames);
	}
	
	
	
}"
FlightRoute.java,"package edu.nd.dronology.services.core.items;

import java.io.Serializable;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.UUID;

import edu.nd.dronology.core.Discuss;
import edu.nd.dronology.core.DronologyConstants;
import edu.nd.dronology.core.util.Waypoint;

/**
 * 
 * Implementation of a flight route, containing a series of waypoints and additional meta-data.
 * 
 * @author Michael Vierhauser
 *
 */
public class FlightRoute implements IFlightRoute, Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = -3151158691427417882L;
	private String name;
	private String id;
	private String category = ""Default"";
	private LinkedList<Waypoint> waypoints;
	private double takeoffaltitude = DronologyConstants.TAKE_OFF_ALTITUDE;
	private String description;

	public double setTakeoffAltitude() {
		return takeoffaltitude;
	}

	public FlightRoute() {
		id = UUID.randomUUID().toString();
		waypoints = new LinkedList<>();
		name = id;
	}

	@Override
	public void setName(String name) {
		this.name = name;

	}

	@Override
	public String getId() {
		return id;
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public String getDescription() {
		return description;
	}

	@Override
	public void setDescription(String description) {
		this.description = description;

	}

	@Override
	public void setCategory(String category) {
		this.category = category;

	}

	@Override
	public String getCategory() {
		return category;
	}

	@Override
	public List<Waypoint> getWaypoints() {
		return Collections.unmodifiableList(waypoints);
	}

	@Override
	public void addWaypoint(Waypoint waypoint) {
		waypoints.add(waypoint);
	}

	@Discuss(discuss = ""this currently breaks if you add 2 identical coordinates..."")
	@Override
	public int removeWaypoint(Waypoint coordinate) {
		int index = waypoints.indexOf(coordinate);
		if (index != -1) {
			waypoints.remove(coordinate);
		}
		return index;
	}

	@Override
	public void addWaypoint(Waypoint waypoint, int index) {
		waypoints.add(index, waypoint);
	}

	@Override
	public Waypoint removeWaypoint(int index) {
		return waypoints.remove(index);

	}

	@Override
	public void setTakeoffAltitude(double altitude) {
		if (altitude <= 0) {
			throw new IllegalArgumentException(""Takeoff altitude must not be a postive number > 0"");
		}
		this.takeoffaltitude = altitude;
	}
}
"
ReadDispatcher.java,"package edu.nd.dronology.gstation.connector.dispatch;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.Socket;
import java.net.SocketException;
import java.util.concurrent.atomic.AtomicBoolean;

import edu.nd.dronology.core.monitoring.DronologyMonitoringManager;
import edu.nd.dronology.core.util.FormatUtil;
import edu.nd.dronology.gstation.connector.messages.AbstractUAVMessage;
import edu.nd.dronology.gstation.connector.messages.UAVAcknowledgeMessage;
import edu.nd.dronology.gstation.connector.messages.UAVHandshakeMessage;
import edu.nd.dronology.gstation.connector.messages.UAVMessageFactory;
import edu.nd.dronology.gstation.connector.messages.UAVModeChangeMessage;
import edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;
import edu.nd.dronology.gstation.connector.messages.UAVStateMessage;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * 
 * Threat handling incoming messages from a GCS. <br>
 * The {@link ReadDispatcher} can handle json messages that are transformed into UAV Messages (extending {@link AbstractUAVMessage}) by the {@link UAVMessageFactory}.
 * 
 * 
 * @author Michael Vierhauser
 * 
 *
 */
public class ReadDispatcher implements Runnable {

	private InputStream inputStream;
	private AtomicBoolean cont = new AtomicBoolean(false);
	private static final ILogger LOGGER = LoggerProvider.getLogger(ReadDispatcher.class);

	private BufferedReader reader;
	private DispatchQueueManager dispatchQueueManager;

	public ReadDispatcher(Socket pythonSocket, DispatchQueueManager dispatchQueueManager) {
		try {
			this.dispatchQueueManager = dispatchQueueManager;
			inputStream = pythonSocket.getInputStream();
			cont.set(true);
		} catch (IOException e) {
			LOGGER.error(e);
		}
	}

	@Override
	public void run() {
		try {
			LOGGER.info(""Read-Dispatcher started"");
			reader = new BufferedReader(new InputStreamReader(inputStream));
			while (cont.get() && !Thread.currentThread().interrupted()) {
				String line = reader.readLine();
				if (line != null) {
					// TODO: create the timestamp before deserializing the
					// object....
					try {
						AbstractUAVMessage<?> msg = UAVMessageFactory.create(line);
						processMessage(msg);
						if (msg == null) {
							LOGGER.hwFatal(""Error when parsing incomming message '"" + line + ""'"");
						}

					} catch (Exception ex) {
						ex.printStackTrace();
						LOGGER.hwFatal(""Error when parsing incomming message '"" + line + ""' "" + ex.getMessage());
					} 

				} else {
					LOGGER.hwInfo(""null message received: closing socket."");
					tearDown();
				}

			}
			LOGGER.info(""Reader Thread shutdown"");
			try {
				if (inputStream != null) {
					inputStream.close();
				}
				if (reader != null) {
					reader.close();
				}

			} catch (IOException e) {
				LOGGER.error(e);
			}

		} catch (SocketException sex) {
			LOGGER.error(""Socket Exception groundstation "" + dispatchQueueManager.getGroundstationid()
					+ "" disconnected - shutting down connection -- Error: "" + sex.getMessage());
			dispatchQueueManager.tearDown();
			cont.set(false);

		} catch (Throwable t) {
			LOGGER.error(t);
		} finally {
			if (inputStream != null) {
				try {
					inputStream.close();
				} catch (IOException e) {
					LOGGER.error(e);
				}
			}
			if (reader != null) {
				try {
					reader.close();
				} catch (IOException e) {
					LOGGER.error(e);
				}
			}
		}
	}

	private void processMessage(AbstractUAVMessage<?> message) {
		if (message instanceof UAVStateMessage) {
			LOGGER.hwTrace(UAVMessageFactory.toJson(message));
			dispatchQueueManager.postDroneStatusUpdate(message.getUavid(), message);

		} else if (message instanceof UAVModeChangeMessage) {
			dispatchQueueManager.postDroneStatusUpdate(message.getUavid(), message);
		} else if (message instanceof UAVHandshakeMessage) {
			LOGGER.hwInfo(FormatUtil.formatTimestamp(message.getTimestamp(), FormatUtil.FORMAT_YEAR_FIRST_MILLIS) + "" - ""
					+ message.toString()); 
			dispatchQueueManager.postDoneHandshakeMessage(message.getUavid(), (UAVHandshakeMessage) message);
 
		} else if (message instanceof UAVMonitoringMessage) {
			dispatchQueueManager.postMonitoringMessage((UAVMonitoringMessage) message);

		} else if (message instanceof UAVAcknowledgeMessage) {
			DronologyMonitoringManager.getInstance().publish(message);
		}
	}

	public void tearDown() {
		cont.set(false);
		dispatchQueueManager.tearDown();
	}

	public String getConnectionId() {
		return ""ADS"";
	}
}
"
UAVTypeRegistration.java,"package edu.nd.dronology.services.core.items;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class UAVTypeRegistration implements IUAVTypeRegistration {

	private String id;
	private String name;
	private String description;
	private String type = ""Default"";
	private Map<String, Serializable> attributes;
	private byte[] image;

	public UAVTypeRegistration() {
		id = UUID.randomUUID().toString();
		attributes = new HashMap<>();
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String getId() {
		return id;
	}

	@Override
	public String getDescription() {
		return description;
	}

	@Override
	public void setDescription(String description) {
		this.description = description;

	}

	@Override
	public Serializable getAttribute(String key) {
		return attributes.get(key);
	}

	@Override
	public void addAttribute(String key, Serializable value) {
		attributes.put(key, value);
	}

	@Override
	public void setUAVImage(byte[] image) {
		this.image = image;
	}

	@Override
	public byte[] getImage() {
		return image;
	}
}
"
SimpleTakeoffFlightPlan.java,"package edu.nd.dronology.core.flight.internal;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import edu.nd.dronology.core.Discuss;
import edu.nd.dronology.core.DronologyConstants;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.exceptions.FlightZoneException;
import edu.nd.dronology.core.flight.IFlightPlan;
import edu.nd.dronology.core.util.FormatUtil;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.core.vehicle.ManagedDrone;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * Stores flight information including its waypoints and current status.
 * 
 * @author Jane Cleland-Huang
 * @version 0.1
 *
 */
public class SimpleTakeoffFlightPlan implements IFlightPlan {

	/**
	 * 
	 */
	private static final long serialVersionUID = -3288935042986922882L;

	private transient static final ILogger LOGGER = LoggerProvider.getLogger(SimpleTakeoffFlightPlan.class);

	private static int flightNumber = 0;
	private String flightID;

	private Status status;
	private transient ManagedDrone drone = null;

	private long startTime = -1;
	private long endTime = -1;
	private String uavid;

	private double altitude;

	private List<Waypoint> wayPoints = new ArrayList<>();

	private enum Status {
		PLANNED, FLYING, COMPLETED, ON_HOLD;

		@Override
		public String toString() {
			return name().charAt(0) + name().substring(1).toLowerCase();
		}

	}

	public SimpleTakeoffFlightPlan(ManagedDrone drone, String planName, double altitude) {
		this.altitude = altitude;
		if (altitude > DronologyConstants.MAX_ALTITUDE) {
			altitude = DronologyConstants.MAX_ALTITUDE;
			LOGGER.warn(""Altitude override - Takeoff altitude exceeding max altitude of ""
					+ DronologyConstants.MAX_ALTITUDE + ""m"");
		}
		this.drone = drone; 
		this.uavid = drone.getDroneName();
		LlaCoordinate current = drone.getCoordinates();
		wayPoints.add(new Waypoint(new LlaCoordinate(current.getLatitude(), current.getLongitude(), altitude)));
		this.flightID = ""DF-"" + Integer.toString(++flightNumber) + "" - "" + planName;
		status = Status.PLANNED;

	}

	/**
	 * 
	 * @return flight ID
	 */
	@Override
	public String getFlightID() {
		return flightID;
	}

	/**
	 * 
	 * @return Starting Coordinates
	 */
	@Override
	public LlaCoordinate getStartLocation() {
		return null;
	}

	/**
	 * 
	 * @return Ending Coordinates
	 */
	@Override
	public LlaCoordinate getEndLocation() {
		return null;
	}

	/**
	 * Returns the drone assigned to the flight plan. Will return null if no drone
	 * is yet assigned.
	 * 
	 * @return iDrone
	 */
	@Override
	public ManagedDrone getAssignedDrone() {
		return drone;
	}

	@Override
	public void clearAssignedDrone() {
		drone = null;
	}

	/**
	 * 
	 * @param drone
	 * @return true if drone is currently flying, false otherwise.
	 * @throws FlightZoneException
	 */
	@Override
	public boolean setStatusToFlying(ManagedDrone drone) throws FlightZoneException {
		if (status == Status.PLANNED) {
			status = Status.FLYING;
			startTime = System.currentTimeMillis();
			this.drone = drone;
			LOGGER.missionInfo(""Flight Plan '"" + getFlightID() + ""'"" + drone.getDroneName() + ""' started "");
			return true;
		} else
			throw new FlightZoneException(""Only currently planned flights can have their status changed to flying"");
	}

	/**
	 * Sets flightplan status to completed when called.
	 * 
	 * @return true
	 * @throws FlightZoneException
	 */
	@Override
	public boolean setStatusToCompleted() throws FlightZoneException {
		if (status == Status.FLYING) {
			status = Status.COMPLETED;
			endTime = System.currentTimeMillis();
			LOGGER.missionInfo(""Flight Plan '"" + getFlightID() + ""'"" + drone.getDroneName() + ""' completed ""
					+ FormatUtil.formatTimestamp(startTime) + ""-"" + FormatUtil.formatTimestamp(endTime));
			return true; // success (may add real check here later)
		} else
			throw new FlightZoneException(""Only currently flying flights can have their status changed to completed"");
	}

	/**
	 * Returns current flightplan status (Planned, Flying, Completed)
	 * 
	 * @return status
	 */
	public String getStatus() {

		return status.toString();

	}

	@Override
	public String toString() {
		return flightID + ""\n"" + getStartLocation() + "" - "" + getEndLocation() + ""\n"" + getStatus();
	}

	/**
	 * Returns way points
	 * 
	 * @return List<Waypoint>
	 */
	@Override
	public List<Waypoint> getWayPoints() {
		return Collections.unmodifiableList(wayPoints);
	}

	/**
	 * Returns start time of flight.
	 * 
	 * @return date object
	 */
	@Override
	public long getStartTime() {
		return startTime;
	}

	/**
	 * REturns end time of flight.
	 * 
	 * @return date object
	 */
	@Override
	public long getEndTime() {
		return endTime;
	}

	@Override
	public String getDesignatedDroneId() {
		return uavid;
	}

	@Override
	@Discuss(discuss = ""unessecary double check of plan complete.. needs to be fixed"")
	public boolean isCompleted() {
		return status == Status.COMPLETED || getWayPoints().get(0).isReached();
	}

	@Override
	public double getTakeoffAltitude() {
		return altitude;
	}
 
	@Override
	public void setDesignatedDroneId(String uavid) {
		this.uavid=uavid;
		
	}
	
}
"
MissionElementFactory.java,"package edu.nd.dronology.services.extensions.missionplanning.service.internal;

import edu.nd.dronology.services.core.items.IMissionPlan;
import edu.nd.dronology.services.extensions.missionplanning.persistence.PersistableMissionPlan;

public class MissionElementFactory {

	public static IMissionPlan createNewMissionPlan() {
		return new PersistableMissionPlan();
	}

}
"
FlightDirectorFactory.java,"package edu.nd.dronology.core.flight;

import edu.nd.dronology.core.flight.internal.SoloDirector;
import edu.nd.dronology.core.vehicle.ManagedDrone;

public class FlightDirectorFactory {

	public static IFlightDirector getFlightDirector(ManagedDrone managedDrone) {
		return new SoloDirector(managedDrone);
	}

}
"
RemoteInfoFactory.java,"//package edu.nd.dronology.services.info;
//
//import java.util.List;
//
//import edu.nd.dronology.core.flight.Flights;
//import edu.nd.dronology.core.flight.IFlightPlan;
//import edu.nd.dronology.core.util.LlaCoordinate;
//import edu.nd.dronology.core.util.Waypoint;
//import edu.nd.dronology.services.core.info.FlightInfo;
//import edu.nd.dronology.services.core.info.FlightPlanInfo;
//
//public class RemoteInfoFactory {
//
//	public static FlightInfo createFlightInfo(Flights flights) {
//
//		FlightInfo info = new FlightInfo(""FlightInfo"", ""FlightInfo"");
//
//		for (IFlightPlan flt : flights.getCurrentFlights()) {
//			FlightPlanInfo fpl = createPlanInfo(flt);
//			info.addCurrentFlight(fpl);
//
//		}asdsa
//
//		for (IFlightPlan flt : flights.getAwaitingTakeOffFlights()) {
//			FlightPlanInfo fpl = createPlanInfo(flt);
//			info.addAwaitingTakeoff(fpl);
//		}
//
//		for (IFlightPlan flt : flights.getCompletedFlights()) {
//			FlightPlanInfo fpl = createPlanInfo(flt);
//			info.addCompleted(fpl);
//		}
//
//		for (IFlightPlan flt : flights.getPendingFlights()) {
//			FlightPlanInfo fpl = createPlanInfo(flt);
//			info.addPending(fpl);
//		}
//
//		return info;
//
//	}
//
//	private static FlightPlanInfo createPlanInfo(IFlightPlan flt) {
//		FlightPlanInfo flightPlanInfo = new FlightPlanInfo(flt.getFlightID(), flt.getFlightID());
//		String droneId = flt.getAssignedDrone() != null ? flt.getAssignedDrone().getDroneName() : ""--"";
//		
//	
//		
//		List<Waypoint> waypoints = flt.getWayPoints();
//		LlaCoordinate start = flt.getStartLocation();
//		long startTime = flt.getStartTime();
//		long endTime = flt.getEndTime();
//
//		flightPlanInfo.setDroneId(droneId);
//		flightPlanInfo.setWaypoints(waypoints);
//		flightPlanInfo.setStartLocation(start);
//		flightPlanInfo.setStartTime(startTime);
//		flightPlanInfo.setEndTime(endTime);
//
//		return flightPlanInfo;
//	}
//
//}
"
IMonitoringDataHandler.java,"package edu.nd.dronology.core.monitoring;

import java.util.concurrent.BlockingQueue;

public interface IMonitoringDataHandler extends Runnable {

	void setQueue(BlockingQueue<IMonitorableMessage> queue);

}
"
TakeOffMessage.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal.message;

public class TakeOffMessage extends AbstractMessage {
}
"
RandomRouteSelector.java,"package edu.nd.dronology.services.extensions.areamapping.selection.random;

import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.IntStream;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.areamapping.MetricsStatistics;
import edu.nd.dronology.services.core.items.IAreaMapping;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.extensions.areamapping.internal.Geometry;
import edu.nd.dronology.services.extensions.areamapping.metrics.AllocationInformation;
import edu.nd.dronology.services.extensions.areamapping.metrics.Drone;
import edu.nd.dronology.services.extensions.areamapping.metrics.MetricsRunner;
import edu.nd.dronology.services.extensions.areamapping.metrics.MetricsUtilities;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;
import edu.nd.dronology.services.extensions.areamapping.selection.GeneratedRoutesInfo;
import edu.nd.dronology.services.extensions.areamapping.selection.IRouteSelectionStrategy;
import edu.nd.dronology.services.extensions.areamapping.selection.ResultCreationUtil;
import edu.nd.dronology.services.extensions.areamapping.selection.RouteSelectionResult;
import edu.nd.dronology.services.extensions.areamapping.util.Utilities;

public class RandomRouteSelector implements IRouteSelectionStrategy {

	private static final double APERATURE_WIDTH = 10;
	private static final double APERATURE_HEIGHT = 0.8 * APERATURE_WIDTH;
	private static final double OVERLAP_FACTOR = 0.7;
	private static final int DEFAULT_RESULTS = 100;
	private double avgLatitude;
	// private int availableDrones;
	private List<RoutePrimitive> routePrimitives;
	private MetricsRunner metricsRunner;
	private List<IUAVProxy> uavs;
	private long start;
	private long end;
	private List<AllocationInformation> allAllocations;

	@Override
	public void initialize(GeneratedRoutesInfo info, Collection<IUAVProxy> uavs, IAreaMapping mapping)
			throws DronologyServiceException {

		try {
			routePrimitives = Utilities.splitRoutePrimitives(info.getRoutePrimitives(), APERATURE_HEIGHT, OVERLAP_FACTOR);
			this.avgLatitude = info.getAverageLatitude();
			this.uavs = new ArrayList<>(uavs);
			metricsRunner = new MetricsRunner(routePrimitives, info.getTotalRiverSegment(), info.getBankList(),
					APERATURE_WIDTH, APERATURE_HEIGHT, uavs.size());
		} catch (Exception e) {
			e.printStackTrace();
			throw new DronologyServiceException(e.getMessage());
		}

	}

	@Override
	public RouteSelectionResult generateAssignments(int numAssignments) throws DronologyServiceException {
		try {
			allAllocations = new ArrayList<>();

			IntStream.range(0, numAssignments).forEach(i -> createAssignment());

			return createResult();
		} catch (Throwable t) {
			t.printStackTrace();
			throw new DronologyServiceException(t.getMessage());
		}

	}

	private void createAssignment() {
		List<Drone> assignments = generateRandomAssingments();
		AllocationInformation currentAllocation = new AllocationInformation();
		currentAllocation.setDroneAllocations(assignments);
		currentAllocation.setMetricsStatistics(generateMetricsStatistics(assignments));
		allAllocations.add(currentAllocation);

	}

	private RouteSelectionResult createResult() {
		Collections.sort(allAllocations);
		ResultCreationUtil rcUtil = new ResultCreationUtil(routePrimitives);
		rcUtil.createRoutes(avgLatitude);

		RouteSelectionResult result = rcUtil.createResult(allAllocations);
		result.setSelectionTime(end - start);

		return result;

	}

	// GeneratedRouteAssignment....
	private List<Drone> generateRandomAssingments() {
		try {
		Set<Integer> assignedRoutes = new HashSet<>();
		int availableDrones = uavs.size();
		int droneNum;
		int routeNum;

		int routeAssignmentNum = MetricsUtilities.generateRandomNumber(routePrimitives.size() - 1, 1);
		List<Drone> droneList = new ArrayList<>();
		for (int i = 0; i < availableDrones; i++) {
			droneList.add(new Drone());
			LlaCoordinate home = uavs.get(i).getHomeLocation();
			LlaCoordinate currentLocation = uavs.get(i).getCoordinates();
			droneList.get(i).setDroneHomeLocation(
					Geometry.gpsToCartesian(new Point2D.Double(home.getLatitude(), home.getLongitude()), avgLatitude));
			droneList.get(i).setDroneStartPoint(Geometry.gpsToCartesian(
					new Point2D.Double(currentLocation.getLatitude(), currentLocation.getLongitude()), avgLatitude));
			droneList.get(i).setUAVId(uavs.get(i).getID());
		}

		// while (assignedRoutes.size() < routeAssignmentNum) {
		// // assign drone routes in here
		// droneNum = MetricsUtilities.generateRandomNumber(availableDrones - 1, 0);
		// routeNum = MetricsUtilities.generateRandomNumber(routeAssignmentNum, 0);
		// while (assignedRoutes.contains(routeNum)) {
		// routeNum = MetricsUtilities.generateRandomNumber(routeAssignmentNum, 0);
		// }
		// droneList.get(droneNum).getDroneRouteAssignment().add(routePrimitives.get(routeNum));
		// assignedRoutes.add(routeNum);
		// }
		List<RoutePrimitive> shuffledRoutes = new ArrayList<>(routePrimitives);
		Collections.shuffle(shuffledRoutes);
		List<RoutePrimitive> availableRoutes = new ArrayList(shuffledRoutes.subList(0, (routeAssignmentNum+1)));
		AtomicInteger assignCounter = new AtomicInteger(0);
		while (assignCounter.get() < routeAssignmentNum) {
			droneNum = MetricsUtilities.generateRandomNumber(availableDrones - 1, 0);
			routeNum = MetricsUtilities.generateRandomNumber(availableRoutes.size()-1, 0);
			RoutePrimitive toAssign = availableRoutes.remove(routeNum);
			droneList.get(droneNum).getDroneRouteAssignment().add(toAssign);
			assignCounter.incrementAndGet();
		}
		return droneList;
		}catch (Throwable e) {
			e.printStackTrace();
			return Collections.EMPTY_LIST;
		}
	}

	private MetricsStatistics generateMetricsStatistics(List<Drone> drones) {
		long start = System.currentTimeMillis();
		metricsRunner.setDroneAssignments(drones);
		MetricsStatistics metrics = metricsRunner.runMetrics();
		long end  = System.currentTimeMillis();
//		System.out.println(end-start);
		return metrics;
	}

	@Override
	public RouteSelectionResult generateAssignments() throws DronologyServiceException {
		return generateAssignments(DEFAULT_RESULTS);
	}

}
"
ConnectionResponseCommand.java,"package edu.nd.dronology.core.vehicle.commands;

public class ConnectionResponseCommand extends AbstractDroneCommand implements IDroneCommand {

	/**
	 * 
	 */
	private static final long serialVersionUID = -2039989878208633422L;

	public ConnectionResponseCommand(String groundstationId, boolean success) {
		super(groundstationId, CommandIds.CONNECTION_RESPONSE);
		data.put(ATTRIBUTE_SUCCESS, Boolean.toString(success));
	}

}
"
LandMessage.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal.message;

public class LandMessage extends AbstractMessage {
}
"
IDrone.java,"package edu.nd.dronology.core.vehicle;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.exceptions.FlightZoneException;
import edu.nd.dronology.core.vehicle.commands.AbstractDroneCommand;
import edu.nd.dronology.core.vehicle.proxy.UAVProxy;


/**
 * iDrone interface
 * 
 * @author Jane Cleland-Huang
 * @version 0.01
 *
 */
public interface IDrone {

	public UAVProxy getDroneStatus();

	/**
	 * 
	 * @return latitude of drone
	 */
	public double getLatitude();

	/**
	 * 
	 * @return longitude of drone
	 */
	public double getLongitude();

	/**
	 * 
	 * @return altitude of drone
	 */
	public double getAltitude();

	/**
	 * Fly drone to target coordinates
	 * 
	 * @param targetCoordinates
	 * @param speed
	 */
	public void flyTo(LlaCoordinate targetCoordinates, Double speed);

	/**
	 * 
	 * @return current coordinates
	 */
	public LlaCoordinate getCoordinates();

	/**
	 * 
	 * @return unique name of drone
	 */
	public String getDroneName();

	/**
	 * Land the drone. Update status.
	 * 
	 * @throws FlightZoneException
	 */
	void land() throws FlightZoneException;

	/**
	 * Takeoff. Update status.
	 * 
	 * @throws FlightZoneException
	 */
	void takeOff(double altitude) throws FlightZoneException;

	/**
	 * Sets drones coordinates
	 * 
	 * @param lat
	 *          latitude
	 * @param lon
	 *          Longitude
	 * @param alt
	 *          Altitude
	 */
	public void setCoordinates(double lat, double lon, double alt);

	public double getBatteryStatus();

	public boolean move(double i);

	public void setVoltageCheckPoint();

	public boolean isDestinationReached(int distanceMovedPerTimeStep);

	void setBaseCoordinates(LlaCoordinate basePosition);

	public LlaCoordinate getBaseCoordinates();

	public void setGroundSpeed(double speed);

	public void setVelocity(double x, double y, double z);

	void setCoordinates(LlaCoordinate coordinate);

	public void sendCommand(AbstractDroneCommand command) throws DroneException;

	public DroneSnapshotInternal getLatestDroneSnapshot();

	public void setManagedDrone(ManagedDrone managedDrone);

	public void resendCommand() throws DroneException;

}
"
DroneCollector.java,"package edu.nd.dronology.core.collisionavoidance;

import edu.nd.dronology.core.vehicle.ManagedDrone;

import java.util.List;

/**
 * I think of this as an agent who's one job is to find a list of ManagedDrones. The motivation for this to exist comes
 * from making it easier to isolate CollisionAvoidanceCheckTask under test.
 */
public interface DroneCollector {
    List<ManagedDrone> getManagedDrones();
}
"
MonitoringDispatchThread.java,"package edu.nd.dronology.gstation.connector.dispatch;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;

import edu.nd.dronology.core.IUAVPropertyUpdateNotifier;
import edu.nd.dronology.core.monitoring.DronologyMonitoringManager;
import edu.nd.dronology.gstation.connector.messages.AbstractUAVMessage;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class MonitoringDispatchThread extends AbstractStatusDispatchThread<AbstractUAVMessage> implements Callable {
	private static final ILogger LOGGER = LoggerProvider.getLogger(MonitoringDispatchThread.class);

	private IUAVPropertyUpdateNotifier listener;

	public MonitoringDispatchThread(final BlockingQueue<AbstractUAVMessage> queue) {
		super(queue);
	}

	@Override
	public Object call() {
		while (cont.get() && !Thread.currentThread().isInterrupted()) {

			try {
				AbstractUAVMessage message = queue.take();
				DronologyMonitoringManager.getInstance().publish(message);
			} catch (InterruptedException e) {
				LOGGER.info(""Monitoring Dispatcher shutdown! -- "" + e.getMessage());

			} catch (Throwable e) {
				LOGGER.error(e);
			}

		}
		LOGGER.info(""Monitoring Dispatcher shutdown!"");
		return null;
	}

}
"
GetSnapshotMessage.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal.message;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;
import edu.nd.dronology.core.collisionavoidance.DroneSnapshotOption;

import java.util.concurrent.ArrayBlockingQueue;

public class GetSnapshotMessage extends AbstractMessage {
    public final ArrayBlockingQueue<DroneSnapshotOption> returnBox;
    public GetSnapshotMessage(ArrayBlockingQueue<DroneSnapshotOption> returnQueue) {
        this.returnBox = returnQueue;
    }
}
"
AMControlsComponent.java,"package edu.nd.dronology.ui.vaadin.areamapping;

import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.VerticalLayout;

/**
 * This controls component shows the info panel (list of mappings) and contains the main layout.
 * 
 * @author Andrew Slavin
 *
 */

public class AMControlsComponent extends CustomComponent {
	
	private static final long serialVersionUID = 1L;
	private AMInfoPanel info = new AMInfoPanel(this);
	AMMainLayout mainLayout;
	
	public AMControlsComponent(AMMainLayout layout) {
		this.setWidth(""100%"");
		addStyleName(""controls_component"");
		
		VerticalLayout content = new VerticalLayout();

		content.addComponent(info);
		setCompositionRoot(content);
		mainLayout = layout;
	}
	
	// Returns the list of area mappings, which appears on the left hand side of the display.
	public AMInfoPanel getInfoPanel(){
		return info;
	}
	// Returns the table and grid combination, which appears on the right hand side of the display.
	public AMMainLayout getMainLayout() {
		return mainLayout;
		
	}

}
"
UAVMessageFactory.java,"package edu.nd.dronology.gstation.connector.messages;

import java.text.DateFormat;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.json.JSONObject;

import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import edu.nd.dronology.gstation.connector.GroundStationException;

/**
 * 
 * Factory class for creating {@link AbstractUAVMessage} from JSON strings.
 * 
 * @author Michael Vierhauser  
 *
 */
public class UAVMessageFactory {

	private static final String MESSAGE_TYPE = ""type"";

	public static final transient Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()
			.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).setVersion(1.0)
			.serializeSpecialFloatingPointValues().serializeSpecialFloatingPointValues()
			.registerTypeAdapter(UAVModeChangeMessage.class, new ModeChangeMessageTypeAdapter()).create();

	static final Gson TYPE_GSON = new GsonBuilder().serializeNulls().setDateFormat(DateFormat.LONG)
			.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).setVersion(1.0)
			.serializeSpecialFloatingPointValues().registerTypeAdapter(Map.class, new StateMessageTypeAdapter())

			.create();

	public static AbstractUAVMessage<?> create(String messagestring) throws Exception {

		JSONObject messageObject = new JSONObject(messagestring);
		String messagetype = messageObject.optString(MESSAGE_TYPE);

		if (messagetype == null || StringUtils.isEmpty(messagetype)) {
			throw new GroundStationException(""Message Type of received message was null!"");
		}
		AbstractUAVMessage<?> message = null;
		switch (messagetype) {
			case UAVStateMessage.MESSAGE_TYPE: {
				message = TYPE_GSON.fromJson(messagestring, UAVStateMessage.class);
				message.timestamp();
				return message;
			}

			case UAVHandshakeMessage.MESSAGE_TYPE: {
				message = GSON.fromJson(messagestring, UAVHandshakeMessage.class);
				message.timestamp();
				return message;
			}
			case UAVMonitoringMessage.MESSAGE_TYPE: {
				message = GSON.fromJson(messagestring, UAVMonitoringMessage.class);
				message.timestamp();
				return message;
			}
			case ConnectionRequestMessage.MESSAGE_TYPE: {
				message = GSON.fromJson(messagestring, ConnectionRequestMessage.class);
				message.timestamp();
				return message;
			}
			case UAVModeChangeMessage.MESSAGE_TYPE: {
				message = GSON.fromJson(messagestring, UAVModeChangeMessage.class);
				message.timestamp();
				return message;
			}

			default:
				throw new GroundStationException(""Unknown Message Type! '"" + messagetype + ""'"");
		}
	}

	public static String toJson(AbstractUAVMessage<?> message) {
		return GSON.toJson(message);
	}

}
"
AssignFlightMessage.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal.message;

import edu.nd.dronology.core.flight.IFlightDirector;

public class AssignFlightMessage extends AbstractMessage {
    public final IFlightDirector flightDirective;

    public AssignFlightMessage(IFlightDirector flightDirective) {
        this.flightDirective = flightDirective;
    }
}
"
FakePassivPythonGroundstation.java,"package edu.nd.dronology.misc.gcs;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.text.DateFormat;
import java.util.Random;

import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import edu.nd.dronology.core.vehicle.commands.ConnectionResponseCommand;
import edu.nd.dronology.gstation.connector.messages.ConnectionRequestMessage;
import edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class FakePassivPythonGroundstation {

	//private static Socket socket;
	private static final ILogger LOGGER = LoggerProvider.getLogger(FakePassivPythonGroundstation.class);
	
	final static Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()
			.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)
			.setVersion(1.0).serializeSpecialFloatingPointValues().create();

	public static void main(String[] args) {
		try {
			int port = 1234;
			// ServerSocket serverSocket = new ServerSocket(port);
			// Server is running always. This is done using this while(true) loop

			// socket = serverSocket.accept();
			String hostAddr = ""localhost"";

			LOGGER.info(""Connecting to Python base "" + hostAddr + ""@"" + port);
			Socket pythonSocket = new Socket();
			pythonSocket.connect(new InetSocketAddress(hostAddr, port), 5000);

			System.out.println(""Client has connected!"");
			InputStream is = pythonSocket.getInputStream();
			InputStreamReader isr = new InputStreamReader(is);
			BufferedReader br = new BufferedReader(isr);

			//UAVHandshakeMessage handshake = new UAVHandshakeMessage(""Drone1"", ""Drone1"");
			ConnectionRequestMessage connect = new ConnectionRequestMessage(""FAKE_GROUND_1"");
			
		
			String handshakeString = GSON.toJson(connect);
			Thread.sleep(10000);
			OutputStream os = pythonSocket.getOutputStream();
			OutputStreamWriter osw = new OutputStreamWriter(os);
			BufferedWriter bw = new BufferedWriter(osw);
			bw.write(handshakeString);
			bw.write(""\n"");
			System.out.println(""Message sent to the client is "" + handshakeString);
			bw.flush();
			
			

			String ackMesasge = br.readLine();
			ConnectionResponseCommand response = GSON.fromJson(ackMesasge, ConnectionResponseCommand.class);
			System.out.println(""RESPONSE:"" + response.toJsonString());
			Thread.sleep(3000);
			
			Thread.sleep(10000);

			int i=2;
			while (i>1) {

				UAVMonitoringMessage mm = new UAVMonitoringMessage(""Drone1"",  ""FAKE"",""Drone1"");
				Random rand = new Random();
				mm.setType(UAVMonitoringMessage.MESSAGE_TYPE);
				// mm.setuavid(""DRONE1"");
				mm.addPropery(""NR_SATELITES"", ""5"");
				mm.addPropery(""GPS_BIAS"", ""3.125"");
				mm.addPropery(""CURRENT_SPEED"", ""5.25"");
				mm.addPropery(""BLEVEL_VOLTAGE"", ""3"");
				mm.addPropery(""BATTERY_MAXPOWERX"", ""50"");
				mm.addPropery(""BATTERY_VOLTAGE"", rand.nextInt(10));
				mm.addPropery(""BATTERY_POWER"", rand.nextInt(10));
				mm.addPropery(""BLEVEL_POWER"", rand.nextInt(10));

				// if flying mission mlevel > 20%
				// if retunr home blvel > 10;

				String toSend = GSON.toJson(mm);

				// Reading the message from the client

				// String number = br.readLine();
				// System.out.println(""Message received from client is "" + number);

				// Multiplying the number by 2 and forming the return message
				// String returnMessage;
				// try {
				// int numberInIntFormat = Integer.parseInt(number);
				// int returnValue = numberInIntFormat * 2;
				// returnMessage = String.valueOf(returnValue) + ""\n"";
				// } catch (NumberFormatException e) {
				// // Input was not a number. Sending proper message back to client.
				// returnMessage = ""Please send a proper number\n"";
				// }

				// Sending the response back to the client.
				// OutputStream os = socket.getOutputStream();
				// OutputStreamWriter osw = new OutputStreamWriter(os);
				// BufferedWriter bw = new BufferedWriter(osw);
				bw.write(toSend);
				bw.write(""\n"");
				System.out.println(""Message sent to the client is "" + toSend);
				bw.flush();

				Thread.sleep(5000);

			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

}"
SetTargetAltitudeMessage.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal.message;

public class SetTargetAltitudeMessage extends AbstractMessage {
    public final double altitude;

    public SetTargetAltitudeMessage(double altitude) {
        this.altitude = altitude;
    }
}
"
StopLayer.java,"package edu.nd.dronology.core.collisionavoidance.strategy.onionbackend;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;
import edu.nd.dronology.core.collisionavoidance.strategy.StopEveryone;

public class StopLayer implements ILayer {
    private final double triggerDistance;

    public StopLayer(double triggerDistance) {
        this.triggerDistance = triggerDistance;
    }

	@Override
	public void applyAction(DroneSnapshot snapshot) {
		StopEveryone.stopDroneIfNotStopped(snapshot);
	}

	@Override
	public boolean isTriggered(double distance) {
		return distance < this.triggerDistance;
	}

	@Override
	public double getTriggerDistance() {
		return triggerDistance;
	}
}"
BaseServiceProvider.java,"package edu.nd.dronology.monitoring.simplechecker;

import java.net.MalformedURLException;
import java.rmi.Naming;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;

import edu.nd.dronology.services.core.api.IBaseServiceProvider;
import edu.nd.dronology.services.core.remote.IRemoteManager;
import edu.nd.dronology.services.core.util.DronologyServiceException;

/**
 * Configurable utility class providing remote services via RMI.
 * 
 * @author Michael Vierhauser
 * 
 */
public class BaseServiceProvider implements IBaseServiceProvider {

	private static String ADDRESS_SCHEME = ""rmi://%s:%s/Remote"";

	private static IBaseServiceProvider INSTANCE = new BaseServiceProvider();

	private static final String DEFAULT_ADDRESS = ""localhost"";
	private static final int DEFAULT_PORT = 9779;

	private String ip;
	private int port;

	/**
	 * 
	 * @param ip
	 *            The ip address of the server
	 * @param port
	 *            The port of the remote service.
	 */
	public BaseServiceProvider(String ip, int port) {
		this.ip = ip;
		this.port = port;
	}

	/**
	 * Default constructor using standard port and localhost.
	 */
	public BaseServiceProvider() {
		this(DEFAULT_ADDRESS, DEFAULT_PORT);
	}

	/**
	 * @return The remote manager instance via RMI
	 * @throws DistributionException
	 *             if the service can not be retrieved.
	 */
	@Override
	public IRemoteManager getRemoteManager() throws DronologyServiceException {
		try {
			IRemoteManager manager = (IRemoteManager) Naming.lookup(String.format(ADDRESS_SCHEME, ip, port));
			return manager;
		} catch (MalformedURLException e) {
			throw new DronologyServiceException(e);
		} catch (RemoteException e) {
			throw new DronologyServiceException(e);
		} catch (NotBoundException e) {
			throw new DronologyServiceException(e);
		}

	}

	@Override
	public void init(String ip, int port) {
		this.ip = ip;
		this.port = port;

	}

	public static IBaseServiceProvider getInstance() {
		return INSTANCE;
	}

}
"
SimulatorScenarioPersistenceProvider.java,"package edu.nd.dronology.services.core.persistence;

import edu.nd.dronology.services.core.items.ISimulatorScenario;
import edu.nd.dronology.services.core.persistence.internal.SimulatorScenarioXStreamPersistor;

/**
 * Provider implementation for {@link ISimulatorScenario}.<br>
 * Details see {@link AbstractItemPersistenceProvider}
 * 
 * @author Michael Vierhauser
 * 
 */
public class SimulatorScenarioPersistenceProvider extends AbstractItemPersistenceProvider<ISimulatorScenario> {

	public SimulatorScenarioPersistenceProvider() {
		super();
	}

	@Override
	protected void initPersistor() {
		PERSISTOR = new SimulatorScenarioXStreamPersistor();

	}

	@Override
	protected void initPersistor(String type) {
		initPersistor();
	}

	public static SimulatorScenarioPersistenceProvider getInstance() {
		return new SimulatorScenarioPersistenceProvider();
	}

}
"
DroneSnapshot.java,"package edu.nd.dronology.core.collisionavoidance;

import edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.goal.AbstractGoal;
import edu.nd.dronology.core.goal.IGoalSnapshot;
import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;

import java.util.ArrayList;
import java.util.Set;

public interface DroneSnapshot {
    LlaCoordinate getPosition();
    ArrayList<Command> getCommands();
    String getName();
    Vector3D getVelocity();
    Vector3D getAttitude();
    String getState();
    Set<IGoalSnapshot> getGoals();
}
"
AFEmergencyComponent.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Label;
import com.vaadin.ui.NativeButton;
import com.vaadin.ui.VerticalLayout;

/**
 * This is the set of emergency buttons in the AFInfoPanel
 * 
 * @author Patrick Falvey 
 *
 */
public class AFEmergencyComponent extends CustomComponent{
	private static final long serialVersionUID = -650745296345774988L;
	private HorizontalLayout buttons = new HorizontalLayout();
	private NativeButton hover = new NativeButton(""All UAVs<br>Hover in Place"");
  private NativeButton home = new NativeButton(""All UAVs<br>Return to Home"");
  
	public AFEmergencyComponent(){
		VerticalLayout layout = new VerticalLayout();
		layout.addStyleName(""af_operations_group"");
    
		Label caption = new Label(""Emergency Operations"");
    
    hover.setCaptionAsHtml(true);
    hover.addStyleName(""btn-warning"");
    home.setCaptionAsHtml(true);
    home.addStyleName(""btn-warning"");
    
    buttons.addComponents(hover, home);
    layout.addComponents(caption, buttons);
    
    setCompositionRoot(layout);
	}
	
	public NativeButton getHome(){
		return home;
	}
	
	public NativeButton getHover(){
		return hover;
	}
	
}
"
UAVTypeRegistrationInfo.java,"package edu.nd.dronology.services.core.info;

public class UAVTypeRegistrationInfo extends RemoteInfoObject {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2844123024068335148L;
	private String type = ""Default"";

	public UAVTypeRegistrationInfo(String name, String id) {
		super(name, id);
	}

	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;

	}

}
"
PassThrough.java,"package edu.nd.dronology.core.collisionavoidance.strategy;

import java.util.ArrayList;

import edu.nd.dronology.core.collisionavoidance.CollisionAvoider;
import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;
import edu.nd.dronology.core.goal.WaypointGoalSnapshot;

public class PassThrough implements CollisionAvoider {

	@Override
	public void avoid(ArrayList<DroneSnapshot> drones) {
        ArrayList<DroneSnapshot> flyingDrones = StopEveryone.findFlyingDrones(drones);
        for (DroneSnapshot drone : flyingDrones) {
            WaypointGoalSnapshot waypointGoal = StopEveryone.findActiveWaypointGoal(drone.getGoals());
            if (waypointGoal != null) {
                StopEveryone.flyToGoalIfNotAlready(drone, waypointGoal);
            }
        }
    }
    
}"
IAction.java,"package edu.nd.dronology.core.collisionavoidance.strategy.onionbackend;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;

public interface IAction {
    public void applyAction(DroneSnapshot snapshot);
}"
RemoteInfo.java,"package edu.nd.dronology.services.core.remote;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

import javax.xml.bind.annotation.XmlRootElement;

import edu.nd.dronology.services.core.base.AbstractRegisterableUnit;

/**
 * 
 * Transmittable object for a Remote Clients containing information on the Subscriber.
 * 
 * @author Michael Vierhauser
 * 
 */
@XmlRootElement
public class RemoteInfo extends AbstractRegisterableUnit {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1876222975522920266L;

	/** Flag for subscribing to all sources. */
	public static final String ALL = ""all"";

	private Set<String> subscribeIDs = new HashSet<>();

	protected RemoteInfo(String ID, String hostname) {
		super(ID, hostname);
	}

	/**
	 * @return A list of subscribed sources.
	 */
	public Set<String> getSubscribeIDs() {
		return Collections.unmodifiableSet(subscribeIDs);
	}


	/**
	 * 
	 * @param id The source to be added.
	 */
	public void addSourceID(String id) {
		subscribeIDs.add(id);

	}



	@Override
	public String toString() {
		return ""REMOTE CLIENT  [id: "" + ID /* + "" | callbackURL: "" + callbackURL + "" subscribeIDs: "" + getRegisteredIds() */
				+ ""]"";
	}

	@Override
	public String getUnitType() {
		return ""Subscriber"";
	}
}
"
SyncTask.java,"package edu.nd.dronology.services.extensions.missionplanning.tasks;

public class SyncTask extends AbstractMissionTask {

	protected SyncTask(String uavID, String taskName) {
		super(uavID, taskName);
	}
}"
UAVTypeRegistrationService.java,"package edu.nd.dronology.services.instances.registration.types;

import edu.nd.dronology.services.core.base.AbstractFileTransmitServerService;
import edu.nd.dronology.services.core.info.UAVTypeRegistrationInfo;

public class UAVTypeRegistrationService
		extends AbstractFileTransmitServerService<IUAVTypeRegistrationServiceInstance, UAVTypeRegistrationInfo> {

	private static volatile UAVTypeRegistrationService INSTANCE;

	protected UAVTypeRegistrationService() {
		super();
	}

	/**
	 * @return The singleton ConfigurationService instance
	 */
	public static UAVTypeRegistrationService getInstance() {
		if (INSTANCE == null) {
			synchronized (UAVTypeRegistrationService.class) {
				if (INSTANCE == null) {
					INSTANCE = new UAVTypeRegistrationService();
				}
			}
		}
		return INSTANCE;

	}

	@Override
	protected IUAVTypeRegistrationServiceInstance initServiceInstance() {
		return new UAVTypeRegistrationServiceInstance();
	}



}
"
SetVelocityCommand.java,"package edu.nd.dronology.core.vehicle.commands;

public class SetVelocityCommand extends AbstractDroneCommand implements IDroneCommand {

	/**
	 * 
	 * Command sent to the GCS for setting a velocity vector to the UAV.<br>
	 * The vector is specified in NED (north,east,down).
	 * 
	 * 
	 * @author Michael Vierhauser
	 */
	private static final long serialVersionUID = 2864106869131015180L;

	public SetVelocityCommand(String uavid, double x, double y, double z) {
		super(uavid, CommandIds.SET_VELOCITY_COMMAND);
		data.put(ATTRIBUTE_X, x);
		data.put(ATTRIBUTE_Y, y);
		data.put(ATTRIBUTE_Z, z);
	}

}
"
OpenUniversityDemoScript.java,"package edu.nd.dronology.misc.scripts;

import java.net.MalformedURLException;
import java.rmi.Naming;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.services.core.info.DroneInitializationInfo;
import edu.nd.dronology.services.core.info.DroneInitializationInfo.DroneMode;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;
import edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;
import edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;
import edu.nd.dronology.services.core.remote.IRemoteManager;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public class OpenUniversityDemoScript {

	private static final String ADDRESS_SCHEME = ""rmi://%s:%s/Remote"";

	public static void main(String[] args) {
		try {
			// Flying Field
			LlaCoordinate cord1 = new LlaCoordinate(52.024928, -0.705930, 0);
			LlaCoordinate cord2 = new LlaCoordinate(52.026177, -0.713478,0);
			LlaCoordinate cord3 = new LlaCoordinate(52.023837, -0.714029, 0);

			IRemoteManager manager = (IRemoteManager) Naming.lookup(String.format(ADDRESS_SCHEME, ""localhost"", 9779));

			IDroneSetupRemoteService service = (IDroneSetupRemoteService) manager.getService(IDroneSetupRemoteService.class);

			IFlightManagerRemoteService managerService = (IFlightManagerRemoteService) manager
					.getService(IFlightManagerRemoteService.class);

			IFlightRouteplanningRemoteService planningService = (IFlightRouteplanningRemoteService) manager
					.getService(IFlightRouteplanningRemoteService.class);
			//

			DroneInitializationInfo inff = new DroneInitializationInfo(""Bashars-UAV"", DroneMode.MODE_VIRTUAL,
					""IRIS+"", cord1);
			service.initializeDrones(inff);

			DroneInitializationInfo inff2 = new DroneInitializationInfo(""Yijuns-UAV"", DroneMode.MODE_VIRTUAL,
					""IRIS+"", cord2);
			service.initializeDrones(inff2);

			DroneInitializationInfo inff3 = new DroneInitializationInfo(""Royal-UAV"", DroneMode.MODE_VIRTUAL,
					""IRIS+"", cord3);
			service.initializeDrones(inff3);

			List<FlightRouteInfo> allRoutes = new ArrayList<>(planningService.getItems());
//			int NUM_DRONES = 0;
//			for (int i = 0; i < NUM_DRONES; i++) {
//				double coordofset = (double) i / 10000;
//				LlaCoordinate coord = new LlaCoordinate((41.519400 + coordofset), -86.239927, 0);
//				DroneInitializationInfo dr = new DroneInitializationInfo(""Sim-Drone"" + i, DroneMode.MODE_VIRTUAL, ""IRIS+"",
//						coord);
//
//				service.initializeDrones(dr);
//			}

			// for (DroneStatus dr : service.getDrones().values()) {
			// FlightRouteInfo inf = getRandomRoute(allRoutes);
			//
			// managerService.planFlight(dr.getID(), ""randplan"", inf.getWaypoints());
			//
			// }

			// for (DroneStatus dr : service.getDrones().values()) {
			// FlightRouteInfo inf = allRoutes.remove(0);
			//
			// managerService.planFlight(dr.getID(), ""randplan"", inf.getWaypoints());
			//
			// }

		} catch (RemoteException | DronologyServiceException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NotBoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	static Random rand = new Random();

	private static FlightRouteInfo getRandomRoute(List<FlightRouteInfo> allRoutes) {
		int routeSize = allRoutes.size();

		int randomNumber = rand.nextInt(routeSize);

		return allRoutes.get(randomNumber);

	}

}
"
RemindsConnector.java,"package edu.nd.dronology.monitoring.reminds;

import java.text.DateFormat;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import at.jku.mevss.eventdistributor.core.transmit.TransmittableEventObject;
import at.jku.mevss.eventdistributor.core.transmit.TransmittableObjectFactory;
import at.jku.mevss.eventpublisher.core.internal.Publisher;
import at.jku.mevss.util.utils.PreciseTimestamp;
import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage;
import edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;
import edu.nd.dronology.gstation.connector.messages.UAVStateMessage;

public class RemindsConnector {
	static Gson gson = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()
			.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).setVersion(1.0)
			.serializeSpecialFloatingPointValues().create();
	private static Map<String, MockupProbe> stateProbes = new ConcurrentHashMap();
	private static Map<String, MockupProbe> dronologyProbes = new ConcurrentHashMap<>();
	private static Map<String, MockupProbe> monitoringProbes = new ConcurrentHashMap<>();
	static {
		try {
			Publisher.setMode(Publisher.Mode.M_SOCKET);
		} catch (Throwable e) {
			e.printStackTrace();
		}
	}

	public static synchronized void notify(UAVStateMessage message) {
		MockupProbe probePoint = getStateProbe(message.getUavid());
		// p.publish();
		TransmittableEventObject event = transform(message);
		try {
			probePoint.sendData(event);
		} catch (Throwable t) {
			t.printStackTrace();
		}
	}

	public static synchronized void notify(UAVMonitoringMessage message) {
		MockupProbe probePoint = getMonitoringProbes(message.getUavid());
		// p.publish();
		TransmittableEventObject event = transform(message);
		try {
			probePoint.sendData(event);
		} catch (Throwable t) {
			t.printStackTrace();
		}
	}

	// public static void notify(UAVStateChangeMessage message) {
	//
	// MockupProbe probePoint = getDronologyProbes(message.getType().name(),
	// message.getUavid());
	// // p.publish();
	// TransmittableEventObject event = transform(message);
	// try {
	// probePoint.sendData(event);
	// } catch (Throwable t) {
	// t.printStackTrace();
	// }
	// }
	public static void notify(UAVMonitorableMessage message) {
		MockupProbe probePoint = getProbe(message);
		// p.publish();
		TransmittableEventObject event = transform(message);
		try {
			probePoint.sendData(event);
		} catch (Throwable t) {
			t.printStackTrace();
		}
	}

	private static MockupProbe getProbe(UAVMonitorableMessage message) {
		String uavid = message.getUavid();
		String msgType = message.getData() != null ? message.getDataType() : message.getType().name();
		if (msgType.equals(""GoToCommand"") || msgType.equals(""TakeoffCommand"") || msgType.equals(""SetGroundSpeedCommand"")
				|| msgType.equals(""SetModeCommand"")) {
			msgType = ""flightcontrol"";
		} else if (message.getDataType().equals(""STATE_CHANGE"")
				|| message.getType().toString().equals(""STATE_CHANGE"")) {
			msgType = ""uavcontrol"";
		}

		else if (msgType.equals(""planchange"") || message.getType().toString().equals(""WAYPOINT_REACHED"")
				|| msgType.equals(""FlightPlan"")|| msgType.equals(""SimpleTakeoffFlightPlan"")) {
			msgType = ""routeplanning"";
		} else if (message.getType().toString().equals(""PHYSICAL_UAV_ACTIVATED"") || message.getDataType().equals(""FlightMode"")) {
			msgType = ""uavcontrol"";
		} else {
			System.out.println("">>>>>>>>>"" + message.toString() + ""::::"" + message.getData());
		}
		String id = ""dronology."" + msgType + ""."" + uavid;
		if (dronologyProbes.containsKey(id)) {
			return dronologyProbes.get(id);
		}
		String scope = (""dronology."" + msgType);
		// String probename = id + ""-dronologymessage"";
		MockupProbe pp = new MockupProbe(id, ""DRONOLOGY_INTERNAL"", scope);
		dronologyProbes.put(id, pp);
		return pp;
	}

	// public static void notify(UAVPlanChangeMessage message) {
	//
	// MockupProbe probePoint = getProbe(message.getType().name(),
	// message.getUavid());
	// // p.publish();
	// TransmittableEventObject event = transform(message);
	// try {
	// probePoint.sendData(event);
	// } catch (Throwable t) {
	// t.printStackTrace();
	// }
	// }
	private static synchronized MockupProbe getStateProbe(String uavid) {
		if (stateProbes.containsKey(uavid)) {
			return stateProbes.get(uavid);
		}
		String scope = (""dronology.gcs1.uav@"" + uavid);
		String probename = uavid + ""-statemessages"";
		MockupProbe pp = new MockupProbe(probename, ""CS"", scope);
		stateProbes.put(uavid, pp);
		return pp;
	}

	// private static synchronized MockupProbe getDronologyProbes(String
	// messageType, String uavid) {
	// String id = ""dronology."" + messageType + ""."" + uavid;
	// if (dronologyProbes.containsKey(id)) {
	// return dronologyProbes.get(id);
	// }
	// String scope = (""dronology."" + messageType);
	// // String probename = id + ""-dronologymessage"";
	// MockupProbe pp = new MockupProbe(id, ""DRONOLOGY_INTERNAL"", scope);
	// dronologyProbes.put(id, pp);
	// return pp;
	// }
	private static synchronized MockupProbe getMonitoringProbes(String uavid) {
		if (monitoringProbes.containsKey(uavid)) {
			return monitoringProbes.get(uavid);
		}
		String scope = (""dronology.gcs1.uav@"" + uavid);
		String probename = uavid + ""-monitoringmessage"";
		MockupProbe pp = new MockupProbe(probename, ""CS"", scope);
		monitoringProbes.put(uavid, pp);
		return pp;
	}

	private static TransmittableEventObject transform(UAVStateMessage message) {
		TransmittableEventObject event = TransmittableObjectFactory.createEventObject(PreciseTimestamp.create(),
				""UAVStateMessage"");
		event.addData(TransmittableObjectFactory.createEventData(gson.toJson(message), ""state""));
		return event;
	}

	private static TransmittableEventObject transform(UAVMonitoringMessage message) {
		TransmittableEventObject event = TransmittableObjectFactory.createEventObject(PreciseTimestamp.create(),
				""UAVMonitoringMessage"");
		event.addData(TransmittableObjectFactory.createEventData(gson.toJson(message), ""monitoring""));
		return event;
	}

	// private static TransmittableEventObject transform(UAVStateChangeMessage
	// message) {
	// TransmittableEventObject event =
	// TransmittableObjectFactory.createEventObject(PreciseTimestamp.create(),
	// ""UAVStateChangeMessage"");
	// event.addData(TransmittableObjectFactory.createEventData(gson.toJson(message),
	// ""statechange""));
	// return event;
	// }
	//
	// private static TransmittableEventObject transform(UAVPlanChangeMessage
	// message) {
	// TransmittableEventObject event =
	// TransmittableObjectFactory.createEventObject(PreciseTimestamp.create(),
	// ""UAVPlanChangeMessage"");
	// event.addData(TransmittableObjectFactory.createEventData(gson.toJson(message),
	// ""planchange""));
	// return event;
	// }
	public static TransmittableEventObject transform(UAVMonitorableMessage message) {
		String msgType = message.getData() != null ? message.getDataType() : message.getType().name();
		if(message.getType().toString().equals(""WAYPOINT_REACHED"")) {
			msgType = ""WaypointReached"";
		}
		if(message.getType().toString().equals(""PLAN_ACTIVATED"")) {
			msgType = ""FlightPlanActivated"";
		}
		if(message.getType().toString().equals(""PLAN_COMPLETE"")) {
			msgType = ""FlightPlanComplete"";
		}
		if(message.getType().toString().equals(""PHYSICAL_UAV_ACTIVATED"")) {
			msgType = ""UAVActivation"";
		}
		if(message.getType().toString().equals(""STATE_CHANGE"")) {
			msgType = ""StateChange"";
		}
		
		
		if(msgType.equals(""FlightPlan"")) {
			System.out.println(""xx"");
		}
		TransmittableEventObject event = TransmittableObjectFactory.createEventObject(PreciseTimestamp.create(),
				msgType);
		if (message.getData() != null) {
			event.addData(TransmittableObjectFactory.createEventData(message.getData(), ""data""));
		}
		return event;
	}
}"
FlightRouteplanningService.java,"package edu.nd.dronology.services.instances.flightroute;

import java.util.Collection;

import edu.nd.dronology.services.core.base.AbstractFileTransmitServerService;
import edu.nd.dronology.services.core.info.FlightRouteCategoryInfo;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

/**
 * 
 * Service for handling flight routes.<br>
 * Allows creating new routes, retrieving existing routus, and transmitting modified routes.
 * 
 * 
 * @author Michael Vierhauser  
 *
 */
public class FlightRouteplanningService
		extends AbstractFileTransmitServerService<IFlightRouteplanningServiceInstance, FlightRouteInfo> {

	private static volatile FlightRouteplanningService INSTANCE;

	protected FlightRouteplanningService() {
		super();
	}

	/**
	 * @return The singleton ConfigurationService instance
	 */
	public static FlightRouteplanningService getInstance() {
		if (INSTANCE == null) {
			synchronized (FlightRouteplanningService.class) {
				if (INSTANCE == null) {
					INSTANCE = new FlightRouteplanningService();
				}
			}
		}
		return INSTANCE;
	}

	@Override
	protected IFlightRouteplanningServiceInstance initServiceInstance() {
		return new FlightRouteplanningServiceInstance();
	}

	public Collection<FlightRouteCategoryInfo> getFlightPathCategories() {
		return serviceInstance.getFlightPathCategories();
	}

	public FlightRouteInfo getItem(String name) throws DronologyServiceException {
		return serviceInstance.getItem(name);
	}

	public FlightRouteInfo getRouteByName(String routeName) throws DronologyServiceException {
		return serviceInstance.getRouteByName(routeName);
	}

}
"
UAVProxyManager.java,"package edu.nd.dronology.core.vehicle.proxy;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.util.Immutables;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * Singleton class that keeps track of all {@link UAVProxy} instances that have
 * been created.
 */
public class UAVProxyManager {

	private static final ILogger LOGGER = LoggerProvider.getLogger(UAVProxyManager.class);

	private Map<String, IUAVProxy> drones;
	private static volatile UAVProxyManager INSTANCE = null;

	protected UAVProxyManager() {
		drones = new HashMap<>();
	}

	public static UAVProxyManager getInstance() {
		if (INSTANCE == null) {
			synchronized (UAVProxyManager.class) {
				if (INSTANCE == null) {
					INSTANCE = new UAVProxyManager();
				}
			}
		}
		return INSTANCE;
	}

	public void testStatus() {
		LOGGER.info(""Print current drone dump"");
		for (IUAVProxy droneStatus : drones.values()) {
			LOGGER.info(droneStatus.toString());
		}
	}

	// @Deprecated
	// public Map<String, IUAVProxy> getDrones() {
	// return Collections.unmodifiableMap(drones);
	// }

	public Collection<IUAVProxy> getActiveUAVs() {
		return Immutables.linkedListCopy(drones.values());
	}

	public void addDrone(IUAVProxy drone) {
		drones.put(drone.getID(), drone);
	}

	public void removeDrone(String droneID) {
		if (drones.containsKey(droneID)) {
			drones.remove(droneID);
		} else {
			LOGGER.error(""UAV with '"" + droneID + ""' not found"");
		}
	}

	public void removeDrone(UAVProxy drone) {
		if (drones.containsKey(drone.getID())) {
			drones.remove(drone.getID());
		} else {
			LOGGER.error(""UAV with '"" + drone.getID() + ""' not found"");
		}
	}

	public IUAVProxy getActiveUAV(String droneID) {
		if (drones.containsKey(droneID)) {
			return drones.get(droneID);
		}
		return null;
	}
}
"
AMMainLayout.java,"package edu.nd.dronology.ui.vaadin.areamapping;

import java.rmi.RemoteException;
import java.util.Collection;
import java.util.LinkedList;

import com.vaadin.ui.CssLayout;
import com.vaadin.ui.CustomComponent;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.areamapping.EdgeLla;
import edu.nd.dronology.services.core.areamapping.GeneratedMappedArea;
import edu.nd.dronology.services.core.info.AreaMappingInfo;
import edu.nd.dronology.services.core.remote.IAreaMappingRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.ui.vaadin.areamapping.windows.AMDeleteMappingConfirmation;
import edu.nd.dronology.ui.vaadin.areamapping.windows.AMUnsavedChangesConfirmation;
import edu.nd.dronology.ui.vaadin.start.MyUI;
import edu.nd.dronology.ui.vaadin.utils.WaitingWindow;
import edu.nd.dronology.ui.vaadin.utils.WaypointReplace;

/**
 * This is the main layout for the Area Mapping UI.
 * 
 * @author Andrew Slavin
 */

public class AMMainLayout extends CustomComponent {

	private static final long serialVersionUID = -4912347541234441237L;
	private AMControlsComponent controls = new AMControlsComponent(this);
	private AMMapComponent mapComponent;
	private AMDeleteMappingConfirmation deleteMappingConfirmation;
	private AMUnsavedChangesConfirmation unsavedChangesConfirmation;
	private WaitingWindow waitingWindow = new WaitingWindow();
	private Boolean deletingMapping = false;

	@WaypointReplace
	public AMMainLayout() {
		addStyleName(""main_layout"");
		CssLayout content = new CssLayout();
		content.setSizeFull();

		mapComponent = new AMMapComponent(this);

		deleteMappingConfirmation = new AMDeleteMappingConfirmation(this);
		unsavedChangesConfirmation = new AMUnsavedChangesConfirmation(this);

		content.addComponents(controls, mapComponent);
		setCompositionRoot(content);
	}

	public AMDeleteMappingConfirmation getDeleteMappingConfirmation() {
		return deleteMappingConfirmation;
	}

	public AMUnsavedChangesConfirmation getUnsavedChangesConfirmation() {
		return unsavedChangesConfirmation;
	}

	public WaitingWindow getWaitingWindow() {
		return waitingWindow;
	}

	// Displays the mapping that is clicked
	public void switchMapping(AMInfoBox switchToInfoBox) {
		// When one mapping is clicked, the others go back to default background color.
		controls.getInfoPanel().unhighlightAllInfoBoxes();
		controls.getInfoPanel()
				.highlightInfoBox(controls.getInfoPanel().getMappingIndex(switchToInfoBox.getAreaMappingInfo()));

		// Displays the mapping on map.
		mapComponent.displayAreaMapping(switchToInfoBox.getAreaMappingInfo());
	}

	// runs the algorithm when ""generate route"" is clicked in metainfo
	public void generateRouteFromMapping(Collection<IUAVProxy> dronesToSend) {
		// send stuff to Dronology
		try {
			IAreaMappingRemoteService service = (IAreaMappingRemoteService) MyUI.getProvider().getRemoteManager()
					.getService(IAreaMappingRemoteService.class);

			AreaMappingInfo info = mapComponent.getMetaInfo().getMappingInfo();
			
			// if upstream is opposite the way that it was drawn, flip the points around
			if (!mapComponent.getMapUtilities().getUpstream()) {
				LinkedList<EdgeLla> originalList1 = info.getCoordinates(0);
				LinkedList<EdgeLla> swappedList1 = new LinkedList<>();
				for (int i = originalList1.size()-1; i >= 0; i--) {
					swappedList1.add(originalList1.get(i));
					info.removeCoordinate(0, originalList1.get(i));
				}
				for (int i = 0; i < swappedList1.size(); i++) {
					info.addCoordinate(0, swappedList1.get(i));
				}
				LinkedList<EdgeLla> originalList2 = info.getCoordinates(1);
				LinkedList<EdgeLla> swappedList2 = new LinkedList<>();
				for (int i = originalList2.size()-1; i >= 0; i--) {
					swappedList2.add(originalList2.get(i));
					info.removeCoordinate(1, originalList2.get(i));
				}
				for (int i = 0; i < swappedList2.size(); i++) {
					info.addCoordinate(1, swappedList2.get(i));
				}
			}
			
			GeneratedMappedArea generated = service.generateAreaMapping(info, dronesToSend);
			service.executeAreaMapping(generated);

		} catch (RemoteException | DronologyServiceException e) {
			e.printStackTrace();
		}
	}

	// Gets the controls component that holds the infoPanel and mainLayout.
	public AMControlsComponent getControls() {
		return controls;
	}

	// Gets the currently displayed map.
	public AMMapComponent getMapComponent() {
		return mapComponent;
	}

	// sets the map component
	public void setMapComponent(AMMapComponent mapComponent) {
		this.mapComponent = mapComponent;
	}

	public Boolean getDeletingMapping() {
		return deletingMapping;
	}

	public void setDeletingMapping(Boolean deletingMapping) {
		this.deletingMapping = deletingMapping;
	}
}"
ExportAllocationInformation.java,"package edu.nd.dronology.services.core.areamapping;

import java.util.ArrayList;
import java.util.List;

public class ExportAllocationInformation {
	private List<ExportDrone> droneAllocations;
	private MetricsStatistics metricsStatistics;
	
	public ExportAllocationInformation() {
		droneAllocations = new ArrayList<>();
	}
	
	public List<ExportDrone> getDroneAllocations(){
		return droneAllocations;
	}
	
	public MetricsStatistics getMetricStatistics() {
		return metricsStatistics;
	}
	
	public void addDroneAllocation(ExportDrone droneAllocation) {
		droneAllocations.add(droneAllocation);
	}
	
	public void setDroneAllocations(List<ExportDrone> droneAllocations) {
		this.droneAllocations = droneAllocations;
	}
	
	public void setMetricsStatistics(MetricsStatistics metricsStatistics) {
		this.metricsStatistics = metricsStatistics;
	}
}
"
GeneratedMappedArea.java,"package edu.nd.dronology.services.core.areamapping;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class GeneratedMappedArea implements Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 5991442648634740620L;

	List<ExportDrone> uavList = new ArrayList<>();

	public void addUAVRouteAssignment(ExportDrone ed) {
		uavList.add(ed);

	}

	public List<ExportDrone> getUAVAssignments() {
		return Collections.unmodifiableList(uavList);
	}

}
"
WorkspaceInitializer.java,"package edu.nd.dronology.services.supervisor;

import java.io.File;
import java.security.CodeSource;

import edu.nd.dronology.services.core.util.DronologyConstants;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.util.FileUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class WorkspaceInitializer {

	private static final ILogger LOGGER = LoggerProvider.getLogger(WorkspaceInitializer.class);
	private String root;
	private static WorkspaceInitializer instance = new WorkspaceInitializer();

	private void prepareRoot() throws DronologyServiceException {
		if (root == null) {
			root = getDefaultRootFolder();
		}
		if (root == null) {
			root = DronologyConstants.DEFAULT_ROOT_FOLDER;
		}

		// Replace file path in Windows
		root = root.replace(""file:\\"", """");
		// Replace file path on Linux/MAC
		root = root.replace(""file:/"", ""/"");

		LOGGER.info(""Server workspace root location is: '"" + root + ""'"");

		File f = new File(root);
		LOGGER.info(""Absolute path is: '"" + f.getPath().toString() + ""'"");
		if (!f.exists()) {
			f.mkdirs();
		}
		try {
			root = f.getPath();
		} catch (Exception e) {
			throw new DronologyServiceException(""Error when setting workspace root '"" + root + ""'"");
		}
	}

	private String getDefaultRootFolder() throws DronologyServiceException {
		CodeSource codeSource = WorkspaceInitializer.class.getProtectionDomain().getCodeSource();
		File codeFolder;
		codeFolder = new File(codeSource.getLocation().toExternalForm());
		File parent = codeFolder.getParentFile();
		if (parent == null) {
			return null;
		}
		File ws = parent.getParentFile();
		if (ws == null) {
			return null;
		}

		return ws.getPath() + File.separator + DronologyConstants.DRONOLOGY_ROOT_FOLDER;
	}

	public void prepareServerWorkspace(String workspace) throws DronologyServiceException {
		this.root = formatPath(workspace);
		prepareRoot();
		prepareFlightPathWorkspace();
		prepareSpecificationWorkspace();
		prepareAreaMappingWorkspace();
		prepareMissionPlanningWorkspace();
	}

	private String formatPath(String workspace) {
		if (workspace == null) {
			return null;
		}
		String formated = workspace.replace(""/"", ""\\"");
		return formated;
	}

	private void prepareFlightPathWorkspace() {
		String folderPath = getFlightRouteLocation();
		File f = new File(folderPath);
		if (!f.exists()) {
			f.mkdirs();
		}
	}

	private void prepareSpecificationWorkspace() {
		String folderPath = getDroneSpecificationLocation();
		File f = new File(folderPath);
		if (!f.exists()) {
			f.mkdirs();
		}
	}
	
	private void prepareMissionPlanningWorkspace() {
		String folderPath = getMissionPlanningLocation();
		File f = new File(folderPath);
		if (!f.exists()) {
			f.mkdirs();
		}
	}
	
	private void prepareAreaMappingWorkspace() {
		String folderPath = getAreaMappingLocation();
		File f = new File(folderPath);
		if (!f.exists()) {
			f.mkdirs();
		}
	}

	String getWorkspaceLocation() {
		return root;
	}

	String getFlightRouteLocation() {
		return root + File.separator + DronologyConstants.FOLDER_FLIGHTROUTE;
	}

	public String getSimScenarioLocation() {
		return root + File.separator + DronologyConstants.FOLDERN_SIM_SCENARIO;
	}

	public String getDroneSpecificationLocation() {
		return root + File.separator + DronologyConstants.FOLDER_REGISTRATION;
	}
	
	public String getAreaMappingLocation() {
		return root + File.separator + DronologyConstants.FOLDER_AREAMAPPING;
	}

	public String getMissionPlanningLocation() {
		return root + File.separator + DronologyConstants.FOLDER_MISSIONPLANNING;
	}

	public static WorkspaceInitializer getInstance() {
		return instance;
	}

	public boolean importItem(String fileName, byte[] byteArray, boolean overwrite) throws DronologyServiceException {
		String ext = FileUtil.getExtension(fileName);
		if (ext == null) {
			LOGGER.warn(""File with no extension found '"" + fileName + ""'"");
			return false;
		}
		switch (ext) {
		case DronologyConstants.EXTENSION_FLIGHTROUTE:
			return importFlightPath(fileName, byteArray, overwrite);
		default:
			LOGGER.warn(""File with extension '"" + FileUtil.getExtension(fileName) + ""' not processable"");
			return false;
		}
	}

	private boolean importFlightPath(String fileName, byte[] content, boolean overwrite) {
		String location = getFlightRouteLocation();
		String fName = location + File.separator + fileName;
		return importFile(fName, content, overwrite);

	}

	private boolean importFile(String absolutePath, byte[] content, boolean overwrite) {
		File f = new File(absolutePath);
		if (f.exists() && !overwrite) {
			return false;
		}
		return FileUtil.saveByteArrayToFile(f, content);
	}



}
"
GroundStationException.java,"package edu.nd.dronology.gstation.connector;

public class GroundStationException extends Exception {



	/**
	 * 
	 */
	private static final long serialVersionUID = 4245430380511186933L;
	
	
	public GroundStationException(String text) {
		super(text);
	}

}
"
SoloDirector.java,"package edu.nd.dronology.core.flight.internal;

import java.util.ArrayList;
import java.util.List;

import edu.nd.dronology.util.NullUtil;
import edu.nd.dronology.core.Discuss;
import edu.nd.dronology.core.DronologyConstants;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.exceptions.FlightZoneException;
import edu.nd.dronology.core.flight.IFlightDirector;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.core.vehicle.ManagedDrone;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * Directions for one flight containing multiple waypoints.
 * 
 * @author Jane Cleland-Huang
 * 
 */
public class SoloDirector implements IFlightDirector {

	private static final ILogger LOGGER = LoggerProvider.getLogger(SoloDirector.class);

	private final ManagedDrone drone;
	private boolean safetyDiversion = false;
	private LlaCoordinate targetPosition = null;
	private List<Waypoint> wayPoints = new ArrayList<>();
	private List<LlaCoordinate> roundaboutPath = new ArrayList<>();

	@Override
	public LlaCoordinate flyToNextPoint() {
		targetPosition = flyToNextWayPoint();
		return targetPosition;
	}

	public List<Waypoint> getWayPoints() {
		return new ArrayList<>(this.wayPoints);
	}

	/**
	 * Constructor
	 * 
	 * @param managedDrone
	 */
	public SoloDirector(ManagedDrone managedDrone) {
		this.drone = managedDrone;
	}

	@Override
	public void setWayPoints(List<Waypoint> wayPoints) {
		this.wayPoints = new ArrayList<>(wayPoints);
	}

	@Override
	public void clearWayPoints() {
		wayPoints.clear();
	}

	@Override
	public boolean hasMoreWayPoints() {
		return !wayPoints.isEmpty();
	}

	@Discuss(discuss = ""this is called way to often.. needs fixing"")
	private LlaCoordinate flyToNextWayPoint() {
		// LOGGER.info(""Flying to next waypoint"");
		if (!wayPoints.isEmpty()) {
			Waypoint nextWaypoint = wayPoints.get(0);
			drone.flyTo(nextWaypoint.getCoordinate(), nextWaypoint.getApproachingspeed());
			return nextWaypoint.getCoordinate();
		}
		return null;
	}

	@Override
	public boolean isUnderSafetyDirectives() {
		return safetyDiversion;
	}

	@Override
	public void clearCurrentWayPoint() {
		if (isUnderSafetyDirectives()) {
			if (!roundaboutPath.isEmpty()) {
				roundaboutPath.remove(0);
				if (roundaboutPath.isEmpty()) { 
					safetyDiversion = false;
				}
			}
		} else {
			if (!wayPoints.isEmpty()) {
				Waypoint wp = wayPoints.remove(0);
				wp.reached(true);
			}
			if (wayPoints.isEmpty()) {
				try { 
					drone.getFlightModeState().setModeToInAir(); 
				} catch (FlightZoneException e) {
					LOGGER.error(e);
				}
			}
		}
	}

	@Override
	public void addWayPoint(Waypoint wayPoint) {
		wayPoints.add(wayPoint);
	}

	@Override
	public void flyHome() {
		drone.flyTo(drone.getBaseCoordinates(), DronologyConstants.RETURN_TO_HOME_SPEED);

	}

	@Override
	public void returnHome(Waypoint home) {
		NullUtil.checkNull(home);
		addWayPoint(home);
		ArrayList<Waypoint> tempWayPoints = new ArrayList<>(wayPoints);

		for (Waypoint wayPoint : tempWayPoints) {
			if (!wayPoint.equals(home)) {
				wayPoints.remove(wayPoint);
			}
		}

		// Should only have one waypoint left and ready to go home!!
	}

	@Override
	public boolean readyToLand() {
		return hasMoreWayPoints();

	}

	@Override
	public boolean readyToTakeOff() {
		if (!hasMoreWayPoints()) {
			return false;
		} else {
			return true;
		}
	}

}
"
Drone.java,"package edu.nd.dronology.services.extensions.areamapping.metrics;

import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.collections4.Get;
import org.apache.logging.log4j.core.appender.routing.Route;

import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;

public class Drone {
	private Point2D.Double startPoint;
	private Point2D.Double homeLocation;
	private DroneRouteAssignment routeAssignment;
	private String UAVId;
	
	public Drone() {
		startPoint = new Point2D.Double();
		homeLocation = new Point2D.Double();
		routeAssignment = new DroneRouteAssignment();
	}
	
	public Point2D.Double getDroneStartPoint(){
		return startPoint;
	}
	
	public Point2D.Double getDroneHomeLocation(){
		return homeLocation;
	}
	
	public DroneRouteAssignment getDroneRouteAssignment() {
		return routeAssignment;
	}
	
	public List<Point2D.Double> getDroneFullRoute() {
		List<Point2D.Double> fullRoute = new ArrayList<>();
		for(RoutePrimitive route : routeAssignment.get()) {
			fullRoute.addAll(route.getRoute());
		}
		return fullRoute;
	}
	
	public void setDroneStartPoint(Point2D.Double start) {
		startPoint = start;
	}
	
	public void setDroneHomeLocation(Point2D.Double home) {
		homeLocation = home;
	}
	
	public void setDroneRouteAssignment(DroneRouteAssignment route) {
		routeAssignment = route;
	}

	public String getUAVId() {
		return UAVId;
	}

	public void setUAVId(String UAVId) {
		this.UAVId = UAVId;
	}
}
"
IUAVSafetyValidator.java,"package edu.nd.dronology.gstation.connector;

public interface IUAVSafetyValidator {

	boolean validate(String uavid, String safetyCase);

}
"
DronologyElementFactory.java,"package edu.nd.dronology.services.extensions.areamapping.instances;

import edu.nd.dronology.services.core.items.AreaMapping;
import edu.nd.dronology.services.core.items.IAreaMapping;

public class DronologyElementFactory {

	

	public static IAreaMapping createNewAreaMapping() {
		return new AreaMapping();
	}


}
"
IncommingGroundstationConnectionServer.java,"package edu.nd.dronology.gstation.connector.connect;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;

import edu.nd.dronology.gstation.connector.GroundstationConnector;
import edu.nd.dronology.gstation.connector.service.connector.DroneConnectorService;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * The {@link IncommingGroundstationConnectionServer} listens on a predefined port for new connections from GCS.
 * 
 * 
 * @author Michael Vierhauser
 */
 
public class IncommingGroundstationConnectionServer implements Runnable {
	private int port = 1234;
	private ServerSocket serverSocket;
	private boolean cont = true;
	private static final ILogger LOGGER = LoggerProvider.getLogger(IncommingGroundstationConnectionServer.class);
	private String URL = ""127.0.0.1"";

	public IncommingGroundstationConnectionServer() {

	}

	@Override
	public void run() {

		serverSocket = null;
		try {
			serverSocket = new ServerSocket(port, 3000);
			// server.setReuseAddress(true);

			LOGGER.info(""Incomming-Groundstation Connection Server listening on port: "" + port);
			// server.setSoTimeout(1000);

			while (cont) {
				Socket socket = null;
				try {
					socket = serverSocket.accept();
					GroundstationConnector handler = new GroundstationConnector(this, socket);
					DroneConnectorService.getInstance().handleConnection(handler);

				} catch (SocketException e) {
					LOGGER.info(""Socket was closed!"");
				} catch (IOException e) {
					LOGGER.error(e);

				}
			}
		} catch (Exception e) {
			LOGGER.error(e);
		} finally {
			try {
				if (serverSocket != null) {
					serverSocket.close();
				}
			} catch (IOException e) {
				LOGGER.error(e);
			}
		}

	}


}
"
UAVTypeRegistrationServiceRemoteFacade.java,"package edu.nd.dronology.services.facades;

import java.rmi.RemoteException;
import java.util.Collection;

import org.apache.commons.lang.NotImplementedException;

import edu.nd.dronology.services.core.info.UAVTypeRegistrationInfo;
import edu.nd.dronology.services.core.listener.IItemChangeListener;
import edu.nd.dronology.services.core.remote.IUAVTypeRegistrationRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.instances.registration.types.UAVTypeRegistrationService;
import edu.nd.dronology.services.remote.AbstractRemoteFacade;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class UAVTypeRegistrationServiceRemoteFacade extends AbstractRemoteFacade implements IUAVTypeRegistrationRemoteService {
	/**
	 * 
	 */
	private static final long serialVersionUID = -4580658378477037955L;
	private static final ILogger LOGGER = LoggerProvider.getLogger(UAVTypeRegistrationServiceRemoteFacade.class);
	private static volatile UAVTypeRegistrationServiceRemoteFacade INSTANCE;

	protected UAVTypeRegistrationServiceRemoteFacade() throws RemoteException {
		super(UAVTypeRegistrationService.getInstance());
	}

	public static IUAVTypeRegistrationRemoteService getInstance() throws RemoteException {
		if (INSTANCE == null) {
			try {
				synchronized (UAVTypeRegistrationServiceRemoteFacade.class) {
					if (INSTANCE == null) {
						INSTANCE = new UAVTypeRegistrationServiceRemoteFacade();
					}
				}
			} catch (RemoteException e) {
				LOGGER.error(e);
			}
		}
		return INSTANCE;
	}

	@Override
	public byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException {
		return UAVTypeRegistrationService.getInstance().requestFromServer(id);
	}

	@Override
	public void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException {
		UAVTypeRegistrationService.getInstance().transmitToServer(id, content);

	}

	@Override
	public boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException {
		throw new NotImplementedException();
	}

	@Override
	public boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException {
		throw new NotImplementedException();
	}

	@Override
	public Collection<UAVTypeRegistrationInfo> getItems() throws RemoteException {
		return UAVTypeRegistrationService.getInstance().getItems();
	}

	@Override
	public UAVTypeRegistrationInfo createItem() throws RemoteException, DronologyServiceException {
		return UAVTypeRegistrationService.getInstance().createItem();
	}

	@Override
	public void deleteItem(String itemid) throws RemoteException, DronologyServiceException {
		// TODO Auto-generated method stub
		throw new NotImplementedException();
	}



}"
ISupervisorServiceInstance.java,"package edu.nd.dronology.services.supervisor;

import java.util.Map;

import edu.nd.dronology.services.core.api.IServiceInstance;
import edu.nd.dronology.services.core.util.DronologyServiceException;


/**
 * 
 * 
 * @author Michael Vierhauser
 * 
 */
public interface ISupervisorServiceInstance extends IServiceInstance {

	void shutdownServer();

	void restartAllServices();


	String getWorkspaceLocation();

	Map<String, String> getGlobalProperties();

	boolean importItem(String fileName, byte[] byteArray, boolean overwrite) throws DronologyServiceException;

	

	String getFlightPathLocation();

	String getDroneSpecificationLocation();

	String getSimScenarioLocation();

	String getAreaMappingLocation();

	String getMissionPlanningLocation();



}
"
GeofenceRectangle.java,"package edu.nd.dronology.monitoring.simplechecker.checker;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

public class GeofenceRectangle {

	double lonStart;
	double lonEnd;
	double latStart;
	double latEnd;

	public GeofenceRectangle(double latStart, double latEnd, double lonStart, double lonEnd) {
		this.latStart = latStart;
		this.latEnd = latEnd;
		this.lonStart = lonStart;
		this.lonEnd = lonEnd;
	}

	public GeofenceRectangle(LlaCoordinate topLeft, LlaCoordinate bottomRight) {
		this(topLeft.getLatitude(), bottomRight.getLatitude(), topLeft.getLongitude(), bottomRight.getLongitude());
	}

	public boolean isInside(LlaCoordinate toCheck) {
		double lat = toCheck.getLatitude();
		double lon = toCheck.getLongitude();
		return lat < latStart && lat > latEnd && lon > lonStart && lon < lonEnd;

	}
}
"
RemoteManager.java,"package edu.nd.dronology.services.remote;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import edu.nd.dronology.services.core.api.ServiceInfo;
import edu.nd.dronology.services.core.base.AbstractServerService;
import edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;
import edu.nd.dronology.services.core.remote.IDroneSimulatorRemoteService;
import edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;
import edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;
import edu.nd.dronology.services.core.remote.IRemoteManager;
import edu.nd.dronology.services.core.remote.IRemoteServiceListener;
import edu.nd.dronology.services.core.remote.IRemoteableService;
import edu.nd.dronology.services.core.remote.IUAVEquipmentTypeRegistrationRemoteService;
import edu.nd.dronology.services.core.remote.IUAVRegistrationRemoteService;
import edu.nd.dronology.services.core.remote.IUAVTypeRegistrationRemoteService;
import edu.nd.dronology.services.core.remote.RemoteInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.facades.DroneSetupServiceRemoteFacade;
import edu.nd.dronology.services.facades.DroneSimulatorServiceRemoteFacade;
import edu.nd.dronology.services.facades.FlightManagerServiceRemoteFacade;
import edu.nd.dronology.services.facades.FlightRouteplanningServiceRemoteFacade;
import edu.nd.dronology.services.facades.UAVEquipmentTypeRegistrationServiceRemoteFacade;
import edu.nd.dronology.services.facades.UAVRegistrationServiceRemoteFacade;
import edu.nd.dronology.services.facades.UAVTypeRegistrationServiceRemoteFacade;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class RemoteManager implements IRemoteManager {

	/**
	 * 
	 */
	private static final long serialVersionUID = -2718289978864805774L;

	private static final ILogger LOGGER = LoggerProvider.getLogger(RemoteManager.class);

	private static RemoteManager instance;

	private Map<Class, IRemoteableService> externalServices = new HashMap<>();

	/**
	 * @return The singleton instance of the RemoteManager.
	 */
	public static IRemoteManager getInstance() {
		if (instance == null) {
			instance = new RemoteManager();
		}
		return instance;
	}

	@Override
	public Object getService(Class<?> service) throws RemoteException, DronologyServiceException {
		if (!IRemoteableService.class.isAssignableFrom(service)) {
			throw new DronologyServiceException(
					""Invalid service requested - Valid services extend "" + IRemoteableService.class.getCanonicalName());
		}

		if (service.equals(IFlightRouteplanningRemoteService.class)) {
			return FlightRouteplanningServiceRemoteFacade.getInstance();
		}

		if (service.equals(IFlightManagerRemoteService.class)) {
			return FlightManagerServiceRemoteFacade.getInstance();
		}

		if (service.equals(IDroneSetupRemoteService.class)) {
			return DroneSetupServiceRemoteFacade.getInstance();
		}

		if (service.equals(IUAVRegistrationRemoteService.class)) {
			return UAVRegistrationServiceRemoteFacade.getInstance();
		}

		if (service.equals(IUAVTypeRegistrationRemoteService.class)) {
			return UAVTypeRegistrationServiceRemoteFacade.getInstance();
		}

		if (service.equals(IDroneSimulatorRemoteService.class)) {
			return DroneSimulatorServiceRemoteFacade.getInstance();
		}
		if (service.equals(IUAVEquipmentTypeRegistrationRemoteService.class)) {
			return UAVEquipmentTypeRegistrationServiceRemoteFacade.getInstance();
		}

		if (externalServices.containsKey(service)) {
			return externalServices.get(service);
		}

		throw new DronologyServiceException(""Service"" + service.getCanonicalName() + "" not found!"");

	}

	@Override
	public void addServiceListener(IRemoteServiceListener processListener) throws RemoteException {
		AbstractServerService.addUniversialServiceListener(new RemoteServerProcessListenerAdapter(processListener));

	}

	@Override
	public void removeServiceListener(IRemoteServiceListener processListener) throws RemoteException {
		AbstractServerService.removeUniversialServiceListener(new RemoteServerProcessListenerAdapter(processListener));

	}

	@Override
	public List<ServiceInfo> getServices() throws RemoteException, DronologyServiceException {

		List<ServiceInfo> allServices = new ArrayList<>();

		allServices.addAll(getCoreServices());
		// allServices.addAll(getExtensionServices());

		return Collections.unmodifiableList(allServices);

	}

	@Override
	public List<ServiceInfo> getCoreServices() throws RemoteException, DronologyServiceException {
		return AbstractServerService.getCoreServices();
	}

	@Override
	public List<ServiceInfo> getAllServices() throws RemoteException, DronologyServiceException {
		return AbstractServerService.getServiceInfos();
	}

	@Override
	public List<ServiceInfo> getFileServices() throws RemoteException, DronologyServiceException {
		return AbstractServerService.getFileServiceInfos();
	}

	@Override
	public void contributeService(Class service, IRemoteableService serviceInstance)
			throws RemoteException, DronologyServiceException {
		externalServices.put(service, serviceInstance);
	}

	@Override
	public void register(RemoteInfo rInfo) throws RemoteException {
		RemoteService.getInstance().register(rInfo);

	}

	@Override
	public void unregister(RemoteInfo rInfo) throws RemoteException {
		RemoteService.getInstance().unregister(rInfo);
	}

	@Override
	public void initialize() throws RemoteException, DronologyServiceException {
		// TODO Auto-generated method stub

	}

	@Override
	public void tearDown() throws RemoteException, DronologyServiceException {
		// TODO Auto-generated method stub

	}

}
"
ImageWaypoints.java,"package edu.nd.dronology.services.extensions.areamapping.internal;

import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class ImageWaypoints {
	
	private List<ImageWaypoint> imageWaypoints;
	
	
	public ImageWaypoints() {
		imageWaypoints = new Vector<ImageWaypoint>();
	}
	
	public void add(ImageWaypoint bankNode) {
		imageWaypoints.add(bankNode);
	}
	
	public void reverse() {
		Collections.reverse(imageWaypoints);
	}
	
	public List<ImageWaypoint> get(){
		return Collections.unmodifiableList(imageWaypoints);
	}
	
	public ImageWaypoint get(int entry){
		return imageWaypoints.get(entry);
	}
	
	public void set(int index, ImageWaypoint entry) {
		imageWaypoints.set(index, entry);
	}
	
	public int size() {
		return imageWaypoints.size();
	}


}
"
IServiceInstance.java,"package edu.nd.dronology.services.core.api;

import java.util.Properties;

import edu.nd.dronology.services.core.listener.IServiceListener;
import edu.nd.dronology.services.core.util.DronologyServiceException;

/**
 * Base interface for all server processes.
 * 
 * 
 * @author Michael Vierhauser
 * 
 */
public interface IServiceInstance {

	/**
	 * 
	 * @return The id of the service.
	 */
	public String getServiceID();

	/**
	 * 
	 * @return The human readable description for this service.
	 */
	public String getDescription();

	/**
	 * @return The configuration properties of the service containing infos on host, port...
	 */
	public Properties getConfigurationProperties();

	/**
	 * 
	 * @return The current status of the service.
	 */
	public ServiceStatus getStatus();

	/**
	 * Starts the services.
	 * 
	 * @throws DronologyServiceException
	 */
	void startService() throws DronologyServiceException;

	/**
	 * Stops the service.
	 * 
	 * @throws DronologyServiceException
	 */
	void stopService() throws DronologyServiceException;

	/**
	 * @return The {@link ServiceInfo} object.
	 */
	public ServiceInfo getServiceInfo();

	/**
	 * Adds a new {@link IServiceListener} to the service.<br>
	 * The listener is triggered when the status of the service changes.
	 * 
	 * @param listener
	 *          The listener to be added.
	 * @return True if adding was performed successfully, false otherwise.
	 */
	boolean addServiceListener(IServiceListener listener);

	/**
	 * 
	 * @param listener
	 *          The listener to be removed.
	 * @return True if removing was performed successfully, false otherwise.
	 */
	boolean remoteServiceListener(IServiceListener listener);




}
"
EdgeLla.java,"package edu.nd.dronology.services.core.areamapping;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

/**
 * Implements Coordinate, but also has an edge member, which denotes the side of the mapping that a coordinate belongs to.
 * 
 * @author Andrew Slavin
 *
 */

public class EdgeLla extends LlaCoordinate {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	
	private int side;
	
	
	public EdgeLla(double latitude, double longitude, double side) {
		super(latitude, longitude, 0);
		this.side = (int)side;
	}
	
	public int getSide() {
		return side;
	}
	
	public void setSide(int side) {
		this.side = side;
	}
	

}
"
MetricsRunner.java,"package edu.nd.dronology.services.extensions.areamapping.metrics;

import java.awt.geom.Path2D;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.List;

import com.thoughtworks.xstream.io.path.Path;

import edu.nd.dronology.services.core.areamapping.MetricsStatistics;
import edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;
import edu.nd.dronology.services.extensions.areamapping.util.Utilities;

public class MetricsRunner {
	private List<Drone> drones;
	private List<RoutePrimitive> allRoutes;
	private Path2D.Double totalRiverSegment;
	private List<RiverBank> bankList;
	private double APERATURE_WIDTH;
	private double APERATURE_HEIGHT;
	
	public MetricsRunner(List<RoutePrimitive> routes, Path2D.Double riverSegment, List<RiverBank> listOfBanks, double A_W, double A_H, int uavs) {
		drones = new ArrayList<>();
		for(int i = 0; i < uavs; i++) {
			drones.add(new Drone());
		}
		allRoutes = routes;
		totalRiverSegment = riverSegment;
		bankList = listOfBanks;
		APERATURE_WIDTH = A_W;
		APERATURE_HEIGHT = A_H;
		//droneSetup();
	}
	
	public void droneSetup() {
		int counter = 0;
		for(Drone drone : drones) {
			DroneRouteAssignment routeAssignment = new DroneRouteAssignment();
			routeAssignment.add(allRoutes.get(counter));
			counter += 1;
			drone.setDroneRouteAssignment(routeAssignment);
		}
		drones.get(0).setDroneStartPoint(new Point2D.Double(4639658.290263815, -7163020.664734639));
		drones.get(0).setDroneHomeLocation(new Point2D.Double(4639658.290263815, -7163020.664734639));
		drones.get(1).setDroneStartPoint(new Point2D.Double(4639698.333003777, -7163031.375602997));
		drones.get(1).setDroneHomeLocation(new Point2D.Double(4639698.333003777, -7163031.375602997));
		drones.get(2).setDroneStartPoint(new Point2D.Double(4639719.355442258, -7163044.2452510195));
		drones.get(2).setDroneHomeLocation(new Point2D.Double(4639719.355442258, -7163044.2452510195));
		drones.get(3).setDroneStartPoint(new Point2D.Double(4639658.290263815, -7163020.664734639));
		drones.get(3).setDroneHomeLocation(new Point2D.Double(4639658.290263815, -7163020.664734639));
	}
	
	public void setDroneAssignments(List<Drone> drones) {
		this.drones = drones;
	}
	
	public MetricsStatistics runMetrics() {
		double equalityOfTasks =  MetricsUtilities.equalityOfTasks(drones);

		double allocationCoverage =  MetricsUtilities.calculateRouteCoverage(drones, totalRiverSegment, bankList, APERATURE_WIDTH, APERATURE_HEIGHT);

		double downstreamRatio =  MetricsUtilities.calculateDownstreamRatio(drones);

		boolean batteryFailed = false;
		for(Drone drone : drones) {
			if(MetricsUtilities.batteryFailure(drone)) {
				batteryFailed = true;
				break;
			}
		}

		for(Drone drone : drones) {
			if(MetricsUtilities.routeAssignmentOutsideRiver(drone.getDroneRouteAssignment(), totalRiverSegment, APERATURE_HEIGHT)) {
				System.out.println(""route transition goes outside river segment"");
			}
		}

		int collisions = MetricsUtilities.collisionCheck(drones);

		double totalDistance = MetricsUtilities.totalAllocationDistance(drones);
		
		List<Double> droneDistances = MetricsUtilities.calculateDroneDistances(drones);
		
		double priorityCoverage = MetricsUtilities.calculateAllocationPriorityCoverage(drones);
	
		return new MetricsStatistics(equalityOfTasks, allocationCoverage, downstreamRatio, batteryFailed, collisions, totalDistance, droneDistances, priorityCoverage);
	}
}
"
UpdateGuidanceMessage.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal.message;

import edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;

import java.util.List;

public class UpdateGuidanceMessage extends AbstractMessage {
    public final List<Command> commands;
    public UpdateGuidanceMessage(List<Command> commands) {
        this.commands = commands;
    }
}
"
AbstractRemoteFacade.java,"package edu.nd.dronology.services.remote;

import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

import edu.nd.dronology.services.core.api.ServiceInfo;
import edu.nd.dronology.services.core.base.AbstractServerService;
import edu.nd.dronology.services.core.listener.IServiceListener;
import edu.nd.dronology.services.core.remote.IRemoteableService;
import edu.nd.dronology.services.core.util.DronologyServiceException;

/** 
 * Base implementation for all services implementing {@link IRemoteableService}
 * @author Michael Vierhauser
 *
 */
public class AbstractRemoteFacade extends UnicastRemoteObject implements IRemoteableService {

	/**
	 * 
	 */
	private static final long serialVersionUID = -7820839372017475896L;
	protected AbstractServerService<?> service;

	protected AbstractRemoteFacade(AbstractServerService<?> service) throws RemoteException {
		super();
		this.service = service;
	}

	@Override
	public ServiceInfo getServiceInfo() throws RemoteException {
		return service.getServerInfo();
	}

	@Override
	public void startService() throws RemoteException, DronologyServiceException {
		service.startService();
	}

	@Override
	public void stopService() throws RemoteException, DronologyServiceException {
		service.stopService();

	}

	@Override
	public boolean removeServiceListener(IServiceListener servicelistener) throws RemoteException {
		return service.removeServiceListener(servicelistener);

	}

	@Override
	public boolean addServiceListener(IServiceListener servicelistener) throws RemoteException {
		return service.removeServiceListener(servicelistener);

	}

	@Override
	public void restartService() throws RemoteException, DronologyServiceException {
		service.restartService();
	}

}
"
IStopStrategy.java,"package edu.nd.dronology.core.vehicle.uav;

public interface IStopStrategy {

	void execute();

}
"
UAVEquipmentTypeRegistrationService.java,"package edu.nd.dronology.services.instances.registration.equipment;

import edu.nd.dronology.services.core.base.AbstractFileTransmitServerService;

import edu.nd.dronology.services.core.info.UAVEquipmentTypeRegistrationInfo;

public class UAVEquipmentTypeRegistrationService
		extends AbstractFileTransmitServerService<IUAVEquipmentTypeRegistrationServiceInstance, UAVEquipmentTypeRegistrationInfo> {

	private static volatile UAVEquipmentTypeRegistrationService INSTANCE;

	protected UAVEquipmentTypeRegistrationService() {
		super();
	}

	/**
	 * @return The singleton ConfigurationService instance
	 */
	public static UAVEquipmentTypeRegistrationService getInstance() {
		if (INSTANCE == null) {
			synchronized (UAVEquipmentTypeRegistrationService.class) {
				if (INSTANCE == null) {
					INSTANCE = new UAVEquipmentTypeRegistrationService();
				}
			}
		}
		return INSTANCE;

	}

	@Override
	protected IUAVEquipmentTypeRegistrationServiceInstance initServiceInstance() {
		return new UAVEquipmentTypeRegistrationServiceInstance();
	}



}
"
RemoteServerProcessListenerAdapter.java,"package edu.nd.dronology.services.remote;

import java.rmi.RemoteException;

import edu.nd.dronology.services.core.api.ServiceStatus;
import edu.nd.dronology.services.core.listener.IServiceListener;
import edu.nd.dronology.services.core.remote.IRemoteServiceListener;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class RemoteServerProcessListenerAdapter implements IServiceListener {

	private static final ILogger LOGGER = LoggerProvider.getLogger(RemoteServerProcessListenerAdapter.class);
	private IRemoteServiceListener listener;

	public RemoteServerProcessListenerAdapter(IRemoteServiceListener listener) {
		this.listener = listener;
	}

	@Override
	public void statusChanged(ServiceStatus newState) {
		try {
			listener.statusChanged(newState);
		} catch (RemoteException e) {
			LOGGER.error(e);
		}
	}
	
	@Override
	public boolean equals(Object thatObject) {
		if (this == thatObject) {
			return true;
		}
		if (!(thatObject instanceof RemoteServerProcessListenerAdapter)) {
			return false;
		}
		return this.listener.equals(((RemoteServerProcessListenerAdapter) thatObject).listener);
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((listener == null) ? 0 : listener.hashCode());
		return result;
	}
	
	
	

}
"
FlightManagerServiceInstance.java,"package edu.nd.dronology.services.instances.flightmanager;

import java.util.Collection;
import java.util.List;

import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.exceptions.FlightZoneException;
import edu.nd.dronology.core.flightzone.FlightZoneManager2;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.services.core.base.AbstractServiceInstance;
import edu.nd.dronology.services.core.info.FlightInfo;
import edu.nd.dronology.services.core.info.FlightPlanInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.core.util.ServiceIds;

public class FlightManagerServiceInstance extends AbstractServiceInstance implements IFlightManagerServiceInstance {

	private FlightZoneManager2 flightManager;

	public FlightManagerServiceInstance() {
		super(ServiceIds.SERVICE_FLIGHTMANAGER, ""Flight Management"");
	}

	@Override
	protected Class<?> getServiceClass() {
		return FlightManagerService.class;
	}

	@Override
	protected int getOrder() {
		// TODO Auto-generated method stub
		return 2;
	}

	@Override
	protected String getPropertyPath() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected void doStartService() throws Exception {
		flightManager = new FlightZoneManager2();
	}

	@Override
	protected void doStopService() throws Exception {
		// TODO Auto-generated method stub

	}

	@Override
	public FlightInfo getFlightDetails() {

		// return
		// RemoteInfoFactory.createFlightInfo(flightManager.getFlights());
		return null;
	}

	@Override
	public void planFlight(String uavid, String planName, List<Waypoint> waypoints) throws Exception {
		flightManager.planFlight(uavid, planName, waypoints);

	}

	@Override
	public void planFlight(String planName, List<Waypoint> waypoints) throws Exception {
		flightManager.planFlight(planName, waypoints);

	}

	@Override
	public void returnToHome(String uavid) throws Exception {
		flightManager.returnToHome(uavid);

	}

	@Override
	public void pauseFlight(String uavid) throws Exception {
		flightManager.pauseFlight(uavid);

	}

	@Override
	public FlightInfo getFlightInfo(String uavId) throws DronologyServiceException {
		return FlightInfoCreator.createInfo(uavId);
	}

	@Override
	public Collection<FlightPlanInfo> getCurrentFlights() {
		return FlightInfoCreator.getCurrenctFlights();
	}

	@Override
	public void cancelPendingFlights(String uavid) throws Exception {
		flightManager.cancelPendingFlights(uavid);
	}


 
	@Override
	public void takeoff(String uavid, double altitude) throws DronologyServiceException {
		try {
			flightManager.takeoff(uavid, altitude);
		} catch (DroneException | FlightZoneException e) {
			throw new DronologyServiceException(e.getMessage());
		}

	}

	@Override
	public void emergencyStop(String uavid) throws DronologyServiceException {
		try {
			flightManager.emergencyStop(uavid);
		} catch (DroneException e) {
			throw new DronologyServiceException(e.getMessage());
		}

	}

}
"
GetCoordinatesMessage.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal.message;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

import java.util.concurrent.SynchronousQueue;

public class GetCoordinatesMessage extends AbstractMessage {
    public final SynchronousQueue<LlaCoordinate> returnBox = new SynchronousQueue<>();
}
"
AreaMappingCategoryInfo.java,"package edu.nd.dronology.services.core.info;

public class AreaMappingCategoryInfo extends RemoteInfoObject {
	/**
	 * 
	 */
	private static final long serialVersionUID = -7327376857430499641L;

	public AreaMappingCategoryInfo(String name, String id) {
		super(name, id);
	}
}
"
FlyingFieldDemoScript.java,"package edu.nd.dronology.services.launch;

import java.net.MalformedURLException;
import java.rmi.Naming;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.services.core.info.DroneInitializationInfo;
import edu.nd.dronology.services.core.info.DroneInitializationInfo.DroneMode;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;
import edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;
import edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;
import edu.nd.dronology.services.core.remote.IRemoteManager;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public class FlyingFieldDemoScript {

	private static final String ADDRESS_SCHEME = ""rmi://%s:%s/Remote"";

	public static void main(String[] args) {
		try {
			// Flying Field
			LlaCoordinate cord1 = new LlaCoordinate(41.694116,  -86.253591, 0);
			LlaCoordinate cord2 = new LlaCoordinate(41.519400, -86.239527, 0);
			LlaCoordinate cord4 = new LlaCoordinate(41.717158, -86.228932, 0);

			IRemoteManager manager = (IRemoteManager) Naming.lookup(String.format(ADDRESS_SCHEME, ""localhost"", 9779));

			IDroneSetupRemoteService service = (IDroneSetupRemoteService) manager.getService(IDroneSetupRemoteService.class);

			IFlightManagerRemoteService managerService = (IFlightManagerRemoteService) manager
					.getService(IFlightManagerRemoteService.class);

			IFlightRouteplanningRemoteService planningService = (IFlightRouteplanningRemoteService) manager
					.getService(IFlightRouteplanningRemoteService.class);
			//

			DroneInitializationInfo inff = new DroneInitializationInfo(""S&R-UAV1"", DroneMode.MODE_VIRTUAL,
					""IRIS+"", cord1);
			service.initializeDrones(inff);

			DroneInitializationInfo inff2 = new DroneInitializationInfo(""S&R-UAV2"", DroneMode.MODE_VIRTUAL,
					""IRIS+"", cord4);
			service.initializeDrones(inff2);

			DroneInitializationInfo inff3 = new DroneInitializationInfo(""S&R-UAV3"", DroneMode.MODE_VIRTUAL,
					""IRIS+"", cord4);
			service.initializeDrones(inff3);

			List<FlightRouteInfo> allRoutes = new ArrayList<>(planningService.getItems());
//			int NUM_DRONES = 0;
//			for (int i = 0; i < NUM_DRONES; i++) {
//				double coordofset = (double) i / 10000;
//				LlaCoordinate coord = new LlaCoordinate((41.519400 + coordofset), -86.239927, 0);
//				DroneInitializationInfo dr = new DroneInitializationInfo(""Sim-Drone"" + i, DroneMode.MODE_VIRTUAL, ""IRIS+"",
//						coord);
//
//				service.initializeDrones(dr);
//			}

			// for (DroneStatus dr : service.getDrones().values()) {
			// FlightRouteInfo inf = getRandomRoute(allRoutes);
			//
			// managerService.planFlight(dr.getID(), ""randplan"", inf.getWaypoints());
			//
			// }

			// for (DroneStatus dr : service.getDrones().values()) {
			// FlightRouteInfo inf = allRoutes.remove(0);
			//
			// managerService.planFlight(dr.getID(), ""randplan"", inf.getWaypoints());
			//
			// }

		} catch (RemoteException | DronologyServiceException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NotBoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	static Random rand = new Random();

	private static FlightRouteInfo getRandomRoute(List<FlightRouteInfo> allRoutes) {
		int routeSize = allRoutes.size();

		int randomNumber = rand.nextInt(routeSize);

		return allRoutes.get(randomNumber);

	}

}
"
AdaptedCreepingLinePrimitive.java,"package edu.nd.dronology.services.extensions.areamapping.internal;

import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.math3.ml.neuralnet.twod.util.TopographicErrorHistogram;
import org.apache.logging.log4j.core.appender.routing.Route;

import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive.RouteType;
import edu.nd.dronology.services.extensions.areamapping.util.Utilities;

public class AdaptedCreepingLinePrimitive implements SearchPatternStrategy{
	
	private List<SourcePoints> sourcePoints;
	private RoutePrimitive.RouteType routeType;
	
	public AdaptedCreepingLinePrimitive() {
		sourcePoints = new ArrayList<>();
	}
	
	@Override
	public void setSourcePoints(List<SourcePoints> points) {
		sourcePoints = points;
	}
	
	public void setRouteType(RoutePrimitive.RouteType routeType) {
		this.routeType = routeType;
	}
	
	
	/**
	 * This method generates the creeping line route between the source points.
	 * @param sideA
	 * @param sideB
	 * @return RoutePrimitive
	 */
	private RoutePrimitive generateCreepingLineRoute(SourcePoints sideA, SourcePoints sideB) {
		int opposingRouteIndex = 0;
		int firstOpposingRouteIndex = 0;
		int lastOpposingRouteIndex = 0;
		boolean missedFirstPoints = false;
		boolean missedLastPoints = false;
		RoutePrimitive newRoute = new RoutePrimitive(routeType, sideA.getWeight());
		Point2D.Double startPoint = new Point2D.Double();
		Point2D.Double opposingPoint = new Point2D.Double();
		Point2D.Double previousOpposingPoint = new Point2D.Double();
		//main for loop for adding waypoints to the route primitive
		for(int i = 0; i < sideA.size(); i++) {
			startPoint = sideA.getSourcePoint(i);
			newRoute.addRouteWaypoint(startPoint);
			opposingPoint = Geometry.findClosestOpposingPoint(startPoint, sideB.getSourcePoints());
			if(i > 0) {
				if(sideB.getSourcePoints().indexOf(opposingPoint) - opposingRouteIndex > 1) {
					generateCreepingLineMiddle(sideA, sideB, newRoute, opposingRouteIndex, sideB.getSourcePoints().indexOf(opposingPoint));
				}
			}
			opposingRouteIndex = sideB.getSourcePoints().indexOf(opposingPoint);
			if(i == 0) {
				if(opposingRouteIndex > 0) {
					missedFirstPoints = true;
					firstOpposingRouteIndex = opposingRouteIndex;
				}
			}
			//System.out.println(""index of opposing point: "" + opposingRouteIndex);
			//do I want this portion? --- attempts to minimize doubling of routes
			if(opposingPoint == previousOpposingPoint && i < sideA.size()-1) {
				previousOpposingPoint = new Point2D.Double();
			} else {
				newRoute.addRouteWaypoint(opposingPoint);
				previousOpposingPoint = opposingPoint;
			}
		}
		//checking for any missed waypoint nodes
		if(opposingRouteIndex != sideB.size()) {
			missedLastPoints = true;
			lastOpposingRouteIndex = opposingRouteIndex;
		}
		if(missedFirstPoints) {
			generateCreepingLineBeginning(sideA, sideB, newRoute, firstOpposingRouteIndex);
		}
		if(missedLastPoints) {
			generateCreepinLineEnd(sideA, sideB, newRoute, lastOpposingRouteIndex);
		} 
		return newRoute;
	}
	
	private void generateCreepingLineMiddle(SourcePoints sideA, SourcePoints sideB, RoutePrimitive newRoute, int previousOpposingRouteIndex, int newOpposingRouteIndex) {
		Point2D.Double pointA = newRoute.getRouteEndPoint();
		if((newOpposingRouteIndex - previousOpposingRouteIndex) % 2 == 0) {
			newRoute.addRouteWaypoint(sideB.getSourcePoint(previousOpposingRouteIndex + 1));
			if(newOpposingRouteIndex - previousOpposingRouteIndex > 1) {
				for(int i = previousOpposingRouteIndex + 2; i < newOpposingRouteIndex; i++) {
					newRoute.addRouteWaypoint(sideB.getSourcePoint(i));
					newRoute.addRouteWaypoint(pointA);
					newRoute.addRouteWaypoint(sideB.getSourcePoint(i+1));
					i++;
				}
			}
		} else {
			for(int i = previousOpposingRouteIndex + 1; i < newOpposingRouteIndex; i++) {
				newRoute.addRouteWaypoint(sideB.getSourcePoint(i));
				newRoute.addRouteWaypoint(sideB.getSourcePoint(i+1));
				newRoute.addRouteWaypoint(pointA);
				i++;
			}
		}
	}
	
	
	/**
	 * This is a helper method for generateCreepingLineRoute() to handle any source points 
	 * missed at the beginning of the route.
	 * @param sideA
	 * @param sideB
	 * @param newRoute
	 * @param firstOpposingRouteIndex
	 */
	private void generateCreepingLineBeginning(SourcePoints sideA, SourcePoints sideB, RoutePrimitive newRoute, int firstOpposingRouteIndex) {
		if(firstOpposingRouteIndex % 2 == 0) {
			int counter = 0;
			for(int i = 0; i < firstOpposingRouteIndex; i++) {
				newRoute.insertRouteWaypoint(counter, sideA.getSourcePoint(0));
				newRoute.insertRouteWaypoint(counter + 1, sideB.getSourcePoint(i));
				newRoute.insertRouteWaypoint(counter + 2, sideB.getSourcePoint(i+1));
				counter += 3;
				i++;
			}
		} else {
			int counter = 1;
			newRoute.insertRouteWaypoint(0, sideB.getSourcePoint(0));
			if(firstOpposingRouteIndex > 1) {
				for(int i = 1; i < firstOpposingRouteIndex; i++) {
					newRoute.insertRouteWaypoint(counter, sideA.getSourcePoint(0));
					newRoute.insertRouteWaypoint(counter + 1, sideB.getSourcePoint(i));
					newRoute.insertRouteWaypoint(counter + 1, sideB.getSourcePoint(i+1));
					counter += 2;
					i++;
				}
			}
		}
	}
	
	
	/**
	 * This is a helper method for generateCreepingLineRoute() to handle and source point 
	 * missed at the end of the route.
	 * @param sideA
	 * @param sideB
	 * @param newRoute
	 * @param lastOpposingRouteIndex
	 */
	private void generateCreepinLineEnd(SourcePoints sideA, SourcePoints sideB, RoutePrimitive newRoute, int lastOpposingRouteIndex) {
		for(int i = lastOpposingRouteIndex + 1; i < sideB.size(); i++) {
			newRoute.addRouteWaypoint(sideB.getSourcePoint(i));
			newRoute.addRouteWaypoint(sideA.getSourcePoint(sideA.size()-1));
			if(i < sideB.size()-1) {
				newRoute.addRouteWaypoint(sideB.getSourcePoint(i+1));
			}
			i++;
		}
	}
	
	@Override
	public List<RoutePrimitive> generateRoutePrimitive(double APERATURE_HEIGHT, double OVERLAP_FACTOR){
		List<RoutePrimitive> routes = new ArrayList<>();
		SourcePoints source1 = sourcePoints.get(0);
		SourcePoints source2 = sourcePoints.get(1);
		RoutePrimitive creepingLineRoute;
		if(source1.size() < source2.size()) {
			creepingLineRoute = generateCreepingLineRoute(source2, source1);
		} else {
			creepingLineRoute = generateCreepingLineRoute(source1, source2);
		}
		//NOTE: should actually be APERATURE_HEIGHT
		Utilities.generateImageWaypoints(creepingLineRoute, APERATURE_HEIGHT, OVERLAP_FACTOR);
		routes.add(creepingLineRoute);
		return routes;
	}
}
"
IRemoteServiceListener.java,"package edu.nd.dronology.services.core.remote;

import java.rmi.RemoteException;

import edu.nd.dronology.services.core.api.IRemotable;
import edu.nd.dronology.services.core.api.ServiceStatus;
/**
 * Listener for notifying clients on status changes of the registered service.
 * 
 * 
 * @author Michael Vierhauser
 *
 */
public interface IRemoteServiceListener extends IRemotable{
	
	/**
	 * 
	 * @param newState The current status of the service.
	 * @throws RemoteException
	 */
	public void statusChanged(ServiceStatus newState) throws RemoteException;


}
"
LandingStrategy.java,"package edu.nd.dronology.core.vehicle.uav;

public class LandingStrategy implements IStopStrategy {

	@Override
	public void execute() {
		// TODO Auto-generated method stub
		
	}

}
"
DroneSetupServiceRemoteFacade.java,"package edu.nd.dronology.services.facades;

import java.rmi.RemoteException;
import java.util.Collection;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.info.DroneInitializationInfo;
import edu.nd.dronology.services.core.listener.IDroneStatusChangeListener;
import edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.instances.dronesetup.DroneSetupService;
import edu.nd.dronology.services.remote.AbstractRemoteFacade;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Remote facade for handling UAVs.<br>
 * Allows initializing new UAVs. <br>
 * Allows retrieving active UAVs which returns a proxy ({@link IUAVProxy}) of the actual physical or virtual uav.
 * 
 * 
 * @author Michael Vierhauser
 *
 */
public class DroneSetupServiceRemoteFacade extends AbstractRemoteFacade implements IDroneSetupRemoteService {
	/**
	 * 
	 */
	private static final long serialVersionUID = -4580658378477037955L;
	private static final ILogger LOGGER = LoggerProvider.getLogger(DroneSetupServiceRemoteFacade.class);
	private static volatile DroneSetupServiceRemoteFacade INSTANCE;

	protected DroneSetupServiceRemoteFacade() throws RemoteException {
		super(DroneSetupService.getInstance());
	}

	public static IDroneSetupRemoteService getInstance() throws RemoteException {
		if (INSTANCE == null) {
			try {
				synchronized (DroneSetupServiceRemoteFacade.class) {
					if (INSTANCE == null) {
						INSTANCE = new DroneSetupServiceRemoteFacade();
					}
				}
			} catch (RemoteException e) {
				LOGGER.error(e);
			}
		}
		return INSTANCE;

	}


	@Override
	public void initializeDrones(DroneInitializationInfo... info) throws RemoteException, DronologyServiceException {
		DroneSetupService.getInstance().initializeDrones(info);

	}

	@Override
	public void addDroneStatusChangeListener(IDroneStatusChangeListener listener) {
		DroneSetupService.getInstance().addDroneStatusChangeListener(listener);
	}

	@Override
	public void removeDroneStatusChangeListener(IDroneStatusChangeListener listener) {
		DroneSetupService.getInstance().removeDroneStatusChangeListener(listener);

	}

	@Override
	public Collection<IUAVProxy> getActiveUAVs() throws RemoteException {
		return DroneSetupService.getInstance().getActiveUAVs();
	}

	@Override
	public void resendCommand(String uavid) throws RemoteException, DronologyServiceException {
		DroneSetupService.getInstance().resendCommand(uavid);
	}

}"
AbstractMissionTask.java,"package edu.nd.dronology.services.extensions.missionplanning.tasks;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

public class AbstractMissionTask implements IMissionTask {
	private final String uavID;
	private final String taskName;

	protected AbstractMissionTask(String uavID, String taskName) {
		this.uavID = uavID;

		this.taskName = taskName;
	}

	@Override
	public String getTaskName() {
		return taskName;
	}

	@Override
	public String getUAVId() {
		return uavID;
	}

	@Override
	public LlaCoordinate getWaypoint() {
		throw new UnsupportedOperationException();
	}

}"
UAVTypeRegistrationXStreamPersistor.java,"package edu.nd.dronology.services.core.persistence.internal;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.XppDriver;

import edu.nd.dronology.services.core.items.IUAVRegistration;
import edu.nd.dronology.services.core.items.IUAVTypeRegistration;
import edu.nd.dronology.services.core.persistence.DronologyPersistenceUtil;
import edu.nd.dronology.services.core.persistence.IPersistenceManager;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class UAVTypeRegistrationXStreamPersistor implements IPersistenceManager<IUAVTypeRegistration> {

	private static final XStream xstream = new XStream(new XppDriver());
	private static ILogger LOGGER = LoggerProvider.getLogger(UAVTypeRegistrationXStreamPersistor.class);

	static final boolean useCompression = false;

	@Override
	public IUAVTypeRegistration open(InputStream fin) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
	//	 xstream.setMode(XStream.);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");
		
		if (useCompression) {
			return loadedCompressedStream(fin);
		} else {
			return loadUncompressedStream(fin);
		}
	}

	private IUAVTypeRegistration loadUncompressedStream(InputStream fin) throws PersistenceException {
		try {
			InputStreamReader reader = new InputStreamReader(new BufferedInputStream(fin), Charset.forName(""UTF-8""));
			Object model = xstream.fromXML(reader);
			return (IUAVTypeRegistration) model;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (fin != null) {
					fin.close();
				}
			} catch (Exception e) {
				LOGGER.error(e);
			}
		}
	}

	private IUAVTypeRegistration loadedCompressedStream(InputStream fin) throws PersistenceException {
		InputStream zIn = null;
		try {
			zIn = new GZIPInputStream(fin);
			Object model = xstream.fromXML(new BufferedReader(new InputStreamReader(zIn, ""UTF-8"")));

			return (IUAVTypeRegistration) model;
		} catch (IOException e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (zIn != null) {
					zIn.close();
				}
				if (fin != null) {
					fin.close();
				}
			} catch (Exception e) {
				LOGGER.error(e);
			}

		}
	}
 
	@Override
	public boolean save(IUAVTypeRegistration o, OutputStream fout) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
		// xstream.setMode(XStream.ID_REFERENCES);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");
		// xstream.addImplicitMap(ImplMEEvent.class, ""relatedEvents"", ImplMEEvent.class, ""relatedEvents"");

		if (useCompression) {
			return saveCompressedStream(o, fout);
		} else {
			return saveUncompressedStream(o, fout);
		}

	}

	private boolean saveUncompressedStream(IUAVTypeRegistration o, OutputStream fout) throws PersistenceException {
		OutputStreamWriter writer = null;
		try {
			writer = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(""UTF-8""));
			xstream.toXML(o, writer);
			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (writer != null) {
					writer.close();
				}
				if (fout != null) {
					fout.close();
				}
			} catch (IOException e) {
				LOGGER.error(e);
			}
		}

	}

	private boolean saveCompressedStream(IUAVTypeRegistration o, OutputStream fout) throws PersistenceException {
		try {
			GZIPOutputStream zOut = new GZIPOutputStream(fout);
			xstream.toXML(o, new BufferedWriter(new OutputStreamWriter(zOut, ""UTF-8"")));

			zOut.close();
			fout.close();

			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		}
	}

}
"
SetGimbalTargetCommand.java,"package edu.nd.dronology.core.vehicle.commands;

import edu.nd.dronology.core.CoordinateChange;
import edu.nd.dronology.core.coordinate.LlaCoordinate;

@CoordinateChange
public class SetGimbalTargetCommand extends AbstractDroneCommand implements IDroneCommand {

	/**
	 * 
	 */
	private static final long serialVersionUID = 364759212900805189L;

	public SetGimbalTargetCommand(String uavid, LlaCoordinate coord) {
		super(uavid, """");

	}

}
"
UAVEquipmentTypeRegistrationServiceInstance.java,"package edu.nd.dronology.services.instances.registration.equipment;

import java.io.File;

import java.util.Set;

import edu.nd.dronology.services.core.api.IFileChangeNotifyable;
import edu.nd.dronology.services.core.api.ServiceInfo;
import edu.nd.dronology.services.core.base.AbstractFileTransmitServiceInstance;
import edu.nd.dronology.services.core.info.UAVEquipmentTypeRegistrationInfo;
import edu.nd.dronology.services.core.items.IUAVEquipmentTypeRegistration;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import edu.nd.dronology.services.core.persistence.UAVEquipmentTypeRegistrationPersistenceProvider;
import edu.nd.dronology.services.core.util.DronologyConstants;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.core.util.ServiceIds;
import edu.nd.dronology.services.instances.DronologyElementFactory;
import edu.nd.dronology.services.supervisor.SupervisorService;
import edu.nd.dronology.util.FileUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class UAVEquipmentTypeRegistrationServiceInstance extends AbstractFileTransmitServiceInstance<UAVEquipmentTypeRegistrationInfo>
		implements IFileChangeNotifyable, IUAVEquipmentTypeRegistrationServiceInstance {

	private static final ILogger LOGGER = LoggerProvider.getLogger(UAVEquipmentTypeRegistrationServiceInstance.class);

	private static final int ORDER = 2;

	public static final String EXTENSION = DronologyConstants.EXTENSION_EQUIPMENT_TYPEREGISTRATION;


	public UAVEquipmentTypeRegistrationServiceInstance() {
		super(ServiceIds.SERVICE_EQUIP_TYPE_REGISTRATION, ""UAV Equipment TypeRegistration Management"", EXTENSION);
	}

	@Override
	protected Class<?> getServiceClass() {
		return UAVEquipmentTypeRegistrationServiceInstance.class;
	}

	@Override
	protected int getOrder() {
		return ORDER;
	}

	@Override
	protected String getPropertyPath() {
		return null;
	}

	@Override
	protected void doStartService() throws Exception {
		reloadItems();
	}

	@Override
	protected void doStopService() throws Exception {
		fileManager.tearDown();
	}

	@Override
	public ServiceInfo getServiceInfo() {
		ServiceInfo sInfo = super.getServiceInfo();
		sInfo.addAttribute(ServiceInfo.ATTRIBUTE_TYPE, ServiceInfo.ATTRIBUTE_FILE);
		return sInfo;
	}

	@Override
	public UAVEquipmentTypeRegistrationInfo createItem() throws DronologyServiceException {
		UAVEquipmentTypeRegistrationPersistenceProvider persistor = UAVEquipmentTypeRegistrationPersistenceProvider.getInstance();
		IUAVEquipmentTypeRegistration specification = DronologyElementFactory.createNewUAVEquipmentTypeSpecification();
		specification.setName(""New-UAVEquipmentTypeSpecification""); 
		String savePath = FileUtil.concat(storagePath, specification.getId(), EXTENSION);

		try {
			persistor.saveItem(specification, savePath);
		} catch (PersistenceException e) {
			throw new DronologyServiceException(""Error when creating drone euqipment: "" + e.getMessage());
		}
		return new UAVEquipmentTypeRegistrationInfo(specification.getName(), specification.getId());
	}

	@Override
	protected String getPath() {
		String path = SupervisorService.getInstance().getDroneSpecificationLocation();
		return path;
	}

	@Override
	protected UAVEquipmentTypeRegistrationInfo fromFile(String id, File file) throws Throwable {
		IUAVEquipmentTypeRegistration atm = UAVEquipmentTypeRegistrationPersistenceProvider.getInstance().loadItem(file.toURI().toURL());
		UAVEquipmentTypeRegistrationInfo info = new UAVEquipmentTypeRegistrationInfo(atm.getName(), id);
		return info;
	}

	@Override
	protected boolean hasProperties() {
		return false;
	}

	@Override
	public void notifyFileChange(Set<String> changed) {
		for (String s : changed) {
			updateItem(s);
		}
		super.notifyFileChange(changed);
		for (String s : changed) {
			String id = s.replace(""."" + extension, """");
			if (!itemmap.containsKey(id)) {

			}
		}
	}

	private void updateItem(String s) {
		System.out.println(""UPDATE"");

	}

}
"
CheckerTaskMessage.java,"package edu.nd.dronology.core.collisionavoidance.backendmessage;

public class CheckerTaskMessage extends AbstractMessage {
}
"
Waypoint.java,"package edu.nd.dronology.core.util;

import java.io.Serializable;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.flight.internal.FlightPlan;
import edu.nd.dronology.util.NullUtil;

/**
 * 
 * Waypoint implementation used in {@link FlightPlan} and Fight Route to represent coordinates (as {@link LlaCoordinate})<br>
 * and the approaching speed towards the respective waypoint. <br>
 * <br>
 * This class (and all its constituent fields) have to be {@link Serializable} as this class is passed via the remote interface.
 * 
 * @author Michael Vierhauser
 *
 */
public class Waypoint implements Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 5855436372355880741L;

	private final LlaCoordinate coordinate;
	private boolean destinationReached = false;

	private double approachingspeed = 0.0d;

	public LlaCoordinate getCoordinate() {
		return coordinate;
	}

	public Waypoint() {
		coordinate = new LlaCoordinate(0, 0, 0);
	}

	public Waypoint(LlaCoordinate coordinate) {
		super();
		NullUtil.checkNull(coordinate);
		this.coordinate = coordinate;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (!(obj instanceof Waypoint))
			return false;
		Waypoint other = (Waypoint) obj;
		return coordinate.equals(other.getCoordinate());
	}

	public boolean isReached() {
		return destinationReached;
	}

	@Override
	public int hashCode() {
		return coordinate.hashCode();
	}

	public void reached(boolean reached) {
		this.destinationReached = reached;

	}

	public double getApproachingspeed() {
		return approachingspeed;
	}

	public void setApproachingspeed(double approachingspeed) {
		this.approachingspeed = approachingspeed;
	}

}
"
TypeRegistrationInfo.java,"package edu.nd.dronology.services.core.info;

public class TypeRegistrationInfo extends RemoteInfoObject {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2844123024068335148L;

	public TypeRegistrationInfo(String name, String id) {
		super(name, id);
	}

}
"
DroneSetupServiceInstance.java,"package edu.nd.dronology.services.instances.dronesetup;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.fleet.AbstractDroneFleetFactory;
import edu.nd.dronology.core.fleet.DroneFleetManager;
import edu.nd.dronology.core.fleet.PhysicalDroneFleetFactory;
import edu.nd.dronology.core.fleet.VirtualDroneFleetFactory;
import edu.nd.dronology.core.flight.PlanPoolManager;
import edu.nd.dronology.core.status.DroneCollectionStatus;
import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.core.vehicle.ManagedDrone;
import edu.nd.dronology.core.vehicle.proxy.UAVProxyManager;
import edu.nd.dronology.services.core.base.AbstractServiceInstance;
import edu.nd.dronology.services.core.info.DroneInitializationInfo;
import edu.nd.dronology.services.core.info.DroneInitializationInfo.DroneMode;
import edu.nd.dronology.services.core.listener.IDroneStatusChangeListener;
import edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.util.NullUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Service instance for handling UAVs<br>
 * See {@link IDroneSetupRemoteService} for details.
 *
 */
public class DroneSetupServiceInstance extends AbstractServiceInstance implements IDroneSetupServiceInstance {

	private static final ILogger LOGGER = LoggerProvider.getLogger(DroneSetupServiceInstance.class);

	private AbstractDroneFleetFactory physicalDroneFleetFactory;
	private AbstractDroneFleetFactory virtualDroneFleetFactory;

	private List<IDroneStatusChangeListener> listenerList = new ArrayList<>();

	public DroneSetupServiceInstance() {
		super(""DRONESETUP"");
	}

	@Override
	protected Class<?> getServiceClass() {
		return DroneSetupService.class;
	}

	@Override
	protected int getOrder() {
		return 3;
	}

	@Override
	protected String getPropertyPath() {
		return null;
	}

	@Override
	protected void doStartService() throws Exception {
		physicalDroneFleetFactory = PhysicalDroneFleetFactory.getInstance();
		virtualDroneFleetFactory = VirtualDroneFleetFactory.getInstance();

	}

	@Override
	protected void doStopService() throws Exception {
	}

	@Override
	public void initializeDrones(DroneInitializationInfo[] info) throws DronologyServiceException {
		NullUtil.checkArrayNull(info);
		for (DroneInitializationInfo di : info) {
			try {
				doInitDrone(di);
			} catch (DroneException e) {
				throw new DronologyServiceException(e.getMessage());
			}
		}
	}
 
	private void doInitDrone(DroneInitializationInfo di) throws DroneException {
		if (di.getMode() == DroneMode.MODE_PHYSICAL) {
			physicalDroneFleetFactory.initializeDrone(di.getId(), di.getType(), di.getInitialLocation());
		} else {
			virtualDroneFleetFactory.initializeDrone(di.getId(), di.getType(), di.getInitialLocation());
		}

		IUAVProxy drStat = UAVProxyManager.getInstance().getActiveUAV(di.getId());
		notifyDroneStatusChange(drStat);
	}

	@Override
	public void addDroneStatusChangeListener(IDroneStatusChangeListener listener) {
		synchronized (listenerList) {
			boolean success = listenerList.add(listener);
			if (!success) {
				// throw exception
			}
		}

	}

	@Override
	public void removeDroneStatusChangeListener(IDroneStatusChangeListener listener) {
		synchronized (listenerList) {
			boolean success = listenerList.remove(listener);
			if (!success) {
				// throw exception
			}
		}

	}

	private void notifyDroneStatusChange(IUAVProxy status) {
		List<IDroneStatusChangeListener> notifyList;
		synchronized (listenerList) {
			notifyList = new ArrayList<>(listenerList);
		}
		for (IDroneStatusChangeListener listener : notifyList) {
			try {
				listener.droneStatusChanged(status);
			} catch (Exception e) {
				LOGGER.error(e);
				listenerList.remove(listener);
			}
		}
	}

	@Override
	public Collection<IUAVProxy> getActiveUAVs() {
		return UAVProxyManager.getInstance().getActiveUAVs();
	}

	@Override
	public void deactivateDrone(IUAVProxy status) throws DronologyServiceException {
		try {
			LOGGER.info(""Unregistering UAV '"" + status.getID() + ""'"");
			DroneFleetManager.getInstance().unregisterDroe(status.getID());
			DroneCollectionStatus.getInstance().removeDrone(status);
			cancelPlans(status.getID());
			notifyDroneStatusChange(status);
		} catch (DroneException e) {
			throw new DronologyServiceException(e.getMessage());
		}

	}

	private void cancelPlans(String id) {
		if (PlanPoolManager.getInstance().getCurrentPlan(id) != null) {
			try {
				PlanPoolManager.getInstance().overridePlan(null, id);
			} catch (DroneException e) {
				LOGGER.error(e);
			}
		}
		if (PlanPoolManager.getInstance().getPendingPlans(id).size() > 0) {
			try {
				PlanPoolManager.getInstance().cancelPendingPlans(id);
			} catch (DroneException e) {
				LOGGER.error(e);
			}
		}

	}

	@Override
	public IUAVProxy getActiveUAV(String uavId) throws DronologyServiceException {
		IUAVProxy uavProxy = UAVProxyManager.getInstance().getActiveUAV(uavId);
		if (uavProxy == null) {
			throw new DronologyServiceException(""UAV '"" + uavId + ""' not active"");
		}
		return uavProxy;
	}

	@Override
	public void resendCommand(String uavId) throws DronologyServiceException {

		try {
			ManagedDrone drone = DroneFleetManager.getInstance().getRegisteredDrone(uavId);
			drone.resendCommand();

		} catch (DroneException e) {
			LOGGER.info(e.getMessage());
			throw new DronologyServiceException(e.getMessage());
		}

	}

}
"
SimpleCheckerMessageHandler.java,"package edu.nd.dronology.monitoring.simplechecker.checker;

import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.text.DateFormat;

import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import edu.nd.dronology.core.DronologyConstants;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.monitoring.DronologyMonitoringManager;
import edu.nd.dronology.core.monitoring.IMonitorableMessage;
import edu.nd.dronology.core.monitoring.MessageMarshaller;
import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;
import edu.nd.dronology.gstation.connector.messages.UAVStateMessage;
import edu.nd.dronology.monitoring.IRemoteMonitoringMessageHandler;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class SimpleCheckerMessageHandler extends UnicastRemoteObject implements IRemoteMonitoringMessageHandler {

	/**
	 * 
	 */
	private static final long serialVersionUID = 3680886616398014407L;

	private static final transient ILogger LOGGER = LoggerProvider.getLogger(SimpleCheckerMessageHandler.class);

	static final transient Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()
			.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)
			.setVersion(1.0).serializeSpecialFloatingPointValues().create();

	public SimpleCheckerMessageHandler() throws RemoteException {

		super();
	}

	GeofenceRectangle geofence = new GeofenceRectangle(new LlaCoordinate(41.682, -86.253, 0),
			new LlaCoordinate(41.676, -86.244, 0));

	// 'LlaCoordinate(41.679517, -86.252505, 10.000000)
	@Override
	public void notifyMonitoringMessage(IMonitorableMessage message) throws RemoteException {
		if (message.getType().equals(MessageType.PHYSICAL_UAV_ACTIVATED)) {
			String data = message.getData();
			LlaCoordinate cord = GSON.fromJson(data, LlaCoordinate.class);
			boolean latOK = checkLat(cord);
			boolean longOK = checkLong(cord);
			boolean altOK = checkAlt(cord);

			boolean fence = geofence.isInside(cord);

			if (latOK && longOK && altOK) {
				LOGGER.info(""Home Location of '"" + message.getUavid() + ""' OK"");

			}
			if (fence) {
				LOGGER.info(""Home Location of '"" + message.getUavid() + ""inside of geofence!"");
				DronologyMonitoringManager.getInstance().publish(MessageMarshaller
						.createMessage(MessageType.FENCE_CHECK, message.getUavid(), message.getData()));

			} else {
				LOGGER.error(""Home Location of '"" + message.getUavid() + ""outside  of geofence!"");
				DronologyMonitoringManager.getInstance().publish(MessageMarshaller
						.createMessage(MessageType.FENCE_BREACH, message.getUavid(), message.getData()));
			}
		} else if (message instanceof UAVStateMessage) {
			UAVStateMessage msg = (UAVStateMessage) message;

			boolean fence = true || geofence.isInside(msg.getLocation());

			DistanceChecker.getInstance().notify(message);

			if (fence) {
				// LOGGER.info(""Location of '"" + message.getUavid() + ""inside of geofence!"");

			} else {
				LOGGER.missionError(""GEOFENCE BREACH! -- '"" + message.getUavid() + ""outside  of geofence!"");
				DronologyMonitoringManager.getInstance().publish(
						MessageMarshaller.createMessage(MessageType.FENCE_BREACH, message.getUavid(), msg.getData()));
				SimpleChecker.getInstance().emergencyStop(msg.getUavid());
			}

		} else {
			// System.out.println(message.toString());
		}
	}

	private boolean checkAlt(LlaCoordinate cord) {
		if (cord.getAltitude() < 0 || cord.getAltitude() > DronologyConstants.TAKE_OFF_ALTITUDE) {
			LOGGER.error(""WRONG LATITUDE"");
			return false;
		}
		return true;
	}

	private boolean checkLong(LlaCoordinate cord) {
		if (cord.getLongitude() > -86 || cord.getLongitude() < -87) {
			LOGGER.error(""WRONG LATITUDE"");
			return false;
		}
		return true;
	}

	private boolean checkLat(LlaCoordinate cord) {
		if (cord.getLatitude() > 42 || cord.getLatitude() < 41) {
			LOGGER.error(""WRONG LATITUDE"");
			return false;
		}
		return true;
	}

}
"
KMLExporter.java,"package edu.nd.dronology.misc.kml;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.TimeZone;

import edu.nd.dronology.core.util.FormatUtil;
import edu.nd.dronology.gstation.connector.messages.UAVMessageFactory;
import edu.nd.dronology.gstation.connector.messages.UAVStateMessage;
import edu.nd.dronology.util.FileUtil;

public class KMLExporter {

	private static final String UAVID = ""IRIS2"";
	private String name = ""test.kml"";
	private String datapath = ""d:\\kmlexport"";
	private String rootTemplate;
	private String pointTemplate;

	public static void main(String[] args) {

		new KMLExporter().createKMLFile(""d:\\log.log"");

	}

	public void createKMLFile(String logfile) {

		rootTemplate = FileUtil.readFile(""./template/track.txt"");
		pointTemplate = FileUtil.readFile(""./template/trackpoint.txt"");

		// System.out.println(pointTemplate);

		List<UAVStateMessage> messages = readMessages(logfile);

		String kmlString = createKMLBody(messages);

		writeToFile(kmlString);
	}

	private List<UAVStateMessage> readMessages(String logfile) {
		List<UAVStateMessage> messageList = new ArrayList<>();
		try {

			List<String> lines = Files.readAllLines(Paths.get(logfile));

			lines.forEach(l -> messageList.add(parseLine(l)));
			return messageList;
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return messageList;
	}

	private UAVStateMessage parseLine(String l) {
		int start = l.indexOf(""{"");
		String msgText = l.substring(start);

		UAVStateMessage msg;
		try {
			msg = (UAVStateMessage) UAVMessageFactory.create(msgText);
			return msg;
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;

	}

	private void writeToFile(String kmlString) {
		File testexists = new File(datapath + ""/"" + name + "".kml"");
		Writer fwriter;

		if (!testexists.exists()) {
			try {

				fwriter = new FileWriter(datapath + ""/"" + name + "".kml"");
				fwriter.write(kmlString);
				fwriter.flush();
				fwriter.close();
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}

		else {

			// schleifenvariable
			String filecontent = """";

			ArrayList<String> newoutput = new ArrayList<String>();
			;

			try {
				BufferedReader in = new BufferedReader(new FileReader(testexists));
				while ((filecontent = in.readLine()) != null)

					newoutput.add(filecontent);

			} catch (FileNotFoundException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}

			// newoutput.add(2, kmlelement);

			String rewrite = """";
			for (String s : newoutput) {
				rewrite += s;
			}

			try {
				fwriter = new FileWriter(datapath + ""/"" + name + "".kml"");
				fwriter.write(rewrite);
				fwriter.flush();
				fwriter.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}

	}

	private String createKMLBody(List<UAVStateMessage> messages) {

		String tqFile = new String(rootTemplate);

		StringBuilder cordBuilder = new StringBuilder();
		for (UAVStateMessage m : messages) {
			String res = createKMLElement(m);
			if (res != null) {
				cordBuilder.append(res);
			}
		}

		tqFile = tqFile.replace(""%points"", cordBuilder.toString());

		// StringBuilder sb = new StringBuilder();
		// content.forEach(str -> {
		// sb.append(str);
		// sb.append(""\n"");
		// });
		return tqFile;

	}

	private String createKMLElement(UAVStateMessage m) {

		// DateFormat df = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss'Z'"");
		// df.setTimeZone(TimeZone.getTimeZone(""Zulu""));
		String ts = FormatUtil.formatTimestamp(m.getTimestamp(), ""yyyy-MM-dd'T'HH:mm:ss'Z'"");

		if (!m.getUavid().equals(UAVID)) {
			return null;
		}

		String tp = new String(pointTemplate);

		tp = tp.replace(""%lat"", Double.toString(m.getLocation().getLatitude()));
		tp = tp.replace(""%lon"", Double.toString(m.getLocation().getLongitude()));
		tp = tp.replace(""%alt"", Double.toString(m.getLocation().getAltitude()));
		tp = tp.replace(""%time"", ts);

		return tp + ""\n"";
	}
}
"
PersistableUAVMissionDescription.java,"package edu.nd.dronology.services.extensions.missionplanning.persistence;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import edu.nd.dronology.services.core.items.IUAVMissionDescription;
import edu.nd.dronology.services.core.items.IUAVMissionTask;

public class PersistableUAVMissionDescription implements Serializable, IUAVMissionDescription {

	private static final long serialVersionUID = 1278076975080384731L;
	private String name;
	private String description;
	private Map<String, Serializable> attributes = new HashMap<>();
	private List<IUAVMissionTask> tasks = new ArrayList<>();

	public PersistableUAVMissionDescription(String name) {
		this.name = name;
	}

	@Override
	public String getDescription() {
		return description;

	}

	@Override
	public void setDescription(String description) {
		this.description = description;
	}

	@Override
	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public void addAttribute(String key, Serializable value) {
		attributes.put(key, value);
	}

	@Override
	public Serializable getAttributes(String key) {
		return attributes.get(key);
	}

	@Override
	public void addTask(IUAVMissionTask task) {
		tasks.add(task);
	}

	@Override
	public void addTask(IUAVMissionTask task, int index) {
		tasks.add(index, task);
	}

	@Override
	public boolean removeTask(int index) {
		if (index >= tasks.size()) {
			return false;
		}
		return tasks.remove(index) != null;
	}

	@Override
	public boolean removeTask(IUAVMissionTask task) {
		return tasks.remove(task);
	}

	@Override
	public List<IUAVMissionTask> getTasks() {
		return Collections.unmodifiableList(tasks);
	}

}
"
FlightInfoCreator.java,"package edu.nd.dronology.services.instances.flightmanager;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import edu.nd.dronology.core.flight.IFlightPlan;
import edu.nd.dronology.core.flight.PlanPoolManager;
import edu.nd.dronology.services.core.info.FlightInfo;
import edu.nd.dronology.services.core.info.FlightPlanInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.instances.dronesetup.DroneSetupService;

public class FlightInfoCreator {

	public static FlightInfo createInfo(String uavId) throws DronologyServiceException {
		DroneSetupService.getInstance().getActiveUAV(uavId);

		FlightInfo info = new FlightInfo(uavId, uavId);

		IFlightPlan currentFlight = PlanPoolManager.getInstance().getCurrentPlan(uavId);
		if (currentFlight != null) {
			FlightPlanInfo currPl = new FlightPlanInfo(currentFlight.getFlightID(), currentFlight.getFlightID());
			currPl.setWaypoints(currentFlight.getWayPoints());
			currPl.setDroneId(currentFlight.getDesignatedDroneId());
			info.setCurrentFlight(currPl);

		}

		List<IFlightPlan> pendingPlans = PlanPoolManager.getInstance().getPendingPlans(uavId);
		for (IFlightPlan plan : pendingPlans) {
			FlightPlanInfo pinfo = new FlightPlanInfo(plan.getFlightID(), plan.getFlightID());
			pinfo.setWaypoints(plan.getWayPoints());
			pinfo.setDroneId(plan.getDesignatedDroneId());
			info.addPending(pinfo);
		}
		List<IFlightPlan> completedPlans = PlanPoolManager.getInstance().getCompletedPlans(uavId);
		for (IFlightPlan plan : completedPlans) {
			FlightPlanInfo pinfo = new FlightPlanInfo(plan.getFlightID(), plan.getFlightID());
			pinfo.setWaypoints(plan.getWayPoints());
			pinfo.setDroneId(plan.getDesignatedDroneId());
			info.addCompleted(pinfo);
		}

		return info;
	}

	public static Collection<FlightPlanInfo> getCurrenctFlights() {
		List<IFlightPlan> current = new ArrayList<>(PlanPoolManager.getInstance().getCurrentFlights());
		List<FlightPlanInfo> planInfo = new ArrayList<>();
		for (IFlightPlan plan : current) {
			FlightPlanInfo pinfo = new FlightPlanInfo(plan.getFlightID(), plan.getFlightID());
			pinfo.setWaypoints(plan.getWayPoints());
			pinfo.setDroneId(plan.getDesignatedDroneId());
			planInfo.add(pinfo);
		}
		return planInfo;
	}

}
"
IRouteSelectionStrategy.java,"package edu.nd.dronology.services.extensions.areamapping.selection;

import java.util.Collection;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.items.IAreaMapping;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public interface IRouteSelectionStrategy {

	void initialize(GeneratedRoutesInfo info, Collection<IUAVProxy> uavs, IAreaMapping mapping)
			throws DronologyServiceException;

	RouteSelectionResult generateAssignments() throws DronologyServiceException;

	RouteSelectionResult generateAssignments(int numAssignments) throws DronologyServiceException;

}"
PysicalDroneIdGenerator.java,"package edu.nd.dronology.gstation.connector.dispatch;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class PysicalDroneIdGenerator {

	private static final String pattern =""\\:(%s$)"";
	
	public static String generate(String id, String groundstationid) {
		return id + "":"" + groundstationid;
	}
	
	
	public static boolean isAssociatedWithGroundstation(String id, String groundstationid) {
		String pat = String.format(pattern, groundstationid);
		
		Matcher m = Pattern.compile(pat).matcher(id);
		return m.find();
	
	}

}

"
MissionExecutionException.java,"package edu.nd.dronology.services.extensions.missionplanning;

public class MissionExecutionException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = -6239074784039693199L;

	public MissionExecutionException(String message) {
		super(message);
	}

}
"
MonitorDialog.java,"package edu.nd.dronology.monitoring.simplechecker.monitor;

import java.awt.BorderLayout;
import java.awt.EventQueue;
import java.awt.Font;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;
import javax.swing.BoxLayout;

public class MonitorDialog {

	private static JFrame frmMonitor;
	private static JTextArea textArea;

	/**
	 * Launch the application.
	 */
	public static void main(String[] args) {
		EventQueue.invokeLater(new Runnable() {
			@Override
			public void run() {
				try {
					MonitorDialog window = new MonitorDialog();
					window.frmMonitor.setVisible(true);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
	}

	/**
	 * Create the application.
	 */
	public MonitorDialog() {
		initialize();
	}

	/**
	 * Initialize the contents of the frame.
	 */
	private void initialize() {
		frmMonitor = new JFrame();
		frmMonitor.setTitle(""Simple-Monitor"");
		frmMonitor.setBounds(100, 100, 705, 500);
		frmMonitor.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		JPanel middlePanel = new JPanel();
		middlePanel.setBorder(new TitledBorder(new EtchedBorder(), """"));
		frmMonitor.getContentPane().add(middlePanel);
		middlePanel.setLayout(new BoxLayout(middlePanel, BoxLayout.X_AXIS));
		// create the middle panel components

		textArea = new JTextArea();
		textArea.setLineWrap(true);
		textArea.setWrapStyleWord(true);

		textArea.setEditable(false); // set textArea non-editable
		JScrollPane scroll = new JScrollPane(textArea);
		scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

		// Add Textarea in to middle panel
		middlePanel.add(scroll);

		textArea.setFont(new Font(""Courier New"", Font.BOLD, 20));
		textArea.setEditable(false);
		// textArea.getDocument().addDocumentListener(this);
	}

	public void addLine(String line) {
		SwingUtilities.invokeLater(() -> {
			textArea.append(line);
			textArea.append(""\n"");
			textArea.setSelectionEnd(textArea.getText().length());
		});

	}

}
"
IMonitoringMessage.java,"package edu.nd.dronology.monitoring;

public interface IMonitoringMessage {

}
"
SynchronizationState.java,"package edu.nd.dronology.services.extensions.missionplanning.sync;

/**
 * Possible state of a {@link SynchronizationPoint}
 * 
 * @author Jane Cleland-Huang 
 *
 */
public enum SynchronizationState {
	NOTACTIVATED, ACTIVE, SYNCHED; 
}
"
IDroneSetupServiceInstance.java,"package edu.nd.dronology.services.instances.dronesetup;

import java.util.Collection;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.api.IServiceInstance;
import edu.nd.dronology.services.core.info.DroneInitializationInfo;
import edu.nd.dronology.services.core.listener.IDroneStatusChangeListener;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public interface IDroneSetupServiceInstance extends IServiceInstance {


	void initializeDrones(DroneInitializationInfo[] info) throws DronologyServiceException;

	void addDroneStatusChangeListener(IDroneStatusChangeListener listener);

	void removeDroneStatusChangeListener(IDroneStatusChangeListener listener);

	Collection<IUAVProxy> getActiveUAVs();

	void deactivateDrone(IUAVProxy status) throws DronologyServiceException;

	IUAVProxy getActiveUAV(String uavId) throws DronologyServiceException;

	void resendCommand(String uavId) throws DronologyServiceException;

}
"
IRemoteInfoObject.java,"package edu.nd.dronology.services.core.api;

import java.util.Map.Entry;
import java.util.Set;

/**
 * Base interface for all serializable objects sent over remote interfaces containing information on constraints, requirements, models etc.
 * 
 * @author Michael Vierhauser
 * 
 */
public interface IRemoteInfoObject extends IRemoteTransferObject, Comparable<IRemoteInfoObject> {

	/**
	 * 
	 * @param key
	 *          The key of the attribute.
	 * @return The value for the given attribute key.<br>
	 *         Returns {@code null} if no value for the given key is available.
	 */
	String getAttribute(String key);

	String getName();

	String getId();

	Set<Entry<String, String>> getAttributes();

	void addAttribute(String key, String value);

}
"
ImageWaypoint.java,"package edu.nd.dronology.services.extensions.areamapping.internal;

import java.awt.geom.Point2D;


public class ImageWaypoint {
	private Point2D.Double waypoint;
	private double orientationAngle;
	
	public ImageWaypoint() {
		waypoint = new Point2D.Double();
	}
	
	public ImageWaypoint(Point2D.Double point, double angle) {
		waypoint = new Point2D.Double();
		setWaypoint(point.getX(), point.getY());
		setOrientationAngle(angle);
	}
	
	public Point2D.Double getWaypoint() {
		return waypoint;
	}
	
	public double getOrientationAngle() {
		return orientationAngle;
	}
	
	public void setImageWaypoint(double latitude, double longitude, double angle) {
		setWaypoint(latitude, longitude);
		setOrientationAngle(angle);
	}
	
	public void setWaypoint(double latitude, double longitude) {
		waypoint.setLocation(latitude, longitude);
	}
	
	public void setOrientationAngle(double angle) {
		orientationAngle = angle;
	}
}
"
UAVTypeRegistrationServiceInstance.java,"package edu.nd.dronology.services.instances.registration.types;

import java.io.File;
import java.util.Set;

import edu.nd.dronology.services.core.api.IFileChangeNotifyable;
import edu.nd.dronology.services.core.api.ServiceInfo;
import edu.nd.dronology.services.core.base.AbstractFileTransmitServiceInstance;
import edu.nd.dronology.services.core.info.UAVTypeRegistrationInfo;
import edu.nd.dronology.services.core.items.IUAVTypeRegistration;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import edu.nd.dronology.services.core.persistence.UAVTypeRegistrationPersistenceProvider;
import edu.nd.dronology.services.core.util.DronologyConstants;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.core.util.ServiceIds;
import edu.nd.dronology.services.instances.DronologyElementFactory;
import edu.nd.dronology.services.supervisor.SupervisorService;
import edu.nd.dronology.util.FileUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class UAVTypeRegistrationServiceInstance extends AbstractFileTransmitServiceInstance<UAVTypeRegistrationInfo>
		implements IFileChangeNotifyable, IUAVTypeRegistrationServiceInstance {

	private static final ILogger LOGGER = LoggerProvider.getLogger(UAVTypeRegistrationServiceInstance.class);

	private static final int ORDER = 2;

	public static final String EXTENSION = DronologyConstants.EXTENSION_TYPEREGISTRATION;


	public UAVTypeRegistrationServiceInstance() {
		super(ServiceIds.SERVICE_REGISTRATION, ""UAV TypeRegistration Management"", EXTENSION);
	}

	@Override
	protected Class<?> getServiceClass() {
		return UAVTypeRegistrationServiceInstance.class;
	}

	@Override
	protected int getOrder() {
		return ORDER;
	}

	@Override
	protected String getPropertyPath() {
		return null;
	}

	@Override
	protected void doStartService() throws Exception {
		reloadItems();
	}

	@Override
	protected void doStopService() throws Exception {
		fileManager.tearDown();
	}

	@Override
	public ServiceInfo getServiceInfo() {
		ServiceInfo sInfo = super.getServiceInfo();
		sInfo.addAttribute(ServiceInfo.ATTRIBUTE_TYPE, ServiceInfo.ATTRIBUTE_FILE);
		return sInfo;
	}

	@Override
	public UAVTypeRegistrationInfo createItem() throws DronologyServiceException {
		UAVTypeRegistrationPersistenceProvider persistor = UAVTypeRegistrationPersistenceProvider.getInstance();
		IUAVTypeRegistration specification = DronologyElementFactory.createNewUAVTypeSpecification();
		specification.setName(""New-UAVTypeSpecification"");
		String savePath = FileUtil.concat(storagePath, specification.getId(), EXTENSION);

		try {
			persistor.saveItem(specification, savePath);
		} catch (PersistenceException e) {
			throw new DronologyServiceException(""Error when creating drone euqipment: "" + e.getMessage());
		}
		return new UAVTypeRegistrationInfo(specification.getName(), specification.getId());
	}

	@Override
	protected String getPath() {
		String path = SupervisorService.getInstance().getDroneSpecificationLocation();
		return path;
	}

	@Override
	protected UAVTypeRegistrationInfo fromFile(String id, File file) throws Throwable {
		IUAVTypeRegistration atm = UAVTypeRegistrationPersistenceProvider.getInstance().loadItem(file.toURI().toURL());
		UAVTypeRegistrationInfo info = new UAVTypeRegistrationInfo(atm.getName(), id);
		return info;
	}

	@Override
	protected boolean hasProperties() {
		return false;
	}

	@Override
	public void notifyFileChange(Set<String> changed) {
		for (String s : changed) {
			updateItem(s);
		}
		super.notifyFileChange(changed);
		for (String s : changed) {
			String id = s.replace(""."" + extension, """");
			if (!itemmap.containsKey(id)) {

			}
		}
	}

	private void updateItem(String s) {
		System.out.println(""UPDATE"");

	}

}
"
MAVLinkUAVConnector.java,"package edu.nd.dronology.gstation.connector;
//package edu.nd.dronology.gstation.python.connector;
//
//import java.io.IOException;
//import java.net.InetAddress;
//import java.net.InetSocketAddress;
//import java.net.Socket;
//import java.net.UnknownHostException;
//import java.util.Map;
//import java.util.concurrent.ConcurrentHashMap;
//import java.util.concurrent.ExecutorService;
//import java.util.concurrent.Executors;
//
//import edu.nd.dronology.core.IUAVPropertyUpdateNotifier;
//import edu.nd.dronology.core.exceptions.DroneException;
//import edu.nd.dronology.core.vehicle.IDroneCommandHandler;
//import edu.nd.dronology.core.vehicle.commands.IDroneCommand;
//import edu.nd.dronology.gstation.python.connector.dispatch.DispatchQueueManager;
//import edu.nd.dronology.gstation.python.connector.dispatch.ReadDispatcher;
//import edu.nd.dronology.gstation.python.connector.dispatch.WriteDispatcher;
//import edu.nd.dronology.util.NamedThreadFactory;
//import net.mv.logging.ILogger;
//import net.mv.logging.LoggerProvider;
//
//public class MAVLinkUAVConnector implements IDroneCommandHandler {
//
//	private static final ILogger LOGGER = LoggerProvider.getLogger(MAVLinkUAVConnector.class);
//
//	protected static final ExecutorService servicesExecutor = Executors.newFixedThreadPool(10,
//			new NamedThreadFactory(""Groundstation-Threads""));
//
//	// socket for communication with python ground station
//	private Socket pythonSocket;
//	private final Map<String, IUAVPropertyUpdateNotifier> registeredListeners = new ConcurrentHashMap<>();
//	private ReadDispatcher readDispatcher;
//	private WriteDispatcher writeDispatcher;
//	private final String groundstationid;
//	private final DispatchQueueManager dispatchQueueManager;
//	private final String host;
//	private final int port;
//	private boolean connected;
//
//	public MAVLinkUAVConnector(String groundstationid, String host, int port) {
//		this.groundstationid = groundstationid;
//		dispatchQueueManager = new DispatchQueueManager(groundstationid);
//		this.host = host;
//		this.port = port;
//		this.connected = false;
//		connect();
//	}
//
//	private void connect() {
//		try {
//			InetAddress hostAddr = InetAddress.getByName(host);
//
//			String hostStr = hostAddr.toString();
//
//			LOGGER.info(""Connecting to Python base "" + hostStr + ""@"" + port);
//			pythonSocket = new Socket();
//			pythonSocket.connect(new InetSocketAddress(hostAddr, port), 5000);
//			// pythonSocket.setSoTimeout(20000);
//
//			LOGGER.hwInfo(""Connected to "" + pythonSocket.getInetAddress().toString() + ""@"" + pythonSocket.getPort());
//		//	readDispatcher = new ReadDispatcher(pythonSocket, dispatchQueueManager);
//			writeDispatcher = new WriteDispatcher(pythonSocket, dispatchQueueManager.getOutgoingCommandQueue());
//			servicesExecutor.submit(readDispatcher);
//			servicesExecutor.submit(writeDispatcher);
//			connected = true;
//		} catch (UnknownHostException e) {
//			LOGGER.hwFatal(""Can't connect to Python Groundstation "");
//			scheduleReconnect();
//		} catch (Throwable e) {
//			LOGGER.hwFatal(""Can't connect to Python Groundstation "" + e.getMessage());
//			scheduleReconnect();
//		}
//	}
//
//	private void scheduleReconnect() {
//		// TODO implement me...
//
//	}
//
//	@Override
//	public void sendCommand(IDroneCommand cmd) throws DroneException {
//		LOGGER.hwInfo(groundstationid + "" Sending Command to UAV "" + cmd.toString());
//		dispatchQueueManager.send(cmd);
//	}
//
//	@Override
//	public void setStatusCallbackNotifier(String id, IUAVPropertyUpdateNotifier listener) throws DroneException {
//		if (registeredListeners.containsKey(id)) {
//			throw new DroneException(""An listener with '"" + id + ""' is already registered"");
//		}
//		registeredListeners.put(id, listener);
//		dispatchQueueManager.createDispatchThread(id, listener);
//	}
//
//	public void tearDown() {
//		try {
//			pythonSocket.close();
//			readDispatcher.tearDonw();
//			writeDispatcher.tearDown();
//			dispatchQueueManager.tearDown();
//		} catch (IOException e) {
//			LOGGER.hwFatal(e);
//		}
//	}
//
//	@Override
//	public String getHandlerId() {
//		return groundstationid;
//	}
//
//	public void registerMonitoringMessageHandler(IMonitoringMessageHandler monitoringhandler) {
//		dispatchQueueManager.registerMonitoringMessageHandler(monitoringhandler);
//
//	}
//
//	public void registerSafetyValidator(IUAVSafetyValidator validator) {
//		dispatchQueueManager.registerSafetyValidator(validator);
//
//	}
//
//}
"
MissionExecutionTester.java,"package edu.nd.dronology.services.launch;

import java.net.MalformedURLException;
import java.rmi.Naming;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.util.Collection;
import java.util.List;
import java.util.Random;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.services.core.info.DroneInitializationInfo;
import edu.nd.dronology.services.core.info.DroneInitializationInfo.DroneMode;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.info.MissionInfo;
import edu.nd.dronology.services.core.info.UAVMappingInfo;
import edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;
import edu.nd.dronology.services.core.remote.IMissionPlanningRemoteService;
import edu.nd.dronology.services.core.remote.IRemoteManager;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public class MissionExecutionTester {

	private static final String ADDRESS_SCHEME = ""rmi://%s:%s/Remote"";

	public static void main(String[] args) {
		try {
			// Flying Field
			LlaCoordinate cord1 = new LlaCoordinate(41.694116, -86.253591, 0);
			LlaCoordinate cord2 = new LlaCoordinate(41.519400, -86.239527, 0);
			LlaCoordinate cord4 = new LlaCoordinate(41.717158, -86.228932, 0);

			IRemoteManager manager = (IRemoteManager) Naming.lookup(String.format(ADDRESS_SCHEME, ""localhost"", 9779));

			IMissionPlanningRemoteService service = (IMissionPlanningRemoteService) manager
					.getService(IMissionPlanningRemoteService.class);

			IDroneSetupRemoteService dservice = (IDroneSetupRemoteService) manager
					.getService(IDroneSetupRemoteService.class);

			DroneInitializationInfo inff = new DroneInitializationInfo(""frank"", DroneMode.MODE_VIRTUAL, ""IRIS+"", cord1);
		//	dservice.initializeDrones(inff);

			Collection<MissionInfo> items = service.getItems();
			System.out.println(""INFIS:"" + items.size());
			for (MissionInfo mi : items) {
				System.out.println(""MI:"" + mi.getName());
				if (mi.getName().equals(""mission1"")) {
					UAVMappingInfo mapping = new UAVMappingInfo();
					mapping.addAttribute(""uav1"", ""frank"");
					service.executeMissionPlan(mi,mapping);
				}
			}
			//

			//
			// DroneInitializationInfo inff2 = new DroneInitializationInfo(""S&R-UAV2"",
			// DroneMode.MODE_VIRTUAL, ""IRIS+"",
			// cord4);
			// dservice.initializeDrones(inff2);
			//
			// DroneInitializationInfo inff3 = new DroneInitializationInfo(""S&R-UAV3"",
			// DroneMode.MODE_VIRTUAL, ""IRIS+"",
			// cord4);
			// dservice.initializeDrones(inff3);

		} catch (RemoteException | DronologyServiceException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NotBoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	static Random rand = new Random();

	private static FlightRouteInfo getRandomRoute(List<FlightRouteInfo> allRoutes) {
		int routeSize = allRoutes.size();

		int randomNumber = rand.nextInt(routeSize);

		return allRoutes.get(randomNumber);

	}

}
"
PhysicalDroneTest.java,"package edu.nd.dronology.groundstation.connector;
//package TestCases;
//import java.util.Calendar;
//
//import org.junit.Test;
//
//import edu.nd.dronology.core.exceptions.FlightZoneException;
//import edu.nd.dronology.core.util.Coordinate;
//import edu.nd.dronology.core.vehicle.IDrone;
//import model.drone.groundstation.PythonBase;
//import model.drone.runtime.PhysicalDrone;
//
//public class PhysicalDroneTest {
//
//	@Test
//	public void test() throws FlightZoneException, InterruptedException {
//		PythonBase baseStation = new PythonBase();
//		
//		DroneSet
//		
//		IDrone drone = DroneFleetfacotry.(""test_drone"", baseStation);
//		long alt_tolerance = 1;
//		long init_lat = drone.getLatitude();
//		long init_lon = drone.getLongitude();
//		long init_alt = drone.getAltitude();
//		System.out.println(init_lat);
//		System.out.println(init_lon);
//		System.out.println(init_alt);
//		
//		assert(init_alt<=alt_tolerance);
//		
//		long dest_lat = init_lat + 1000;
//		long dest_lon = init_lon + 1000;
//		int dest_alt = 20;
//		
//		//TestTakeoff(drone,alt_tolerance,45000,dest_alt);
//		//TestLand(drone,0,45000);
//		
//		//Thread.sleep(1000); //TODO: figure out why land then takeoff doesn't work
//		
//		TestTakeoff(drone,alt_tolerance,45000,dest_alt);
//		TestFlyTo(drone, 60000, dest_lat, dest_lon, dest_alt);
//		TestFlyTo(drone, 60000, init_lat, init_lon, dest_alt);
//		TestLand(drone,alt_tolerance,45000);
//	}
//	
//	private void TestTakeoff(IDrone drone, long alt_tolerance, long timeout, int dest_alt) throws FlightZoneException, InterruptedException {
//		drone.takeOff(dest_alt);
//		long init_time = Calendar.getInstance().getTimeInMillis();
//		//long init_time = System.currentTimeMillis();
//		long current_time = init_time;
//		boolean still_taking_off = true;
//		while(((current_time-init_time)<timeout) && still_taking_off) {
//			Thread.sleep(10);
//			if(drone.getAltitude()>=(dest_alt-alt_tolerance)) {
//				still_taking_off = false;
//			}
//			current_time = Calendar.getInstance().getTimeInMillis();
//		}
//		assert(!still_taking_off);
//	}
//	
//	private void TestLand(IDrone drone, long alt_tolerance, long timeout) throws FlightZoneException, InterruptedException {
//		drone.land();
//		long init_time = Calendar.getInstance().getTimeInMillis();
//		long current_time = init_time;
//		boolean still_landing = true;
//		while(((current_time-init_time)<timeout) && still_landing) {
//			Thread.sleep(10);
//			if(drone.getAltitude()<=alt_tolerance) {
//				still_landing = false;
//			}
//			current_time = Calendar.getInstance().getTimeInMillis();
//		}
//		assert(!still_landing);
//	}
//	
//	private void TestFlyTo(IDrone drone, long timeout, long lat, long lon, long alt) throws FlightZoneException, InterruptedException {
//		drone.flyTo(new Coordinate(lat, lon, (int)alt));
//		long init_time = Calendar.getInstance().getTimeInMillis();
//		long current_time = init_time;
//		boolean still_flying = true;
//		while(((current_time-init_time)<timeout) && still_flying) {
//			Thread.sleep(10);
//			if(drone.isDestinationReached(0)) {
//				still_flying = false;
//			}
//			current_time = Calendar.getInstance().getTimeInMillis();
//		}
//		assert(!still_flying);
//	}
//}
"
MissionController.java,"package edu.nd.dronology.services.extensions.missionplanning.plan;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;

import com.google.common.util.concurrent.RateLimiter;

import edu.nd.dronology.services.core.info.UAVMappingInfo;
import edu.nd.dronology.services.core.items.IMissionPlan;
import edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;
import edu.nd.dronology.services.extensions.missionplanning.sync.SynchronizationManager;
import edu.nd.dronology.services.extensions.missionplanning.v1.FullMissionPlan;
import edu.nd.dronology.services.instances.dronesetup.DroneSetupService;
import edu.nd.dronology.util.NamedThreadFactory;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Central control class responsible for building, initializing, and executing a
 * {@link FullMissionPlan}.<br>
 * The {@link MissionController} periodically checks for new tasks that can be
 * activated and activates them on demand.
 * 
 * @author Michael Vierhauser
 */
public class MissionController implements Runnable {
	private static final ILogger LOGGER = LoggerProvider.getLogger(MissionController.class);
	RateLimiter barrier = RateLimiter.create(1);
	AtomicBoolean missionrunning = new AtomicBoolean(true);
	private transient IExecuteableMissionPlan missionPlan;
	private static final ExecutorService SERVICE_EXECUTOR = Executors
			.newSingleThreadExecutor(new NamedThreadFactory(""MissionControl""));
	private transient static MissionController INSTANCE;

	@Deprecated
	public void executeMission(String mission) throws MissionExecutionException {
		if (missionPlan != null) {
			throw new MissionExecutionException(""Another mission is currently running!"");
		}

		FullMissionPlan mp = new FullMissionPlan(mission);
		mp.build();
		missionPlan = mp;
		SERVICE_EXECUTOR.submit(this);
	}

	public void executeMission(IMissionPlan mission, UAVMappingInfo mapping) throws MissionExecutionException {
		if (missionPlan != null) {
			throw new MissionExecutionException(""Another mission is currently running!"");
		}
		
		FullMissionPlan2 mp = new FullMissionPlan2(mission);
		mp.build(mapping);
		missionPlan = mp;
		SERVICE_EXECUTOR.submit(this);

	}

	@Override
	public void run() {
		missionrunning.getAndSet(true);
		while (missionrunning.get() && missionPlan.isMissionActive()) {
			barrier.acquire();
			try {
				missionPlan.checkAndActivateTask();
			} catch (MissionExecutionException e) {
				LOGGER.error(e);
				try {
					cancelMission();
				} catch (MissionExecutionException e1) {
					LOGGER.error(e1);
				}
			}
		}
		LOGGER.info(""Mission complete"");
		SynchronizationManager.getInstance().resetAltitudes();
		missionPlan = null;
	}

	/**
	 * @return The singleton MissionController instance
	 */
	public static MissionController getInstance() {
		if (INSTANCE == null) {
			synchronized (DroneSetupService.class) {
				if (INSTANCE == null) {
					INSTANCE = new MissionController();
				}
			}
		}
		return INSTANCE;
	}

	public void cancelMission() throws MissionExecutionException {
		if (missionPlan == null) {
			throw new MissionExecutionException(""No mission currently active"");
		}
		SynchronizationManager.getInstance().resetAltitudes();
		missionrunning.getAndSet(false);
		missionPlan.cancelMission();
		missionPlan = null;
	}

}
"
WatchServiceRunner.java,"package edu.nd.dronology.services.core.util;

import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;

import java.io.IOException;
import java.nio.file.ClosedWatchServiceException;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.StandardWatchEventKinds;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import edu.nd.dronology.services.core.api.IFileChangeNotifyable;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class WatchServiceRunner implements Runnable {
	private static final ILogger LOGGER = LoggerProvider.getLogger(WatchServiceRunner.class);
	private boolean recursive;
	private IFileChangeNotifyable manager;
	private String[] fileExtensions;

	public WatchServiceRunner(String dir, boolean recursive, IFileChangeNotifyable manager, String... fileExtensions) {
		this.dir = dir;
		this.fileExtensions = fileExtensions;
		this.recursive = recursive;
		this.manager = manager;
	}

	private WatchService watcher;
	private String dir;
	private Object notifyTask;
	private List<String> changeList = new ArrayList<>();
	private static Map<WatchKey, Path> keys = new HashMap<>();

	@Override
	public void run() {

		try {
			watcher = FileSystems.getDefault().newWatchService();
			register(Paths.get(dir));

			while (true) {
				WatchKey watchKey = watcher.take();
				for (WatchEvent<?> watchEvent : watchKey.pollEvents()) {
					Path context = (Path) watchEvent.context();
					for (String ext : fileExtensions) {
						if (context.getFileName().toString().endsWith(ext)) {
							if (""ENTRY_DELETE"".equals(watchEvent.kind().toString())
									|| ""ENTRY_CREATE"".equals(watchEvent.kind().toString())
									|| ""ENTRY_MODIFY"".equals(watchEvent.kind().toString())) {
								changed(context.getFileName().toString());
							}
						}
					}
				}
				watchKey.reset();
			}
		} catch (ClosedWatchServiceException e) {
		} catch (IOException e) {
			LOGGER.error(e);
		} catch (Exception e) {
			LOGGER.error(e);
		}

	}

	private void changed(String fileName) {
		changeList.add(fileName);
		if (notifyTask != null) {
			return;
		}
		Timer timer = new Timer();
		timer.schedule(new NotifyChangeTask(), 500);
		notifyTask = new NotifyChangeTask();
	}

	class NotifyChangeTask extends TimerTask {
		@Override
		public void run() {
			Set<String> changed = new HashSet<>();
			synchronized (changeList) {
				changed.addAll(changeList);
				changeList.clear();
				notifyTask = null;
			}
			manager.notifyFileChange(changed);

		}
	}

	private void registerAll(final Path start) throws IOException {
		// register directory and sub-directories

		Files.walkFileTree(start, new SimpleFileVisitor<Path>() {
			@Override
			public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
				try {
					if (dir.getFileName() != null && (dir.getFileName().toString().startsWith(""."")
							|| dir.getFileName().toString().startsWith(""$""))) {
						return FileVisitResult.SKIP_SUBTREE;
					}
					register(dir);
					return FileVisitResult.CONTINUE;

				} catch (Exception e) {
					e.printStackTrace();
					return FileVisitResult.SKIP_SUBTREE;
				}
			}

			@Override
			public FileVisitResult visitFileFailed(Path file, IOException exc) {
				System.err.format(""Unable to register:"" + "" %s: %s%n"", file, exc);
				return FileVisitResult.CONTINUE;
			}
		});

	}

	/**
	 * Register the given directory with the WatchService
	 */
	private void register(Path dir) throws IOException {

		// WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE,
		// ENTRY_MODIFY);
		WatchKey key = dir.register(watcher, ENTRY_CREATE, StandardWatchEventKinds.ENTRY_MODIFY,
				StandardWatchEventKinds.ENTRY_DELETE);
		if (true) {
			// System.out.println(""VALID: ""+dir.getFileName().toString());
			Path prev = keys.get(key);
			if (prev == null) {
				// System.out.format(""register: %s\n"", dir);
			} else {
				if (!dir.equals(prev)) {
					// System.out.format(""update: %s -> %s\n"", prev, dir);
				}
			}
		}
		keys.put(key, dir);
	}

	public void stop() {
		try {
			watcher.close();
		} catch (IOException e) {
			LOGGER.error(e);
		}
	}

}
"
PersistenceException.java,"package edu.nd.dronology.services.core.persistence;

public class PersistenceException extends Throwable {

	public PersistenceException(Exception e) {
		super(e);
	}

	public PersistenceException() {
		super();
	}

	public PersistenceException(String message) {
		super(message);
	}

	/**
	 * 
	 */
	private static final long serialVersionUID = -7093839510895063175L;

}
"
IFlightManagerServiceInstance.java,"package edu.nd.dronology.services.instances.flightmanager;

import java.util.Collection;
import java.util.List;

import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.services.core.api.IServiceInstance;
import edu.nd.dronology.services.core.info.FlightInfo;
import edu.nd.dronology.services.core.info.FlightPlanInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public interface IFlightManagerServiceInstance extends IServiceInstance {

	public FlightInfo getFlightDetails();

	public void planFlight(String uavid, String planName, List<Waypoint> waypoints) throws Exception;

	public void planFlight(String planName, List<Waypoint> waypoints) throws Exception;

	public void returnToHome(String uavid) throws Exception;

	public void pauseFlight(String uavid) throws Exception;

	public FlightInfo getFlightInfo(String uavId) throws DronologyServiceException;

	Collection<FlightPlanInfo> getCurrentFlights();

	public void cancelPendingFlights(String uavid) throws Exception;

	public void takeoff(String uavid, double altitude) throws DronologyServiceException;

	public void emergencyStop(String uavid) throws DronologyServiceException;

}
"
ServiceInfo.java,"package edu.nd.dronology.services.core.api;

import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;

import edu.nd.dronology.util.NullUtil;

/**
 * 
 * Wrapper object for various attributes and properties of an {@link IServiceInstance}
 * 
 * 
 * @author Michael Vierhauser
 * 
 */
public class ServiceInfo implements IRemoteTransferObject, Comparable<ServiceInfo> {

	public static final String ATTRIBUTE_SERVICEID = ""Service ID"";
	public static final String ATTRIBUTE_SOCKET = ""Socket"";
	public static final String ATTRIBUTE_REMOTE = ""Remote"";
	public static final String ATTRIBUTE_FILE = ""File"";
	
	public static final String ATTRIBUTE_TYPE= ""Type"";
	public static final String ATTRIBUTE_DISPATCHQUEUESIZE = ""Queue Size"";
	public static final String ATTRIBUTE_DISTRIBUTORPRIORITY = ""Priority"";
	public static final String ATTRIBUTE_SUBSCRIBER = ""Registered Subscriber"";
	public static final String ATTRIBUTE_TYPE_DISTRIBUTOR = ""Distributor"";
	public static final String ATTRIBUTE_TYPE_SERVICE = ""Service"";

	public static final String ATTRIBUTE_TIMESTAMP = ""Timestamp"";
	/**
	 * 
	 */
	private static final long serialVersionUID = 376263095158789667L;

	


	private Map<String, String> attributes = new TreeMap<>();
	private Map<String, String> properties = new TreeMap<>();
	private String serviceID;
	private String description;
	private ServiceStatus serviceStatus = ServiceStatus.STOPPED;
	private String className;
	private final int order;

	/**
	 * 
	 * @param serviceID
	 * @param serviceStatus
	 * @param description
	 * @param attributes
	 * @param properties
	 * @param order
	 */
	public ServiceInfo(String serviceID, ServiceStatus serviceStatus, String description, Map<String, String> attributes,
			Map<String, String> properties, int order) {
		super();
		NullUtil.checkNull(attributes, properties);
		this.attributes = new TreeMap<>(attributes);
		this.properties = new TreeMap<>(properties);
		this.serviceID = serviceID;
		this.serviceStatus = serviceStatus;
		this.description = description;
		this.order = order;
	}

	@Override
	public String toString() {
		StringBuffer sb = new StringBuffer();
		for (Entry<String, String> e : attributes.entrySet()) {
			sb.append(e.getKey());
			sb.append("":"");
			sb.append(e.getValue());
			sb.append(""\n"");
		}
		return sb.toString();
	}

	/**
	 * 
	 * @return The attributes of the server process.
	 */
	public Map<String, String> getDetails() {
		return attributes;
	}

	/**
	 * 
	 * @return The configuration properties of the server process.
	 */
	public Map<String, String> getProperties() {
		return properties;
	}

	/**
	 * @return The id of the service.
	 */
	public String getServiceID() {
		return serviceID;
	}

	/**
	 * @return A description for the service.
	 */
	public String getDescription() {
		return description;
	}

	/**
	 * @return M map of configuration properties.
	 */
	public Map<String, String> getConfigurationProperties() {
		return properties;
	}

	/**
	 * @return The current status of the service.
	 */
	public ServiceStatus getStatus() {
		return serviceStatus;
	}

	/**
	 * @return The canonical name of the service class.
	 */
	public String getServiceClass() {
		return className;
	}

	/**
	 * @param className
	 *          The canonical name of the service class.
	 */
	public void setServiceClass(String className) {
		this.className = className;
	}

	@Override
	public int compareTo(ServiceInfo that) {
		return Integer.compare(this.order, that.order);
	}

	/**
	 * Adds an key-value attribute pair to the attribute table.
	 * 
	 * @param key
	 * @param value
	 */
	public void addAttribute(String key, String value) {
		attributes.put(key, value);

	}

	public void setStatus(ServiceStatus serviceStatus) {
		this.serviceStatus = serviceStatus;
	}

}
"
PriorityPolygonPrimitive.java,"package edu.nd.dronology.services.extensions.areamapping.internal;


import java.awt.Point;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.SortedSet;
import java.util.Vector;

import javax.xml.transform.Source;

import edu.nd.dronology.services.extensions.areamapping.model.RiverSubsegment;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive.RouteType;
import edu.nd.dronology.services.extensions.areamapping.util.Utilities;

public class PriorityPolygonPrimitive implements SearchPatternStrategy {
	private List<SourcePoints> sourcePoints;
	private List<Point2D.Double> priorityPolygonPoints;
	private RoutePrimitive.RouteType routeType;
	
	@Override
	public void setSourcePoints(List<SourcePoints> points) {
		sourcePoints = points;
	}
	
	@Override
	public void setRouteType(RouteType routeType) {
		this.routeType = routeType;
	}
	
	private List<Line2D.Double> findBoundingRectangleCrossingLines(Point2D.Double minPoint, Point2D.Double maxPoint, double APERATURE_HEIGHT, double OVERLAP_FACTOR){
		List<Line2D.Double> crossingLines = new ArrayList<>();
		Point2D.Double pointA = new Point2D.Double(minPoint.getX(), maxPoint.getY());
		Point2D.Double pointB = minPoint;
		Point2D.Double newPoint  = new Point2D.Double();
		double totalDistance = Geometry.findCartesianDistance(pointA, pointB);
		double traverseDistance = 10 * OVERLAP_FACTOR;
		crossingLines.add(new Line2D.Double(pointA, maxPoint));
		while(traverseDistance < totalDistance) {
			newPoint = Geometry.findOffsetPoint(pointA, pointB, traverseDistance / totalDistance);
			crossingLines.add(new Line2D.Double(newPoint, new Point2D.Double(maxPoint.getX(), newPoint.getY())));
			pointA = newPoint;
			totalDistance = totalDistance - traverseDistance;
		}
		crossingLines.add(new Line2D.Double(minPoint, new Point2D.Double(maxPoint.getX(),minPoint.getY())));
		return crossingLines;
	}
	
	private RoutePrimitive generateRouteWaypoints(List<Line2D.Double> crossingLines, SourcePoints sourcePoints) {
		RoutePrimitive newRoutePrimitive = new RoutePrimitive(routeType, sourcePoints.getWeight());
		Line2D.Double polygonSegment = new Line2D.Double();
		for(int i = 0; i < crossingLines.size(); i++) {
			List<Point2D.Double> intersectionPoints = new ArrayList<>();
			for(int j = 0; j < priorityPolygonPoints.size()-1; j++) {
				polygonSegment.setLine(priorityPolygonPoints.get(j), priorityPolygonPoints.get(j+1));
				if(crossingLines.get(i).intersectsLine(polygonSegment)) {
					intersectionPoints.add(Geometry.findLineIntersection(crossingLines.get(i), polygonSegment));
				}
			}
			//does this comparison thing work? 
			Collections.sort(intersectionPoints, Comparator.comparingDouble(Point2D.Double::getX));
			for(Point2D.Double entry : intersectionPoints) {
				//there is probably a better way to do this
				if(!newRoutePrimitive.getRoute().contains(entry)) {
					newRoutePrimitive.addRouteWaypoint(entry);
				}
			}
		}
		return newRoutePrimitive; 
	}

	@Override
	public List<RoutePrimitive> generateRoutePrimitive(double APERATURE_HEIGHT, double OVERLAP_FACTOR) {
		List<RoutePrimitive> priorityPolygonRoute = new ArrayList<>();
		List<SourcePoints> priorityAreas = new ArrayList<>();
		for(SourcePoints source : sourcePoints) {
			priorityPolygonPoints = new ArrayList<>(source.getSourcePoints());
			priorityPolygonPoints.add(priorityPolygonPoints.get(0));
			Vector<Point2D.Double> boundPoints = Geometry.simplePriorityPolygonBoundingRectangle(priorityPolygonPoints);
			List<Line2D.Double> crossingLines = findBoundingRectangleCrossingLines(boundPoints.get(0), boundPoints.get(1), APERATURE_HEIGHT, OVERLAP_FACTOR);
			RoutePrimitive newRoute = generateRouteWaypoints(crossingLines, source);
			priorityPolygonRoute.add(newRoute);
			Utilities.generateImageWaypoints(newRoute, APERATURE_HEIGHT, OVERLAP_FACTOR);
			
			//simply for printout visualization purposes
			SourcePoints area = new SourcePoints();
			area.setSourcePoints(priorityPolygonPoints);
			priorityAreas.add(area);
		}
		System.out.println(""Priority area boundaries: "");
		Utilities.printSourcePoints(priorityAreas);
		Utilities.printRoutePrimitives(priorityPolygonRoute);
		Utilities.printImageWaypoints(priorityPolygonRoute);
		return priorityPolygonRoute;
	}
}
"
IRemoteManager.java,"package edu.nd.dronology.services.core.remote;

import java.rmi.RemoteException;
import java.util.List;

import edu.nd.dronology.services.core.api.IRemotable;
import edu.nd.dronology.services.core.api.ServiceInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

/**
 * Interface for handling communication between server UI and server services.
 * 
 * 
 * @author Michael Vierhauser
 * 
 */
public interface IRemoteManager extends IRemotable {

	/**
	 * Retrieve the desired service to offer remote operations.<br>
	 * Requested service has to extends {@link IRemoteableService}.
	 * 
	 * 
	 * @param service
	 *          The Service to retrieve.
	 * @return The requested Service.
	 * @throws RemoteException
	 * @throws DronologyServiceException
	 */
	public Object getService(Class<?> service) throws RemoteException, DronologyServiceException;

	
	/**
	 * @return A list of all registered Services.
	 * @throws RemoteException
	 * @throws DronologyServiceException
	 */
	public List<ServiceInfo> getServices() throws RemoteException, DronologyServiceException;


	/**
	 * Adds a service listener to all currently available services informing on service status changes.
	 * 
	 * @param listener
	 *          The listener to be added.
	 * @throws RemoteException
	 */
	public void addServiceListener(IRemoteServiceListener listener) throws RemoteException;

	/**
	 * 
	 * @param listener
	 *          The listener to be removed.
	 * @throws RemoteException
	 */
	public void removeServiceListener(IRemoteServiceListener listener) throws RemoteException;

	public void register(RemoteInfo rInfo) throws RemoteException;

	public void unregister(RemoteInfo create) throws RemoteException;

	/**
	 * @return
	 * @throws RemoteException
	 * @throws DronologyServiceException
	 */

	List<ServiceInfo> getCoreServices() throws RemoteException, DronologyServiceException;


	public List<ServiceInfo> getFileServices() throws RemoteException, DronologyServiceException;

	List<ServiceInfo> getAllServices() throws RemoteException, DronologyServiceException;

	public void initialize() throws RemoteException, DronologyServiceException;
	public void tearDown()throws RemoteException, DronologyServiceException;


	void contributeService(Class service, IRemoteableService serviceInstance) throws RemoteException, DronologyServiceException;

}
"
SelectionWriter.java,"package edu.nd.dronology.services.extensions.areamapping.util;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.Serializable;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import org.apache.commons.io.FileUtils;

import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import edu.nd.dronology.core.util.FormatUtil;
import edu.nd.dronology.services.core.areamapping.ExportAllocationInformation;
import edu.nd.dronology.services.core.areamapping.ExportDrone;
import edu.nd.dronology.services.core.areamapping.MetricsStatistics;
import edu.nd.dronology.services.core.items.IFlightRoute;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import edu.nd.dronology.services.core.persistence.internal.FlightRouteXStreamPersistor;
import edu.nd.dronology.services.extensions.areamapping.selection.RouteSelectionResult;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class SelectionWriter {

	private static final ILogger LOGGER = LoggerProvider.getLogger(SelectionWriter.class);

	private static final String WRITE_LOCATION = ""/home/michael/mapping/"";

	public static final transient Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()
			.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).setVersion(1.0)
			.serializeSpecialFloatingPointValues().serializeSpecialFloatingPointValues().create();

	private static final String SEPARATOR = "","";
	private FileOutputStream dest;
	private ZipOutputStream out;

	public void writeRouteSelection(RouteSelectionResult selection) {

		long runid = System.currentTimeMillis();
		String format = FormatUtil.formatTimestamp(runid, FormatUtil.FORMAT_FILE);
		if (Files.notExists(Paths.get(WRITE_LOCATION))) {
			new File(WRITE_LOCATION).mkdirs();
		}

		writeStatFile(WRITE_LOCATION + """" + format + "".csv"", selection);
		writeJSONFile(WRITE_LOCATION + """" + format + "".txt"", selection);

		createNewZipFile(WRITE_LOCATION + """" + format + "".zip"");

		zipRoutes(selection);

	}

	private void writeJSONFile(String filename, RouteSelectionResult selection) {

		List<ExportAllocationInformation> allocations = selection.getEportAllocationInformation();
		List<WriteAllocation> writeAllocations = new ArrayList<>();
		for (ExportAllocationInformation info : allocations) {
			WriteAllocation alloc = new WriteAllocation();
			for (ExportDrone dro : info.getDroneAllocations()) {
				WriteData wd = new WriteData(dro.getUAVId());
				dro.getDroneRouteAssignment().forEach(route -> {
					wd.addRoute(route.getName());
				});
				alloc.addAssignment(wd);
			}
			writeAllocations.add(alloc);
		}

		String jsonString = GSON.toJson(writeAllocations);
		try {
			FileUtils.writeStringToFile(new File(filename), jsonString);
		} catch (IOException e) {
			LOGGER.error(e);
		}

	}

	private void zipRoutes(RouteSelectionResult selection) {
		HashMap<String, IFlightRoute> routes = new HashMap<>();

		for (ExportAllocationInformation alloc : selection.getEportAllocationInformation()) {
			for (ExportDrone a : alloc.getDroneAllocations()) {
				for (IFlightRoute r : a.getDroneRouteAssignment()) {
					routes.put(r.getName(), r);
				}
			}
		}

		LOGGER.info(""UNIQUE ROUTES:"" + routes.size());
		routes.forEach((name, route) -> {
			zipRoute(route);
		});
		try {
			out.flush();
			out.finish();
			out.close();
		} catch (IOException e) {
			LOGGER.error(e);
		}

	}

	FlightRouteXStreamPersistor provider = new FlightRouteXStreamPersistor();

	private void zipRoute(IFlightRoute route) {
		try {
			String filename = route.getName().replace("" "", ""_"");

			LOGGER.info(""new zip entry:"" + filename + "".froute"");
			ZipEntry entry = new ZipEntry(filename + "".froute"");
			out.putNextEntry(entry);
			provider.save(route, out, false);
			out.closeEntry();

		} catch (PersistenceException e) {
			LOGGER.error(e);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	private boolean createNewZipFile(final String location) {
		dest = null;
		out = null;

		try {
			dest = new FileOutputStream(location);
			out = new ZipOutputStream(new BufferedOutputStream(dest));
			out.setMethod(ZipOutputStream.DEFLATED);
			return true;
		} catch (IOException e) {
			LOGGER.error(""Error adding file"", e);
		} finally {

			// if (out != null) {
			// try {
			// out.close();
			// } catch (IOException e) {
			// LOGGER.error(e);
			// }
			// }
			// if (dest != null) {
			// try {
			// dest.close();
			// } catch (IOException e) {
			// LOGGER.error(e);
			// }
			// }
		}
		return false;
	}

	private void writeStatFile(String filename, RouteSelectionResult selection) {
		List<String> lines = new ArrayList<>();

		StringBuilder sb = new StringBuilder();

		sb.append(""time"");
		sb.append(SEPARATOR);
		sb.append(""overall"");
		sb.append(SEPARATOR);
		sb.append(""battery"");
		sb.append(SEPARATOR);
		sb.append(""collision"");
		sb.append(SEPARATOR);
		sb.append(""coverage-score"");
		sb.append(SEPARATOR);
		sb.append(""taskequality"");
		sb.append(SEPARATOR);
		sb.append(""allocation-priority"");
		sb.append(SEPARATOR);
		sb.append(""allocation-score"");
		sb.append(SEPARATOR);
		sb.append(""total-distance"");
		sb.append(SEPARATOR);
		sb.append(""USDS-ratio"");
		sb.append(SEPARATOR);
		sb.append(""drone-distances"");

		lines.add(sb.toString());

		for (ExportAllocationInformation allocation : selection.getEportAllocationInformation()) {

			MetricsStatistics stat = allocation.getMetricStatistics();
			double overall = stat.getAllocationScore();
			boolean battery = stat.getBatteryFailed();
			int collision = stat.getCollisions();
			double dsus = stat.getDownstreamToUpstreamRatio();
			double cover = stat.getAllocationCoverage();
			double equality = stat.getEqualityOfTasks();

			double allocationPrority = stat.getAllocationPriorityCoverage();
			double allocationScope = stat.getAllocationScore();
			double totalDistance = stat.getTotalDistance();
			List<Double> distances = stat.getDroneDistances();

			sb = new StringBuilder();

			double time = selection.getSelectionTime();
			sb.append(time);
			sb.append(SEPARATOR);
			sb.append(overall);
			sb.append(SEPARATOR);
			sb.append(battery);
			sb.append(SEPARATOR);
			sb.append(collision);
			sb.append(SEPARATOR);
			sb.append(cover);
			sb.append(SEPARATOR);
			sb.append(equality);
			sb.append(SEPARATOR);
			sb.append(allocationPrority);
			sb.append(SEPARATOR);
			sb.append(allocationScope);
			sb.append(SEPARATOR);
			sb.append(totalDistance);
			sb.append(SEPARATOR);
			sb.append(dsus);
			sb.append(SEPARATOR);
			sb.append(distances.stream().map(i -> i.toString()).collect(Collectors.joining("";"")));
			lines.add(sb.toString());

		}

		try {
			Files.write(Paths.get(filename), lines, Charset.forName(""UTF-8""));
		} catch (IOException e) {
			LOGGER.error(e);
		}

	}

	public class WriteData implements Serializable {

		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private final String uavId;
		private List<String> routes = new ArrayList<>();

		public WriteData(String uavId) {
			this.uavId = uavId;
		}

		public void addRoute(String routeid) {
			routes.add(routeid);
		}

	}

	public class WriteAllocation implements Serializable {
		/**
		 * 
		 */
		private static final long serialVersionUID = 1L;
		private List<WriteData> assignments = new ArrayList<>();

		public void addAssignment(WriteData ass) {
			assignments.add(ass);
		}
	}

}
"
DroneSetupService.java,"package edu.nd.dronology.services.instances.dronesetup;

import java.util.Collection;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.base.AbstractServerService;
import edu.nd.dronology.services.core.info.DroneInitializationInfo;
import edu.nd.dronology.services.core.listener.IDroneStatusChangeListener;
import edu.nd.dronology.services.core.util.DronologyServiceException;


/**
 * 
 * Service for handling UAVs.<br>
 * Allows initializing new UAVs. <br>
 * Allows retrieving active UAVs which returns a proxy ({@link IUAVProxy}) of the actual physical or virtual uav.
 * 
 * 

 * @author Michael Vierhauser
 * 
 *
 */
public class DroneSetupService extends AbstractServerService<IDroneSetupServiceInstance> {

	private static volatile DroneSetupService INSTANCE;

	protected DroneSetupService() {
	}

	/**
	 * @return The singleton ConfigurationService instance
	 */
	public static DroneSetupService getInstance() {
		if (INSTANCE == null) {
			synchronized (DroneSetupService.class) {
				if (INSTANCE == null) {
					INSTANCE = new DroneSetupService();
				}
			}
		}
		return INSTANCE;
	}

	@Override
	protected IDroneSetupServiceInstance initServiceInstance() {
		return new DroneSetupServiceInstance();
	}
 
	public void initializeDrones(DroneInitializationInfo... info) throws DronologyServiceException {
		serviceInstance.initializeDrones(info);
	}

	public void addDroneStatusChangeListener(IDroneStatusChangeListener listener) {
		serviceInstance.addDroneStatusChangeListener(listener);

	}

	public void removeDroneStatusChangeListener(IDroneStatusChangeListener listener) {
		serviceInstance.removeDroneStatusChangeListener(listener);

	}

	public Collection<IUAVProxy> getActiveUAVs() {
		return serviceInstance.getActiveUAVs();
	}

	public void deactivateDrone(IUAVProxy status) throws DronologyServiceException {
		serviceInstance.deactivateDrone(status);

	}

	public IUAVProxy getActiveUAV(String uavId) throws DronologyServiceException {
		return serviceInstance.getActiveUAV(uavId);
 
	}

	public void resendCommand(String uavid) throws DronologyServiceException {
		serviceInstance.resendCommand(uavid);
	}

}
"
MonitoringConnectionTester.java,"package edu.nd.dronology.test;

import edu.nd.dronology.core.monitoring.ArtifactIdentifier;
import edu.nd.dronology.monitoring.reminds.RemoteMessageHandler;
import edu.nd.dronology.monitoring.service.IDroneMonitoringRemoteService;

public class MonitoringConnectionTester {

	public static void main(String[] args) {
		BaseServiceProvider provider = new BaseServiceProvider();

		try {
			System.setProperty(""java.rmi.server.hostname"", ""localhost"");
			
			IDroneMonitoringRemoteService sevice = (IDroneMonitoringRemoteService) provider.getRemoteManager()
					.getService(IDroneMonitoringRemoteService.class);

		//	ArtifactIdentifier id = new ArtifactIdentifier(ArtifactIdentifier.ROOT, ""INTERNAL"");
			ArtifactIdentifier id = new ArtifactIdentifier(ArtifactIdentifier.ROOT);
			// DroneMonitoringService.getInstance().registerMonitoringMessageHandler(new
			// RemoteMessageHandler(), id);
			RemoteMessageHandler handler = new RemoteMessageHandler();
			sevice.registerMonitoringMessageHandler(handler, id);
			
			//ProcessorManager.getInstance().initListener();
			
			
	
	//		new SeparationDistanceChecker();
			
			

		} catch (Throwable e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
"
DispatchQueueManager.java,"package edu.nd.dronology.gstation.connector.dispatch;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.LinkedBlockingQueue;

import edu.nd.dronology.core.DronologyConstants;
import edu.nd.dronology.core.IUAVPropertyUpdateNotifier;
import edu.nd.dronology.core.vehicle.commands.IDroneCommand;
import edu.nd.dronology.core.vehicle.internal.PhysicalDrone;
import edu.nd.dronology.gstation.connector.IUAVSafetyValidator;
import edu.nd.dronology.gstation.connector.messages.AbstractUAVMessage;
import edu.nd.dronology.gstation.connector.messages.UAVHandshakeMessage;
import edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;
import edu.nd.dronology.gstation.connector.messages.UAVStateMessage;
import edu.nd.dronology.gstation.connector.service.connector.DroneConnectorService;
import edu.nd.dronology.services.core.info.DroneInitializationInfo;
import edu.nd.dronology.services.core.info.DroneInitializationInfo.DroneMode;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.instances.dronesetup.DroneSetupService;
import edu.nd.dronology.util.NamedThreadFactory;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * The {@link DispatchQueueManager} handles both <i>incoming</i> and <i>outgoing</i> queues. </br>
 * Incoming queues contain {@link UAVState} received from the UAV to be dispatched to the {@link PhysicalDrone}.<br>
 * The outgoing queue contains {@link IDroneCommand}s being sent to the UAV.
 * 
 * @author Michael Vierhauser
 *
 */
@SuppressWarnings(""rawtypes"")
public class DispatchQueueManager {

	private static final ILogger LOGGER = LoggerProvider.getLogger(DispatchQueueManager.class);

	private static final int NUM_THREADS = 20;
	private static final ExecutorService SERVICE_EXECUTOR = Executors.newFixedThreadPool(NUM_THREADS,
			new NamedThreadFactory(""Dispatch-Threads""));

	private static final boolean USE_MONITORING = true;

	Map<String, BlockingQueue<AbstractUAVMessage>> queueMap = new ConcurrentHashMap<>();
	List<Future> dispatchThreads = new ArrayList<>();

	private BlockingQueue<IDroneCommand> outgoingCommandQueue = new LinkedBlockingDeque<>(100);
	private BlockingQueue<AbstractUAVMessage> monitoringQueue = new LinkedBlockingDeque<>(100);

	private final String groundstationid;

	public String getGroundstationid() {
		return groundstationid;
	}

	private IUAVSafetyValidator validator;

	public DispatchQueueManager(String groundstationid) {
		this.groundstationid = groundstationid;
		if (USE_MONITORING) {
			createMonitoringDispatchThread(monitoringQueue);
		}
	} 

	public void postDroneStatusUpdate(String id, AbstractUAVMessage<?> status) {
		try {
			synchronized (queueMap) {
				boolean success = false;
				if (queueMap.containsKey(id)) {
					success = queueMap.get(id).offer(status);
				} else {
					LOGGER.hwInfo(""No uav with id '"" + id + ""' registered - discarding message"");
					return;
				}
				if (!success) {
					LOGGER.hwFatal(""Buffer overflow! '"" + id + ""'"");
				}
				if (status instanceof UAVStateMessage) {
					forwardToValidator((UAVStateMessage) status);
				}
			}

		} catch (Throwable t) {
			LOGGER.error(t);
		}
	}

	private void forwardToValidator(UAVStateMessage status) {
		try {
			if (!DronologyConstants.USE_MONITORING) {
				return;
			}
			boolean success = false;
			success = monitoringQueue.offer(status);
			if (!success) {
				LOGGER.warn(""MonitoringQueue is Full!"");
			}
		} catch (Throwable e) {
			LOGGER.error(e);
		} 
	}

	private void registerNewDrone(String uavid, UAVHandshakeMessage message) {
		LOGGER.hwInfo(""New drone registered with  '"" + uavid + ""' -> "" + message.toString());
		DroneInitializationInfo info = new DroneInitializationInfo(PysicalDroneIdGenerator.generate(uavid, groundstationid),
				DroneMode.MODE_PHYSICAL, uavid, message.getHome());
		try {
			DroneSetupService.getInstance().initializeDrones(info);
		} catch (DronologyServiceException e) {
			LOGGER.error(e);
		}

	}

	public void createDispatchThread(String id, IUAVPropertyUpdateNotifier listener) {
		try {
			BlockingQueue<AbstractUAVMessage> queue;
			synchronized (queueMap) {
				if (queueMap.containsKey(id)) {
					queue = queueMap.get(id);
				} else {
					queue = new LinkedBlockingQueue<>(DronologyConstants.NR_MESSAGES_IN_QUEUE);
					queueMap.put(id, queue);
				}
			}
			StatusDispatchThread thread = new StatusDispatchThread(queue, listener);

			LOGGER.hwInfo(""New Dispatch-Thread for UAV '"" + id + ""' created"");
			Future<Object> ftr = SERVICE_EXECUTOR.submit(thread);
			dispatchThreads.add(ftr);
		} catch (Throwable t) {
			LOGGER.error(t);
		}
	}

	private void createMonitoringDispatchThread(BlockingQueue<AbstractUAVMessage> queue) {
		MonitoringDispatchThread thread = new MonitoringDispatchThread(queue);

		LOGGER.hwInfo(""New Monitoring Dispatch-Thread created"");
		Future ftr = SERVICE_EXECUTOR.submit(thread);
		dispatchThreads.add(ftr);
	}

	public void tearDown() { 

		LOGGER.hwInfo(""Ground Control Station '"" + groundstationid + ""' terminated"");
		try {
			DroneConnectorService.getInstance().unregisterConnection(groundstationid);
		} catch (Exception e) {
			LOGGER.error(""No groundstation connection with id '"" + groundstationid + ""' registered"");
		}
		for (Future<?> ft : dispatchThreads) {
			ft.cancel(true);
		}
		// SERVICE_EXECUTOR.shutdown();
	}

	public BlockingQueue<IDroneCommand> getOutgoingCommandQueue() {
		return outgoingCommandQueue;
	}

	public void send(IDroneCommand cmd) {
		boolean taken = outgoingCommandQueue.offer(cmd);
		LOGGER.trace(""Command added to queue!"");
		if (!taken) {
			LOGGER.hwFatal(""Outgoing Command queue limit reached - command dropped!"");
		}

	}

	public void postMonitoringMessage(UAVMonitoringMessage message) {
		if (!DronologyConstants.USE_MONITORING) {
			return;
		}
		String uavid = message.getUavid();
		synchronized (queueMap) {
			if (!queueMap.containsKey(uavid)) {
				LOGGER.hwInfo(""No uav with id '"" + uavid + ""' registered - discarding message"");
				return;
			}
		}

		// LOGGER.info(""Message "" + message.getClass().getSimpleName() + "" received :: "" + groundstationid);
		boolean success = false;
		success = monitoringQueue.offer(message);
		if (!success) {
			LOGGER.warn(""MonitoringQueue is Full!"");
		}
	}

	public void postDoneHandshakeMessage(String uavid, UAVHandshakeMessage message) {
 
		if (DronologyConstants.USE_SAFETY_CHECKS) {
			if (validator != null) {
				if (message.getSafetyCase() == null) {
					LOGGER.error(""No safety information provided"");
				} else {
					boolean success = validator.validate(uavid, message.getSafetyCase());
					if (success) {
						registerNewDrone(uavid, message);
					} else {
						LOGGER.error(""Safety checks failed - uav '"" + uavid + ""' not registered!"");
					}
				}
			} else {
				LOGGER.error(""No validator provided"");
			}
		} else {
			registerNewDrone(uavid, message);
		}

	}

	public void registerSafetyValidator(IUAVSafetyValidator validator) {
		this.validator = validator;

	}

}
"
ServiceStatus.java,"package edu.nd.dronology.services.core.api;

/**
 * 
 * Reflects the current status of an {@link IServiceInstance}
 * 
 * @author Michael Vierhauser
 * 
 */
public enum ServiceStatus {

	RUNNING, STOPPED, STARTING, ERROR;

}
"
AbstractDroneFleetFactory.java,"package edu.nd.dronology.core.fleet;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.vehicle.ManagedDrone;

/**
 * Abstract factory class for drone fleet factory
 * 
 * @author Jane
 * 
 */
public abstract class AbstractDroneFleetFactory {
//	private final List<ManagedDrone> drones = new ArrayList<>();

	public AbstractDroneFleetFactory() {
	}

	protected String createDroneID(String droneID) {
		return droneID;
	}

	/**
	 * Returns list of drones
	 * 
	 * @return array list of iDrones
	 * @throws DroneException 
	 */
//	public List<ManagedDrone> getDrones() {
//		return drones;
//	}

	@Deprecated
	abstract public ManagedDrone initializeDrone(String DroneID, String DroneType, double latitude, double longitude,
			double altitude) throws DroneException;

	public void initializeDrone(String id, String type, LlaCoordinate initialLocation) throws DroneException {
		initializeDrone(id, type, initialLocation.getLatitude(), initialLocation.getLongitude(),
				initialLocation.getAltitude());

	}

}
"
PersistableMissionPlan.java,"package edu.nd.dronology.services.extensions.missionplanning.persistence;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import edu.nd.dronology.services.core.items.IMissionPlan;
import edu.nd.dronology.services.core.items.IUAVMissionDescription;

public class PersistableMissionPlan implements IMissionPlan {

	private String name;
	private String id;
	private String description;
	private Map<String, Serializable> attributes = new HashMap<>();
	private List<IUAVMissionDescription> missionDescriptions = new ArrayList<>();

	public PersistableMissionPlan() {
		id = UUID.randomUUID().toString();
		name = id;
	}

	@Override
	public void setName(String name) {
		this.name = name;

	}

	@Override
	public String getId() {
		return id;
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public String getDescription() {
		return description;
	}

	@Override
	public void setDescription(String description) {
		this.description = description;

	}

	public void addAttribute(String key, Serializable value) {
		attributes.put(key, value);
	}

	public Serializable getAttributes(String key) {
		return attributes.get(key);
	}

	@Override
	public List<IUAVMissionDescription> getMissionDescriptions() {
		return Collections.unmodifiableList(missionDescriptions);
	}

	@Override
	public void addMissionDescription(IUAVMissionDescription description) {
		missionDescriptions.add(description);
	}

	public boolean removeMissionDescription(String name) {
		for (IUAVMissionDescription desc : new ArrayList<>(missionDescriptions)) {
			if (desc.getName().equals(name)) {
				missionDescriptions.remove(desc);
				return true;
			}

		}
		return false;
	}

}
"
GeneratedRoutesInfo.java,"package edu.nd.dronology.services.extensions.areamapping.selection;

import java.awt.geom.Path2D.Double;
import java.util.List;

import edu.nd.dronology.services.extensions.areamapping.internal.RiverBank;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;

public class GeneratedRoutesInfo {

	private final double avgLatitude;
	private final List<RoutePrimitive> routePrimitives;
	private final Double totalRiverSegment;
	private final List<RiverBank> bankList;

	public GeneratedRoutesInfo(List<RoutePrimitive> routePrimitives, double avgLatitude, Double totalRiverSegment,
			List<RiverBank> bankList) {
		super();
		this.avgLatitude = avgLatitude;
		this.routePrimitives = routePrimitives;
		this.totalRiverSegment = totalRiverSegment;
		this.bankList = bankList;
	}

	public List<RoutePrimitive> getRoutePrimitives() {
		return routePrimitives;
	}

	public double getAverageLatitude() {
		return avgLatitude;
	}

	public Double getTotalRiverSegment() {
		return totalRiverSegment;
	}

	public List<RiverBank> getBankList() {
		return bankList;
	}

}
"
DronologyMonitoringManager.java,"package edu.nd.dronology.core.monitoring;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import edu.nd.dronology.util.NamedThreadFactory;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class DronologyMonitoringManager {

	private static DronologyMonitoringManager INSTANCE = new DronologyMonitoringManager();

	private static final ILogger LOGGER = LoggerProvider.getLogger(DronologyMonitoringManager.class);

	private static final BlockingQueue<IMonitorableMessage> queue = new ArrayBlockingQueue<>(500);

	private static final ExecutorService SERVICE_EXECUTOR = Executors
			.newSingleThreadExecutor(new NamedThreadFactory(""Monitoring-Manager""));

	private boolean handlerRegistered;

	/**
	 * 
	 * @return The singleton instance.
	 */
	public static DronologyMonitoringManager getInstance() {

		if (INSTANCE == null) {
			synchronized (DronologyMonitoringManager.class) {
				if (INSTANCE == null) {
					INSTANCE = new DronologyMonitoringManager();
				}
			}
		}
		return INSTANCE;
	}

	public void publish(IMonitorableMessage message) {
		try {
			if (!handlerRegistered) {
				return;
			}

			boolean taken = queue.offer(message);
			if (!taken) {
				LOGGER.error(""Monitoring queue full!"");
			}
		} catch (Throwable t) {
			LOGGER.error(t); 
		}

	}

	public void registerHandler(IMonitoringDataHandler handler) {
		handler.setQueue(queue);
		handlerRegistered = true;
		SERVICE_EXECUTOR.submit(handler);
	}

}
"
IManagedDroneStateChangeListener.java,"package edu.nd.dronology.core.vehicle;

public interface IManagedDroneStateChangeListener {

	public void notifyStateChange();

}
"
DroneConnectorServiceInstance.java,"package edu.nd.dronology.gstation.connector.service.connector;

import java.text.DateFormat;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import edu.nd.dronology.core.DronologyConstants;
import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.fleet.RuntimeDroneTypes;
import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.gstation.connector.GroundStationException;
import edu.nd.dronology.gstation.connector.GroundstationConnector;
import edu.nd.dronology.gstation.connector.connect.IncommingGroundstationConnectionServer;
import edu.nd.dronology.gstation.connector.messages.ConnectionRequestMessage;
import edu.nd.dronology.services.core.base.AbstractServiceInstance;
import edu.nd.dronology.services.instances.dronesetup.DroneSetupService;
import edu.nd.dronology.util.NamedThreadFactory;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class DroneConnectorServiceInstance extends AbstractServiceInstance implements IDroneConnectorServiceInstance {
	ExecutorService connectionExecutor = Executors.newFixedThreadPool(DronologyConstants.MAX_GROUNDSTATIONS,
			new NamedThreadFactory(""Connection-Socket-Threads""));

	private static final ILogger LOGGER = LoggerProvider.getLogger(DroneConnectorServiceInstance.class);

	static final transient Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()
			.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)
			.setVersion(1.0).serializeSpecialFloatingPointValues().create();

	private IncommingGroundstationConnectionServer server;
	private Map<String, GroundstationConnector> activeConnections = new HashMap<>();

	public DroneConnectorServiceInstance() {
		super(""DRONECONNECTOR"");
	}

	@Override
	protected Class<?> getServiceClass() {
		return DroneConnectorService.class;
	}

	@Override
	protected int getOrder() {
		// TODO Auto-generated method stub
		return 3;
	}

	@Override
	protected String getPropertyPath() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected void doStartService() throws Exception {
		server = new IncommingGroundstationConnectionServer();
		servicesExecutor.submit(server);
	}

	@Override
	protected void doStopService() throws Exception {
		// TODO Auto-generated method stub

	}

	@Override
	public void unregisterConnection(String connectionId) throws GroundStationException {
		if (activeConnections.containsKey(connectionId)) {
			LOGGER.info(""Removing connection!"" + connectionId);
			GroundstationConnector conn = activeConnections.remove(connectionId);
			conn.tearDown(); 
			unregisterDrones(connectionId);
			try {
				RuntimeDroneTypes.getInstance().unregisterCommandHandler(connectionId);
			} catch (DroneException e) {
				throw new GroundStationException(""Connection with id "" + connectionId + "" not found"");
			}
		} else {
			throw new GroundStationException(""Connection with id "" + connectionId + "" not found"");
		}
	}

	private synchronized void unregisterDrones(String groundstationid) {

		Collection<IUAVProxy> activeDrones = DroneSetupService.getInstance().getActiveUAVs();
		for (IUAVProxy st : activeDrones) {
			if (st.getGroundstationId().equals(groundstationid)) {
				try {
					DroneSetupService.getInstance().deactivateDrone(st);
				} catch (Throwable e) {
					LOGGER.error(e);
				}
			}
		}
	}

	@Override
	public void handleConnection(GroundstationConnector connectionHandler) {
		if (activeConnections.size() >= DronologyConstants.MAX_GROUNDSTATIONS) {
			LOGGER.warn(""Connection Limit reached - no new parallel connections can be added!"");
			return;
		}

		Future<?> future = connectionExecutor.submit(connectionHandler);
	}

	@Override
	public void registerConnection(GroundstationConnector connector, ConnectionRequestMessage msg)
			throws GroundStationException {
		LOGGER.info(""Connection requested by groundstation '"" + msg.getGCSId() + ""'"");
		String groundstationId = msg.getGCSId();
		if (activeConnections.containsKey(groundstationId)) {
			throw new GroundStationException(""Groundstation already registered! "" + groundstationId);
		}
		activeConnections.put(groundstationId, connector);
	}

}
"
SupervisorServiceInstance.java,"package edu.nd.dronology.services.supervisor;

import java.util.Collections;
import java.util.Map;

import edu.nd.dronology.services.core.api.ServiceInfo;
import edu.nd.dronology.services.core.base.AbstractServerService;
import edu.nd.dronology.services.core.base.AbstractServiceInstance;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class SupervisorServiceInstance extends AbstractServiceInstance implements ISupervisorServiceInstance {

	private static final ILogger LOGGER = LoggerProvider.getLogger(SupervisorServiceInstance.class);

	private static String customWorkspace;

	public SupervisorServiceInstance() {
		super(""SUPERVISOR"", ""Managing the server"");
	}

	@Override
	protected Class<?> getServiceClass() {
		return SupervisorService.class;
	}

	@Override
	protected int getOrder() {
		return 1;
	}

	@Override
	protected String getPropertyPath() {
		return null;
	}

	@Override
	protected void doStartService() throws Exception {
		WorkspaceInitializer.getInstance().prepareServerWorkspace(SupervisorService.getWorkspace());
		LogCleaner.run();
		
		
	}

	@Override
	protected void doStopService() throws Exception {
		// TODO Auto-generated method stub
	}

	@Override
	public void shutdownServer() {
		LOGGER.info(""Shuting Down - Services"");
		AbstractServerService.stopAll();
		LOGGER.info(""Shutting down application - bye!"");
		System.exit(0);
	}

	@Override
	public void restartAllServices() {
		LOGGER.info(""Restarting all Services!"");

		AbstractServerService.restartAll();

	}

	@Override
	public ServiceInfo getServiceInfo() {
		ServiceInfo sInfo = super.getServiceInfo();
		sInfo.addAttribute(ServiceInfo.ATTRIBUTE_TYPE, ServiceInfo.ATTRIBUTE_REMOTE);
		return sInfo;
	}

	@Override
	public String getFlightPathLocation() {
		return WorkspaceInitializer.getInstance().getFlightRouteLocation();
	}



	@Override
	public String getWorkspaceLocation() {
		return WorkspaceInitializer.getInstance().getWorkspaceLocation();
	}

	@Override
	public Map<String, String> getGlobalProperties() {
		//return GlobalConfReader.getGlobalPropertySet();\
		return Collections.emptyMap();
	}

	@Override
	public boolean importItem(String fileName, byte[] byteArray, boolean overwrite) throws DronologyServiceException {
		return WorkspaceInitializer.getInstance().importItem(fileName, byteArray, overwrite);
	}

	@Override
	protected boolean hasProperties() {
		return false;
	}

	@Override
	public String getDroneSpecificationLocation() {
		return WorkspaceInitializer.getInstance().getDroneSpecificationLocation();
	}

	@Override
	public String getSimScenarioLocation() {
		return WorkspaceInitializer.getInstance().getSimScenarioLocation();
	}

	@Override
	public String getAreaMappingLocation() {
		return WorkspaceInitializer.getInstance().getAreaMappingLocation();
	}

	@Override
	public String getMissionPlanningLocation() {
		return WorkspaceInitializer.getInstance().getMissionPlanningLocation();
	}



}"
ManagedDrone.java,"package edu.nd.dronology.core.vehicle;

import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;

import com.google.common.util.concurrent.RateLimiter;

import edu.nd.dronology.core.Discuss;
import edu.nd.dronology.core.DronologyConstants;
import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;
import edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;
import edu.nd.dronology.core.collisionavoidance.DroneSnapshotOption;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.NedCommand;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand;
import edu.nd.dronology.core.coordinate.AbstractPosition;
import edu.nd.dronology.core.goal.AbstractGoal;
import edu.nd.dronology.core.goal.AbstractGoal.GoalState;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.exceptions.FlightZoneException;
import edu.nd.dronology.core.fleet.DroneFleetManager;
import edu.nd.dronology.core.flight.FlightDirectorFactory;
import edu.nd.dronology.core.flight.IFlightDirector;
import edu.nd.dronology.core.monitoring.DronologyMonitoringManager;
import edu.nd.dronology.core.monitoring.MessageMarshaller;
import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;
import edu.nd.dronology.core.goal.IGoalSnapshot;
import edu.nd.dronology.core.goal.WaypointGoal;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.core.vehicle.commands.AbstractDroneCommand;
import edu.nd.dronology.core.vehicle.commands.EmergencyStopCommand;
import edu.nd.dronology.core.vehicle.manageddroneinternal.*;
import edu.nd.dronology.core.vehicle.manageddroneinternal.message.AbstractMessage;
import edu.nd.dronology.core.vehicle.manageddroneinternal.message.AssignFlightMessage;
import edu.nd.dronology.core.vehicle.manageddroneinternal.message.GetSnapshotMessage;
import edu.nd.dronology.core.vehicle.manageddroneinternal.message.GoalUpdateMessage;
import edu.nd.dronology.core.vehicle.manageddroneinternal.message.UnassignFlightMessage;
import edu.nd.dronology.core.vehicle.manageddroneinternal.message.UpdateGuidanceMessage;
import edu.nd.dronology.core.vehicle.proxy.UAVProxyManager;
import edu.nd.dronology.util.NamedThreadFactory;
import edu.nd.dronology.util.NullUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Handler class for both {@link VirtualDrone} and {@link PhysicalDrone}.<br>
 * Handles basic functionality that is independent of a virtual or physical endpoint.<br>
 * Contains information on coordinates, state, and flight instructions.
 *  
 *  
 * @author Jane Cleland-Huang
 */
@Discuss(discuss = ""does the drone need to be observable?"")
public class ManagedDrone extends Observable implements Runnable, Observer {
	// region fields
	private static final ILogger LOGGER = LoggerProvider.getLogger(ManagedDrone.class);

	private AtomicBoolean cont = new AtomicBoolean(true);

	private RateLimiter LIMITER = RateLimiter.create(10);

	private static final ExecutorService EXECUTOR_SERVICE = Executors
			.newFixedThreadPool(DronologyConstants.MAX_DRONE_THREADS, new NamedThreadFactory(""ManagedDrone""));

	private final IDrone drone; // Controls primitive flight commands for drone

	private DroneFlightStateManager droneState;
	private DroneSafetyStateManager droneSafetyState;

	@Discuss(discuss = ""why not final? - new flight director for each flight??"")
	private IFlightDirector flightDirector = null; // Each drone can be assigned
	// a single flight plan.
	private volatile double targetAltitude = 0;

	private Timer haltTimer = new Timer();
	private HaltTimerTask currentHaltTimer;

	private List<AbstractGoal> goals;
	private Set<AbstractGoal> activeGoals = new HashSet<>();
	private List<Command> commandQueue = new ArrayList<>();
	private List<Command> completedCommands = new ArrayList<>();
	private Command currentCommand;
	private CommandExecutor currentExecutor;

	private final ManagedDroneMessenger messenger;
	// TODO figure out what this value should be
	private static final int MAILBOX_CAPACITY = 50;
	private static final boolean FIFO_MAILBOX = true;
	private final ArrayBlockingQueue<AbstractMessage> mailbox = new ArrayBlockingQueue<>(MAILBOX_CAPACITY,
			FIFO_MAILBOX);
	private final CommandExecutorFactory executorFactory;
	private final CountDownLatch startGate = new CountDownLatch(1);
	// endregion

	/**
	 * Constructs drone
	 *
	 * @param drone
	 */
	public ManagedDrone(IDrone drone) {
		NullUtil.checkNull(drone);
		this.drone = drone;// specify
		droneState = new DroneFlightStateManager(this);
		droneSafetyState = new DroneSafetyStateManager();
		drone.getDroneStatus().setStatus(droneState.getStatus());
		this.flightDirector = FlightDirectorFactory.getFlightDirector(this); // Don't
		droneState.addStateChangeListener(() -> notifyStateChange());
		this.goals = new ArrayList<>();
		this.messenger = new ManagedDroneMessenger(mailbox);
		this.executorFactory = new CommandExecutorFactory(this.drone);
	}

	private class HaltTimerTask extends TimerTask {

		@Override
		public void run() {
			synchronized (droneSafetyState) {
				if (!droneSafetyState.isSafetyModeHalted()) {
					currentHaltTimer = null;
					return;
				}

				try {
					droneSafetyState.setSafetyModeToNormal();
					droneState.setModeToFlying();
					currentHaltTimer = null;
				} catch (FlightZoneException e) {
					LOGGER.error(e);
				}
			}
		}

	}

	// region public methods
	/**
	 * Get the messenger associated with this drone. Client code needing to access
	 * this drone's functionality must do so through the messenger.
	 * 
	 * @return The messenger that can command this managed drone to carry out
	 *         operations.
	 */
	public ManagedDroneMessenger getMessenger() {
		return messenger;
	}

	/**
	 * Blocks until the ManagedDrone run method has been called.
	 */
	public void awaitStart() {
		try {
			this.startGate.await();
		} catch (InterruptedException e) {
			throw new RuntimeException(e);
		}
	}

	public void returnToHome() {
		synchronized (droneSafetyState) {
			getFlightSafetyModeState().setSafetyModeToNormal();

			if (currentHaltTimer != null) {
				currentHaltTimer.cancel();
				currentHaltTimer = null;
			}

		}

	}

	/**
	 *
	 * @param targetAltitude Sets target altitude for takeoff
	 */
	public void setTargetAltitude(double targetAltitude) {
		this.targetAltitude = targetAltitude;
	}

	/**
	 * Controls takeoff of drone
	 *
	 * @throws FlightZoneException
	 */
	public void takeOff() throws FlightZoneException {
		if (targetAltitude == 0) {
			throw new FlightZoneException(""Target Altitude is 0"");
		}
		droneState.setModeToTakingOff();
		drone.takeOff(targetAltitude);

	}

	/**
	 * Delegates flyto behavior to virtual or physical drone
	 *
	 * @param targetCoordinates
	 * @param speed
	 */
	public void flyTo(LlaCoordinate targetCoordinates, Double speed) {
		drone.flyTo(targetCoordinates, speed);
	}

	/**
	 * Gets current coordinates from virtual or physical drone
	 *
	 * @return current coordinates
	 */
	public LlaCoordinate getCoordinates() {
		return drone.getCoordinates();
	}

	public void start() {
		// thread.start();
		LOGGER.info(""Starting Drone '"" + drone.getDroneName() + ""'"");
		EXECUTOR_SERVICE.submit(this);
	}

	public boolean isStarted() {
    	try {
			return this.startGate.await(0, TimeUnit.NANOSECONDS);
		} catch (InterruptedException e) {
			LOGGER.error(e);
			return false;
		}
	}
		

	@Override
	public void run() {
		try {
			this.startGate.countDown();
			while (cont.get() && !Thread.currentThread().isInterrupted()) {
				LIMITER.acquire();
				
				processAllMessages();

				// Probably not necessary anymore... TODO: fix- do not try to assign point in
				// every iteration of the loop...
				if (flightDirector != null && droneState.isFlying()) {
					this.flyDrone();
					/*
					 * LlaCoordinate targetCoordinates = flightDirector.flyToNextPoint();
					 * drone.flyTo(); if (!drone.move(0.1)) {
					 * LOGGER.missionInfo(drone.getDroneName() + "" - Waypoint reached - "" +
					 * targetCoordinates.toString()); flightDirector.clearCurrentWayPoint(); }
					 */
					checkForEndOfFlight();
				}
				if (droneState.isTakingOff()) {
					if (Math.abs(drone.getAltitude() - targetAltitude) < DronologyConstants.THRESHOLD_TAKEOFF_HEIGHT) {
						LOGGER.info(""Target Altitude reached - ready for flying"");
						try {
							droneState.setModeToFlying();
						} catch (FlightZoneException e) {
							LOGGER.error(e);
						}
					}
				}
			}
		} catch (Throwable e) {
			LOGGER.error(e);
		}
		LOGGER.info(""UAV-Thread '"" + drone.getDroneName() + ""' terminated"");
		UAVProxyManager.getInstance().removeDrone(getDroneName());
	}
	// needs refactoring to improve performance...
	public boolean permissionForTakeoff() {
		double dronDistance = 0;
		List<ManagedDrone> flyingDrones = DroneFleetManager.getInstance().getRegisteredDrones();
		for (ManagedDrone drone2 : flyingDrones) {
			if (!this.equals(flyingDrones) 
					&& (drone2.getFlightModeState().isFlying() || drone2.getFlightModeState().isInAir())) {
				dronDistance = this.getCoordinates().distance(drone2.getCoordinates());
				if (dronDistance < DronologyConstants.SAFETY_ZONE) {
					LOGGER.error(""Safety Distance Violation - Drone not allowed to TakeOff! distance: "" + dronDistance
							+ "" safety zone: "" + DronologyConstants.SAFETY_ZONE + "" => "" + dronDistance);
					return false;
				}
			}
		}
		return true;
	}

	/**
	 *
	 * @return unique drone ID
	 */
	public String getDroneName() {
		return drone.getDroneName();
	}

	/**
	 * Land the drone. Delegate land functions to virtual or physical drone
	 *
	 * @throws FlightZoneException
	 */
	public void land() throws FlightZoneException {
		if (!droneState.isLanding() || !droneState.isOnGround()) {
			droneState.setModeToLanding();
			drone.land();
			droneState.setModeToOnGround();
			unassignFlight();
		}
	}

	/**
	 * Temporarily Halt
	 *
	 * @param haltinms
	 */
	public void haltInPlace(int haltinms) {
		synchronized (droneSafetyState) {
			try {
				if (currentHaltTimer != null) {
					return;
					// currentHaltTimer.cancel();
					// droneSafetyState.setSafetyModeToNormal();
					// droneState.setModeToFlying();
					// currentHaltTimer = null;
				} else {
					droneSafetyState.setSafetyModeToHalted();
					droneState.setModeToInAir();
					currentHaltTimer = new HaltTimerTask();
					haltTimer.schedule(currentHaltTimer, haltinms);
				}

			} catch (FlightZoneException e) {
				LOGGER.error(e);
			}
		}
	}

	/**
	 * Temporarily Halt
	 * 
	 * @param haltinms
	 * @throws FlightZoneException
	 */
	public void resumeFlight() throws FlightZoneException {
		synchronized (droneSafetyState) {
			if (currentHaltTimer == null) {
				throw new FlightZoneException(""UAV not halted"");
			} else {
				currentHaltTimer.cancel();
				droneSafetyState.setSafetyModeToNormal();
				droneState.setModeToFlying();
				currentHaltTimer = null;
			}
		}
	}

	/**
	 * 
	 *
	 * return current flight mode state
	 *
	 * @return droneState
	 */
	public DroneFlightStateManager getFlightModeState() {
		return droneState;
	}

	public LlaCoordinate getBaseCoordinates() {
		return drone.getBaseCoordinates();
	}

	public void sendCommand(AbstractDroneCommand command) throws DroneException {
		drone.sendCommand(command);

	}

	public void stop() {
		if (!droneState.isOnGround()) {
			LOGGER.warn(""Removing UAV '"" + drone.getDroneName() + ""' while in state "" + droneState.getStatus());
		} else {
			LOGGER.info(""Removing UAV '"" + drone.getDroneName() + ""'"");
		}
		cont.set(false);
		haltTimer.cancel();
	}

	public void emergencyStop() throws DroneException {
		LOGGER.warn(""Emergency stop for UAV '"" + drone.getDroneName() + ""' requested"");
		sendCommand(new EmergencyStopCommand(drone.getDroneName()));

	}

	public void resendCommand() throws DroneException {
		drone.resendCommand();

	}

	public DroneSnapshot getSnapshot() {
		DroneSnapshotInternal snapshot = drone.getLatestDroneSnapshot();
		if (snapshot == null) {
			LOGGER.debug(""The backend drone didn't provide a snapshot"");
			return null;
		}
		snapshot.setName(drone.getDroneName());
		snapshot.getCommands().clear();
		for (Command cmd : commandQueue) {
			snapshot.getCommands().add(cmd);
		}

		snapshot.setState(droneState.getStatus());

		HashSet<IGoalSnapshot> activeGoalSnapshots = new HashSet<>();
		// need a thread safe way to copy the set of active goals
		for (AbstractGoal goal : activeGoals) {
			activeGoalSnapshots.add(goal.buildSnapshot());
		}
		snapshot.setGoals(activeGoalSnapshots);

		return snapshot;
	}

	@Override
	public void update(Observable observable, Object o) {
		if (observable instanceof AbstractGoal) {
			this.messenger.updateGoal((AbstractGoal) observable);
		}
	}
	
	private void updateGoals(AbstractGoal goal) {
		GoalState state = goal.getState();
		if (state == GoalState.ACTIVE) {
			activeGoals.add(goal);
		} else {
			activeGoals.remove(goal);
		}
	}
	// endregion

	// region private methods

	private void processAllMessages() {
		try {
			AbstractMessage msg = this.mailbox.poll(0, TimeUnit.NANOSECONDS);
			while (msg != null) {
				processesMessage(msg);
				msg = this.mailbox.poll(0, TimeUnit.NANOSECONDS);
			}
			
		} catch (Exception e) {
			LOGGER.error(e);
		}
	}

	private void processesMessage(AbstractMessage msg) {
		if (msg instanceof GetSnapshotMessage) {
			processGetSnapshotMessage((GetSnapshotMessage) msg);
		} else if (msg instanceof UpdateGuidanceMessage) {
			processUpdateGuidanceMessage((UpdateGuidanceMessage) msg);
		} else if (msg instanceof AssignFlightMessage) {
			processAssignFlightMessage((AssignFlightMessage) msg);
		} else if (msg instanceof UnassignFlightMessage) {
			processUnassignFlightMessage((UnassignFlightMessage) msg);
		} else if (msg instanceof GoalUpdateMessage) {
			processGoalUpdateMessage((GoalUpdateMessage) msg);
		}
	}

	private void processGetSnapshotMessage(GetSnapshotMessage msg) {
		try {
			msg.returnBox.put(new DroneSnapshotOption(this.getSnapshot(), this.getDroneName()));
		} catch (InterruptedException e) {
			e.printStackTrace();
			LOGGER.error(e);
		}
	}

	private void processUpdateGuidanceMessage(UpdateGuidanceMessage msg) {
		this.updateGuidance(msg.commands);
	}

	private void processAssignFlightMessage(AssignFlightMessage msg) {
		assignFlight(msg.flightDirective);
	}

	private void processUnassignFlightMessage(UnassignFlightMessage msg) {
		unassignFlight();
	}

	private void processGoalUpdateMessage(GoalUpdateMessage msg) {
		updateGoals(msg.goal);
	}

	private void notifyStateChange() {
		drone.getDroneStatus().setStatus(droneState.getStatus());
	}

		/**
	 * Assigns a flight directive to the managed drone
	 *
	 * @param flightDirective
	 */
	private void assignFlight(IFlightDirector flightDirective) {
		LOGGER.debug(""Assigning flight director"");
		clearGoals();
		this.flightDirector = flightDirective;

		LOGGER.trace(""The flight has "" + flightDirector.getWayPoints().size() + "" waypoints"");
		// Create waypoint goals for each waypoint in the flight director.
		for (Waypoint wp : flightDirector.getWayPoints()) {
			WaypointGoal wpg = new WaypointGoal(wp);

			// Add an observer that will update the GUI when this waypoint is reached.
			wpg.addObserver((observable, o) -> {
				GoalState state = ((AbstractGoal) observable).getState();

				if (state == GoalState.COMPLETE) {
					wp.reached(true);
					DronologyMonitoringManager.getInstance().publish( 
						MessageMarshaller.createMessage(MessageType.WAYPOINT_REACHED, drone.getDroneName(), wp.getCoordinate()));
				}
			});

			addGoal(wpg);
		}

		completedCommands.clear();
		commandQueue.clear();

		if (!goals.isEmpty()) {
			Thread tmpThread = new Thread(new Runnable(){
			
				@Override
				public void run() {
					goals.get(0).setActive();
				}
			});
			tmpThread.start();
			int lastIndex = goals.size() - 1;
			goals.get(lastIndex).addObserver((observable, o) -> {
				GoalState state = ((AbstractGoal) observable).getState();

				if (state == GoalState.COMPLETE) {
					try {
						droneState.setModeToInAir();
					} catch (FlightZoneException e) {
						LOGGER.warn(e);
					}
				}
			});
		}
	}

	/**
	 * Removes an assigned flight
	 */
	private void unassignFlight() {
		flightDirector = null; // DANGER. NEEDS FIXING. CANNOT UNASSIGN FLIGHT
		// WITHOUT RETURNING TO BASE!!!
		LOGGER.warn(""Unassigned DRONE: "" + getDroneName());
		clearGoals();
	}

	// Check for end of flight. Land if conditions are satisfied
	private boolean checkForEndOfFlight() {
		if (flightDirector != null && flightDirector.readyToLand())
			return false; // it should have returned here.
		if (droneState.isLanding())
			return false;
		if (droneState.isOnGround())
			return false;
		if (droneState.isInAir())
			return false;

		// Otherwise
		try {
			land();
		} catch (FlightZoneException e) {
			LOGGER.error(getDroneName() + "" is not able to land!"", e);
		}
		return true;
	}

	/**
	 *
	 * @return current safety mode state
	 */
	public DroneSafetyStateManager getFlightSafetyModeState() {
		return droneSafetyState;
	}

	private void flyDrone() {
		// check to see if we are flying the right command
		if (commandQueue.size() < 1) {
			commandQueue.add(new StopCommand(0.0));
		}
		if (commandQueue.get(0) != currentCommand) {
			currentCommand = commandQueue.get(0);
			currentExecutor = executorFactory.makeExecutor(currentCommand);
		}

		currentExecutor.process();

		if (currentExecutor.isFinished()) {
			Command current = commandQueue.remove(0);
			completedCommands.add(current);
			LOGGER.missionInfo(drone.getDroneName() + "" command completed: "" + current.toString());
		}
	}

	private boolean isCompleted(Command ref) {
		NullUtil.checkNull(ref);
		int index = 0;
		while (index < completedCommands.size()) {
			if (completedCommands.get(index) == ref) {
				return true;
			}
			++index;
		}
		return false;
	}

	private void updateGuidance(List<Command> commands) {
		LOGGER.debug(""New guidance from CA: "" + commands.stream().map(Object::toString).collect(Collectors.joining("", "", ""["", ""]"")));
		NullUtil.checkNull(commands);
		// find the first item in commands that is not completed
		// what if the first command is new and a later command is completed?
		int index = 0;

		while (index < commands.size() && isCompleted(commands.get(index))) {
			++index;
		}

		commandQueue.clear();
		if (index >= commands.size()) {
			commandQueue.add(new StopCommand(0.0));
		} else {
			List<Command> remaining = commands.subList(index, commands.size());
			for (Command cmd : remaining) {
				commandQueue.add(cmd);
			}
		}
	}

	private void clearGoals() {
		goals.clear();
		activeGoals.clear();
	}

	private void addGoal(AbstractGoal goal) {
		NullUtil.checkNull(goal);

		// ManagedDrone should observe each goal.
		// When the goal changes state, ManagedDrone needs to update its active goals.
		goal.addObserver(this);
		((AbstractDrone) drone).addObserver(goal);

		// If the new goal is a WaypointGoal, it needs to observe the previous
		// WaypointGoal (if one exists).
		if (goal instanceof WaypointGoal) {
			int lastWaypointIdx = -1;

			// Find the index of the previous waypoint goal.
			for (int i = 0; i < goals.size(); i++) {
				if (goals.get(i) instanceof WaypointGoal) {
					lastWaypointIdx = i;
				}
			}

			// If there is a previous waypoint goal, make the new goal an observe of it.
			// When the previous waypoint is completed, the new goal will become active.
			if (lastWaypointIdx >= 0) {
				goals.get(lastWaypointIdx).addObserver(goal);
			}

		}

		goals.add(goal);
	}
	// endregion
}
"
AreaMappingServiceRemoteFacade.java,"package edu.nd.dronology.services.extensions.areamapping.facade;

import java.rmi.RemoteException;
import java.util.Collection;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.areamapping.GeneratedMappedArea;
import edu.nd.dronology.services.core.info.AreaMappingCategoryInfo;
import edu.nd.dronology.services.core.info.AreaMappingInfo;
import edu.nd.dronology.services.core.listener.IItemChangeListener;
import edu.nd.dronology.services.core.remote.IAreaMappingRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.extensions.areamapping.instances.AreaMappingService;
import edu.nd.dronology.services.instances.flightmanager.FlightManagerService;
import edu.nd.dronology.services.remote.AbstractRemoteFacade;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider; 

/**
 * 
 * 
 * 
 * @author Michael Vierhauser
 *
 */
public class AreaMappingServiceRemoteFacade extends AbstractRemoteFacade implements IAreaMappingRemoteService {
	/**
	 * 
	 */
	private static final long serialVersionUID = -4580658378477037955L;
	private static final ILogger LOGGER = LoggerProvider.getLogger(AreaMappingServiceRemoteFacade.class);
	private static volatile AreaMappingServiceRemoteFacade INSTANCE;

	protected AreaMappingServiceRemoteFacade() throws RemoteException {
		super(FlightManagerService.getInstance());
	}

	public static IAreaMappingRemoteService getInstance() throws RemoteException {
		if (INSTANCE == null) {
			try {
				synchronized (AreaMappingServiceRemoteFacade.class) {
					if (INSTANCE == null) {
						INSTANCE = new AreaMappingServiceRemoteFacade();
					}
				}

			} catch (RemoteException e) {
				LOGGER.error(e);
			}
		}
		return INSTANCE;
	}

	@Override
	public byte[] requestFromServer(String id) throws RemoteException, DronologyServiceException {
		return AreaMappingService.getInstance().requestFromServer(id);
	}

	@Override
	public void transmitToServer(String id, byte[] content) throws RemoteException, DronologyServiceException {
		AreaMappingService.getInstance().transmitToServer(id, content);
	}

	@Override
	public boolean addItemChangeListener(IItemChangeListener listener) throws RemoteException {
		return AreaMappingService.getInstance().addItemChangeListener(listener);
	}

	@Override
	public boolean removeItemChangeListener(IItemChangeListener listener) throws RemoteException {
		return AreaMappingService.getInstance().removeItemChangeListener(listener);

	}

	@Override
	public Collection<AreaMappingInfo> getItems() throws RemoteException {
		return AreaMappingService.getInstance().getItems();

	}

	@Override
	public AreaMappingInfo createItem() throws RemoteException, DronologyServiceException {
		return AreaMappingService.getInstance().createItem();

	}

	@Override
	public void deleteItem(String itemid) throws RemoteException, DronologyServiceException {
		AreaMappingService.getInstance().deleteItem(itemid);

	}

	@Override
	public Collection<AreaMappingCategoryInfo> getMappingPathCategories() throws RemoteException {
		return AreaMappingService.getInstance().getMappingPathCategories();
	}

	@Override
	public GeneratedMappedArea generateAreaMapping(AreaMappingInfo info)
			throws DronologyServiceException, RemoteException {
		return AreaMappingService.getInstance().generateAreaMapping(info);
	}
	
	@Override
	public GeneratedMappedArea generateAreaMapping(AreaMappingInfo info, Collection<IUAVProxy> selectedUAVs)
			throws DronologyServiceException, RemoteException {
		return AreaMappingService.getInstance().generateAreaMapping(info,selectedUAVs);
	}

	@Override
	public void executeAreaMapping(GeneratedMappedArea area) throws DronologyServiceException, RemoteException {
		AreaMappingService.getInstance().executeAreaMapping(area);

	}



}"
AreaMappingServiceInstance.java,"package edu.nd.dronology.services.extensions.areamapping.instances;

import java.io.File;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.api.IFileChangeNotifyable;
import edu.nd.dronology.services.core.areamapping.EdgeLla;
import edu.nd.dronology.services.core.areamapping.ExportDrone;
import edu.nd.dronology.services.core.areamapping.GeneratedMappedArea;
import edu.nd.dronology.services.core.base.AbstractFileTransmitServiceInstance;
import edu.nd.dronology.services.core.info.AreaMappingCategoryInfo;
import edu.nd.dronology.services.core.info.AreaMappingInfo;
import edu.nd.dronology.services.core.items.IAreaMapping;
import edu.nd.dronology.services.core.items.IFlightRoute;
import edu.nd.dronology.services.core.persistence.AreaMappingPersistenceProvider;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import edu.nd.dronology.services.core.util.DronologyConstants;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.core.util.ServiceIds;
import edu.nd.dronology.services.extensions.areamapping.AreaMappingGenerator;
import edu.nd.dronology.services.instances.dronesetup.DroneSetupService;
import edu.nd.dronology.services.instances.flightmanager.FlightManagerService;
import edu.nd.dronology.services.supervisor.SupervisorService;
import edu.nd.dronology.util.FileUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class AreaMappingServiceInstance extends AbstractFileTransmitServiceInstance<AreaMappingInfo>
		implements IFileChangeNotifyable, IAreaMappingServiceInstance {

	private static final ILogger LOGGER = LoggerProvider.getLogger(AreaMappingServiceInstance.class);

	public static final String EXTENSION = DronologyConstants.EXTENSION_AREA;

	private Collection<AreaMappingCategoryInfo> categories = new ArrayList<>();

	public AreaMappingServiceInstance() {
		super(ServiceIds.SERVICE_AREAMAPPING, ""Area Mapping"", EXTENSION);
	}

	@Override
	protected Class<?> getServiceClass() {
		return AreaMappingService.class;
	}

	@Override
	protected int getOrder() {
		return 2;
	}

	@Override
	protected String getPropertyPath() {
		return null;
	}

	@Override
	protected void doStartService() throws Exception {
		reloadItems();
	}

	@Override
	protected void doStopService() throws Exception {
		fileManager.tearDown();
	}

	@Override
	public AreaMappingInfo createItem() throws DronologyServiceException {
		AreaMappingPersistenceProvider persistor = AreaMappingPersistenceProvider.getInstance();
		IAreaMapping areaMapping = DronologyElementFactory.createNewAreaMapping();
		areaMapping.setName(""New-AreaMapping"");
		String savePath = FileUtil.concat(storagePath, areaMapping.getId(), EXTENSION);

		try {
			persistor.saveItem(areaMapping, savePath);
		} catch (PersistenceException e) {
			throw new DronologyServiceException(""Error when creating area mapping: "" + e.getMessage());
		}
		return new AreaMappingInfo(areaMapping.getName(), areaMapping.getId());
	}

	@Override
	protected String getPath() {
		String path = SupervisorService.getInstance().getAreaMappingLocation();
		return path;
	}

	@Override
	protected AreaMappingInfo fromFile(String id, File file) throws Throwable {
		IAreaMapping atm = AreaMappingPersistenceProvider.getInstance().loadItem(file.toURI().toURL());
		AreaMappingInfo info = new AreaMappingInfo(atm.getName(), id);
		for (int i = 0; i <= 1; i++)
			for (EdgeLla coordinate : atm.getMappedPoints(i)) {
				info.addCoordinate(i, coordinate);
			}

		BasicFileAttributes attr = Files.readAttributes(Paths.get(file.toURI()), BasicFileAttributes.class);
		info.setDateCreated(attr.creationTime().toMillis());
		info.setDateModified(attr.lastModifiedTime().toMillis());
		info.setDescription(atm.getDescription());
		return info;
	}

	@Override
	public Collection<AreaMappingCategoryInfo> getMappingPathCategories() {
		return Collections.unmodifiableCollection(categories);
	}

	@Override
	public AreaMappingInfo getItem(String name) throws DronologyServiceException {
		for (AreaMappingInfo item : itemmap.values()) {
			if (item.getId().equals(name)) {
				return item;
			}
		}
		throw new DronologyServiceException(""Area mapping '"" + name + ""' not found"");
	}

	@Override
	public AreaMappingInfo getMappingByName(String mappingName) throws DronologyServiceException {
		for (AreaMappingInfo item : itemmap.values()) {
			if (item.getName().equals(mappingName)) {
				return item;
			}
		}
		throw new DronologyServiceException(""Area mapping '"" + mappingName + ""' not found"");
	}

	@Override
	public GeneratedMappedArea generateAreaMapping(AreaMappingInfo info) throws DronologyServiceException {

		Collection<IUAVProxy> allUAVs = DroneSetupService.getInstance().getActiveUAVs();
		return generateAreaMapping(info, allUAVs);

	}

	@Override
	public GeneratedMappedArea generateAreaMapping(AreaMappingInfo info, Collection<IUAVProxy> selectedUAVs)
			throws DronologyServiceException {
		try {
			File file = fileManager.getFile(info.getId());
			IAreaMapping mapping;
			mapping = AreaMappingPersistenceProvider.getInstance().loadItem(file.toURI().toURL());
			AreaMappingGenerator generator = new AreaMappingGenerator(mapping, selectedUAVs);

			return generator.generateMapping();
		} catch (MalformedURLException | PersistenceException e) {
			throw new DronologyServiceException(e.getMessage());
		}

	}

	@Override
	public void executeAreaMapping(GeneratedMappedArea area) throws DronologyServiceException {

		for (ExportDrone ex : area.getUAVAssignments()) {
			String uavid = ex.getUAVId();
			int i = 0;
			List<IFlightRoute> assignments = ex.getDroneRouteAssignment();
			if (assignments.size() > 0) {

				try {
					FlightManagerService.getInstance().takeoff(uavid,
							assignments.get(0).getWaypoints().get(0).getCoordinate().getAltitude());
				} catch (DronologyServiceException e) {
					LOGGER.error(e);
				}
			} else {
				throw new DronologyServiceException(""Error when creating route assignments - no assignments available"");
			}
			for (IFlightRoute assignment : assignments) {
				List<Waypoint> waypoints = assignment.getWaypoints();
				try {
					FlightManagerService.getInstance().planFlight(uavid, ""Generated-RouteAssignment-"" + i, waypoints);
				} catch (Exception e) {
					LOGGER.error(e);
				}

				i++;
			}

			//
			// try {
			// FlightManagerService.getInstance().planFlight(uavid,
			// ""Generated-RouteAssignment"" + i, waypoints);
			// } catch (Exception e) {
			// LOGGER.error(e);
			// }

		}

	}

	private List<Waypoint> convertToWaypoints(List<LlaCoordinate> droneFullRoute) {
		List<Waypoint> wp = new ArrayList<>();

		droneFullRoute.forEach(coord -> {
			wp.add(new Waypoint(coord));
		});
		return wp;
	}

}
"
MissionUtil.java,"package edu.nd.dronology.services.extensions.missionplanning.plan;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;
import edu.nd.dronology.services.extensions.missionplanning.tasks.IMissionTask;
import edu.nd.dronology.services.extensions.missionplanning.tasks.RouteTask;
import edu.nd.dronology.services.instances.dronesetup.DroneSetupService;
import edu.nd.dronology.services.instances.flightmanager.FlightManagerService;
import edu.nd.dronology.services.instances.flightroute.FlightRouteplanningService;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class MissionUtil {

	private static final ILogger LOGGER = LoggerProvider.getLogger(MissionUtil.class);

	public static void activateRoute(IMissionTask activeTask) throws MissionExecutionException {
		FlightRouteInfo route = null;
		Collection<FlightRouteInfo> routes;
		try {
			routes = FlightRouteplanningService.getInstance().getItems();
		} catch (RemoteException e) {
			throw new MissionExecutionException(""Error when fetching routes"");
		}
		for (FlightRouteInfo s : routes) {
			if (s.getName().equals(activeTask.getTaskName())) {
				route = s;
				break;
			}
		}
		if (route == null) {
			throw new MissionExecutionException(""Route '"" + activeTask.getTaskName() + ""' not found"");
		}
		try {

			ArrayList<Waypoint> wp = new ArrayList<>(route.getWaypoints());
			FlightManagerService.getInstance().planFlight(activeTask.getUAVId(), activeTask.getTaskName(), wp);
		} catch (Exception e) {
			throw new MissionExecutionException(""Error when activating flight plan: "" + e.getMessage());
		}
	}

	public static void activateWaypoint(IMissionTask activeTask) throws MissionExecutionException {
		Waypoint wp = new Waypoint(activeTask.getWaypoint());
		try {
			FlightManagerService.getInstance().planFlight(activeTask.getUAVId(), activeTask.getTaskName(),
					Collections.singletonList(wp));
		} catch (Exception e) {
			throw new MissionExecutionException(""Error when activating flight plan: "" + e.getMessage());
		}
	}

	public static LlaCoordinate getFinalWaypoint(List<IMissionTask> allTasks) throws MissionExecutionException {
		IMissionTask task = allTasks.get(allTasks.size() - 1);
		if (task instanceof RouteTask) {
			LlaCoordinate finalWP = getLastWaypoint(task.getTaskName());
			return finalWP;
		}
		throw new MissionExecutionException(""Last task is not a route!"");
	}

	private static LlaCoordinate getLastWaypoint(String routeName) throws MissionExecutionException {
		FlightRouteInfo route = null;
		try {
			// route = FlightRouteplanningService.getInstance().getItem(routeName);

			Collection<FlightRouteInfo> items = FlightRouteplanningService.getInstance().getItems();
			for (FlightRouteInfo i : items) {
				if (i.getName().equals(routeName)) {
					route = i;
					break;
				}
			}
			if (route == null) {
				throw new MissionExecutionException(""Route '"" + routeName + ""' not found!"");
			}

			Waypoint firstWaypoint = new LinkedList<>(route.getWaypoints()).getLast();

			return firstWaypoint.getCoordinate();
		} catch (RemoteException e) {
			throw new MissionExecutionException(e.getMessage());
		}

	}

	/**
	 * Given a routename extract the first way point
	 * 
	 * @param routeName
	 * @return
	 */
	public static LlaCoordinate getFirstWayPoint(String routeName) throws MissionExecutionException {

		FlightRouteInfo route = null;
		try {
			// route = FlightRouteplanningService.getInstance().getItem(routeName);

			Collection<FlightRouteInfo> items = FlightRouteplanningService.getInstance().getItems();
			for (FlightRouteInfo i : items) {
				if (i.getName().equals(routeName)) {
					route = i;
					break;
				}
			}
			if (route == null) {
				throw new MissionExecutionException(""Route '"" + routeName + ""' not found!"");
			}

			Waypoint firstWaypoint = route.getWaypoints().get(0);

			return firstWaypoint.getCoordinate();

		} catch (RemoteException e) {
			throw new MissionExecutionException(e.getMessage());
		}
	}

	/**
	 * Get the home coordinates of *this* UAV i.e., uavID (class variable)
	 * 
	 * @param routeName
	 * @return
	 * @throws MissionExecutionException
	 */
	public static LlaCoordinate getHome(String uavid) throws MissionExecutionException {
		Collection<IUAVProxy> uavList = DroneSetupService.getInstance().getActiveUAVs();

		for (IUAVProxy uav : uavList) {
			if (uav.getID().equals(uavid)) {

				return uav.getHomeLocation();
			}
		}
		throw new MissionExecutionException(""UAV '"" + uavid + ""' not found!"");

	}

	public static void stopUAV(String uavid) {
		try {
			FlightManagerService.getInstance().emergencyStop(uavid);
		} catch (DronologyServiceException e) {
			LOGGER.error(e);
		}

	}

}
"
PersistableUAVMissionTask.java,"package edu.nd.dronology.services.extensions.missionplanning.persistence;

import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import edu.nd.dronology.services.core.items.IUAVMissionTask;

public class PersistableUAVMissionTask implements Serializable, IUAVMissionTask {
	
	public static final String DELAY_DURATION =""duration"";
	

	private static final long serialVersionUID = 2287087726638295092L;
	private String id;
	private Map<String, Serializable> attributes = new HashMap<>();
	private String type;

	public PersistableUAVMissionTask(String id, String type) {
		this.id = id;
		this.setType(type);
	}

	public void addAttribute(String key, Serializable value) {
		attributes.put(key, value);
	}

	@Override
	public Serializable getAttribute(String key) {
		return attributes.get(key);
	}

	@Override
	public String getId() {
		return id;
	}

	@Override
	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;
	}

	@Override
	public Map<String,Serializable> getParameters() {
		return Collections.unmodifiableMap(attributes);
	}

}
"
CollisionAvoidanceMessenger.java,"package edu.nd.dronology.core.collisionavoidance;

import edu.nd.dronology.core.collisionavoidance.backendmessage.*;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;
import edu.nd.dronology.core.goal.IGoalSnapshot;
import edu.nd.dronology.core.vehicle.ManagedDrone;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

import java.util.List;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;

/**
 * The CollisionAvoidanceMessenger class facilitates sending messages to instances of CollisionAvoidanceBackend. Use
 * instances of this class when you need to send a message to CollisionAvoidanceBackend.
 */
public class CollisionAvoidanceMessenger {
    private static final ILogger LOGGER = LoggerProvider.getLogger(CollisionAvoidanceMessenger.class);
    private final ArrayBlockingQueue<AbstractMessage> mailbox;

    // This constructor intentionally has no access modifier. Instances of this class should be created by
    // CollisionAvoidanceBackend.
    CollisionAvoidanceMessenger(ArrayBlockingQueue<AbstractMessage> mailbox) {
        this.mailbox = mailbox;
    }

    private void offerMessage(AbstractMessage msg) {
        if(!mailbox.offer(msg)) {
            LOGGER.warn(""Could not add message to mailbox "" + msg);
        }
    }

    /**
     * Send a message to the CollisionAvoidanceBackend telling it to run CollisionAvoider.avoid() and disperse guidance
     * to the managed drones.
     */
    //TODO rename this method
    public void sendCheckTask() {
        offerMessage(new CheckerTaskMessage());
    }

    /**
     * Send an update message with state from a physical drone. This message contains data sensed by a drones
     * (its position, velocity, etc.). Messages of this type should be sent when new data is received from the
     * drone.
     * @param snapshot a snapshot of the data received from the drone
     */
    public void sendPhysicalDroneUpdate(DroneSnapshotInternal snapshot) {
        offerMessage(new PhysicalDroneUpdateMessage(snapshot.getName(),
                snapshot.getPosition(), snapshot.getVelocity(), snapshot.getAttitude()));
    }

    /**
     * Sends an update message with state from a managed drone. This message contains a snapshot of the active goals as
     * well as the queue of commands currently being executed. Messages of this type should be sent when the set of
     * active goals changes or when the queue of commands changes.
     *
     * @param name the name of the drone
     * @param commandQueue the current queue of commands the managed drone is executing (this should not be the same
     *                     object use by managed drone, but a copy of that list)
     * @param goals a snapshot of the goals for this drone
     * @param state the state of the drone (FLYING, ON_GROUND, etc.)
     * @param managedDrone a reference to the managed drone this data came from (used to pass guidance back to the
     *                     managed drone after the next call of CollisionAvoider.avoid()).
     */
    public void sendManagedDroneUpdate(String name, List<Command> commandQueue, Set<IGoalSnapshot> goals, String state, ManagedDrone managedDrone) {
        offerMessage(new ManagedDroneUpdateMessage(name, commandQueue, goals, state, managedDrone));
    }

    /**
     * Send a stop message. This message should be sent when the program is shutting down. This message causes the
     * CollisionAvoidanceBackend thread to stop gracefully.
     */
    public void sendStopMessage() {
        try {
            mailbox.put(new StopMessage());
        } catch (InterruptedException e) {
            LOGGER.error(""Could not send stop command to CollisionAvoidanceBackend"");
            LOGGER.trace(e);
            throw new RuntimeException(e);
        }

    }
 }
"
FlightPlan.java,"package edu.nd.dronology.core.flight.internal;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import edu.nd.dronology.core.Discuss;
import edu.nd.dronology.core.DronologyConstants;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.exceptions.FlightZoneException;
import edu.nd.dronology.core.flight.IFlightPlan;
import edu.nd.dronology.core.monitoring.DronologyMonitoringManager;
import edu.nd.dronology.core.monitoring.MessageMarshaller;
import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;
import edu.nd.dronology.core.util.FormatUtil;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.core.vehicle.ManagedDrone;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * Stores flight information including its waypoints and current status.
 * 
 * @author Jane Cleland-Huang
 * @version 0.1
 *
 */
public class FlightPlan implements IFlightPlan {

	/**
	 * 
	 */
	private static final long serialVersionUID = -390109273842862492L;

	private static final ILogger LOGGER = LoggerProvider.getLogger(FlightPlan.class);

	private static int flightNumber = 0;
	private String flightID;

	private List<Waypoint> wayPoints;
	private LlaCoordinate startLocation;
	private LlaCoordinate endLocation;
	private Status status;
	private transient ManagedDrone drone = null;

	private long startTime = -1;
	private long endTime = -1;
	private String uavid;

	private enum Status {
		PLANNED, FLYING, COMPLETED, ON_HOLD;

		@Override
		public String toString() {
			return name().charAt(0) + name().substring(1).toLowerCase();
		}

	}

	public FlightPlan(String planName, List<Waypoint> wayPoints) {
		this(null, planName, wayPoints);

	}

	public FlightPlan(String uavid, String planName, List<Waypoint> wayPointsToAdd) {
		this.wayPoints = new ArrayList<>();
		for (Waypoint oldWP : wayPointsToAdd) {
			Waypoint newWP = new Waypoint(oldWP.getCoordinate());
			newWP.setApproachingspeed(oldWP.getApproachingspeed());
			this.wayPoints.add(newWP);
		}

		this.uavid = uavid;
		this.startLocation = wayPoints.get(0).getCoordinate();
		if (this.wayPoints.size() > 0) {
			this.endLocation = this.wayPoints.get(this.wayPoints.size() - 1).getCoordinate();
		} else {
			endLocation = startLocation;
		}
		this.flightID = ""DF-"" + Integer.toString(++flightNumber) + "" - "" + planName;
		status = Status.PLANNED;

	}

	/**
	 * 
	 * @return flight ID
	 */
	@Override
	public String getFlightID() {
		return flightID;
	}

	/**
	 * 
	 * @return Starting Coordinates
	 */
	@Override
	public LlaCoordinate getStartLocation() {
		return startLocation;
	}

	/**
	 * 
	 * @return Ending Coordinates
	 */
	@Override
	public LlaCoordinate getEndLocation() {
		return endLocation;
	}

	/**
	 * Returns the drone assigned to the flight plan. Will return null if no drone
	 * is yet assigned.
	 * 
	 * @return iDrone
	 */
	@Override
	public ManagedDrone getAssignedDrone() {
		return drone;
	}

	@Override
	public void clearAssignedDrone() {
		drone = null;
	}

	/**
	 * 
	 * @param drone
	 * @return true if drone is currently flying, false otherwise.
	 * @throws FlightZoneException
	 */
	@Override
	public boolean setStatusToFlying(ManagedDrone drone) throws FlightZoneException {
		if (status == Status.PLANNED) {
			status = Status.FLYING;
			startTime = System.currentTimeMillis();
			this.drone = drone; 
			LOGGER.missionInfo(""Flight Plan '"" + getFlightID() + ""'"" + drone.getDroneName() + ""' started "");
			return true; 
		} else
			throw new FlightZoneException(""Only currently planned flights can have their status changed to flying"");
	}

	/**
	 * Sets flightplan status to completed when called.
	 * 
	 * @return true
	 * @throws FlightZoneException
	 */
	@Override
	public boolean setStatusToCompleted() throws FlightZoneException {
		if (status == Status.FLYING) {
			status = Status.COMPLETED;
			endTime = System.currentTimeMillis();
			LOGGER.missionInfo(""Flight Plan '"" + getFlightID() + ""'"" + drone.getDroneName() + ""' completed ""
					+ FormatUtil.formatTimestamp(startTime) + ""-"" + FormatUtil.formatTimestamp(endTime));

			return true; // success (may add real check here later)
		} else
			throw new FlightZoneException(""Only currently flying flights can have their status changed to completed"");
	}

	/**
	 * Returns current flightplan status (Planned, Flying, Completed)
	 * 
	 * @return status
	 */
	public String getStatus() {

		return status.toString();

	}

	@Override
	public String toString() {
		return flightID + ""\n"" + getStartLocation() + "" - "" + getEndLocation() + ""\n"" + getStatus();
	}

	/**
	 * Returns way points
	 * 
	 * @return List<Waypoint>
	 */
	@Override
	public List<Waypoint> getWayPoints() {
		return Collections.unmodifiableList(wayPoints);
	}

	/**
	 * Returns start time of flight.
	 * 
	 * @return date object
	 */
	@Override
	public long getStartTime() {
		return startTime;
	}

	/**
	 * REturns end time of flight.
	 * 
	 * @return date object
	 */
	@Override
	public long getEndTime() {
		return endTime;
	}

	@Override
	public String getDesignatedDroneId() {
		return uavid;
	}

	@Override
	@Discuss(discuss = ""unessecary double check of plan complete.. needs to be fixed"")
	public boolean isCompleted() {
		return status == Status.COMPLETED || waypointsReached();
	}

	@Override
	public double getTakeoffAltitude() {
		return DronologyConstants.TAKE_OFF_ALTITUDE;
	}

	private boolean waypointsReached() {
		for (Waypoint wp : wayPoints) {
			if (!wp.isReached()) {
				return false;
			}
		} 
		return true;
	}

	@Override
	public void setDesignatedDroneId(String uavid) {
		this.uavid=uavid;
		
	}
}
"
CollisionInfo.java,"package edu.nd.dronology.monitoring.simplechecker.checker;

import java.io.Serializable;

public class CollisionInfo implements Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = -2177691764314219425L;
	private final String uavid1;
	private final String uavid2;
	private final double distance;

	public CollisionInfo(String uavid1, String uavid2, double distance) {
		this.uavid1 = uavid1;
		this.uavid2 = uavid2;
		this.distance = distance;
	}

}
"
AMMapMarkerUtilities.java,"package edu.nd.dronology.ui.vaadin.areamapping;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.UUID;
import java.util.Vector;

import org.vaadin.addon.leaflet.LMap;
import org.vaadin.addon.leaflet.LMarker;
import org.vaadin.addon.leaflet.LPolygon;
import org.vaadin.addon.leaflet.LPolyline;
import org.vaadin.addon.leaflet.LeafletMouseOutEvent;
import org.vaadin.addon.leaflet.LeafletMouseOutListener;
import org.vaadin.addon.leaflet.LeafletMouseOverEvent;
import org.vaadin.addon.leaflet.LeafletMouseOverListener;
import org.vaadin.addon.leaflet.shared.Point;

import com.vaadin.server.FileResource;
import com.vaadin.server.VaadinService;
import com.vaadin.ui.Component;
import com.vaadin.ui.Notification;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.services.core.items.IAreaMapping;
import edu.nd.dronology.services.core.items.PriorityArea;
import edu.nd.dronology.services.core.items.PrioritySide;
import edu.nd.dronology.services.core.persistence.AreaMappingPersistenceProvider;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import edu.nd.dronology.services.core.remote.IAreaMappingRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMMapAddMarkerListener;
import edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMMarkerDragEndListener;
import edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMMarkerMouseOutListener;
import edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMMarkerMouseOverListener;
import edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMPolylineClickListener;
import edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMPriorityAreaMouseOverListener;
import edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMPriorityDragEndListener;
import edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMPriorityMouseOutListener;
import edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMPrioritySideMouseOverListener;
import edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMRightClickListener;
import edu.nd.dronology.ui.vaadin.areamapping.mapoperations.AMUpstreamClickListener;
import edu.nd.dronology.ui.vaadin.areamapping.windows.AMPriorityInfoWindow;
import edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;
import edu.nd.dronology.ui.vaadin.start.MyUI;

/**
 * Adapted from the MapMarkerUtilities class in the utils folder, this class has listeners that allow the user to interact with the map.
 * Also includes many functions for manipulating and updating a current mapping
 * @author Andrew Slavin
 *
 */

public class AMMapMarkerUtilities {	
	private LMap map;
	private AMMapComponent mapComponent;
	 
	private AMMapAddMarkerListener mapAddMarkerListener;
	private AMMarkerMouseOverListener markerMouseOverListener;
	private AMMarkerMouseOutListener markerMouseOutListener;
	private AMMarkerDragEndListener markerDragEndListener;
	private AMPolylineClickListener polylineClickListener;
	private AMRightClickListener rightClickListener;
	
	private AMPriorityInfoWindow priorityInfoWindow;
	
	private LinkedList<Point> polygonVertices = new LinkedList<>();
	private Vector<PriorityArea> allPriorityAreas = new Vector<>();
	private Vector<List<UIEdgePoint>> sides;
	private LPolyline mousedOverLine;
	private PriorityArea mousedOverArea;
	private PrioritySide mousedOverSide;
	private PriorityArea areaToAdd;
	private LinkedList<LMarker> newPolygonPins = new LinkedList<>();
	private LinkedList<LMarker> allPolygonPins = new LinkedList<>();
	private LinkedList<Point> allPolygonPinsCopy = new LinkedList<>();
	private LinkedList<LPolyline> newPolygonLines = new LinkedList<>();
	private LinkedList<LPolyline> newPrioritySideLines = new LinkedList<>();
	private LinkedList<LPolyline> allPriorityLines = new LinkedList<>(); // all red lines on the map
	private LinkedList<PrioritySide> allPrioritySides = new LinkedList<>();
	private LinkedList<LPolyline> removedPriorityLines = new LinkedList<>();
	private LinkedList<LPolyline> allPolylines = new LinkedList<>();
	private LinkedList<UIEdgePoint> allSideWaypoints = new LinkedList<>();
	
	private Boolean upstream; // true means that upstream is the direction the points are drawn; false is opposite
	private boolean sidesAreEditable = false;
	private boolean prioritiesAreEditable = false;
	
	public AMMapMarkerUtilities(AMMapComponent mapComponent) {
		this.mapComponent = mapComponent;
		this.map = mapComponent.getMap();

		// add listeners
		this.mapAddMarkerListener = new AMMapAddMarkerListener(this);
		this.markerMouseOverListener = new AMMarkerMouseOverListener(this);
		this.markerMouseOutListener = new AMMarkerMouseOutListener(this);
		this.markerDragEndListener = new AMMarkerDragEndListener(this);
		this.polylineClickListener = new AMPolylineClickListener(this);	
		this.rightClickListener = new AMRightClickListener(this);
		
		map.addClickListener(mapAddMarkerListener);
		// rightClickListener only knows that the map is being clicked, but uses info about which polyline is moused over
		map.addContextClickListener(rightClickListener);
	}
	
	public AMMapMarkerUtilities(LMap map) {
		this.map = map;
	}
	
	// adds a new pin at a specified point and at a certain index in the list of waypoints (index is relevant when adding a waypoint between two other waypoints)
	// -1 signals that a waypoint was added to the end
	public LMarker addNewPin(Point point, int index) { 
		if (getPins().size() == 0 && mapComponent.getEditSidesController().getSideA()) {
			Notification.show(""Starting with Side A"", Notification.Type.ERROR_MESSAGE);
			mapComponent.getEditSidesController().setSideA();
		}
		if (index > this.getPins().size())
			index = this.getPins().size();
		// Creates a waypoint at the given point, and assigns it a random id.
		UIEdgePoint p = new UIEdgePoint(point, false);
		// set side
		if (mapComponent.getEditSidesController().getSideA())
			p.setSide(1);
		else
			p.setSide(0);
		return addNewPin(p, index);
	}
	
	public LMarker addNewPin(UIEdgePoint p, int index) {
		if (index > this.getPins().size()) {
			index = this.getPins().size();
		}
		
		// Assign the order
		if (index == -1) {
			p.setOrder(this.getPins().size());
		} else {
			p.setOrder(index);
			List<LMarker> pins = this.getPins();
			for (int i = 0; i < pins.size(); i++) {
				UIEdgePoint pInMap = (UIEdgePoint)pins.get(i).getData();
				if (pInMap.getOrder() >= index) {
					pInMap.setOrder(pInMap.getOrder() + 1);
				}
			}
		}
		
		LMarker newPin = null;
		// if sideA is selected, draw it green; otherwise, draw it blue
		newPin = addPinForWayPoint(p);
		String basepath = VaadinService.getCurrent().getBaseDirectory().getAbsolutePath();
		FileResource greenIcon = new FileResource(new File(basepath+""/VAADIN/img/green-dot.png""));
		FileResource blueIcon = new FileResource(new File(basepath+""/VAADIN/img/blue-dot.png""));
		if (p.getSide() == 0) // side A is 0 is red
			newPin.setIcon(greenIcon);
		else if (p.getSide() == 1) // side B is 1 is blue
			newPin.setIcon(blueIcon);
		newPin.setIconSize(new Point(15, 15));
		newPin.setIconAnchor(new Point(7, 10));
		
		
		mapComponent.updateLinesAndGrid();	
		allSideWaypoints.add(p);
		return newPin;
	}
	
	// adds a vertex to a polygon as it's being drawn
	public void addPolygonVertex(Point point) {

		UIEdgePoint p = new UIEdgePoint(point, false);
		LMarker newPin = new LMarker(p.toPoint());
		newPin.setData((p));
		newPin.setId(p.getId());
		newPin.setHeight(""2px"");
		newPin.addDragEndListener(new AMPriorityDragEndListener(this, newPin));
		newPolygonPins.add(newPin);
		map.addComponent(newPin);
		setAllPolygonPins();
		polygonVertices.add(point);
		
		// add polyline between each additional point that is drawn
		if (polygonVertices.size() > 1) {
			LPolyline polyline = new LPolyline(point, polygonVertices.get(polygonVertices.size()-2));
			polyline.setId(UUID.randomUUID().toString());
			polyline.setColor(""#ff5050"");
			polyline.setDashArray(""5 10"");
			polyline.setHeight(""2"");
			polyline.setWeight(1);
			map.addComponent(polyline);
			newPolygonLines.add(polyline);
		}
		String basepath = VaadinService.getCurrent().getBaseDirectory().getAbsolutePath();
		FileResource redIcon = new FileResource(new File(basepath+""/VAADIN/img/red-dot.png""));
		newPin.setIcon(redIcon);
		newPin.setIconSize(new Point(10, 10));
		newPin.setIconAnchor(new Point(5, 7));
	}
	
	// adds a pin in a location designated by the wayPoints
	private LMarker addPinForWayPoint(UIEdgePoint wayPoint) {
		LMarker leafletMarker = new LMarker(wayPoint.toPoint());
		leafletMarker.setData(wayPoint);
		leafletMarker.setId(wayPoint.getId());
		
		if (markerMouseOverListener != null) leafletMarker.addMouseOverListener(markerMouseOverListener);
		if (markerMouseOutListener != null) leafletMarker.addMouseOutListener(markerMouseOutListener);
		if (markerDragEndListener != null) leafletMarker.addDragEndListener(markerDragEndListener);

		leafletMarker.addClickListener(new AMUpstreamClickListener(this));
		
		map.addComponent(leafletMarker);
		return leafletMarker;
	}
	
	// removes a pin when given its ID
	public void removePinById (String id) {
		LMarker p = this.getPinById(id);
		removePin(p);
	}
	
	// remove a pin from the map
	public void removePin (LMarker p) {
		if (p == null)
			return;
		
		UIEdgePoint w = (UIEdgePoint)p.getData();
		
		List<LMarker> pins = this.getPins();
		for (int i = 0; i < pins.size(); i++) {
			UIEdgePoint pInMap = (UIEdgePoint)pins.get(i).getData();
			if (pInMap.getOrder() >= w.getOrder())
				pInMap.setOrder(pInMap.getOrder() - 1);
		}
		map.removeComponent(p);
		
		// if pin was in a priority side, remove it from the list and redraw the priority sides
		for (PrioritySide side : allPrioritySides) {
			List<LlaCoordinate> tempCoords = new LinkedList<LlaCoordinate>();
			removedPriorityLines.clear();
			for (int i = 0; i < side.getCoordinates().size(); i ++) {
				if (new LlaCoordinate(p.getPoint().getLat(), p.getPoint().getLon(), 0).equals(side.getCoordinates().get(i))) {
					// remove lines from allPriorityLines
					for (LPolyline line : getAllPriorityLines()) {
						if (((double)Math.round(line.getPoints()[0].getLat() * 1000000d) / 1000000d == (double)Math.round(p.getPoint().getLat() * 1000000d) / 1000000d)
						&& ((double)Math.round(line.getPoints()[0].getLon() * 1000000d) / 1000000d == (double)Math.round(p.getPoint().getLon() * 1000000d) / 1000000d)
						|| (((double)Math.round(line.getPoints()[1].getLat() * 1000000d) / 1000000d == (double)Math.round(p.getPoint().getLat() * 1000000d) / 1000000d)
						&& ((double)Math.round(line.getPoints()[1].getLon() * 1000000d) / 1000000d == (double)Math.round(p.getPoint().getLon() * 1000000d) / 1000000d)))
						{
							removedPriorityLines.add(line);
							allPriorityLines.remove(line);
						}
					}
				}
				else {
					tempCoords.add(side.getCoordinates().get(i)); // if the deleted pin isn't in allPrioritySides, add it to the temp list
				}
			}
			side.setCoordinates(tempCoords);
		}
		mapComponent.updateLinesAndGrid();
	}
	
	//removes all of the pins from the map
	public void removeAllPins() {
		allSideWaypoints.clear();
		List<LMarker> pins = getPins();
		for (int i = pins.size() - 1; i >= 0; i--) {
			map.removeComponent(pins.get(i));
		}
	}
	
	/**
	 * 
	 * @param wayPoints
	 * @param fromActive
	 * 			should be true if drawLines is being called from the active flights UI. This
	 * 			determines if the first line segment should be green (which it shouldn't
	 * 			be in the flight routes UI). 
	 * @return list of polylines drawn on the map
	 */
	public Vector<List<LPolyline>> drawLinesForWayPoints(Vector<List<UIEdgePoint>> wayPoints, boolean fromActive) {
		// Draws polylines based on a list of waypoints, then outputs the newly formed arraylist of polylines.
		sides = wayPoints;
		Vector<List<LPolyline>> polylines = new Vector<>();
		
		
		for (int j = 0; j <= 1; j++) {
			polylines.add(j, new ArrayList<>());
			for (int i = 0; i < wayPoints.get(j).size() - 1; i++) {
				UIEdgePoint current = wayPoints.get(j).get(i);
				LPolyline polyline = new LPolyline(current.toPoint(), wayPoints.get(j).get(i + 1).toPoint());
				polyline.setId(UUID.randomUUID().toString());
				
				// if priority lines were recently deleted, update allPriorityLines accordingly
				if (removedPriorityLines.size() == 2) {
					if ((((double)Math.round(polyline.getPoints()[0].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[0].getLat() * 1000000d) / 1000000d)
					&& ((double)Math.round(polyline.getPoints()[0].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[0].getLon() * 1000000d) / 1000000d)
					&& ((double)Math.round(polyline.getPoints()[1].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[0].getLat() * 1000000d) / 1000000d)
					&& ((double)Math.round(polyline.getPoints()[1].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[0].getLon() * 1000000d) / 1000000d))
					|| (((double)Math.round(polyline.getPoints()[0].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[0].getLat() * 1000000d) / 1000000d)
					&& ((double)Math.round(polyline.getPoints()[0].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[0].getLon() * 1000000d) / 1000000d)
					&& ((double)Math.round(polyline.getPoints()[1].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[1].getLat() * 1000000d) / 1000000d)
					&& ((double)Math.round(polyline.getPoints()[1].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[1].getLon() * 1000000d) / 1000000d))
					|| (((double)Math.round(polyline.getPoints()[0].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[1].getLat() * 1000000d) / 1000000d)
					&& ((double)Math.round(polyline.getPoints()[0].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[1].getLon() * 1000000d) / 1000000d)
					&& ((double)Math.round(polyline.getPoints()[1].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[1].getLat() * 1000000d) / 1000000d)
					&& ((double)Math.round(polyline.getPoints()[1].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[1].getLon() * 1000000d) / 1000000d))
					|| (((double)Math.round(polyline.getPoints()[0].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[1].getLat() * 1000000d) / 1000000d)
					&& ((double)Math.round(polyline.getPoints()[0].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(0).getPoints()[1].getLon() * 1000000d) / 1000000d)
					&& ((double)Math.round(polyline.getPoints()[1].getLat() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[0].getLat() * 1000000d) / 1000000d)
					&& ((double)Math.round(polyline.getPoints()[1].getLon() * 1000000d) / 1000000d == (double)Math.round(removedPriorityLines.get(1).getPoints()[0].getLon() * 1000000d) / 1000000d)))
					{
						allPriorityLines.add(polyline);
					}
				}
	
				// if it's a priority line, draw it red; otherwise, grey
				polyline.setColor(""#444"");

				for (LPolyline line : allPriorityLines) {
					if ((((double)Math.round(line.getPoints()[0].getLat() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[0].getLat() * 10000d) / 10000d)
					&& ((double)Math.round(line.getPoints()[0].getLon() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[0].getLon() * 10000d) / 10000d)
					&& ((double)Math.round(line.getPoints()[1].getLat() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[1].getLat() * 10000d) / 10000d)
					&& ((double)Math.round(line.getPoints()[1].getLon() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[1].getLon() * 10000d) / 10000d))
					|| (((double)Math.round(line.getPoints()[0].getLat() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[1].getLat() * 10000d) / 10000d)
					&& ((double)Math.round(line.getPoints()[0].getLon() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[1].getLon() * 10000d) / 10000d)
					&& ((double)Math.round(line.getPoints()[1].getLat() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[0].getLat() * 10000d) / 10000d)
					&& ((double)Math.round(line.getPoints()[1].getLon() * 10000d) / 10000d == (double)Math.round(polyline.getPoints()[0].getLon() * 10000d) / 10000d)))
					{
						// if a priority line endpoint was dragged, change that information in allPrioritySides
						if (markerDragEndListener.getDraggedPriorityLine()) {
							for (int p = 0; p < allPrioritySides.size(); p++) {
								for (int q = 0; q < allPrioritySides.get(p).getCoordinates().size(); q++) {
									if ((double)Math.round(allPrioritySides.get(p).getCoordinates().get(q).getLatitude() * 10000d) / 10000d == (double)Math.round(line.getPoints()[0].getLat() * 10000d) / 10000d 
									&& (double)Math.round(allPrioritySides.get(p).getCoordinates().get(q).getLongitude() * 10000d) / 10000d == (double)Math.round(line.getPoints()[0].getLon() * 10000d) / 10000d ) {
										List<LlaCoordinate> tempCoords = new LinkedList<>(allPrioritySides.get(p).getCoordinates());
										tempCoords.set(q, new LlaCoordinate(polyline.getPoints()[0].getLat(), polyline.getPoints()[0].getLon(), 0));
										allPrioritySides.get(p).setCoordinates(tempCoords);
									}
									if ((double)Math.round(allPrioritySides.get(p).getCoordinates().get(q).getLatitude() * 10000d) / 10000d == (double)Math.round(line.getPoints()[1].getLat() * 10000d) / 10000d 
									&& (double)Math.round(allPrioritySides.get(p).getCoordinates().get(q).getLongitude() * 10000d) / 10000d == (double)Math.round(line.getPoints()[1].getLon() * 10000d) / 10000d ) {
										List<LlaCoordinate> tempCoords = new LinkedList<>(allPrioritySides.get(p).getCoordinates());
										tempCoords.set(q, new LlaCoordinate(polyline.getPoints()[1].getLat(), polyline.getPoints()[1].getLon(), 0));
										allPrioritySides.get(p).setCoordinates(tempCoords);
									}
								}
							}
							line.setPoints(polyline.getPoints());
						}
						
						// highlight as priority line
						polyline.setColor(""#ff5050"");
						polyline.addMouseOverListener(new AMPrioritySideMouseOverListener(mapComponent, polyline));
						polyline.addMouseOutListener(new AMPriorityMouseOutListener(this));
						polyline.setOpacity(0.7);
					}
				}
				
				map.addComponent(polyline);
				allPolylines.add(polyline);
				

				// assigns the line that is moused over
				polyline.addMouseOverListener(new LeafletMouseOverListener() {
					@Override
					public void onMouseOver(LeafletMouseOverEvent event) {
						mousedOverLine = (LPolyline)event.getSource();
					}
				});
				
				// if the mouse is removed from the line, set mousedOverLine to null
				polyline.addMouseOutListener(new LeafletMouseOutListener() {
					@Override
					public void onMouseOut(LeafletMouseOutEvent event) {
						mousedOverLine = null;
					}
				});
	
				if (polylineClickListener != null) polyline.addClickListener(polylineClickListener);
				
				polylines.get(j).add(polyline);
			}
		}
		highlightUpstream();
		return polylines;
	}
	
	// Removes all lines from the map and the polylines arraylist unless drawing a polygon
	public void removeAllLines() {
		if (mapComponent.getEditPrioritiesController().getDrawingArea())
			return;
		Iterator<Component> it = map.iterator();
		LinkedList<LPolyline> linesToRemove = new LinkedList<>();
		while(it.hasNext()) {
			Component c = it.next();
			if (c.getClass() == LPolyline.class) {
				linesToRemove.add((LPolyline)c);
			}
		}
		for (LPolyline polyline : linesToRemove) {
			map.removeComponent(polyline);
		}
		allPolylines.clear();
	}
	
	// Removes all lines and points from the polygon that's currently being drawn
	public void deleteNewPolygon() {
		for (int i = 0; i < newPolygonPins.size(); i++) {
			map.removeComponent(newPolygonPins.get(i));
		}
		for (int i = 0; i < newPolygonLines.size(); i++) {
			map.removeComponent(newPolygonLines.get(i));
		}
		polygonVertices.clear();
		clearPolygonVertices();
	}
	
	// removes a polygon from the existing list
	public void deleteOldPolygon(PriorityArea areaToDelete) {
		for (int i = 0; i < allPriorityAreas.size(); i++) {
			if (allPriorityAreas.get(i).getId().equals(areaToDelete.getId())) {
				allPriorityAreas.remove(i);
			}
		}
		// redraw polygons to map (without the one that was deleted)
		LinkedList<PriorityArea> tempPolygonList = new LinkedList<>(allPriorityAreas);
		removeAllPriorityAreas();
		for (int i = 0; i < tempPolygonList.size(); i++) {
			for (int j = 0; j < tempPolygonList.get(i).getCoordinates().size(); j++) {
					addPolygonVertex(new Point(tempPolygonList.get(i).getCoordinates().get(j).getLatitude(), tempPolygonList.get(i).getCoordinates().get(j).getLongitude()));
			}
				drawPolygon();	
				addPriorityArea(tempPolygonList.get(i).getType(), tempPolygonList.get(i).getDescription(), tempPolygonList.get(i).getImportance());
		}
	}
	
	// redraws all the lines to the map
	public Vector<List<LPolyline>> redrawAllLines(boolean fromActive) {
		removeAllLines();
		Vector<List<UIEdgePoint>> mapPoints = getOrderedWayPoints();
		return drawLinesForWayPoints(mapPoints, fromActive);
	}
	
	// highlights the points that are upstream based on upstream variable
	public void highlightUpstream() {
		if (upstream == null || this.getOrderedWayPoints().get(0).size() == 0 || this.getOrderedWayPoints().get(1).size() == 0)
			return;
		String basepath = VaadinService.getCurrent().getBaseDirectory().getAbsolutePath();
		FileResource waterfallIcon = new FileResource(new File(basepath+""/VAADIN/img/waterfall.png""));
		FileResource greenIcon = new FileResource(new File(basepath+""/VAADIN/img/green-dot.png""));
		FileResource blueIcon = new FileResource(new File(basepath+""/VAADIN/img/blue-dot.png""));
		for (int i = 0; i < this.getPins().size(); i++) {
			// if upstream is false, make the last waypoints on both sides into the waterfall icon
			if ((((double)Math.round(getPins().get(i).getPoint().getLat() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(0).get(getOrderedWayPoints().get(0).size()-1).getLatitude()) * 10000d) / 10000d) 
			&& ((double)Math.round(getPins().get(i).getPoint().getLon() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(0).get(getOrderedWayPoints().get(0).size()-1).getLongitude())* 10000d) / 10000d)	
			&& upstream == false)
			|| (((double)Math.round(getPins().get(i).getPoint().getLat() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(1).get(getOrderedWayPoints().get(1).size()-1).getLatitude()) * 10000d) / 10000d) 
			&& ((double)Math.round(getPins().get(i).getPoint().getLon() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(1).get(getOrderedWayPoints().get(1).size()-1).getLongitude())* 10000d) / 10000d)	
			&& upstream == false)) {
				LMarker leafletMarker = this.getPins().get(i);
				leafletMarker.setIcon(waterfallIcon);
				leafletMarker.setIconSize(new Point(30, 30));
				leafletMarker.setIconAnchor(new Point(16, 10));
			}
			
			// if upstream is true, make the first waypoints on both sides into the waterfall icon
			else if ((((double)Math.round(getPins().get(i).getPoint().getLat() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(0).get(0).getLatitude())* 10000d) / 10000d)
			&& ((double)Math.round(getPins().get(i).getPoint().getLon() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(0).get(0).getLongitude()) * 10000d) / 10000d)
			&& upstream == true)
			|| (((double)Math.round(getPins().get(i).getPoint().getLat() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(1).get(0).getLatitude())* 10000d) / 10000d)
			&& ((double)Math.round(getPins().get(i).getPoint().getLon() * 10000d) / 10000d == (double)Math.round(Double.parseDouble(getOrderedWayPoints().get(1).get(0).getLongitude()) * 10000d) / 10000d)
			&& upstream == true)) {
				LMarker leafletMarker = this.getPins().get(i);
				leafletMarker.setIcon(waterfallIcon);
				leafletMarker.setIconSize(new Point(30, 30));
				leafletMarker.setIconAnchor(new Point(16, 10));
			}
			// color all other points normally
			else {
				LMarker leafletMarker = this.getPins().get(i);
				leafletMarker.setIcon(blueIcon);
				leafletMarker.setIconSize(new Point(15, 15));
				leafletMarker.setIconAnchor(new Point(7, 10));
				for (UIEdgePoint point : getOrderedWayPoints().get(0)) {
					if ((double)Math.round(Double.parseDouble(point.getLatitude()) * 10000d) / 10000d == (double)Math.round(this.getPins().get(i).getPoint().getLat() * 10000d) / 10000d
					&& (double)Math.round(Double.parseDouble(point.getLongitude()) * 10000d) / 10000d == (double)Math.round(this.getPins().get(i).getPoint().getLon()* 10000d) / 10000d) {
						leafletMarker.setIcon(greenIcon);
					}
				}
			}
		}
	}

	// get ordered waypoints that belong to each side of the mapping
	public Vector<List<UIEdgePoint>> getOrderedWayPoints() {
		Vector<List<UIEdgePoint>> wayPoints = new Vector<>();
		wayPoints.add(0, new LinkedList<UIEdgePoint>());
		wayPoints.add(1, new LinkedList<UIEdgePoint>());
		for (LMarker p : getPins()) {
			wayPoints.get(((UIEdgePoint)p.getData()).getSide()).add((UIEdgePoint)p.getData());
		}
		wayPoints.get(0).sort(new Comparator<UIEdgePoint>() {
	        @Override
	        public int compare(UIEdgePoint w1, UIEdgePoint w2) {
	        		return  w1.getOrder() - w2.getOrder();
	        }
	    });
		wayPoints.get(1).sort(new Comparator<UIEdgePoint>() {
	        @Override
	        public int compare(UIEdgePoint w1, UIEdgePoint w2) {
	        		return  w1.getOrder() - w2.getOrder();
	        }
	    }); 
		return wayPoints;
	}
	
	// Gets all of the pins that are on the map, excluding polygon pins
	public List<LMarker> getPins() {
		List<LMarker> pins = new ArrayList<>();
		Iterator<Component> it = map.iterator();
		while(it.hasNext()) {
			Component c = it.next();
			if (c.getClass() == LMarker.class) {
				if (c.getHeight() != 2.0) // height of polygon pin
					pins.add((LMarker)c);
			}
		}
		return pins;
	}
	
	// gets pin by its ID
	public LMarker getPinById(String id) {
		List<LMarker> pins = getPins();
		for (LMarker pin : pins) {
			if (pin.getId().equals(id))
				return pin;
		}
		return null;
	}
	
	// draw a polygon using the points that have been plotted on the map
	public void drawPolygon() {
		
		// convert each point to create an area to add
		areaToAdd= new PriorityArea(UUID.randomUUID().toString());
		for (int i = 0; i < polygonVertices.size(); i++) {
			areaToAdd.addCoordinate(new LlaCoordinate(polygonVertices.get(i).getLat(), polygonVertices.get(i).getLon(), 0));
		}
		
		// if polygon already in list, remove it so that copies don't exist
		for (int i = 0; i < allPriorityAreas.size(); i ++) {
			if (areaToAdd.getCoordinates().equals(allPriorityAreas.get(i).getCoordinates()))
				allPriorityAreas.remove(i);
		}
		
		// convert from list to array to create Polygon
		LPolygon newPolygon = new LPolygon();
		newPolygon.setColor(""#ff5050"");
		Point pointArray[] = new Point[polygonVertices.size()];
	    pointArray = polygonVertices.toArray(pointArray);
		newPolygon.setPoints(pointArray);
		map.addComponent(newPolygon);
		AMPriorityAreaMouseOverListener mouseOverListener = new AMPriorityAreaMouseOverListener(mapComponent, areaToAdd.getId());
		newPolygon.addMouseOverListener(mouseOverListener);
		newPolygon.addMouseOutListener(new AMPriorityMouseOutListener(this)); // closes the window from the mouseOverListener
		newPolygonPins.clear();
		newPolygonLines.clear();
	}
	
	// uses the polygonVertices to finish and create a new priority area
	public void addPriorityArea(String type, String description, Integer importance) {
		areaToAdd.setType(type);
		areaToAdd.setDescription(description);
		areaToAdd.setImportance(importance);
		allPriorityAreas.add(areaToAdd);
		polygonVertices.clear();
	}
	
	// iterate through map to find all polygons and polygon pins and delete them
	public void removeAllPriorityAreas() {
		List<LPolygon> polygons = new ArrayList<>();
		List<LMarker> pins = new ArrayList<>();
		List<LPolyline> lines = new ArrayList<>();
		Iterator<Component> it = map.iterator();
		while(it.hasNext()) {
			Component c = it.next();
			if (c.getClass() == LPolygon.class) {
					polygons.add((LPolygon)c);
			}
			if (c.getClass() == LMarker.class) {
				if (c.getHeight() == 2.0) // height of polygon pin
					pins.add((LMarker)c);
			}
			if (c.getClass() == LPolyline.class) {
				if (c.getHeight() == 2.0) // height of polygon line
					lines.add((LPolyline)c);
			}
		}

		// delete all polygons and pins
		for (int i = polygons.size() - 1; i >= 0; i--) {
			map.removeComponent(polygons.get(i));
		}
		for (int i = pins.size() -1; i >= 0; i--) {
			map.removeComponent(pins.get(i));
		}
		for (int i = lines.size() -1; i >= 0; i--) {
			map.removeComponent(lines.get(i));
		}
		
		polygons.clear();
		pins.clear();
		allPriorityAreas.clear();
		polygonVertices.clear();
	}
	
	// updates allPolygonPins based on the pins on the map
	public void setAllPolygonPins() {
		allPolygonPins.clear();
		Iterator<Component> it = map.iterator();
		while(it.hasNext()) {
			Component c = it.next();
			if (c.getClass() == LMarker.class) {
				if (c.getHeight() == 2.0) // height of polygon pin
					allPolygonPins.add((LMarker)c);
			}
		}
		allPolygonPinsCopy.clear();
		for (LMarker marker : allPolygonPins) {
			allPolygonPinsCopy.add(marker.getPoint());
		}
	}
	
	// draw the priorities using the mapping from dronology
	public void drawPriorities() {
		
		// if drawing a polygon, don't refresh all the others because this will interrupt the process
		if (this.getMapComponent().getMapUtilities().getPrioritiesAreEditable() || this.getMapComponent().getMapUtilities().getSidesAreEditable())
			return;

		removeAllPriorityAreas();
		
		// get area mapping from dronology
		IAreaMapping amapping = null;
		BaseServiceProvider provider = MyUI.getProvider();
		AreaMappingPersistenceProvider mappingPersistor = AreaMappingPersistenceProvider.getInstance();
		try {
			IAreaMappingRemoteService service = (IAreaMappingRemoteService) provider.getRemoteManager().getService(IAreaMappingRemoteService.class);
			ByteArrayInputStream inStream;
			String id = mapComponent.getMainLayout().getControls().getInfoPanel().getHighlightedAMInfoBox().getId();
			byte[] information = service.requestFromServer(id);
			inStream = new ByteArrayInputStream(information);
			amapping = mappingPersistor.loadItem(inStream);
		} catch (DronologyServiceException | RemoteException e1) {
		e1.printStackTrace();
		MyUI.setConnected(false);
		} catch (PersistenceException e1) {
		e1.printStackTrace();
		}
		// get and add priority areas/sides from area mapping 
		for (int i = 0; i < amapping.getLocationMappings().size(); i++) {
			if (amapping.getLocationMappings().get(i).getClass() == PriorityArea.class) {
				for (int j = 0; j < amapping.getLocationMappings().get(i).getCoordinates().size(); j++) {
					addPolygonVertex(new Point(amapping.getLocationMappings().get(i).getCoordinates().get(j).getLatitude(), amapping.getLocationMappings().get(i).getCoordinates().get(j).getLongitude()));
				}
				drawPolygon();	
				addPriorityArea(amapping.getLocationMappings().get(i).getType(), amapping.getLocationMappings().get(i).getDescription(), amapping.getLocationMappings().get(i).getImportance());
			}
			else { // priority side

				for (int j = 0; j < amapping.getLocationMappings().get(i).getCoordinates().size() - 1; j++) {
					// find line that connects two coordinates
					for (LPolyline line : this.getPolylines()) {
						double latPolylinePoint1 = (double)Math.round(line.getPoints()[0].getLat() * 1000000d) / 1000000d;
						double lonPolylinePoint1 = (double)Math.round(line.getPoints()[0].getLon() * 1000000d) / 1000000d;
						double latPolylinePoint2 = (double)Math.round(line.getPoints()[1].getLat() * 1000000d) / 1000000d;
						double lonPolylinePoint2 = (double)Math.round(line.getPoints()[1].getLon() * 1000000d) / 1000000d;
						double latPriorityPoint1 = (double)Math.round(amapping.getLocationMappings().get(i).getCoordinates().get(j).getLatitude() * 1000000d) / 1000000d;
						double lonPriorityPoint1 = (double)Math.round(amapping.getLocationMappings().get(i).getCoordinates().get(j).getLongitude() * 1000000d) / 1000000d;
						double latPriorityPoint2 = (double)Math.round(amapping.getLocationMappings().get(i).getCoordinates().get(j+1).getLatitude() * 1000000d) / 1000000d;
						double lonPriorityPoint2 = (double)Math.round(amapping.getLocationMappings().get(i).getCoordinates().get(j+1).getLongitude() * 1000000d) / 1000000d;
						if ((latPolylinePoint1 == latPriorityPoint1 && lonPolylinePoint1 == lonPriorityPoint1 && latPolylinePoint2 == latPriorityPoint2 && lonPolylinePoint2 == lonPriorityPoint2)
							|| (latPolylinePoint2 == latPriorityPoint1 && lonPolylinePoint2 == lonPriorityPoint1 && latPolylinePoint1 == latPriorityPoint2 && lonPolylinePoint1 == lonPriorityPoint2)) {
							addPriorityLine(line);
						}
					}
				}
				addPrioritySide(amapping.getLocationMappings().get(i).getId(), amapping.getLocationMappings().get(i).getType(), amapping.getLocationMappings().get(i).getDescription(), amapping.getLocationMappings().get(i).getImportance());
			}
		}
		
		// also, mark upstream so that the waterfall icon is correctly drawn
		if (amapping != null) {
			upstream = amapping.getUpstream();
		}
	}
	
	// switch out one of the areas in allPriorityAreas with one that was edited
	public void editPriorityArea(PriorityArea changedArea) {
		for (int i = 0; i < allPriorityAreas.size(); i++) {
			if (allPriorityAreas.get(i).getId().equals(changedArea.getId())) {
				allPriorityAreas.set(i, changedArea);
			}
		}
	}
	
	// switch out one of the sides in allPrioritySides with one that was edited
	public void editPrioritySide(PrioritySide changedSide) {
		for (int i = 0; i < allPrioritySides.size(); i++) {
			if (allPrioritySides.get(i).getId().equals(changedSide.getId())) {
				allPrioritySides.set(i, changedSide);
			}
		}
	}
	
	// adds a new priority line
	public void addPriorityLine(LPolyline lineToAdd) {

		Boolean foundInAllPriorityLines = false;
		
		// iterate through existing priority lines to make sure that it doesn't already exist
		for (LPolyline polyline : allPriorityLines) 
			if ((((double)Math.round(lineToAdd.getPoints()[0].getLat() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[0].getLat() * 1000000d) / 1000000d)
			&& ((double)Math.round(lineToAdd.getPoints()[0].getLon() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[0].getLon() * 1000000d) / 1000000d)
			&& ((double)Math.round(lineToAdd.getPoints()[1].getLat() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[1].getLat() * 1000000d) / 1000000d)
			&& ((double)Math.round(lineToAdd.getPoints()[1].getLon() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[1].getLon() * 1000000d) / 1000000d)) 
			|| (((double)Math.round(lineToAdd.getPoints()[0].getLat() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[1].getLat() * 1000000d) / 1000000d)
			&& ((double)Math.round(lineToAdd.getPoints()[0].getLon() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[1].getLon() * 1000000d) / 1000000d)
			&& ((double)Math.round(lineToAdd.getPoints()[1].getLat() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[0].getLat() * 1000000d) / 1000000d)
			&& ((double)Math.round(lineToAdd.getPoints()[1].getLon() * 1000000d) / 1000000d == (double)Math.round(polyline.getPoints()[0].getLon() * 1000000d) / 1000000d))) {
				foundInAllPriorityLines = true;
				break;
			}

		// if not found, add the new line
		if (!foundInAllPriorityLines) {
			lineToAdd.setColor(""#ff5050"");
			lineToAdd.setOpacity(0.7);
			newPrioritySideLines.add(lineToAdd);
			allPriorityLines.add(lineToAdd);
			map.addComponent(lineToAdd);
			lineToAdd.addMouseOverListener(new AMPrioritySideMouseOverListener(mapComponent, lineToAdd));
			lineToAdd.addMouseOutListener(new AMPriorityMouseOutListener(this));
		}
		polylineClickListener.resetPolylineIsClickedInThisEvent();
	}
	
	// adds the current priority side to allPrioritySides
	public void addPrioritySide(String id, String type, String description, int importance) {
		// return if no newPrioritySideLines or if the side already exists in allPrioritySides
		if (newPrioritySideLines.size() == 0) {
			return;
		}
		for (PrioritySide side : allPrioritySides) {
			if (side.getId().equals(id)) {
				return;
			}
		}

		PrioritySide newPrioritySide = new PrioritySide(id);
		newPrioritySide.setType(type);
		newPrioritySide.setDescription(description);
		newPrioritySide.setImportance(importance);
		// add all coords belonging the lines to the list of coords
		for (LPolyline line : newPrioritySideLines) {
			for (int i = 0; i <= 1; i++) {
				LlaCoordinate currCoord = new LlaCoordinate(line.getPoints()[i].getLat(), line.getPoints()[i].getLon(), 0);
				newPrioritySide.addCoordinate(currCoord);
			}
		}

		allPrioritySides.add(newPrioritySide);
		newPrioritySideLines.clear();
	}
	
	// used to add a full side when creating a sub-map
	public void addPrioritySide(PrioritySide side) {
		for (int j = 0; j < side.getCoordinates().size() - 1; j++) {
			// find line that connects two coordinates
			for (LPolyline line : this.getPolylines()) {
				double latPolylinePoint1 = (double)Math.round(line.getPoints()[0].getLat() * 1000000d) / 1000000d;
				double lonPolylinePoint1 = (double)Math.round(line.getPoints()[0].getLon() * 1000000d) / 1000000d;
				double latPolylinePoint2 = (double)Math.round(line.getPoints()[1].getLat() * 1000000d) / 1000000d;
				double lonPolylinePoint2 = (double)Math.round(line.getPoints()[1].getLon() * 1000000d) / 1000000d;
				double latPriorityPoint1 = (double)Math.round(side.getCoordinates().get(j).getLatitude() * 1000000d) / 1000000d;
				double lonPriorityPoint1 = (double)Math.round(side.getCoordinates().get(j).getLongitude() * 1000000d) / 1000000d;
				double latPriorityPoint2 = (double)Math.round(side.getCoordinates().get(j+1).getLatitude() * 1000000d) / 1000000d;
				double lonPriorityPoint2 = (double)Math.round(side.getCoordinates().get(j+1).getLongitude() * 1000000d) / 1000000d;
				if ((latPolylinePoint1 == latPriorityPoint1 && lonPolylinePoint1 == lonPriorityPoint1 && latPolylinePoint2 == latPriorityPoint2 && lonPolylinePoint2 == lonPriorityPoint2)
					|| (latPolylinePoint2 == latPriorityPoint1 && lonPolylinePoint2 == lonPriorityPoint1 && latPolylinePoint1 == latPriorityPoint2 && lonPolylinePoint1 == lonPriorityPoint2)) {
					addPriorityLine(line);
				}
			}
		}
		addPrioritySide(side.getId(), side.getType(), side.getDescription(), side.getImportance());
	}
	
	// Enables/disable sides editing.
	public void setSidesAreEditable (boolean isEditable) {
		sidesAreEditable = isEditable;
	}

	// Returns whether or not edit mode has been enabled.
	public boolean getSidesAreEditable() {
		return sidesAreEditable;
	}
	
	public List<Point> getAllPolygonPins() {
		return allPolygonPinsCopy;
	}
	
	// Enables/disable sides editing.
	public void setPrioritiesAreEditable (boolean isEditable) {
		prioritiesAreEditable = isEditable;
	}
	
	// Returns whether or not edit mode has been enabled.
	public boolean getPrioritiesAreEditable() {
		return prioritiesAreEditable;
	}
	
	// Gets all of the side polylines that are on the map
	public List<LPolyline> getPolylines() {
		return allPolylines;
	}
	
	// Returns the map.
	public LMap getMap() {
		return map;
	}
	
	// Returns the mapComponent (use if the functions in AMMapComponent are needed).
	public AMMapComponent getMapComponent() {
		return mapComponent;
	}
	
	public AMMapAddMarkerListener getMapAddMarkerListener() {
		return mapAddMarkerListener;
	}
	public AMMarkerMouseOverListener getMarkerMouseOverListener() {
		return markerMouseOverListener;
	}
	public AMPolylineClickListener getPolylineClickListener() {
		return polylineClickListener;
	}
	
	public LinkedList<Point> getPolygonVertices() {
		return polygonVertices;
	}
	
	// returns the two sides
	public Vector<List<UIEdgePoint>> getSides() {
		return sides;
	}
	
	// returns the polyline that's moused over
	public LPolyline getMousedOverLine() {
		return mousedOverLine;
	}
	
	// sets the priority area that's moused over
	public void setMousedOverArea(PriorityArea mousedOverArea) {
		this.mousedOverArea = mousedOverArea;
	}
	
	// sets the priority side that's moused over
	public void setMousedOverSide(PrioritySide mousedOverSide) {
		this.mousedOverSide = mousedOverSide;
	}
	
	// gets the priority area that's moused over
	public PriorityArea getMousedOverArea() {
		return mousedOverArea;
	}
	
	// gets the priority side that's moused over
	public PrioritySide getMousedOverSide() {
		return mousedOverSide;
	}
	
	// returns vector that contains a separate list of points for each polygon
	public Vector<PriorityArea> getAllPriorityAreas() {
		return allPriorityAreas;
	}
	
	public void setAllPriorityAreas(Vector<PriorityArea> allPriorityAreas) {
		this.allPriorityAreas = allPriorityAreas;
	}
	
	public void clearPolygonVertices() {
		polygonVertices.clear();
		newPolygonPins.clear();
		newPolygonLines.clear();
	}
	
	public void setPriorityInfoWindow(AMPriorityInfoWindow priorityInfoWindow) {
		this.priorityInfoWindow = priorityInfoWindow;
	}
	public AMPriorityInfoWindow getPriorityInfoWindow() {
		return priorityInfoWindow;
	}
	
	public List<LMarker> getNewPolygonPins() {
		return newPolygonPins;
	}
	
	public List<LPolyline> getNewPrioritySideLines() {
		return newPrioritySideLines;
	}
	
	public List<PrioritySide> getAllPrioritySides() {
		return allPrioritySides;
	}
	
	public List<LPolyline> getAllPriorityLines() {
		return allPriorityLines;
	}
	
	public List<UIEdgePoint> getAllSideWaypoints() {
		return new LinkedList<>(allSideWaypoints);
	}
	
	public Boolean getUpstream() {
		return upstream;
	}
	
	public void setUpstream(Boolean upstream) {
		this.upstream = upstream;
	}
} "
IBaseServiceProvider.java,"package edu.nd.dronology.services.core.api;

import edu.nd.dronology.services.core.remote.IRemoteManager;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public interface IBaseServiceProvider {

	void init(String serverHost, int serverPort);
 
	IRemoteManager getRemoteManager() throws DronologyServiceException;

}
"
CollisionAvoidanceCheckTask.java,"package edu.nd.dronology.core.collisionavoidance;

import edu.nd.dronology.core.fleet.DroneFleetManager;
import edu.nd.dronology.core.vehicle.ManagedDrone;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collector;
import java.util.stream.Collectors;

public class CollisionAvoidanceCheckTask extends TimerTask {
    private static final ILogger LOGGER = LoggerProvider.getLogger(CollisionAvoidanceCheckTask.class);
    private final CollisionAvoider avoiderStrategy;
    private DroneCollector droneCollector;
    private final HashMap<String, DroneSnapshot> tmp = new HashMap<>();

    public CollisionAvoidanceCheckTask(CollisionAvoider avoiderStrategy) {
        this.avoiderStrategy = avoiderStrategy;
        this.droneCollector = new DroneCollector() {
            @Override
            public List<ManagedDrone> getManagedDrones() {
                return DroneFleetManager.getInstance().getRegisteredDrones();
//                return Collections.<ManagedDrone>emptyList();
            }
        };
    }

    @Override
    public void run() {
        LOGGER.debug(""CA timer task started"");
        List<ManagedDrone> allDrones = droneCollector.getManagedDrones().stream().filter(uav -> {
            // return uav.getFlightModeState().isInAir() || uav.getFlightModeState().isFlying();
            return uav.isStarted();
        }).collect(Collectors.toList());
        if (allDrones.size() < 1) {
            return;
        }
        ArrayBlockingQueue<DroneSnapshotOption> returnQueue = new ArrayBlockingQueue<>(allDrones.size());
        ArrayList<DroneSnapshot> input = new ArrayList<>();
        tmp.clear();
        for (ManagedDrone managedDrone : allDrones) {
            managedDrone.getMessenger().getSnapshot(returnQueue);
        }
        for (ManagedDrone managedDrone: allDrones) {
            try {
                DroneSnapshotOption snapshotOption = returnQueue.take();
                DroneSnapshot snapshot = snapshotOption.snapshot;
                if (Objects.nonNull(snapshot)) {
                    input.add(snapshot);
                    tmp.put(snapshot.getName(), snapshot);
                } else {
                    LOGGER.debug(snapshotOption.droneName + "" didn't provide a snapshot."");
                }
            } catch (Exception e) {
                LOGGER.error(e);
                return;
            }
        }

        LOGGER.debug(""Running avoid on "" + input.size() + "" drones"");
        avoiderStrategy.avoid(input);

        for (ManagedDrone managedDrone : allDrones) {
            if (tmp.containsKey(managedDrone.getDroneName())) {
                managedDrone.getMessenger().updateGuidance(tmp.get(managedDrone.getDroneName()).getCommands());
            }
        }
    }

}
"
AbstractServerService.java,"package edu.nd.dronology.services.core.base;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import edu.nd.dronology.services.core.api.IServiceInstance;
import edu.nd.dronology.services.core.api.ServiceInfo;
import edu.nd.dronology.services.core.listener.IServiceListener;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.util.NullUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public abstract class AbstractServerService<S extends IServiceInstance> {

	private static final ILogger LOGGER = LoggerProvider.getLogger(AbstractServerService.class);

	protected S serviceInstance;
	protected AtomicBoolean isStarted = new AtomicBoolean(false);
	private static List<AbstractServerService> services = new ArrayList<>();
	private static String customWorkspace;



	public AbstractServerService() {
		services.add(this);
		serviceInstance = initServiceInstance();
	}

	public S getServer() {
		return serviceInstance;
	}

	public void startService() throws DronologyServiceException {
		if (isStarted.compareAndSet(false, true)) {
			// LOGGER.info(""Service '"" + this.getClass().getSimpleName() + ""' started"");
			serviceInstance.startService();
			// ServiceOrchestrator.registerService(this);
		}
	}

	public void stopService() throws DronologyServiceException {
		if (isStarted.compareAndSet(true, false)) {
			// LOGGER.info(""Service '"" + this.getClass().getSimpleName() + ""' stopped"");
			serviceInstance.stopService();
			// ServiceOrchestrator.unregisterService(this);
		}
	}

	public void restartService() throws DronologyServiceException {
		LOGGER.info(""Restarting "" + getClass().getSimpleName());
		if (!isStarted.get()) {
			startService();
		} else {
			stopService();
			try {
				Thread.sleep(300);
			} catch (InterruptedException e) {
				LOGGER.error(e);
			}
			startService();
		}
	}

	public boolean addServiceListener(IServiceListener processListener) {
		return serviceInstance.addServiceListener(processListener);

	}

	public boolean removeServiceListener(IServiceListener processListener) {
		return serviceInstance.remoteServiceListener(processListener);
	}

	public ServiceInfo getServerInfo() {
		return serviceInstance.getServiceInfo();
	}

	public static void addUniversialServiceListener(IServiceListener processListener) {
		synchronized (services) {
			for (AbstractServerService service : services) {
				service.serviceInstance.addServiceListener(processListener);
			}
		}
	}

	public static void setWorkspace(String customWorkspace) {
		NullUtil.checkNull(customWorkspace);
		AbstractServerService.customWorkspace = customWorkspace;
	}
	

	public static String getWorkspace() {
		return customWorkspace;
	}

	public static void removeUniversialServiceListener(IServiceListener processListener) {
		synchronized (services) {
			for (AbstractServerService service : services) {
				service.serviceInstance.addServiceListener(processListener);
			}
		}
	}

	protected abstract S initServiceInstance();

	public static List<ServiceInfo> getServiceInfos() throws DronologyServiceException {
		List<ServiceInfo> sInfos = new ArrayList<>();
		synchronized (services) {
			for (AbstractServerService service : services) {
				ServiceInfo sInfo = service.getServerInfo();
				if (sInfo == null) {
					throw new DronologyServiceException(""Error retrieving service information from '""
							+ service.getClass().getSimpleName() + ""'"");
				}
				sInfos.add(sInfo);
			}
		}
		return Collections.unmodifiableList(sInfos);
	}

	public static List<ServiceInfo> getFileServiceInfos() throws DronologyServiceException {
		List<ServiceInfo> sInfos = new ArrayList<>();
		synchronized (services) {
			for (AbstractServerService service : services) {
				ServiceInfo sInfo = service.getServerInfo();
				if (sInfo == null) {
					throw new DronologyServiceException(""Error retrieving service information from '""
							+ service.getClass().getSimpleName() + ""'"");
				}
				if (service instanceof AbstractFileTransmitServerService<?, ?>) {
					sInfos.add(sInfo);
				}
			}
		}
		return Collections.unmodifiableList(sInfos);
	}

	public static void stopAll() {
		for (AbstractServerService service : services) {
			try {
				service.stopService();
			} catch (DronologyServiceException e) {
				LOGGER.error(e);
			}
		}
	}

	public static void restartAll() {
		for (AbstractServerService service : services) {
			try {
				service.restartService();
			} catch (DronologyServiceException e) {
				LOGGER.error(e);
			}
		}
	}

	protected AbstractServerService getService(String serviceClass) throws DronologyServiceException {
		for (AbstractServerService service : services) {
			if (service.getClass().getCanonicalName().equals(serviceClass)) {
				return service;
			}
		}
		throw new DronologyServiceException(""Service '"" + serviceClass + ""' not found!"");
	}

	public static List<ServiceInfo> getCoreServices() throws DronologyServiceException {
		List<ServiceInfo> sInfos = new ArrayList<>();
		synchronized (services) {
			for (AbstractServerService service : services) {
				ServiceInfo sInfo = service.getServerInfo();
				if (sInfo == null) {
					throw new DronologyServiceException(""Error retrieving service information from '""
							+ service.getClass().getSimpleName() + ""'"");
				}
				if (!(service instanceof AbstractFileTransmitServerService<?, ?>)) {
					sInfos.add(sInfo);
				}
			}
		}
		return Collections.unmodifiableList(sInfos);
	}



}
"
MissionPlanningService.java,"package edu.nd.dronology.services.extensions.missionplanning.service.internal;

import edu.nd.dronology.services.core.base.AbstractFileTransmitServerService;
import edu.nd.dronology.services.core.info.MissionInfo;
import edu.nd.dronology.services.core.info.UAVMappingInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

/**
 * 
 * Services for planning and executing missions for multiple UAVs .<br>
 * Initial implementation of mission planning capabilities. <br>
 * Allows retrieving sending a mission plan as JSON String to Dronology.
 * 
 * 
 * @author Michael Vierhauser
 *
 */
public class MissionPlanningService
		extends AbstractFileTransmitServerService<IMissionPlanningServiceInstance, MissionInfo> {

	private static volatile MissionPlanningService INSTANCE;

	protected MissionPlanningService() {
	}

	/**
	 * @return The singleton ConfigurationService instance
	 */
	public static MissionPlanningService getInstance() {
		if (INSTANCE == null) {
			synchronized (MissionPlanningService.class) {
				if (INSTANCE == null) {
					INSTANCE = new MissionPlanningService();
				}
			}
		}
		return INSTANCE;
	}

	@Override
	protected IMissionPlanningServiceInstance initServiceInstance() {
		return new MissionPlanningServiceInstance();
	}

	public void executeMissionPlan(String mission) throws DronologyServiceException {
		serviceInstance.executeMissionPlan(mission);

	}

	public void cancelMission() throws DronologyServiceException {
		serviceInstance.cancelMission();

	}

	public void removeUAV(String uavid) throws DronologyServiceException {
		serviceInstance.removeUAV(uavid);

	}

	public void executeMissionPlan(MissionInfo mission) throws DronologyServiceException {
		serviceInstance.executeMissionPlan(mission);

	}

	public void executeMissionPlan(MissionInfo mission, UAVMappingInfo mapping) throws DronologyServiceException {
		serviceInstance.executeMissionPlan(mission, mapping);

	}

}
"
IFlightSimulator.java,"package edu.nd.dronology.core.simulator;

import edu.nd.dronology.core.vehicle.internal.VirtualDrone;

/**
 * 
 * Interface for the internal simulator used with {@link VirtualDrone}.<br>
 * The simulator consists of a {@link IBatterySimulator} and a {@link IMovementSimulator} approximating the behavior of a UAV.
 * 
 * @author Michael Vierhauser
 *
 */
public interface IFlightSimulator extends IBatterySimulator, IMovementSimulator {

}
"
StopEveryone.java,"package edu.nd.dronology.core.collisionavoidance.strategy;

import edu.nd.dronology.core.collisionavoidance.CollisionAvoider;
import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.WaypointCommand;
import edu.nd.dronology.core.goal.AbstractGoal;
import edu.nd.dronology.core.goal.IGoalSnapshot;
import edu.nd.dronology.core.goal.WaypointGoalSnapshot;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

import java.util.ArrayList;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * The StopEveryone CollisionAvoider is a failsafe that only triggers if it detects two drones are intruding into each
 * others space because something has gone wrong. Use this with mission plans that carefully navigate the drones to
 * avoid crashing into one another. StopEveryone assumes the drones will follow a mission plan that takes into account
 * where all the drones will be in space and time. When the StopEveryone CollisionAvoider is triggered the mission is
 * aborted, and humans need to land the drones manually.
 */
public class StopEveryone implements CollisionAvoider {
    private static final ILogger LOGGER = LoggerProvider.getLogger(StopEveryone.class);
    private final double threshold;

    /**
     * Initializes a newly created StopEveryone object that triggers all drones to stop whatever they're doing and hover
     * in place, if any two drones move closer than the threshold distance to one another.
     *
     * @param threshold distance in meters. If any two drones move close enough to be within the threshold distance,
     *                  then StopEveryone will command all drones to stop whatever they're doing and hover in place.
     */
    public  StopEveryone(double threshold) {
        this.threshold = threshold;
    }

    @Override
    public void avoid(ArrayList<DroneSnapshot> drones) {
        ArrayList<DroneSnapshot> flyingDrones = findFlyingDrones(drones);
        if (isSafe(flyingDrones)) {
            // fly to the goal
            for (DroneSnapshot drone : flyingDrones) {
                WaypointGoalSnapshot waypointGoal = findActiveWaypointGoal(drone.getGoals());
                if (waypointGoal != null) {
                    LOGGER.debug(drone.getName() + "" had a waypoint goal: "" + waypointGoal.getPosition().toLlaCoordinate());
                    flyToGoalIfNotAlready(drone, waypointGoal);
                } else {
                    LOGGER.debug(drone.getName() + "" had no waypoint goal"");
                }
            }
        }
        else {
            // stop everyone
            for (DroneSnapshot drone : flyingDrones) {
                LOGGER.fatal(""WARNING ALL DRONES STOPPED"");
                onStopTrigger(drone);
            }
        }
    }

    protected void onStopTrigger(DroneSnapshot drone) {
        stopDroneIfNotStopped(drone);
    }

    /**
     * @param flyingDrones the drones that are flying (not all drones)
     * @return true if every drone is at least threshold distance apart
     */
    private boolean isSafe(ArrayList<DroneSnapshot> flyingDrones) {
        for (int i = 0; i < flyingDrones.size() - 1; ++i) {
            for (int j = i + 1; j < flyingDrones.size(); ++j) {
                if (isTooClose(flyingDrones.get(i), flyingDrones.get(j))) {
                    return false;
                }
            }
        }
        return true;
    }


    /**
     * Check if two drones are too close
     * @param a the first drone
     * @param b the second drone
     * @return true if the distance between the drones is less than the threshold distance
     */
    private boolean isTooClose(DroneSnapshot a, DroneSnapshot b) {
        double distance = a.getPosition().distance(b.getPosition());
        boolean result = distance < this.threshold;
        if (result) {
            LOGGER.warn(""DRONES TOO CLOSE "" + a.getName() + "", "" + b.getName() + "" distance: "" + distance);
        }
        return result;
    }

    /**
     * given the drone snapshots, filter out the drones that are not flying
     * @param drones all the drone snapshots
     * @return a list with all the flying drones
     */
    public static ArrayList<DroneSnapshot> findFlyingDrones(ArrayList<DroneSnapshot> drones) {
        return drones.stream()
                .filter(drone -> ""FLYING"".equals(drone.getState()))
                .collect(Collectors.toCollection(ArrayList::new));
    }

    // if no active waypoint goal exists return null, otherwise return the first one it finds. Note if more than one
    // active waypoint goal exists in the set of active goals, the active goal that is returned is up to the set's
    // iterator
    public static WaypointGoalSnapshot findActiveWaypointGoal(Set<IGoalSnapshot> goals) {
        for (IGoalSnapshot goal: goals) {
            if (goal instanceof WaypointGoalSnapshot && goal.getState() == AbstractGoal.GoalState.ACTIVE) {
                return (WaypointGoalSnapshot) goal;
            }
        }
        return null;
    }

    /**
     * Make sure the drone's command queue has a stop command, overwriting the current command queue if needed.
     * @param drone to stop
     */
    public static void stopDroneIfNotStopped(DroneSnapshot drone) {
        // we don't need to do anything if the first command in the command queue is a stop command
        if (!drone.getCommands().isEmpty()) {
            if (drone.getCommands().get(0) instanceof StopCommand) {
                return;
            }
        }
        drone.getCommands().clear();
        drone.getCommands().add(new StopCommand(-1.0));
    }

    /*
    if this method is called, we want the drone to fly to the current goal, so we will wipe out command queue and put a
    waypoint command in there unless the drone is already doing the right thing.
     */
    public static void flyToGoalIfNotAlready(DroneSnapshot drone, WaypointGoalSnapshot goal) {
        // check if we are doing the right thing: that we have one cmd in the command queue and that cmd matches the
        // current waypoint goal
        if (drone.getCommands().size() == 1) {
            if (drone.getCommands().get(0) instanceof WaypointCommand) {
                WaypointCommand wp = (WaypointCommand) drone.getCommands().get(0);
                boolean sameDest = wp.getDestination().toLlaCoordinate().equals(goal.getPosition().toLlaCoordinate());
                boolean sameSpeed = wp.getSpeed() == goal.getSpeed();
                if (sameDest && sameSpeed) {
                    return;
                }
            }
        }
        // we have now filtered out the case where we don't have to do anything. If this code runs, we need to replace
        // what's in the command queue
        drone.getCommands().clear();
        WaypointCommand cmd = new WaypointCommand(goal.getPosition().toLlaCoordinate(), goal.getSpeed());
        drone.getCommands().add(cmd);
    }
}
"
UAVTypeRegistrationPersistenceProvider.java,"package edu.nd.dronology.services.core.persistence;

import edu.nd.dronology.services.core.items.IUAVRegistration;
import edu.nd.dronology.services.core.items.IUAVTypeRegistration;
import edu.nd.dronology.services.core.persistence.internal.UAVTypeRegistrationXStreamPersistor;


/**
 * Provider implementation for {@link IUAVRegistration}.<br>
 * Details see {@link AbstractItemPersistenceProvider}
 * 
 * @author Michael Vierhauser
 * 
 */
public class UAVTypeRegistrationPersistenceProvider extends AbstractItemPersistenceProvider<IUAVTypeRegistration> {

	public UAVTypeRegistrationPersistenceProvider() {
		super();
	}

	@Override
	protected void initPersistor() {
		PERSISTOR = new UAVTypeRegistrationXStreamPersistor();

	}

	@Override
	protected void initPersistor(String type) {
		initPersistor();
	}

	public static UAVTypeRegistrationPersistenceProvider getInstance() {
		return new UAVTypeRegistrationPersistenceProvider();
	}

}
"
RemoteManagerFactory.java,"package edu.nd.dronology.services.remote.rmi;

import java.util.ArrayList;
import java.util.List;

import edu.nd.dronology.services.core.remote.IRemoteManager;

public class RemoteManagerFactory {



	public static List<IRemoteManager> createRMIObjects(Integer port) {
		List<IRemoteManager> manager = new ArrayList<>();
		manager.add(RemoteRMIRemoteObject.getInstance(port));
		return manager;
		
	}



}
"
AreaMappingGenerator.java,"package edu.nd.dronology.services.extensions.areamapping;

import java.util.Collection;
import java.util.List;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.areamapping.ExportAllocationInformation;
import edu.nd.dronology.services.core.areamapping.ExportDrone;
import edu.nd.dronology.services.core.areamapping.GeneratedMappedArea;
import edu.nd.dronology.services.core.items.IAreaMapping;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.extensions.areamapping.creation.MapRiver;
import edu.nd.dronology.services.extensions.areamapping.selection.GeneratedRoutesInfo;
import edu.nd.dronology.services.extensions.areamapping.selection.IRouteSelectionStrategy;
import edu.nd.dronology.services.extensions.areamapping.selection.RouteSelectionResult;
import edu.nd.dronology.services.extensions.areamapping.selection.StrategyFactory;
import edu.nd.dronology.services.extensions.areamapping.util.SelectionWriter;

public class AreaMappingGenerator {

	private IAreaMapping mapping;
	private Collection<IUAVProxy> selectedUAVs;
	private MapRiver riverMapper;

	public AreaMappingGenerator(IAreaMapping mapping, Collection<IUAVProxy> selectedUAVs) {
		this.mapping = mapping;
		this.selectedUAVs = selectedUAVs;

	}

	public GeneratedMappedArea generateMapping() throws DronologyServiceException {

		try {

			riverMapper = new MapRiver(mapping);

			IRouteSelectionStrategy selector = StrategyFactory.getSelectionStrategy();

			long startGenerate = System.currentTimeMillis();
			GeneratedRoutesInfo gInfo = new GeneratedRoutesInfo(riverMapper.generateRoutePrimitives(),
					riverMapper.getAverageLatitude(), riverMapper.getTotalRiverSegment(), riverMapper.getBankList());
			long endGenerate = System.currentTimeMillis();

			selector.initialize(gInfo, selectedUAVs, mapping);

			long startSelect = System.currentTimeMillis();
			RouteSelectionResult result = selector.generateAssignments();
			long endSelect = System.currentTimeMillis();

			System.out.println(""ROUTE Generation: "" + (endGenerate - startGenerate) / 1000);
			System.out.println(""ROUTE Selection: "" + (endSelect - startSelect) / 1000);
			System.out.println(""Specs: "");
			ExportAllocationInformation flight = result.getEportAllocationInformation().get(0);
			System.out.println(""Mission Score: "" + flight.getMetricStatistics().getAllocationScore());
			System.out.println(""Coverage: "" + flight.getMetricStatistics().getAllocationCoverage());
			System.out.println(""Equality of Tasks: "" + flight.getMetricStatistics().getEqualityOfTasks());
			System.out.println(""Collisions: "" + flight.getMetricStatistics().getCollisions());

			List<ExportDrone> allocations = result.getEportAllocationInformation().get(0).getDroneAllocations();

			GeneratedMappedArea area = new GeneratedMappedArea();

			allocations.forEach(ed -> {
				area.addUAVRouteAssignment(ed);
			});

			new SelectionWriter().writeRouteSelection(result);

			return area;

		} catch (Throwable t) {
			t.printStackTrace();
			throw new DronologyServiceException(t.getMessage());
		}
	}
}
"
IRemoteMonitoringMessageHandler.java,"package edu.nd.dronology.monitoring;

import java.rmi.Remote;
import java.rmi.RemoteException;

import edu.nd.dronology.core.monitoring.IMonitorableMessage;
 
public interface IRemoteMonitoringMessageHandler extends Remote {

	void notifyMonitoringMessage(IMonitorableMessage message) throws RemoteException;

}
"
NvecInterpolator.java,"package edu.nd.dronology.core.simulator.nvecsimulator;

import edu.nd.dronology.core.coordinate.NVector;

/**
 * 
 * @author Michael Murphy
 *
 */
public class NvecInterpolator {
	public static final double TOLERANCE = 0.001; // 1 Millimeter

	private static NVector mid(NVector a, NVector b) {
		double x = average(a.getX(), b.getX());
		double y = average(a.getY(), b.getY());
		double z = average(a.getZ(), b.getZ());
		double alt = average(a.getAltitude(), b.getAltitude());
		return new NVector(x, y, z, alt);
	}
 
	private static double average(double a, double b) {
		return (a + b) / 2.0;
	}

	/**
	 * Uses the bisection method to iteratively hone in on the nvector that is
	 * metersToTravel distance away from the current n-vector along the path
	 * that goes from current to target. A path can be thought of as the set of
	 * NVectors you can create by interpolating between current and target. This
	 * code takes advantage of this to find the NVector on this path that is the
	 * right distance away from the current distance.
	 * 
	 * @param current
	 *            drone current position
	 * @param target
	 *            drone target position
	 * @param metersToTravel
	 *            the distance the drone should travel along the path from
	 *            current to target
	 * @return the nvector taht is meters distance away from current along the
	 *         path that goes from current to target
	 */
	public static NVector move(NVector current, NVector target, double metersToTravel) {
		// a negative value for metersToTravel causes an infinite loop
		if (metersToTravel < 0.0) {
			throw new IllegalArgumentException();
		}
		if (current.distance(target) < metersToTravel) {
			return target;
		}
		NVector lowBall = current;
		NVector highBall = target;
		NVector nextGuess = mid(lowBall, highBall);
		double guessDistance = current.distance(nextGuess);
		while (Math.abs(guessDistance - metersToTravel) > TOLERANCE) {
			if (guessDistance > metersToTravel) {
				highBall = nextGuess;
			} else {
				lowBall = nextGuess;
			}
			nextGuess = mid(lowBall, highBall);
			guessDistance = current.distance(nextGuess);
		}
		return nextGuess;
	}

}
"
IDroneStatusChangeListener.java,"package edu.nd.dronology.services.core.listener;

import java.rmi.RemoteException;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.api.IRemotable;

public interface IDroneStatusChangeListener extends IRemotable{

	void droneStatusChanged(IUAVProxy status) throws RemoteException;
	
}
"
UnitState.java,"package edu.nd.dronology.services.core.util;

/**
 * Enum that reflects the current state of a Probe.
 * 
 * @author Michael Vierhauser
 * 
 */
public enum UnitState {

	/**
	 * The unit is running and able to send data.
	 */
	RUNNING,

	/**
	 * The unit is paused and no data is sent to the server.
	 */
	PAUSED,
	/**
	 * The unit has been terminated. No further data will be processed until restarted.
	 */
	TERMINATED,

	/**
	 * Current status is unknown.
	 */
	UNKNOWN,

	/**
	 * The unit is registered at the server.
	 */
	REGISTERED,

	/**
	 * The unit has been unregistered from the server.
	 */
	UNREGISTERED, 
	
	
	ERROR

}
"
RemoteMessageHandler.java,"package edu.nd.dronology.monitoring.simplechecker.monitor;

import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

import edu.nd.dronology.core.monitoring.IMonitorableMessage;
import edu.nd.dronology.monitoring.IRemoteMonitoringMessageHandler;

public class RemoteMessageHandler extends UnicastRemoteObject implements IRemoteMonitoringMessageHandler {

	/**
	 * 
	 */
	private static final long serialVersionUID = -5811464159361618772L;
	private transient MonitorDialog display;



	public RemoteMessageHandler(MonitorDialog display) throws RemoteException {
		super();
		this.display =display;
	}



	@Override
	public void notifyMonitoringMessage(IMonitorableMessage message) throws RemoteException {

		display.addLine(message.toString());
		
		
	}


}
"
AbstractFileTransmitServiceInstance.java,"package edu.nd.dronology.services.core.base;

import java.io.File;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import edu.nd.dronology.services.core.api.IFileChangeNotifyable;
import edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;
import edu.nd.dronology.services.core.info.RemoteInfoObject;
import edu.nd.dronology.services.core.listener.IItemChangeListener;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.core.util.FileManager;
import edu.nd.dronology.util.FileUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Abstract base class for all services that allow transferring files as a byte
 * array
 * 
 * @author Michael Vierhauser
 *
 * 
 */
public abstract class AbstractFileTransmitServiceInstance<ITEM_TYPE extends RemoteInfoObject>
		extends AbstractServiceInstance implements IFileTransmitServiceInstance<ITEM_TYPE>, IFileChangeNotifyable {

	private static final ILogger LOGGER = LoggerProvider.getLogger(AbstractFileTransmitServiceInstance.class);

	protected String extension;
	protected FileManager fileManager;
	protected List<IItemChangeListener> listeners = new ArrayList<>();
	protected Map<String, ITEM_TYPE> itemmap = new Hashtable<>();
	protected String storagePath;

	public AbstractFileTransmitServiceInstance(String ID, String description, String extension) {
		super(ID, description);
		this.extension = extension;
		storagePath = getPath();
		fileManager = new FileManager(this, storagePath, extension);
	}

	@Override
	public Collection<ITEM_TYPE> getItems() {
		List<ITEM_TYPE> charts;
		synchronized (itemmap) {
			charts = new ArrayList<>(itemmap.values());
		}
		return Collections.unmodifiableList(charts);
	}

	@Override
	public ITEM_TYPE getItem(String id) throws DronologyServiceException {
		synchronized (itemmap) {
			if (itemmap.containsKey(id)) {
				return itemmap.get(id);
			}
		}
		throw new DronologyServiceException(""Item '"" + id + ""' not found"");
	}

	@Override
	public byte[] requestFromServer(String id) throws DronologyServiceException {
		return fileManager.getFileAsByteArray(id);
	}

	@Override
	public void transmitToServer(String id, byte[] content) throws DronologyServiceException {
		fileManager.saveByteArrayToFile(id, content);
	}

	@Override
	public void notifyFileChange(Set<String> changed) {
		reloadItems();
		Set<String> info = new TreeSet<>();
		for (String s : changed) {
			String id = s.replace(""."" + extension, """");
			if (itemmap.containsKey(id)) {
				info.add(""ADDED/UPDATED: "" + itemmap.get(id).getName() + ""["" + id + ""]"");
			} else {
				info.add(""REMOVED: ["" + id + ""]"");
			}
		}

		List<IItemChangeListener> notifyList;
		synchronized (listeners) {
			notifyList = new ArrayList<>(listeners);
		}
		for (IItemChangeListener listener : notifyList) {
			try {
				listener.itemChanged(info);
			} catch (RemoteException e) {
				LOGGER.error(e);
				listeners.remove(listener);
			}
		}

	}

	protected void reloadItems() {
		try {
			itemmap.clear();
			File[] files = fileManager.loadFiles();
			for (File file : files) {
				String id = file.getName().replace(""."" + extension, """");
				ITEM_TYPE item = null;
				try {
					item = fromFile(id, file);
				} catch (Throwable e) {
					LOGGER.error(""Error loading file with id:"" + id + ""file: "" + file.getAbsolutePath(), e);
				}
				if (item != null) {
					itemmap.put(id, item);
				}
			}
		} catch (Exception e) {
			LOGGER.error(e);
		}
	}

	@Override
	public void deleteItem(String itemid) throws DronologyServiceException {
		String savelocation = FileUtil.concat(storagePath, itemid, extension);
		File f = new File(savelocation);
		if (f.exists()) {
			boolean success = f.delete();
			LOGGER.info((success ? ""Done"" : ""Failed"") + "" deleting Item: "" + savelocation);
			reloadItems();
		} else {
			throw new DronologyServiceException(""Item '"" + itemid + ""' does not exist on server"");
		}

	}

	@Override
	public boolean addItemChangeListener(IItemChangeListener listener) {
		synchronized (listeners) {
			if (!listeners.contains(listener)) {
				LOGGER.info(""Adding new Item Change Listener"");
				return listeners.add(listener);
			}
			LOGGER.info(""Listener instance already registered"");
			return false;
		}
	}

	@Override
	public boolean removeItemChangeListener(IItemChangeListener listener) {
		boolean success;
		synchronized (listener) {
			success = listeners.remove(listener);
		}
		if (success) {
			LOGGER.info(""Removed Item Change Listener"");
		} else {
			LOGGER.info(""Failed removing Item Change Listener"");
		}
		return success;
	}

	protected abstract String getPath();

	protected abstract ITEM_TYPE fromFile(String id, File file) throws Throwable;

}
"
NedExecutor.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal;

import edu.nd.dronology.core.collisionavoidance.guidancecommands.NedCommand;
import edu.nd.dronology.core.vehicle.IDrone;
import edu.nd.dronology.core.vehicle.ManagedDrone;

public class NedExecutor implements CommandExecutor {

    enum NedExecutionState {
        RADIOING,
        WATCHING_THE_CLOCK,
        FINISHED;
    }

    private IDrone drone;
    NedExecutionState state = NedExecutionState.RADIOING;
    NedCommand data;
    long startTime;

    public NedExecutor(IDrone drone, NedCommand data) {
        this.drone = drone;
        this.data = data;
    }

    @Override
    public void process() {
        switch (state) {
            case RADIOING:
                radioDrone();
                break;
            case WATCHING_THE_CLOCK:
                checkClock();
                break;
            case FINISHED:
            default:
                // Do nothing.
                break;
        }
    }

    @Override
    public boolean isFinished() {
        return state == NedExecutionState.FINISHED;
    }

    private void radioDrone() {
        drone.setVelocity(data.getNorth(), data.getEast(), data.getDown());
        startTime = System.nanoTime();
        state = NedExecutionState.WATCHING_THE_CLOCK;
    }

    private void checkClock() {
        double waitDuration = data.getTime();
        long deltaNano = System.nanoTime()- startTime;
        double deltaT = deltaNano * 1.0e-9;
        if (deltaT > waitDuration) {
            state = NedExecutionState.FINISHED;
        }
    }
}
"
PatternFactory.java,"package edu.nd.dronology.services.extensions.missionplanning.patterns;

/**
 * Factory class for predefined {@link IFlightPattern}.
 * 
 * @author Michael Vierhauser
 *
 */
public class PatternFactory {

	public enum PatternType {
		COORDINATED_TAKEOFF, COORDINATED_LANDING
	}

	/**
	 * 
	 * @param type
	 *          The {@link PatternType} of the flight pattern to create.
	 * @return A flight pattern for the given pattern type.
	 * @throws An
	 * @{@link IllegalArgumentException} in case the pattern is not supported.
	 */
	public static IFlightPattern getPattern(PatternType type) {
		switch (type) {
			case COORDINATED_TAKEOFF:
				return new CoordinatedTakeoffPattern();

			case COORDINATED_LANDING:
				return new CoordinatedLandingPattern();

			default:
				throw new IllegalArgumentException(""Type "" + type + "" not supported"");
		}
	}

}
"
DroneInitializationInfo.java,"package edu.nd.dronology.services.core.info;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.util.NullUtil;

public class DroneInitializationInfo extends RemoteInfoObject {

	
	public enum DroneMode {
		MODE_VIRTUAL, MODE_PHYSICAL; 

	}

	/**
	 * 
	 */
	private static final long serialVersionUID = 3002533064742692033L;
	private String type;
	private LlaCoordinate initialLocation;
	private DroneMode mode;
	private String safetyInformation;



	public DroneInitializationInfo(String id, DroneMode mode, String type, LlaCoordinate initialLocation) {
		super(id, id);
		NullUtil.checkNull(type, initialLocation,mode);
		this.type = type;
		this.mode= mode;
		this.initialLocation = initialLocation;

	}

	public DroneMode getMode() {
		return mode;
	}

	public String getType() {
		return type;
	}

	public LlaCoordinate getInitialLocation() {
		return initialLocation;
	}
	
	public String getSafetyInformation() {
		return safetyInformation;
	}

	public void setSafetyInformation(String safetyInformation) {
		this.safetyInformation = safetyInformation;
	}

}
"
AFMainLayout.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import java.util.List;

import com.vaadin.ui.CssLayout;
import com.vaadin.ui.CustomComponent;

/**
 * This is the main layout for the Active Flights UI
 * 
 * @author Jinghui Cheng
 */
public class AFMainLayout extends CustomComponent {
	private static final long serialVersionUID = 1L;
	private AFControlsComponent controls = new AFControlsComponent();
	private AFMapComponent map = new AFMapComponent(controls.getPanel());
 
	public AFMainLayout() {
		addStyleName(""main_layout"");

		CssLayout content = new CssLayout();
		content.setSizeFull();

		controls.getPanel().getMapView().getViewButton().addClickListener(e -> {
			map.setFollow(false);
			map.setAverageCenter();
		});



		controls.getPanel().getMapView().getFollowButton().addClickListener(e -> {
			map.setFollow(true);
			map.setFollowZoom(true);
			List<String> names = controls.getPanel().getChecked();
			map.followDrones(names);
		});

		content.addComponents(controls, map);
		setCompositionRoot(content);
	}

	/**
	 * determines if the map should continue in follow mode
	 */
	public void continueFollowing() {
		if (map.getFollow()) {
			List<String> names = controls.getPanel().getChecked();
			map.followDrones(names);
		}
	}

	public AFControlsComponent getControls() {
		return controls;
	}

	public AFMapComponent getAFMap() {
		return map;
	}
}
"
PlanPoolManager.java,"package edu.nd.dronology.core.flight;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.monitoring.DronologyMonitoringManager;
import edu.nd.dronology.core.monitoring.MessageMarshaller;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * Management of pending plans for individual UAVs.<br>
 * Each active UAV has a {@link PlanPool} that keeps track of the assigned (and pending) flight plans.
 * 
 * @author Michael Vierhauser
 *
 */
public class PlanPoolManager {

	private static volatile PlanPoolManager INSTANCE = null;

	private static final ILogger LOGGER = LoggerProvider.getLogger(PlanPoolManager.class);

	private Map<String, PlanPool> planList = new ConcurrentHashMap<>();

	private List<IFlightPlan> pendingPlans = Collections.synchronizedList(new ArrayList<>());

	private List<IPlanStatusChangeListener> planStatusChangeListener = Collections.synchronizedList(new ArrayList<>());

	public static PlanPoolManager getInstance() {
		if (INSTANCE == null) {
			synchronized (PlanPoolManager.class) {
				if (INSTANCE == null) {
					INSTANCE = new PlanPoolManager();
				}
			}
		}
		return INSTANCE;
	}

	public void addNewPlan(IFlightPlan plan) throws DroneException {
		String uavId = plan.getDesignatedDroneId();
		if (uavId == null) {
			assignPlan(plan);
		} else {
			assignToPool(uavId, plan);
		}
	}

	private void assignPlan(IFlightPlan plan) throws DroneException {
		pendingPlans.add(plan);

	}

	private void assignToPool(String uavId, IFlightPlan plan) {
		PlanPool pp = null;
		if (planList.get(uavId) == null) {
			pp = new PlanPool(uavId);
			planList.put(uavId, pp);
		} else {
			pp = planList.get(uavId);
		}
		pp.addPlan(plan);
		pendingPlans.add(plan);
	}

	public boolean hasPendingFlights() {
		return pendingPlans.size() > 0;
	}

	public IFlightPlan getNextPendingPlan() {
		return pendingPlans.get(0);
	}

	public void activatePlan(IFlightPlan plan, String uavid) throws DroneException {
		if (planList.get(uavid) == null) {
			throw new DroneException(""Error no plan for '"" + uavid + ""' pending"");

		}
		pendingPlans.remove(plan);
		planList.get(uavid).setNextPlanToCurrent();
		plan.setDesignatedDroneId(uavid); 
		DronologyMonitoringManager.getInstance().publish(MessageMarshaller.createPlanActive(plan));
	}

	public void checkFormCompletedPlans() throws DroneException {
		for (PlanPool pp : planList.values()) {
			if (pp.getCurrentPlan() != null && pp.getCurrentPlan().isCompleted()) {
				IFlightPlan current = pp.getCurrentPlan();
				pp.setCurrentFlightCompleted();
				DronologyMonitoringManager.getInstance().publish(MessageMarshaller.createPlanCompleted(current));
				notifyPlanChange(current);
			}
		}
	}

	private void notifyPlanChange(IFlightPlan changedPlan) {
		for (IPlanStatusChangeListener listener : planStatusChangeListener) {
			listener.notifyPlanChange(changedPlan);
		}

	}

	public List<IFlightPlan> getCurrentFlights() {
		List<IFlightPlan> currentFlights = new ArrayList<>();
		for (PlanPool pp : planList.values()) {
			if (pp.getCurrentPlan() != null) {
				currentFlights.add(pp.getCurrentPlan());
			}
		}
		return currentFlights;
	}

	public void assignPlan(IFlightPlan plan, String uavId) {
		PlanPool pp = null;
		if (planList.get(uavId) == null) {
			pp = new PlanPool(uavId);
			planList.put(uavId, pp);
		} else {
			pp = planList.get(uavId);
		}
		pp.addPlan(plan);

	}

	public void addPlanStatusChangeListener(IPlanStatusChangeListener listener) {
		planStatusChangeListener.add(listener);

	}

	public IFlightPlan getCurrentPlan(String uavId) {
		if (planList.get(uavId) != null) {
			return planList.get(uavId).getCurrentPlan();
		}
		return null;
	}

	public List<IFlightPlan> getPendingPlans(String uavId) {
		if (planList.get(uavId) != null) {
			return planList.get(uavId).getPendingPlans();
		}
		return Collections.emptyList();
	}

	public List<IFlightPlan> getCompletedPlans(String uavId) {
		if (planList.get(uavId) != null) {
			return planList.get(uavId).getCompletedPlans();
		}
		return Collections.emptyList();
	}

	public void overridePlan(IFlightPlan homePlane, String uavid) throws DroneException {
		if (planList.get(uavid) == null) {
			throw new DroneException(""Error no plan for '"" + uavid + ""' pending"");

		}
		planList.get(uavid).overridePlan(homePlane);

	}

	public void cancelPendingPlans(String uavid) throws DroneException {
		if (planList.get(uavid) == null) {
			throw new DroneException(""Error no plan for '"" + uavid + ""' pending"");

		} 
		planList.get(uavid).cancelPendingPlans();
		synchronized (pendingPlans) {
			List<IFlightPlan> allPending = new ArrayList<>(pendingPlans);

			for (IFlightPlan p : allPending) {
				if (p.getDesignatedDroneId().equals(uavid)) {
					pendingPlans.remove(p);
				}
			}
		}
	}

	public List<IFlightPlan> getPendingPlans() {
		return Collections.unmodifiableList(new ArrayList<>(pendingPlans));
	}

}
"
AllocationInformation.java,"package edu.nd.dronology.services.extensions.areamapping.metrics;

import java.util.ArrayList;
import java.util.List;

import edu.nd.dronology.services.core.areamapping.MetricsStatistics;

public class AllocationInformation implements Comparable<AllocationInformation> {
	private List<Drone> droneAllocations;
	private MetricsStatistics metricsStatistics;

	public AllocationInformation() {
		droneAllocations = new ArrayList<>();
	}

	public List<Drone> getDroneAllocations() {
		return droneAllocations;
	}

	public MetricsStatistics getMetricStatistics() {
		return metricsStatistics;
	}

	public void setDroneAllocations(List<Drone> droneAllocations) {
		this.droneAllocations = droneAllocations;
	}

	public void setMetricsStatistics(MetricsStatistics metricsStatistics) {
		this.metricsStatistics = metricsStatistics;
	}

	@Override
	public int compareTo(AllocationInformation otherAllocation) {
		if (this.getMetricStatistics().getAllocationScore() < otherAllocation.getMetricStatistics().getAllocationScore()) {
			return 1;
		} else if (otherAllocation.getMetricStatistics().getAllocationScore() < this.getMetricStatistics()
				.getAllocationScore()) {
			return -1;
		}
		return 0;
	}
}
"
FileManager.java,"package edu.nd.dronology.services.core.util;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import edu.nd.dronology.services.core.api.IFileChangeNotifyable;
import edu.nd.dronology.util.FileUtil;
import edu.nd.dronology.util.NamedThreadFactory;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class FileManager {

	private static final ILogger LOGGER = LoggerProvider.getLogger(FileManager.class);
	private static final ExecutorService EXECUTOR_SERVICE = Executors.newFixedThreadPool(20,
			new NamedThreadFactory(""Directory-WatchServices""));

	private WatchServiceRunner directoryWatcher;
	private String extension;
	private String path;

	public FileManager(final IFileChangeNotifyable instance, String path, String extension) {
		this.path = path;
		this.extension = extension;
		initWorkspace();

		directoryWatcher = new WatchServiceRunner(path, false, instance, extension);
		EXECUTOR_SERVICE.submit(directoryWatcher);

	}

	private void initWorkspace() {
		File f = new File(path);
		if (!f.exists()) {
			f.mkdirs();
		}

	}

	public byte[] getFileAsByteArray(String fileId) throws DronologyServiceException {
		LOGGER.info(""File '"" + fileId + ""' requested"");

		String savelocation = path + File.separator + fileId + ""."" + extension;
		File f = new File(savelocation);
		if (!f.exists()) {
			LOGGER.info(""File not found: "" + savelocation);
			throw new DronologyServiceException(""File "" + fileId + "" does not exist on server!"");
		}
		byte[] content = FileUtil.toByteArray(f);
		if (content.length == 0) {
			throw new DronologyServiceException(""Error when reading file "" + fileId);
		}
		return content;

	}

	public File getFile(String fileId) throws DronologyServiceException {
		LOGGER.info(""File '"" + fileId + ""' requested"");

		String savelocation = path + File.separator + fileId + ""."" + extension;
		File f = new File(savelocation);
		if (!f.exists()) {
			LOGGER.info(""File not found: "" + savelocation);
			throw new DronologyServiceException(""File "" + fileId + "" does not exist on server!"");
		}
		return f;
	}

	public boolean saveByteArrayToFile(String id, byte[] content) {
		LOGGER.info(""File '"" + id + ""' received"");
		FileOutputStream stream = null;
		String savelocation = path + File.separator + id + ""."" + extension;
		File f = new File(savelocation);
		if (f.exists()) {
			LOGGER.info(""Deleting old file"");
			f.delete();
		}
		return FileUtil.saveByteArrayToFile(f, content);

	}

	public File[] loadFiles() {
		LOGGER.info(""Loading Files | extension:'"" + extension + ""' path: ["" + path + ""]"");
		File f = new File(path);
		File[] files = f.listFiles(new FilenameFilter() {

			@Override
			public boolean accept(File arg0, String arg1) {
				return arg1.endsWith(extension);
			}
		});
		return files;

	}

	public void tearDown() {
		directoryWatcher.stop();
	}

}
"
SearchConstants.java,"package edu.nd.dronology.services.extensions.areamapping.output;

public class SearchConstants {
	private double OVERLAP_FACTOR;
	private double APERATURE_WIDTH;
	private double MAX_RIVER_WIDTH;
	private int dronesNum;
	private static SearchConstants instance = null;
	
	public static SearchConstants getInstance() {
		if(instance == null) {
			instance = new SearchConstants();
		}
		return instance;
	}
	public void initialize(double overlapFactor, double aperatureWidth, double maxRiverWidth, int drones) {
		OVERLAP_FACTOR = overlapFactor;
		APERATURE_WIDTH = aperatureWidth;
		MAX_RIVER_WIDTH = maxRiverWidth;
		dronesNum = drones;
	}
	
	public double getOverlapFactor() {
		return OVERLAP_FACTOR;
	}
	
	public double getAperatureWidth() {
		return APERATURE_WIDTH;
	}
	
	public double getMaxRiverWidth() {
		return MAX_RIVER_WIDTH;
	}
	
	public int getDronesNum() {
		return dronesNum;
	}
}
"
StopExecutorViaWaypoint.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal;

import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.StopCommand;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.vehicle.IDrone;
import edu.nd.dronology.core.vehicle.ManagedDrone;

public class StopExecutorViaWaypoint implements CommandExecutor {

    enum StopExecutionState {
        RADIOING,
        WATCHING_THE_CLOCK,
        WAITING_FOREVER,
        FINISHED;
    }

    private class PositionAndSpeed {
        public LlaCoordinate position;
        public double speed;
    }

    private IDrone drone;
    StopExecutionState state = StopExecutionState.RADIOING;
    StopCommand data;
    long startTime;

    public StopExecutorViaWaypoint(IDrone drone, StopCommand data) {
        this.drone = drone;
        this.data = data;
    }

    @Override
    public void process() {
        switch (state) {
            case RADIOING:
                radioDrone();
                break;

            case WATCHING_THE_CLOCK:
                checkClock();
                break;

            case WAITING_FOREVER:
            case FINISHED:
            default:
                // Do nothing.
                break;
        }
    }

    private void radioDrone() {
        PositionAndSpeed current = getCurrentPositionAndSpeed();
        drone.flyTo(current.position, current.speed);

        double waitDuration = data.getTime();
        if (waitDuration > 0.0) {
            startTime = System.nanoTime();
            state = StopExecutionState.WATCHING_THE_CLOCK;
        }
        else {
            state = StopExecutionState.WAITING_FOREVER;
        }
    }

    private void checkClock() {
        double waitDuration = data.getTime();
        long deltaNano = System.nanoTime()- startTime;
        double deltaT = deltaNano * 1.0e-9;
        if (deltaT > waitDuration) {
            state = StopExecutionState.FINISHED;
        }
    }

    @Override
    public boolean isFinished() {
        return state == StopExecutionState.FINISHED;
    }

    private PositionAndSpeed getCurrentPositionAndSpeed() {
        PositionAndSpeed result = new PositionAndSpeed();
        DroneSnapshotInternal currentState = drone.getLatestDroneSnapshot();
        result.position = currentState.getPosition();
        result.speed = Vector3D.distance(Vector3D.ZERO, currentState.getVelocity());
        return result;
    }

}
"
IFlightDirector.java,"package edu.nd.dronology.core.flight;

import java.util.List;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.util.Waypoint;

public interface IFlightDirector {
	
	//public void returnHome(LlaCoordinate home);
	
		
	public LlaCoordinate flyToNextPoint();


	/**
	 * Clear all waypoints
	 */
	void clearWayPoints();


	
	/** 
	 * Check if more waypoints exist
	 * @return boolean
	 */
	boolean hasMoreWayPoints();

	/**
	 * Specifies if flight is currently under a safety directive.
	 * @return isUnderSafetyDirectives
	 */
	boolean isUnderSafetyDirectives();

	/**
	 * Removes one wayPoint -- typically when a drone reaches a waypoint.
	 * @param wayPoint
	 */
	void clearCurrentWayPoint();

	/**
	 * Add a waypoint to the flight directive.
	 * @param wayPoint
	 */
//	void addWayPoint(LlaCoordinate wayPoint);

	void flyHome();

	boolean readyToLand();

	boolean readyToTakeOff();


	void setWayPoints(List<Waypoint> wayPoints);

	List<Waypoint> getWayPoints();

	void addWayPoint(Waypoint wayPoint);


	void returnHome(Waypoint home);


}"
UAVMonitoringMessage.java,"package edu.nd.dronology.gstation.connector.messages;

import java.io.Serializable;

/**
 * Monitoring message received from the GCS for a specific UAV.
 * 
 * @author Michael Vierhauser
 *
 */
public class UAVMonitoringMessage extends AbstractUAVMessage<Object> implements Serializable {

	private static final long serialVersionUID = 1502042637906425729L;
	public static final String MESSAGE_TYPE = ""monitoring"";

	public UAVMonitoringMessage(String messagetype, String groundstationid, String uavid) {
		super(MESSAGE_TYPE, groundstationid, uavid);
	}

}
"
AreaMapping.java,"package edu.nd.dronology.services.core.items;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;

import edu.nd.dronology.core.util.ManagedHashTableList;
import edu.nd.dronology.services.core.areamapping.EdgeLla; 
import edu.nd.dronology.services.core.areamapping.IRegionOfInterest;
import edu.nd.dronology.services.core.util.DronologyServiceException;

/**
 * 
 * @author Michael Vierhauser
 *
 */ 
public class AreaMapping implements IAreaMapping {

	private String name; 
	private String id;
	private String description;
	private ManagedHashTableList<Integer, EdgeLla> areaMappings = new ManagedHashTableList<>();
	private List<IMappedItem> locationMappings = new ArrayList<>();
	private Boolean upstream;

	// MappedArea area;
	List<IRegionOfInterest> regions = new ArrayList<>();

	public AreaMapping() {
		id = UUID.randomUUID().toString();
		name = id;
	}

	@Override
	public void setName(String name) {
		this.name = name;

	}

	@Override
	public String getId() {
		return id;
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public String getDescription() {
		return description;
	}

	@Override
	public void setDescription(String description) {
		this.description = description;
	}

	@Override
	public List<EdgeLla> getMappedPoints(Integer part) {
		return Collections.unmodifiableList(areaMappings.get(part));
	}

	@Override
	public void addMappedArea(Integer part, List<EdgeLla> coordinates) {
		areaMappings.put(part, coordinates);
	}

	@Override
	public void addMappedArea(Integer part, EdgeLla coordinate) {
		areaMappings.add(part, coordinate);
	}

	@Override
	public void removeCoordinate(int part, EdgeLla coordinate) {
		int index = areaMappings.get(part).indexOf(coordinate);
		if (index != -1) {
			areaMappings.get(part).remove(coordinate);
		}
	}

	@Override
	public void addMappedLocation(IMappedItem item) {
		locationMappings.add(item);
	}
	
	@Override
	public List<IMappedItem> getLocationMappings() {
		return locationMappings;
	}


	@Override
	public void removeMappedLocation(String id) throws DronologyServiceException {
		List<IMappedItem> toCheck = new ArrayList<>(locationMappings);
		for (IMappedItem item : toCheck) {
			if (item.getId().equals(id)) {
				locationMappings.remove(item);
				return;
			}
		}
		throw new DronologyServiceException(""Location with id '"" + id + ""' not found!"");
	}

	@Override
	public void setUpstream(Boolean upstream) {
		this.upstream = upstream;
	}

	@Override
	public Boolean getUpstream() {
		return upstream;
	}

}
"
DroneFlightStateManager.java,"package edu.nd.dronology.core.vehicle;

import java.util.ArrayList;
import java.util.List;

import com.github.oxo42.stateless4j.StateMachine;

import edu.nd.dronology.core.exceptions.FlightZoneException;
import edu.nd.dronology.core.monitoring.DronologyMonitoringManager;
import edu.nd.dronology.core.monitoring.MessageMarshaller;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * Associates a drone state object with a drone. <br>
 * Normal behavior : ON_GROUND -> AWAITING_TAKEOFF_CLEARANCE -> TAKING_OFF -> FLYING -> In IN_AIR -> LANDING <br>
 * Unavailable transitions will result in an exception being thrown.
 *  
 * @author Jane Cleland-Huang
 *
 */
public class DroneFlightStateManager {

	private static final ILogger LOGGER = LoggerProvider.getLogger(DroneFlightStateManager.class);

	public enum FlightMode {
		ON_GROUND, AWAITING_TAKEOFF_CLEARANCE, TAKING_OFF, FLYING, IN_AIR, LANDING, USER_CONTROLLED
	}

	private enum FlightModeTransition {
		TO_ON_GROUND, PLAN_ASSIGNED, TAKEOFF_GRANTED, TARGET_ALTITUED_REACHED, PLAN_COMPLETE, ZERO_ALTITUED_REACHED, LANDING_GRANTED, MANUAL_TAKEOFER;
	}

	private volatile StateMachine<FlightMode, FlightModeTransition> uavStateMachine;

	private final String uavid;

	private List<IManagedDroneStateChangeListener> listeners = new ArrayList<>();

	/**
	 * Constructor States for both FlightMode and SafetyMode set to initial state
	 * 
	 * @param uav
	 *          The UAV the state manager is assigned to.
	 */
	public DroneFlightStateManager(ManagedDrone uav) {
		this.uavid = uav.getDroneName();
		buildStateMachine();
	}

	private void buildStateMachine() {
		uavStateMachine = new StateMachine<>(FlightMode.ON_GROUND);
		uavStateMachine.configure(FlightMode.ON_GROUND).permit(FlightModeTransition.PLAN_ASSIGNED,
				FlightMode.AWAITING_TAKEOFF_CLEARANCE);
		uavStateMachine.configure(FlightMode.AWAITING_TAKEOFF_CLEARANCE).permit(FlightModeTransition.TAKEOFF_GRANTED,
				FlightMode.TAKING_OFF);
		uavStateMachine.configure(FlightMode.TAKING_OFF).permit(FlightModeTransition.TARGET_ALTITUED_REACHED,
				FlightMode.FLYING);
		uavStateMachine.configure(FlightMode.FLYING).permit(FlightModeTransition.PLAN_COMPLETE, FlightMode.IN_AIR);
		uavStateMachine.configure(FlightMode.IN_AIR).permit(FlightModeTransition.PLAN_ASSIGNED, FlightMode.FLYING);
		uavStateMachine.configure(FlightMode.IN_AIR).permit(FlightModeTransition.LANDING_GRANTED, FlightMode.LANDING);
		uavStateMachine.configure(FlightMode.LANDING).permit(FlightModeTransition.ZERO_ALTITUED_REACHED,
				FlightMode.ON_GROUND);

		uavStateMachine.configure(FlightMode.ON_GROUND).permit(FlightModeTransition.MANUAL_TAKEOFER,
				FlightMode.USER_CONTROLLED);
		uavStateMachine.configure(FlightMode.AWAITING_TAKEOFF_CLEARANCE).permit(FlightModeTransition.MANUAL_TAKEOFER,
				FlightMode.USER_CONTROLLED);
		uavStateMachine.configure(FlightMode.TAKING_OFF).permit(FlightModeTransition.MANUAL_TAKEOFER,
				FlightMode.USER_CONTROLLED);
		uavStateMachine.configure(FlightMode.FLYING).permit(FlightModeTransition.MANUAL_TAKEOFER,
				FlightMode.USER_CONTROLLED);
		uavStateMachine.configure(FlightMode.IN_AIR).permit(FlightModeTransition.MANUAL_TAKEOFER,
				FlightMode.USER_CONTROLLED);
		uavStateMachine.configure(FlightMode.LANDING).permit(FlightModeTransition.MANUAL_TAKEOFER,
				FlightMode.USER_CONTROLLED);

	}

	/**
	 * Set Flight Mode to OnGround
	 * 
	 * @throws FlightZoneException
	 *           if mode change does not follow allowed state transition.
	 */
	public void setModeToOnGround() throws FlightZoneException {
		FlightMode oldState = uavStateMachine.getState();
		if (uavStateMachine.canFire(FlightModeTransition.ZERO_ALTITUED_REACHED)) {
			uavStateMachine.fire(FlightModeTransition.ZERO_ALTITUED_REACHED);
			notifyStateChange(oldState, uavStateMachine.getState());

		} else {
			LOGGER.error(""You may not transition from '"" + uavStateMachine.getState() + ""' with trigger '""
					+ FlightModeTransition.ZERO_ALTITUED_REACHED + ""'"");
			throw new FlightZoneException(
					""You may not transition to "" + FlightMode.ON_GROUND + "" directly from "" + uavStateMachine.getState());
		}
	}

	/**
	 * Set Flight Mode to UserControlled
	 * 
	 */ 
	public void setModeToUserControlled() throws FlightZoneException {
		FlightMode oldState = uavStateMachine.getState();
		if (uavStateMachine.canFire(FlightModeTransition.MANUAL_TAKEOFER)) {
			uavStateMachine.fire(FlightModeTransition.MANUAL_TAKEOFER);
			notifyStateChange(oldState, uavStateMachine.getState());

		} else {
			LOGGER.error(""You may not transition from '"" + uavStateMachine.getState() + ""' with trigger '""
					+ FlightModeTransition.MANUAL_TAKEOFER + ""'"");
			throw new FlightZoneException(
					""You may not transition to "" + FlightMode.ON_GROUND + "" directly from "" + uavStateMachine.getState());
		}

	}

	/**
	 * Set Flight mode to awaiting Takeoff Clearance
	 * 
	 * @throws FlightZoneException
	 *           if mode change does not follow allowed state transition.
	 */
	public void setModeToAwaitingTakeOffClearance() throws FlightZoneException {
		FlightMode oldState = uavStateMachine.getState();
		if (uavStateMachine.canFire(FlightModeTransition.PLAN_ASSIGNED)) {
			uavStateMachine.fire(FlightModeTransition.PLAN_ASSIGNED);
			notifyStateChange(oldState, uavStateMachine.getState());
		} else {
			LOGGER.error(""You may not transition from '"" + uavStateMachine.getState() + ""' with trigger '""
					+ FlightModeTransition.PLAN_ASSIGNED + ""'"");
			throw new FlightZoneException(""You may not transition to "" + FlightMode.AWAITING_TAKEOFF_CLEARANCE
					+ "" directly from "" + uavStateMachine.getState());
		}

	}

	/**
	 * Set flight mode to Taking off
	 * 
	 * @throws FlightZoneException
	 *           if mode change does not follow allowed state transition.
	 */
	public void setModeToTakingOff() throws FlightZoneException {
		FlightMode oldState = uavStateMachine.getState();
		if (uavStateMachine.canFire(FlightModeTransition.TAKEOFF_GRANTED)) {
			uavStateMachine.fire(FlightModeTransition.TAKEOFF_GRANTED);
			notifyStateChange(oldState, uavStateMachine.getState());
		} else {
			LOGGER.error(""You may not transition from '"" + uavStateMachine.getState() + ""' with trigger '""
					+ FlightModeTransition.TAKEOFF_GRANTED + ""'"");
			throw new FlightZoneException(
					""You may not transition to "" + FlightMode.TAKING_OFF + "" directly from "" + uavStateMachine.getState());
		}

	}

	/**
	 * Set flight mode to Flying
	 * 
	 * @throws FlightZoneException
	 *           if mode change does not follow allowed state transition.
	 */
	public void setModeToFlying() throws FlightZoneException {
		FlightMode oldState = uavStateMachine.getState();
		if (uavStateMachine.canFire(FlightModeTransition.TARGET_ALTITUED_REACHED)) {
			uavStateMachine.fire(FlightModeTransition.TARGET_ALTITUED_REACHED);
			notifyStateChange(oldState, uavStateMachine.getState());
		} else if (uavStateMachine.canFire(FlightModeTransition.PLAN_ASSIGNED)) {
			uavStateMachine.fire(FlightModeTransition.PLAN_ASSIGNED);
			notifyStateChange(oldState, uavStateMachine.getState());
		} else {
			LOGGER.error(""You may not transition from '"" + uavStateMachine.getState() + ""' with trigger '""
					+ FlightModeTransition.TARGET_ALTITUED_REACHED + ""'"");
			throw new FlightZoneException(
					""You may not transition to "" + FlightMode.FLYING + "" directly from "" + uavStateMachine.getState());
		}

	}

	/**
	 * Set flight mode to Landing
	 * 
	 * @throws FlightZoneException
	 *           if mode change does not follow allowed state transition.
	 */
	public void setModeToLanding() throws FlightZoneException {
		FlightMode oldState = uavStateMachine.getState();
		if (uavStateMachine.canFire(FlightModeTransition.LANDING_GRANTED)) {
			uavStateMachine.fire(FlightModeTransition.LANDING_GRANTED);
			notifyStateChange(oldState, uavStateMachine.getState());
		} else {
			LOGGER.error(""You may not transition from '"" + uavStateMachine.getState() + ""' with trigger '""
					+ FlightModeTransition.LANDING_GRANTED + ""'"");
			throw new FlightZoneException(
					""You may not transition to "" + FlightMode.LANDING + "" directly from "" + uavStateMachine.getState());
		}

	}

	/**
	 * 
	 * @return true if drone is currently on the ground, false otherwise
	 */
	public boolean isOnGround() {
		return uavStateMachine.getState() == FlightMode.ON_GROUND;

	}

	/**
	 * 
	 * @return true if drone is currently in AwaitingTakeOffClearance mode, false otherwise
	 */
	public boolean isAwaitingTakeoffClearance() {
		return uavStateMachine.getState() == FlightMode.AWAITING_TAKEOFF_CLEARANCE;

	}

	/**
	 * 
	 * @return true if drone is currently taking off, false otherwise
	 */
	public boolean isTakingOff() {
		return uavStateMachine.getState() == FlightMode.TAKING_OFF;
	}

	/**
	 * 
	 * @return true if drone is currently flying, false otherwise
	 */
	public boolean isFlying() {
		return uavStateMachine.getState() == FlightMode.FLYING;

	}

	/**
	 * 
	 * @return true if drone is currently landing, false otherwise
	 */
	public boolean isLanding() {
		return uavStateMachine.getState() == FlightMode.LANDING;

	}

	/**
	 * 
	 * @return current status
	 */
	public String getStatus() {
		return uavStateMachine.getState().toString();
		// return currentFlightMode.toString();
	}

	private synchronized void notifyStateChange(FlightMode oldState, FlightMode newState) {
		LOGGER.info(""Drone '"" + uavid + ""' set to: "" + uavStateMachine.getState());
		DronologyMonitoringManager.getInstance().publish(MessageMarshaller.create(uavid, oldState, newState));
		for (IManagedDroneStateChangeListener listener : listeners) {
			listener.notifyStateChange();
		}
	}

	public boolean isInAir() {
		return uavStateMachine.getState() == FlightMode.IN_AIR;
	}

	public void setModeToInAir() throws FlightZoneException {
		FlightMode oldState = uavStateMachine.getState();
		if (uavStateMachine.canFire(FlightModeTransition.PLAN_COMPLETE)) {
			uavStateMachine.fire(FlightModeTransition.PLAN_COMPLETE);
			notifyStateChange(oldState, uavStateMachine.getState());
		} else {
			LOGGER.error(""You may not transition from '"" + uavStateMachine.getState() + ""' with trigger '""
					+ FlightModeTransition.PLAN_COMPLETE + ""'"");
			throw new FlightZoneException(
					""You may not transition to "" + FlightMode.IN_AIR + "" directly from "" + uavStateMachine.getState());
		}
	}

	public void addStateChangeListener(IManagedDroneStateChangeListener listener) {
		listeners.add(listener);

	}

}
"
JSONSendTester.java,"package edu.nd.dronology.misc.gcs;

import java.text.DateFormat;

import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.gstation.connector.messages.UAVHandshakeMessage;
import edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;
import edu.nd.dronology.gstation.connector.messages.UAVStateMessage;

public class JSONSendTester {

	public static void main(String[] args) {
		try {
			final Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()
					.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)
					.setVersion(1.0).serializeSpecialFloatingPointValues().create();

			UAVMonitoringMessage mm = new UAVMonitoringMessage(""Drone1"", ""FAKE"", ""Drone1"");

			mm.setType(UAVMonitoringMessage.MESSAGE_TYPE);
			mm.setUavid(""DRONE1"");
			mm.addPropery(""NR_SATELITES"", 5);
			mm.addPropery(""GPS_BIAS"", 3.125);
			mm.addPropery(""CURRENT_SPEED"", 5.25);

			String toSend = GSON.toJson(mm);

			UAVStateMessage sm = new UAVStateMessage(""Drone1"", ""FAKE"",""Drone1"");

			// sm.setType(UAVStateMessage.MESSAGE_TYPE);
			// sm.setUavid(""DRONE1"");
			// sm.setArmable(true);
			// sm.setArmed(true);
			// sm.setAttitude(new LlaCoordinate(1, 2, 3));
			// sm.setGroundspeed(25.3);
			// sm.setLocation(new LlaCoordinate(3, 4, 5));
			// sm.setMode(edu.nd.dronology.gstation.python.connector.messages.UAVStateMessage.DroneMode.CIRCLE);
			// sm.setStatus(DroneStatus.ACTIVE);
			// sm.setVelocity(new LlaCoordinate(5, 6, 7));
			// sm.setBatterystatus(new BatteryStatus());

			toSend = GSON.toJson(sm);

			UAVHandshakeMessage hm = new UAVHandshakeMessage(""FAKE"", ""Drone1"");
			hm.setType(UAVHandshakeMessage.MESSAGE_TYPE);
			hm.setHome(new LlaCoordinate(3, 5, 8));
			hm.addPropery(""xxx"", ""abc"");
			hm.addPropery(""yyy"", ""more parameters..."");
			toSend = GSON.toJson(hm);

			System.out.println(toSend);

		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}
}
"
FakePassivPythonGroundstation2.java,"package edu.nd.dronology.misc.gcs;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.text.DateFormat;
import java.util.Random;

import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.vehicle.DroneFlightStateManager.FlightMode;
import edu.nd.dronology.core.vehicle.commands.ConnectionResponseCommand;
import edu.nd.dronology.gstation.connector.messages.ConnectionRequestMessage;
import edu.nd.dronology.gstation.connector.messages.UAVHandshakeMessage;
import edu.nd.dronology.gstation.connector.messages.UAVModeChangeMessage;
import edu.nd.dronology.gstation.connector.messages.UAVMonitoringMessage;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class FakePassivPythonGroundstation2 {

	// private static Socket socket;
	private static final ILogger LOGGER = LoggerProvider.getLogger(FakePassivPythonGroundstation2.class);

	final static Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()
			.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES)
			.setVersion(1.0).serializeSpecialFloatingPointValues().create();

	public static void main(String[] args) {
		try {
			int port = 1234;
			// ServerSocket serverSocket = new ServerSocket(port);
			// Server is running always. This is done using this while(true) loop

			// socket = serverSocket.accept();
			String hostAddr = ""localhost"";

			LOGGER.info(""Connecting to Python base "" + hostAddr + ""@"" + port);
			Socket pythonSocket = new Socket();
			pythonSocket.connect(new InetSocketAddress(hostAddr, port), 5000);

			System.out.println(""Client has connected!"");
			InputStream is = pythonSocket.getInputStream();
			InputStreamReader isr = new InputStreamReader(is);
			BufferedReader br = new BufferedReader(isr);

			// UAVHandshakeMessage handshake = new UAVHandshakeMessage(""Drone1"", ""Drone1"");
			ConnectionRequestMessage connect = new ConnectionRequestMessage(""FAKE_GROUND_2"");

			String handshakeString = GSON.toJson(connect);
			Thread.sleep(10000);
			OutputStream os = pythonSocket.getOutputStream();
			OutputStreamWriter osw = new OutputStreamWriter(os);
			BufferedWriter bw = new BufferedWriter(osw);
			bw.write(handshakeString);
			bw.write(""\n"");
			System.out.println(""Message sent to the client is "" + handshakeString);
			bw.flush();

			String ackMesasge = br.readLine();
			ConnectionResponseCommand response = GSON.fromJson(ackMesasge, ConnectionResponseCommand.class);
			System.out.println(""RESPONSE:"" + response.toJsonString());
			Thread.sleep(3000);

			UAVHandshakeMessage hand = new UAVHandshakeMessage(""FAKE_GROUND_2"", ""UAV1"");
			hand.setHome(new LlaCoordinate(0, 0, 0));
			String uavString = GSON.toJson(hand);
			bw.write(uavString);
			bw.write(""\n"");
			System.out.println(""Message sent to the client is "" + uavString);
			bw.flush();

			Thread.sleep(3000);

			// UAVModeChangeMessage mode = new UAVModeChangeMessage(""FAKE_GROUND_2"", ""UAV1"",
			// FlightMode.USER_CONTROLLED.toString());

			// String modeString = GSON.toJson(mode);
			// bw.write(modeString);
			// bw.write(""\n"");
			// System.out.println(""Message sent to the client is "" + modeString);
			// bw.flush();

			int i = 2;
			while (i > 1) {

				UAVMonitoringMessage mm = new UAVMonitoringMessage(""Dronexxx"", ""FAKE_GROUND_2"", ""Dronexxx"");
				Random rand = new Random();
				mm.setType(UAVMonitoringMessage.MESSAGE_TYPE);
				// mm.setuavid(""DRONE1"");
				mm.addPropery(""NR_SATELITES"", ""5"");
				mm.addPropery(""GPS_BIAS"", ""3.125"");
				mm.addPropery(""CURRENT_SPEED"", ""5.25"");
				mm.addPropery(""BLEVEL_VOLTAGE"", ""3"");
				mm.addPropery(""BATTERY_MAXPOWERX"", ""50"");
				mm.addPropery(""BATTERY_VOLTAGE"", rand.nextInt(10));
				mm.addPropery(""BATTERY_POWER"", rand.nextInt(10));
				mm.addPropery(""BLEVEL_POWER"", rand.nextInt(10));

				// if flying mission mlevel > 20%
				// if retunr home blvel > 10;
				UAVModeChangeMessage modeCh = new UAVModeChangeMessage(""FAKE_GROUND_2"", ""UAV1"", ""LOITER"");
				String toSend = GSON.toJson(modeCh);

				// Reading the message from the client

				// String number = br.readLine();
				// System.out.println(""Message received from client is "" + number);

				// Multiplying the number by 2 and forming the return message
				// String returnMessage;
				// try {
				// int numberInIntFormat = Integer.parseInt(number);
				// int returnValue = numberInIntFormat * 2;
				// returnMessage = String.valueOf(returnValue) + ""\n"";
				// } catch (NumberFormatException e) {
				// // Input was not a number. Sending proper message back to client.
				// returnMessage = ""Please send a proper number\n"";
				// }

				// Sending the response back to the client.
				// OutputStream os = socket.getOutputStream();
				// OutputStreamWriter osw = new OutputStreamWriter(os);
				// BufferedWriter bw = new BufferedWriter(osw);
				bw.write(toSend);
				bw.write(""\n"");
				System.out.println(""Message sent to the client is "" + toSend);
				bw.flush();
				i = 0;
			}
			
			Thread.sleep(10000);
			
			UAVModeChangeMessage modeCh = new UAVModeChangeMessage(""FAKE_GROUND_2"", ""UAV1"", ""STABILIZE"");
			String toSend = GSON.toJson(modeCh);
			bw.write(toSend);
			bw.write(""\n"");
			System.out.println(""Message sent to the client is "" + toSend);
			bw.flush();
			
			Thread.sleep(50000);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

}"
RiverBankPrimitive.java,"package edu.nd.dronology.services.extensions.areamapping.internal;

import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.List;

import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive.RouteType;
import edu.nd.dronology.services.extensions.areamapping.util.Utilities;

public class RiverBankPrimitive implements SearchPatternStrategy{
	private List<SourcePoints> sourcePointsList;
	private RoutePrimitive.RouteType routeType;
	
	public RiverBankPrimitive() {
		sourcePointsList = new ArrayList<>();
	}
	
	@Override
	public void setSourcePoints(List<SourcePoints> points) {
		sourcePointsList = points;
	}
	
	@Override
	public void setRouteType(RoutePrimitive.RouteType routeType) {
		this.routeType = routeType;
	}
	
	private RoutePrimitive transformSourcePoints(SourcePoints sourcePoints, double APERATURE_HEIGHT, double OVERLAP_FACTOR) {
		RoutePrimitive newRoute = new RoutePrimitive(routeType, sourcePoints.getWeight());
		for(Point2D.Double entry : sourcePoints.getSourcePoints()) {
			newRoute.addRouteWaypoint(entry);
		}
		Utilities.generateImageWaypoints(newRoute, APERATURE_HEIGHT, OVERLAP_FACTOR);
		return newRoute;
	}
	
	@Override
	public List<RoutePrimitive> generateRoutePrimitive(double APERATURE_HEIGHT, double OVERLAP_FACTOR){

		List<RoutePrimitive> routes = new ArrayList<>();
		for(SourcePoints source : sourcePointsList) {
			routes.add(transformSourcePoints(source, APERATURE_HEIGHT, OVERLAP_FACTOR));
		}
		return routes;
	}
}
"
IDroneCommand.java,"package edu.nd.dronology.core.vehicle.commands;

import java.io.Serializable;
/**
 * Interface for all UAV commands.
 * 
 * @author Michael Vierhauser
 *
 */
public interface IDroneCommand extends Serializable {

	public static final String ATTRIBUTE_FREQUENCY = ""frequency"";
	public static final String ATTRIBUTE_ALTITUDE = ""altitude"";
	public static final String ATTRIBUTE_SPEED = ""speed"";
	public static final String ATTRIBUTE_MODE = ""mode"";

	public static final String ATTRIBUTE_X = ""x"";
	public static final String ATTRIBUTE_Y = ""y"";
	public static final String ATTRIBUTE_Z = ""z"";

	public static final String ATTRIBUTE_SUCCESS = ""success"";

	String toJsonString();

	String getUAVId();

	void timestamp();

}
"
RouteSelectionResult.java,"package edu.nd.dronology.services.extensions.areamapping.selection;

import java.util.ArrayList;
import java.util.List;

import edu.nd.dronology.services.core.areamapping.ExportAllocationInformation;

public class RouteSelectionResult {
	private List<ExportAllocationInformation> allocationInfo;
	private long selectionTime; // in milliseconds

	public RouteSelectionResult() {
		allocationInfo = new ArrayList<>();
	}

	public List<ExportAllocationInformation> getEportAllocationInformation() {
		return allocationInfo;
	}

	public double getSelectionTime() {
		return selectionTime;
	}

	// public void setExportAllocationInformation(List<ExportAllocationInformation> info) {
	// allocationInfo = info;
	// }

	public void setSelectionTime(long time) {
		selectionTime = time;
	}

	public void add(ExportAllocationInformation ass) {
		allocationInfo.add(ass);

	}
}
"
AbstractPosition.java,"package edu.nd.dronology.core.coordinate;

import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;
import org.apache.commons.math3.linear.Array2DRowRealMatrix;
import org.apache.commons.math3.linear.RealMatrix;

/**
 * A terrestrial position in WGS-84. this class implements utility methods for
 * subclasses.
 * 
 * @author Michael Murphy
 *
 */ 
public abstract class AbstractPosition {

	/**
	 * Convert this position if necessary to an NVector.
	 * 
	 * @return a terrestrial position defined an NVector and an altitude.
	 */
	public abstract NVector toNVector();

	/**
	 * Convert this position if necessary to a PVector.
	 * 
	 * @return a terrestrial position defined an X, Y and Z coordinate.
	 */
	public abstract PVector toPVector();

	/**
	 * Convert this position if necessary to an LlaCoordinate.
	 * 
	 * @return a terrestrial position defined by a latitude, longitude, and
	 *         altitude.
	 */
	public abstract LlaCoordinate toLlaCoordinate();

	/**
	 * Calculates the distance from this position to other position. This is the
	 * distance a laser bean would travel to reach the other point.
	 * 
	 * @param other
	 *            the position of the point to calculate the distance to.
	 * @return the distance to the other position in meters
	 */
	public double distance(AbstractPosition other) {
		return NVector.laserDistance(this.toNVector(), other.toNVector());
	}

	/**
	 * Calculates the distance a drone would realistically travel to get from
	 * this position to the other position.
	 * 
	 * Warning! this code is slow. The time it takes to run is proportional to the
	 * distance from this to other.
	 * 
	 * @param other
	 *            the position of the point to calculate the distance to.
	 * @return the distance a drone would need to travel to get to the other
	 *         position in meters
	 */
	public double travelDistance(AbstractPosition other) {
		return NVector.travelDistance(this.toNVector(), other.toNVector());
	}

	/**
	 * Calculate the rotation matrix representation of this position. This
	 * rotation matrix can take displacement vectors in ECEF coordinates and
	 * rotate them into NED coordinates at this position.
	 * 
	 * This position cannot be at the poles as north and east directions don't
	 * make sense there.
	 * 
	 * This is the matrix inverse of equation 11 in <a href=
	 * ""http://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf"">this
	 * paper.</a>
	 * 
	 * 
	 * @return a 3x3 rotation matrix where the rows can be interpreted as
	 *         unit vectors pointing in the north, east and down directions
	 *         respectively.
	 */
	public RealMatrix toRotMatrix() {
		NVector n = this.toNVector();
		Vector3D nvec = new Vector3D(n.getX(), n.getY(), n.getZ());
		Vector3D z = new Vector3D(0, 0, 1);
		Vector3D east = z.crossProduct(nvec).normalize();
		Vector3D north = nvec.crossProduct(east).normalize();
		Vector3D down = nvec.negate();
		double[][] data = { north.toArray(), east.toArray(), down.toArray() };
		return new Array2DRowRealMatrix(data);
	}

	/**
	 * Calculates the number of meters North, East and down (NED coordinates)
	 * from this position to another global position.
	 * 
	 * @param other
	 *            the terrestrial position to transform into NED coordinates
	 *            using this position as the origin
	 * @return the NED coordinates as a vector with 3 elements where the first
	 *         (0th) element is the number of meters north, the second element
	 *         is the number of meters east and the third element is the number
	 *         of meters down.
	 */
	public Vector3D findNed(AbstractPosition other) {
		Vector3D self = makeVector3D(this);
		Vector3D otherVec = makeVector3D(other);
		Vector3D displacement = otherVec.subtract(self);
		RealMatrix tmp = new Array2DRowRealMatrix(displacement.toArray());
		return new Vector3D(this.toRotMatrix().multiply(tmp).getColumn(0));
	}

	/**
	 * Calculates the latitude, longitude and altitude of a relative position
	 * given as the number of meters North, East, and down from this position.
	 * 
	 * @param ned
	 *            a vector with three elements where the first is the number of
	 *            meters north, the second is the number of meters east, and the
	 *            third is the number of meters down.
	 * @return the latitude longitude and altitude of the other position
	 */
	public LlaCoordinate findLla(Vector3D ned) {
		Vector3D self = makeVector3D(this);
		RealMatrix tmp = new Array2DRowRealMatrix(ned.toArray());
		Vector3D d = new Vector3D(this.toRotMatrix().transpose().multiply(tmp).getColumn(0));
		Vector3D p = self.add(d);
		return new PVector(p.getX(), p.getY(), p.getZ()).toLlaCoordinate();
	}

	private static Vector3D makeVector3D(AbstractPosition pos) {
		PVector p = pos.toPVector();
		return new Vector3D(p.getX(), p.getY(), p.getZ());
	}

}
"
FormatUtil.java,"package edu.nd.dronology.core.util;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.concurrent.TimeUnit;

import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class FormatUtil {
	static ILogger LOGGER = LoggerProvider.getLogger(FormatUtil.class);

	public static final String FORMAT_YEAR_FIRST = ""yyyy-MM-dd HH:mm:ss"";
	public static final String FORMAT_YEAR_FIRST_MILLIS = ""yyyy-MM-dd HH:mm:ss.SSS"";
	public static final String FORMAT_FILE = ""yyyy_MM_dd_HH_mm_ss"";
	public static final String FORMAT_HOUR_FIRST_MILLIS = ""HH:mm:ss.SSS"";

	// public static final String FORMAT_YEAR_FIRST = ""yyyy-MM-dd HH:mm:ss"";
	public static final String FORMAT_DATE_STD = ""E M yy"";

	public static String formatTimestamp(long timestamp) {
		return formatTimestamp(timestamp, FORMAT_YEAR_FIRST);
	}

	public static String formatTimeElapsed(long l) {
		final long hr = TimeUnit.MILLISECONDS.toHours(l);
		final long min = TimeUnit.MILLISECONDS.toMinutes(l - TimeUnit.HOURS.toMillis(hr));
		final long sec = TimeUnit.MILLISECONDS.toSeconds(l - TimeUnit.HOURS.toMillis(hr) - TimeUnit.MINUTES.toMillis(min));
		return String.format(""%02d:%02d:%02d"", hr, min, sec);
	}

	public static String formatTimestamp(long timestamp, String format) {
		DateFormat formatter = new SimpleDateFormat(format);
		Calendar c = new GregorianCalendar();
		c.setTimeInMillis(timestamp);
		return formatter.format(c.getTime());
	}

	public static String formatTimestamp(PreciseTimestamp timestamp, String format) {
		return formatTimestamp(timestamp.getTimestamp(), format);
	}
	public static String formatTimestamp(PreciseTimestamp timestamp){
		return formatTimestamp(timestamp.getTimestamp());
		}

	public static long unformatTimestamp(String timestamp, String type) {
		DateFormat formatter = new SimpleDateFormat(type);
		Date date;
		long dateInLong = -1;
		try {
			date = formatter.parse(timestamp);
			dateInLong = date.getTime();
			return dateInLong;
		} catch (ParseException ex) {
			LOGGER.error(ex);
		}
		return -1;
	}

	public static boolean canParse(String timestamp, String type) {
		DateFormat formatter = new SimpleDateFormat(type);
		try {
			formatter.parse(timestamp);
			return true;
		} catch (ParseException ex) {
			return false;
		}
	}

}
"
IRemoteableService.java,"package edu.nd.dronology.services.core.remote;

import java.io.Serializable;
import java.rmi.RemoteException;

import edu.nd.dronology.services.core.api.IRemotable;
import edu.nd.dronology.services.core.api.ServiceInfo;
import edu.nd.dronology.services.core.listener.IServiceListener;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public interface IRemoteableService extends IRemotable, Serializable {

	ServiceInfo getServiceInfo() throws RemoteException;

	void startService() throws RemoteException, DronologyServiceException;

	void stopService() throws RemoteException, DronologyServiceException;

	boolean removeServiceListener(IServiceListener servicelistener) throws RemoteException;

	boolean addServiceListener(IServiceListener servicelistener) throws RemoteException;

	void restartService() throws RemoteException, DronologyServiceException;

}
"
IFlightPlan.java,"package edu.nd.dronology.core.flight;

import java.io.Serializable;
import java.util.List;

import edu.nd.dronology.core.Discuss;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.exceptions.FlightZoneException;
import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.core.vehicle.ManagedDrone;

@Discuss(discuss = ""this interface is currently exposed - i.e. managed drone is exposed "")
public interface IFlightPlan extends Serializable {

	ManagedDrone getAssignedDrone();

	boolean setStatusToCompleted() throws FlightZoneException;

	LlaCoordinate getStartLocation();

	LlaCoordinate getEndLocation();

	void clearAssignedDrone();

	String getFlightID();

	boolean setStatusToFlying(ManagedDrone drone) throws FlightZoneException;

	List<Waypoint> getWayPoints();

	long getStartTime();

	long getEndTime();

	String getDesignatedDroneId();

	boolean isCompleted();

	double getTakeoffAltitude();

	void setDesignatedDroneId(String uavid);

}
"
IFlightManagerRemoteService.java,"package edu.nd.dronology.services.core.remote;

import java.rmi.RemoteException;
import java.util.Collection;
import java.util.List;

import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.services.core.info.FlightInfo;
import edu.nd.dronology.services.core.info.FlightPlanInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

/**
 * 
 * @author Michael Vierhauser
 * 
 */
public interface IFlightManagerRemoteService extends IRemoteableService {

	void planFlight(String planName, List<Waypoint> wayPoints) throws RemoteException, Exception;

	void planFlight(String uavid, String planName, List<Waypoint> wayPoints) throws RemoteException, Exception;

	void returnToHome(String uavid) throws RemoteException, Exception;

	void takeoff(String uavid, double altitude) throws RemoteException, DronologyServiceException;

	void pauseFlight(String iavid) throws RemoteException, Exception;

	FlightInfo getFlightInfo(String uavId) throws RemoteException, Exception;

	Collection<FlightPlanInfo> getCurrentFlights() throws RemoteException;

	void cancelPendingFlights(String uavid) throws RemoteException, Exception;

}
"
MapDrawingUtil.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.vaadin.addon.leaflet.LMap;
import org.vaadin.addon.leaflet.LMarker;
import org.vaadin.addon.leaflet.LPolyline;
import org.vaadin.addon.leaflet.shared.Point;

import com.vaadin.server.Resource;
import com.vaadin.ui.Notification;

import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.info.FlightPlanInfo;
import edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;
import edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;
import edu.nd.dronology.ui.vaadin.start.MyUI;
import edu.nd.dronology.ui.vaadin.utils.ImageProvider;
import edu.nd.dronology.ui.vaadin.utils.MapMarkerUtilities;
import edu.nd.dronology.ui.vaadin.utils.UIWayPoint;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * Utility class for drawing marker and UAV icons on the map <br>
 * <b>NEEDS ADDITIONAL CLEANUP & REFACTORING!<b>
 * 
 * @author Michael Vierhauser
 *
 */
public class MapDrawingUtil {

	private static final ILogger LOGGER = LoggerProvider.getLogger(MapDrawingUtil.class);

	private LMap leafletMap;
	private MapMarkerUtilities utilities;

	private List<List<LMarker>> wayPointMarkers = new ArrayList<>();
	private List<List<LPolyline>> flightRoutes = new ArrayList<>();
	private ArrayList<LMarker> markers = new ArrayList<>();

	private Resource droneIconFocused = ImageProvider.getFocusUAVResource();
	private Resource droneIcon = ImageProvider.getDefaultUAVResource(); 
	private Resource droneIconSelected = ImageProvider.getSelectedUAVResource();

	private Resource dotIcon = ImageProvider.getDotIconResource();

	private AFMapComponent mapComponent;

	BaseServiceProvider provider;
	private IFlightManagerRemoteService flightManagerService;
	private IDroneSetupRemoteService droneSetupService;

	private double ACHN_X = 11;

	private double ANCH_Y = 23;

	public MapDrawingUtil(LMap leafletMap, AFMapComponent mapComponent) {
		this.leafletMap = leafletMap;
		this.mapComponent = mapComponent;
		utilities = new MapMarkerUtilities(leafletMap);
		initConnection();

	}

	private void initConnection() {
		try {
			provider = MyUI.getProvider();
			flightManagerService = (IFlightManagerRemoteService) provider.getRemoteManager()
					.getService(IFlightManagerRemoteService.class);
			droneSetupService = (IDroneSetupRemoteService) provider.getRemoteManager()
					.getService(IDroneSetupRemoteService.class);
		} catch (RemoteException | DronologyServiceException e) {
			MyUI.setConnected(false);// reconnect to dronology if connection is lost
			try {
				Notification.show(""Reconnecting..."");
				droneSetupService = (IDroneSetupRemoteService) provider.getRemoteManager()
						.getService(IDroneSetupRemoteService.class);
				flightManagerService = (IFlightManagerRemoteService) provider.getRemoteManager()
						.getService(IFlightManagerRemoteService.class);
			} catch (RemoteException | DronologyServiceException e1) {
				Notification.show(""Reconnecting..."");
			}
			Notification.show(""Reconnecting..."");

		}

	}

	/**
	 * This function gets the flight routes from dronology core and draws them on the map.
	 * 
	 * @param focused
	 *          this is the drone that is focused in the AFInfoPanel. It's flight route will be orange
	 * @param checked
	 *          this is a list of drones that have their checkbox checked in the AFInfoPanel. Their routes will be black.
	 */
	public void addActiveFlightRoutes(String focused, List<String> checked) {
		try {
			Collection<FlightPlanInfo> currentFlights = flightManagerService.getCurrentFlights();
			for (FlightPlanInfo e : currentFlights) { // goes through each route
				List<Waypoint> coordinates = e.getWaypoints();
				List<UIWayPoint> wayPoints = new ArrayList<>();
				List<LMarker> wayPointMarker = new ArrayList<>();
				int i = 0;
				for (Waypoint coord : coordinates) { // goes through all the coordinates in each route
					Point point = new Point(coord.getCoordinate().getLatitude(), coord.getCoordinate().getLongitude());
					UIWayPoint wayPoint = new UIWayPoint(point, nextReached(coordinates, i + 1));
					wayPoints.add(wayPoint);
					if (wayPointMarkers.size() != currentFlights.size()) { // adds the waypoints to the map first
						LMarker marker = new LMarker(point);
						marker.setIcon(dotIcon);
						marker.setIconSize(new Point(10, 10));
						marker.addMouseOverListener(mapComponent.getWaypointListener());
						wayPointMarker.add(marker);
						leafletMap.addComponent(marker);
					}
					i++;
				}
				List<LPolyline> polyLines = new ArrayList<>(); // draws the lines and loads them into a list
				if (e.getDroneId().equals(focused)) {
					utilities.removeAllLines();
					polyLines = utilities.drawLinesForWayPoints(wayPoints, 2, true);
				} else {
					boolean drawn = false;
					for (String name : checked) {
						if (e.getDroneId().equals(name)) { 
							utilities.removeAllLines();
							polyLines = utilities.drawLinesForWayPoints(wayPoints, 1, true);
							drawn = true;
						}
					}
					if (!drawn) {
						// utilities.removeAllLines();
						polyLines = utilities.drawLinesForWayPoints(wayPoints, 0, true);
					}
				}
				flightRoutes.add(polyLines); // keep a list of all lines and markers
				if (wayPointMarkers.size() != currentFlights.size())
					wayPointMarkers.add(wayPointMarker);
			}
		} catch (RemoteException e) { // reconnect to dronology if connection is lost
			initConnection();
		}
	}

	/**
	 * updates the flight routes. Deletes old ones, adds new ones, and redraws the lines to different colors as each waypoint is reached
	 * 
	 * @param focused
	 *          this is the drone that is focused in the AFInfoPanel. It's flight route will be orange
	 * @param checked
	 *          this is a list of drones that have their checkbox checked in the AFInfoPanel. Their routes will be black.
	 */
	public void updateActiveFlightRoutes(String focused, List<String> checked) {
		try {
			Collection<FlightPlanInfo> currentFlights = flightManagerService.getCurrentFlights();
			if (currentFlights.size() != flightRoutes.size() || true) {
				utilities.removeAllLines();
				boolean exists = true; // determines if flight route is still active
				for (List<LMarker> e : wayPointMarkers) {
					boolean individualExist = false; // helper variable to determine if each flight route is still active
					for (FlightPlanInfo q : currentFlights) {
						if (e.get(0).getPoint().getLat() == q.getWaypoints().get(0).getCoordinate().getLatitude()
								&& e.get(0).getPoint().getLon() == q.getWaypoints().get(0).getCoordinate().getLongitude()) {
							individualExist = true;
						}
					}
					if (individualExist == false)
						exists = false;
				}
				if (!exists || wayPointMarkers.size() != currentFlights.size()) { // if flight doesn't exist, remove it's waypoint markers
					for (List<LMarker> lmarkers : wayPointMarkers) {
						for (LMarker m : lmarkers) {
							utilities.getMap().removeComponent(m);
						}
					}
					wayPointMarkers.clear();
					if (!mapComponent.getFollow() && flightRoutes.size() < currentFlights.size()) // only reset the center when a flight route is added
						mapComponent.setAverageCenter();
				}
			}
			flightRoutes.clear();
			/*
			 * if (wayPointMarkers.size() != flightRoutes.size()){ for (ArrayList<LMarker> e:wayPointMarkers){ utilities.removeAllMarkers(e); } wayPointMarkers.clear(); } flightRoutes.clear();
			 */
			this.addActiveFlightRoutes(focused, checked); // redraw the flight routes
			// }

		} catch (RemoteException e) { // reconnect to dronology
			initConnection();
		}
	}

	/**
	 * This function updates the position of the drone icons on the map
	 * 
	 * @param focused
	 *          this is the drone that is focused in the AFInfoPanel. It's flight route will be orange
	 * @param checked
	 *          this is a list of drones that have their checkbox checked in the AFInfoPanel. Their routes will be black.
	 */
	public void updateDroneMarkers(String focused, List<String> checked) {
		try {
			Collection<IUAVProxy> drones = droneSetupService.getActiveUAVs();
			ArrayList<LMarker> remove = new ArrayList<>();
			if (markers.size() == drones.size()) {
				for (LMarker marker : markers) {
					boolean exists = false;
					for (IUAVProxy e : drones) {
						if (marker.getId().equals(e.getID())) { // if the marker correlates to the drone
							Point temp = new Point();
							temp.setLat(e.getLatitude()); // update location
							temp.setLon(e.getLongitude());
							marker.setPoint(temp);
							if (marker.getId().equals(focused))
								marker.setIcon(droneIconFocused);
							else {
								boolean chosen = false;
								for (String name : checked) {
									if (marker.getId().equals(name)) {
										marker.setIcon(droneIconSelected);
										chosen = true;
									}
								}
								if (!chosen)
									marker.setIcon(droneIcon);
							}
							exists = true;
						}
					}
					if (!exists) { // if the drone that is represented by the marker is no longer active or if the drone is new
						remove.add(marker);
						for (IUAVProxy e1 : drones) {
							boolean old = false;
							for (LMarker marker1 : markers) {
								if (e1.getID().equals(marker1.getId()))
									old = true;
							}
							if (!old) { // the drone does not have a marker represented by it
								LMarker newMarker = new LMarker(e1.getLatitude(), e1.getLongitude());
								newMarker.setId(e1.getID());
								if (marker.getId().equals(focused))
									marker.setIcon(droneIconFocused);
								else {
									boolean chosen = false;
									for (String name : checked) {
										if (marker.getId().equals(name)) {
											marker.setIcon(droneIconSelected);
											chosen = true;
										}
									}
									if (!chosen)
										marker.setIcon(droneIcon);
								}
								newMarker.setIconSize(new Point(33, 33));
								newMarker.setIconAnchor(new Point(ACHN_X, ANCH_Y));
								newMarker.addMouseOverListener(mapComponent.getDroneListener());
								markers.add(newMarker);
								leafletMap.addComponent(newMarker);
								if (!mapComponent.getFollow())
									mapComponent.setAverageCenter();
							}
						}
					}
				}
			} else if (markers.size() < drones.size()) {
				for (IUAVProxy e : drones) {
					boolean exists = false;
					for (LMarker marker : markers) {
						if (e.getID().equals(marker.getId()))
							exists = true;
					}
					if (!exists) {
						LMarker marker = new LMarker(e.getLatitude(), e.getLongitude()); // create new marker for the drone
						marker.setId(e.getID());
						if (marker.getId().equals(focused))
							marker.setIcon(droneIconFocused);
						else {
							boolean chosen = false;
							for (String name : checked) {
								if (marker.getId().equals(name)) {
									marker.setIcon(droneIconSelected);
									chosen = true;
								}
							}
							if (!chosen)
								marker.setIcon(droneIcon);
						}
						marker.setIconSize(new Point(33, 33));
						marker.addMouseOverListener(mapComponent.getDroneListener());
						marker.setIconAnchor(new Point(ACHN_X, ANCH_Y));
						markers.add(marker);
						leafletMap.addComponent(marker);
						if (!mapComponent.getFollow())
							mapComponent.setAverageCenter();

					}
				}
			} else if (markers.size() > drones.size()) {
				for (LMarker marker : markers) {
					boolean exists = false;
					for (IUAVProxy e : drones) {
						if (e.getID().equals(marker.getId()))
							exists = true;
					}
					if (!exists) // remove marker that represents a deactivated drone
						remove.add(marker);
				}
			}
			if (remove.size() > 0) {
				for (LMarker e : remove) {
					markers.remove(e);
					leafletMap.removeComponent(e);
					if (!mapComponent.getFollow())
						mapComponent.setAverageCenter();
				}
				remove.clear();
			}
		} catch (RemoteException e) { // reconnect to dronology
			initConnection();
		}
	}

	/**
	 * This function adds icons on the map that represent each drone's position.
	 * 
	 * @param focused
	 *          this is the drone that is focused in the AFInfoPanel. It's flight route will be orange
	 * @param checked
	 *          this is a list of drones that have their checkbox checked in the AFInfoPanel. Their routes will be black.
	 */
	public void addDroneMarkers(String focused, List<String> checked) {
		Collection<IUAVProxy> drones = Collections.emptyList();
		try {
			drones = droneSetupService.getActiveUAVs();
		} catch (RemoteException e1) {
			initConnection();
		}
		for (

		IUAVProxy e : drones) {
			LMarker marker = new LMarker(e.getLatitude(), e.getLongitude());
			marker.setId(e.getID());
			if (marker.getId().equals(focused))
				marker.setIcon(droneIconFocused);
			else {
				boolean chosen = false;
				for (String name : checked) {
					if (marker.getId().equals(name)) {
						marker.setIcon(droneIconSelected);
						chosen = true;
					}
				}
				if (!chosen)
					marker.setIcon(droneIcon);
			}
			marker.setIconSize(new Point(30, 30));
			marker.setIconAnchor(new Point(ACHN_X, ANCH_Y));
			marker.addMouseOverListener(mapComponent.getDroneListener());
			markers.add(marker);
			leafletMap.addComponent(marker);
			if (!mapComponent.getFollow())
				mapComponent.setAverageCenter();
		}
	}

	/**
	 * assists in the logic of updating flight routes
	 * 
	 * @param coordinates
	 * @param i
	 * @return
	 */
	private boolean nextReached(List<Waypoint> coordinates, int i) {
		if (coordinates.size() <= i) {
			return false;
		}
		Waypoint next = coordinates.get(i);
		return next.isReached();
	}

}
"
AbstractServiceInstance.java,"package edu.nd.dronology.services.core.base;

import java.util.ArrayList;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import org.apache.commons.lang.StringUtils;

import edu.nd.dronology.services.core.api.IServiceInstance;
import edu.nd.dronology.services.core.api.ServiceInfo;
import edu.nd.dronology.services.core.api.ServiceStatus;
import edu.nd.dronology.services.core.listener.IServiceListener;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.util.NamedThreadFactory;
import edu.nd.dronology.util.NullUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Base class for all service instance implementations.
 * 
 * @author Michael Vierhauser
 * 
 */
public abstract class AbstractServiceInstance implements IServiceInstance {

	private static final ILogger LOGGER = LoggerProvider.getLogger(AbstractServiceInstance.class);
	private static final Properties EMPTY_PROPERTIES = new Properties();
	protected static final ExecutorService servicesExecutor = Executors.newFixedThreadPool(25,
			new NamedThreadFactory(""Service-Threads""));

	private final String ID;
	private String description;
	private ServiceStatus status = ServiceStatus.STOPPED;
	private List<IServiceListener> serviceListener = new ArrayList<>();

	private Properties properties;
	protected String PORT_PROPERTY = """";

	/**
	 * 
	 * @param ID
	 *            The id of the service.
	 */
	public AbstractServiceInstance(String ID) {
		this(ID, """");
	}

	/**
	 * 
	 * @param ID
	 *            The id of the service.
	 * @param description
	 *            A description for the service.
	 */
	public AbstractServiceInstance(String ID, String description) {
		NullUtil.checkNull(ID, description);
		this.ID = ID;
		this.description = description;
		PORT_PROPERTY = ""port-"" + ID;
	}

	@Override
	public String getServiceID() {
		return ID;
	}

	@Override
	public String getDescription() {
		return description;
	}

	@Override
	public ServiceStatus getStatus() {
		return status;
	}

	@Override
	public final boolean addServiceListener(IServiceListener listener) {
		return serviceListener.add(listener);
	}

	@Override
	public final boolean remoteServiceListener(IServiceListener listener) {
		return serviceListener.remove(listener);
	}

	@Override
	public final void startService() throws DronologyServiceException {
		if (getStatus() != ServiceStatus.RUNNING) {
			try {
				doStartService();
				setStatus(ServiceStatus.RUNNING);
				return;
			} catch (Exception e) {
				setStatus(ServiceStatus.ERROR);
				throw new DronologyServiceException(""Error when starting service "" + this.getClass().getSimpleName(),
						e);
			}
		}
		throw new DronologyServiceException(""Service already running"");
	}

	@Override
	public final void stopService() throws DronologyServiceException {
		if (getStatus() == ServiceStatus.RUNNING) {
			try {
				doStopService();
				setStatus(ServiceStatus.STOPPED);
				return;
			} catch (Exception e) {
				setStatus(ServiceStatus.ERROR);
				throw new DronologyServiceException(""Error when stopping service"", e);
			}
		}
		throw new DronologyServiceException(""Service not running"");
	}

	@Override
	public Properties getConfigurationProperties() {
		if (!hasProperties()) {
			return EMPTY_PROPERTIES;
		}
		if (properties == null) {
			properties = new Properties();
			// addGlobalProperties();
			if (getPropertyPath() == null || StringUtils.isEmpty(getPropertyPath())) {
				LOGGER.warn(""No property path defined for "" + this.getClass().getSimpleName());
				return properties;
			}

		}
		return properties;
	}

	/**
	 * Sets the status of the service. <br>
	 * May be called from a subsequent server-thread or delegate.<br>
	 * Not an interface method and therefore not intended to be called from
	 * outside!
	 * 
	 * @param status
	 */
	public final void setStatus(ServiceStatus status) {
		NullUtil.checkNull(status);
		// LOGGER.trace(this.getClass().getSimpleName() + "" status set to: "" +
		// status);
		this.status = status;
		for (IServiceListener listener : serviceListener) {
			listener.statusChanged(status);
		}
	}

	@Override
	public ServiceInfo getServiceInfo() {
		Map<String, String> attributes = new HashMap<>();
		Map<String, String> properties = new HashMap<>();

		for (Entry<Object, Object> e : getConfigurationProperties().entrySet()) {
			properties.put(e.getKey().toString(), e.getValue().toString());
		}
		ServiceInfo sInfo = new ServiceInfo(this.getServiceID(), this.getStatus(), this.getDescription(), attributes,
				properties, getOrder());
		sInfo.setServiceClass(getServiceClass().getCanonicalName());
		return sInfo;

	}

	protected void submitServiceThread(Runnable serverThread) {
		servicesExecutor.submit(serverThread);
	}

	protected void checkRunning() throws DronologyServiceException {
		if (getStatus() != ServiceStatus.RUNNING)
			throw new DronologyServiceException(""Service not running!"");
	}

	protected boolean hasProperties() {
		return true;
	}

	protected abstract Class<?> getServiceClass();

	protected abstract int getOrder();

	protected abstract String getPropertyPath();

	protected abstract void doStartService() throws Exception;

	protected abstract void doStopService() throws Exception;

}
"
DronologyServiceRunner.java,"package edu.nd.dronology.services.launch;

import edu.nd.dronology.core.fleet.RuntimeDroneTypes;
import edu.nd.dronology.gstation.connector.service.connector.DroneConnectorService;
import edu.nd.dronology.monitoring.service.DroneMonitoringServiceRemoteFacade;
import edu.nd.dronology.monitoring.service.IDroneMonitoringRemoteService;
import edu.nd.dronology.services.core.remote.IAreaMappingRemoteService;
import edu.nd.dronology.services.core.remote.IMissionPlanningRemoteService;
import edu.nd.dronology.services.extensions.areamapping.facade.AreaMappingServiceRemoteFacade;
import edu.nd.dronology.services.extensions.areamapping.instances.AreaMappingService;
import edu.nd.dronology.services.extensions.missionplanning.service.MissionPlanningServiceRemoteFacade;
import edu.nd.dronology.services.extensions.missionplanning.service.internal.MissionPlanningService;
import edu.nd.dronology.services.instances.dronesetup.DroneSetupService;
import edu.nd.dronology.services.instances.dronesimulator.DroneSimulatorService;
import edu.nd.dronology.services.instances.flightmanager.FlightManagerService;
import edu.nd.dronology.services.instances.flightroute.FlightRouteplanningService;
import edu.nd.dronology.services.instances.registration.types.UAVTypeRegistrationService;
import edu.nd.dronology.services.instances.registration.uavs.UAVRegistrationService;
import edu.nd.dronology.services.remote.RemoteManager;
import edu.nd.dronology.services.remote.RemoteService;
import edu.nd.dronology.services.supervisor.SupervisorService;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class DronologyServiceRunner {

	private static final ILogger LOGGER = LoggerProvider.getLogger(DronologyServiceRunner.class);
	private static final boolean USE_SAFETY_CASES = true;

	public static void main(String[] args) {

		try {

			RemoteService.getInstance().startService();
			SupervisorService.getInstance().startService();
			FlightRouteplanningService.getInstance().startService();
			FlightManagerService.getInstance().startService();
			DroneSetupService.getInstance().startService();
			UAVRegistrationService.getInstance().startService();
			DroneSimulatorService.getInstance().startService();
			
			
			UAVRegistrationService.getInstance().startService();
			UAVTypeRegistrationService.getInstance().startService();
			

			DroneConnectorService.getInstance().startService();
			RuntimeDroneTypes runtimeMode = RuntimeDroneTypes.getInstance();

			runtimeMode.setPhysicalEnvironment();

			// Extension services....
			MissionPlanningService.getInstance().startService();
			AreaMappingService.getInstance().startService();

			RemoteManager.getInstance().contributeService(IMissionPlanningRemoteService.class,
					MissionPlanningServiceRemoteFacade.getInstance());

			RemoteManager.getInstance().contributeService(IDroneMonitoringRemoteService.class,
					DroneMonitoringServiceRemoteFacade.getInstance());
			
			RemoteManager.getInstance().contributeService(IAreaMappingRemoteService.class,
					AreaMappingServiceRemoteFacade.getInstance());

			// DronologyMonitoringManager.getInstance().registerHandler(new
			// MonitoringDataHandler3());

			// new SimpleMonitor().main(null);
			// SimpleChecker.getInstance().init();

		} catch (Throwable e) {
			e.printStackTrace();
		}

	}

}
"
IItemChangeListener.java,"package edu.nd.dronology.services.core.listener;

import java.rmi.RemoteException;
import java.util.Set;

import edu.nd.dronology.services.core.api.IRemotable;

public interface IItemChangeListener extends IRemotable{

	void itemChanged(Set<String> info) throws RemoteException;
	
}
"
SupervisorService.java,"package edu.nd.dronology.services.supervisor;

import java.util.Map;


import edu.nd.dronology.services.core.base.AbstractServerService;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public class SupervisorService extends AbstractServerService<ISupervisorServiceInstance> {

	private static volatile SupervisorService INSTANCE;

	protected SupervisorService() {
		super();
	}

	/**
	 * @return The singleton SupervisorService instance
	 */
	public static SupervisorService getInstance() {
		if (INSTANCE == null) {
			synchronized (SupervisorService.class) {
				if (INSTANCE == null) {
					INSTANCE = new SupervisorService();
				}
			}
		}
		return INSTANCE;
	}

	@Override
	protected ISupervisorServiceInstance initServiceInstance() {
		return new SupervisorServiceInstance();
	}

	public void shutdownServer() {
		serviceInstance.shutdownServer();
	}

	public void restartAllServices() {
		serviceInstance.restartAllServices();
	}

	public String getFlightPathLocation() {
		return serviceInstance.getFlightPathLocation();
	}

	public String getSimScenarioLocation() {
		return serviceInstance.getSimScenarioLocation();
	}

	public String getDroneSpecificationLocation() {
		return serviceInstance.getDroneSpecificationLocation();
	}
	
	public String getAreaMappingLocation() {
		return serviceInstance.getAreaMappingLocation();
	}
	public String getMissionPlanningLocation() {
		return serviceInstance.getMissionPlanningLocation();
	}

	public String getWorkspaceLocation() {
		return serviceInstance.getWorkspaceLocation();

	}

	public Map<String, String> getGlobalProperties() {
		return serviceInstance.getGlobalProperties();
	}

	public boolean importItem(String fileName, byte[] byteArray, boolean overwrite) throws DronologyServiceException {
		return serviceInstance.importItem(fileName, byteArray, overwrite);
	}

	public void restart(String serviceClass) throws DronologyServiceException {
		getService(serviceClass).restartService();

	}

}
"
WaypointGoalSnapshot.java,"package edu.nd.dronology.core.goal;

import edu.nd.dronology.core.coordinate.AbstractPosition;

public class WaypointGoalSnapshot implements IGoalSnapshot {
    private final AbstractPosition position;
    private final double speed;
    private final AbstractGoal.GoalState state;

    public WaypointGoalSnapshot(AbstractPosition position, double speed, AbstractGoal.GoalState state) {
        this.position = position;
        this.speed = speed;
        this.state = state;
    }

    @Override
    public AbstractGoal.GoalState getState() {
        return state;
    }

    public AbstractPosition getPosition() {
        return position;
    }

    public double getSpeed() {
        return speed;
    }
}
"
UAVPlanChangeMessage.java,"//package edu.nd.dronology.core.monitoring.messages;
//
//import edu.nd.dronology.core.monitoring.ArtifactIdentifier;
//import edu.nd.dronology.core.monitoring.IMonitorableMessage;
//import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;
//import edu.nd.dronology.core.util.PreciseTimestamp;
//
//public class UAVPlanChangeMessage implements IMonitorableMessage {
//
//	private String uavid;
//	private long startTime;
//	private String type;
//	private String flightid;
//	private long endTime;
//	private final PreciseTimestamp timestamp;
//
//	public UAVPlanChangeMessage(String uavid, String type, String flightid, long startTime, long endTime) {
//		this.timestamp = PreciseTimestamp.create();
//		this.uavid = uavid;
//		this.type = type;
//		this.flightid = flightid;
//		this.startTime = startTime;
//		this.endTime = endTime;
//	}
//
//	@Override
//	public ArtifactIdentifier<?> getIdentifier() {
//		return new ArtifactIdentifier(ArtifactIdentifier.ROOT, ""INTERNAL"", MessageType.PLAN_CHANGE.toString(), uavid);
//	}
//
//	public String getUavid() {
//		return uavid;
//	}
//
//	@Override
//	public String getData() {
//		// TODO Auto-generated method stub
//		return null;
//	}
//
//	@Override
//	public PreciseTimestamp getTimestamp() {
//		return timestamp;
//	}
//
//	@Override
//	public MessageType getType() {
//		return MessageType.PLAN_CHANGE;
//	}
//
//}
"
FlightPlanFactory.java,"package edu.nd.dronology.core.flight;

import java.util.List;

import edu.nd.dronology.core.flight.internal.FlightPlan;
import edu.nd.dronology.core.util.Waypoint;

public class FlightPlanFactory {

	public static IFlightPlan create(String uavid, String planName, List<Waypoint> waypoints) {
		return new FlightPlan(uavid, planName, waypoints);
	}

	public static IFlightPlan create(String planName, List<Waypoint> waypoints) {
		return new FlightPlan(planName, waypoints);

	}

}
"
DroneFleetListener.java,"package edu.nd.dronology.core.fleet;

import edu.nd.dronology.core.vehicle.ManagedDrone;

public interface DroneFleetListener {
    void droneAdded(ManagedDrone managedDrone);
    void droneRemoved(ManagedDrone managedDrone);
}"
MissionInfo.java,"package edu.nd.dronology.services.core.info;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import edu.nd.dronology.services.core.items.TagList;

public class MissionInfo extends RemoteInfoObject {
	/**
	 * 
	 */
	private static final long serialVersionUID = 6569277297683551416L;
	private TagList tags = new TagList();
	private long dateCreated;
	private long dateModified;
	private List<String> uavids;
	private String description;

	public MissionInfo(String name, String id) {
		super(name, id);
		uavids = new ArrayList<>();
	}

	public void setDateModified(long dateModified) {
		this.dateModified = dateModified;
	}

	public void setDateCreated(long dateCreated) {
		this.dateCreated = dateCreated;
	}

	public long getDateCreated() {
		return dateCreated;
	}

	public long getDateModified() {
		return dateModified;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public void addUavId(String uavid) {
		uavids.add(uavid);
	}
	
	public void removeUavId(String uavid) {
		uavids.remove(uavid);
	}

	public Collection<String> getUAVIds() {
		return Collections.unmodifiableCollection(uavids);
	}

	public TagList getTags() {
		return tags;
	}

	public void addTag(String tag) {
		tags.add(tag);
	}
 
}
"
SynchronizationManager.java,"package edu.nd.dronology.services.extensions.missionplanning.sync;

import java.util.HashMap;
import java.util.Map;

import edu.nd.dronology.core.DronologyConstants;
import edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * The {@link SynchronizationManager} holds a list of {@link SynchronizationPoint} and ensures that a point is fully synced<br>
 * before allowing UAVs to proceed with the next task.
 * 
 * @author Jane Cleland-Huang 
 * 
 * 
 *
 */
public class SynchronizationManager {
	private static final ILogger LOGGER = LoggerProvider.getLogger(SynchronizationManager.class);

	private Map<String, SynchronizationPoint> synchPoints;
	private int availableAltitude = DronologyConstants.MISSION_TAKEOFF_MIN_ALTITUDE;

	private static transient SynchronizationManager INSTANCE;

	private SynchronizationManager() {
		synchPoints = new HashMap<>();
	}

	public static SynchronizationManager getInstance() {
		if (INSTANCE == null) {
			synchronized (SynchronizationManager.class) {
				if (INSTANCE == null) {
					INSTANCE = new SynchronizationManager();
				}
			}
		}
		return INSTANCE;
	}

	public int getNextAltitude() throws MissionExecutionException {
		availableAltitude += DronologyConstants.MISSION_TAKEOFF_ALTITUDE_INCREMENT;
		if (availableAltitude > DronologyConstants.MISSION_MAX_TAKEOFF_DISTANCE) {
			throw new MissionExecutionException(""Max altitude reached - No safe altitude available"");
		}

		return availableAltitude;
	}

	// Create named synchronization point
	public SynchronizationPoint createSynchronizationPoint(String synchName) {
		if (!synchPoints.containsKey(synchName)) {
			SynchronizationPoint synchPoint = new SynchronizationPoint(synchName);
			synchPoints.put(synchName, synchPoint);
			return synchPoint;
		} else {
			return null;
		}
	}

	public boolean synchPointExists(String synchName) {
		return synchPoints.containsKey(synchName);
	}

	// Register a UAV for a synchPoint
	public boolean addSynchItem(String uavid, String synchName) {
		SynchronizationPoint synchPoint = synchPoints.get(synchName);
		if (synchPoint != null) {
			synchPoint.registerCollaborator(uavid);
			LOGGER.missionInfo(""Adding '"" + uavid + ""' to SYNC-Point"" + synchName);
			return true;
		}
		LOGGER.missionError(""Sync point '"" + synchName + ""' not available!"");
		return false;
	}

	// Activate all synchronization points (we may not always want to do this -- but
	// it works for our current coordinated takeoff/landing
	public void activateAllSynchPoints() {
		synchPoints.forEach((k, point) -> {
			point.activateSynchronizationPoint();
		});
	}

	// Remove UAV from the synch point it has visited
	public void uavVisitedSynchPoint(String uavid, String synchName) {
		SynchronizationPoint synchPoint = synchPoints.get(synchName);
		if (synchPoint != null) {
			synchPoint.removeCollaborator(uavid);
		} else {
			LOGGER.missionError(""Sync point '"" + synchName + ""' not found"");
		}
	}

	// Count number of UAVs who are yet to visit the synch point
	public int getCountOfUnsynchedUAVs(String synchName) {
		SynchronizationPoint synchPoint = synchPoints.get(synchName);
		return synchPoint.countUnsynched();
	}

	// Check if all expected UAVs have visited
	public boolean isFullySynched(String synchName) {
		SynchronizationPoint synchPoint = synchPoints.get(synchName);
		return synchPoint.isSynched();
	}

	// Remove UAV after it has visited
	public void removeUAV(String uavID) {
		for (SynchronizationPoint sp : synchPoints.values()) {
			sp.removeCollaborator(uavID);
		}
	}

	public void resetAltitudes() {
		availableAltitude = DronologyConstants.MISSION_TAKEOFF_MIN_ALTITUDE;
	}

}"
CoordinateChange.java,"package edu.nd.dronology.core;


public @interface CoordinateChange {
	

	 

}
"
SearchPatternStrategy.java,"package edu.nd.dronology.services.extensions.areamapping.internal;

import java.util.List;

import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;

public interface SearchPatternStrategy {
	public List<RoutePrimitive> generateRoutePrimitive(double APERATURE_HEIGHT, double OVERLAP_FACTOR);

	public void setSourcePoints(List<SourcePoints> points);
	
	public void setRouteType(RoutePrimitive.RouteType routeType);
}
"
IDroneMonitoringRemoteService.java,"package edu.nd.dronology.monitoring.service;

import java.rmi.RemoteException;

import edu.nd.dronology.core.monitoring.ArtifactIdentifier;
import edu.nd.dronology.monitoring.IRemoteMonitoringMessageHandler;
import edu.nd.dronology.services.core.remote.IRemoteableService;

/**
 *
 * 
 * @author Michael Vierhauser
 * 
 *  
 * 
 */
public interface IDroneMonitoringRemoteService extends IRemoteableService {

	public void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler) throws RemoteException;

	public void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler, ArtifactIdentifier identifier)
			throws RemoteException;

	void setMonitoringFrequency(String uavid, Double frequency) throws RemoteException;

}
"
DroneSimulatorServiceInstance.java,"package edu.nd.dronology.services.instances.dronesimulator;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import edu.nd.dronology.core.util.Waypoint;
import edu.nd.dronology.services.core.api.IFileChangeNotifyable;
import edu.nd.dronology.services.core.api.ServiceInfo;
import edu.nd.dronology.services.core.base.AbstractFileTransmitServiceInstance;
import edu.nd.dronology.services.core.info.DroneInitializationInfo;
import edu.nd.dronology.services.core.info.DroneInitializationInfo.DroneMode;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.info.SimulatorScenarioCategoryInfo;
import edu.nd.dronology.services.core.info.SimulatorScenarioInfo;
import edu.nd.dronology.services.core.items.AssignedDrone;
import edu.nd.dronology.services.core.items.ISimulatorScenario;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import edu.nd.dronology.services.core.persistence.SimulatorScenarioPersistenceProvider;
import edu.nd.dronology.services.core.util.DronologyConstants;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.core.util.ServiceIds;
import edu.nd.dronology.services.instances.DronologyElementFactory;
import edu.nd.dronology.services.instances.dronesetup.DroneSetupService;
import edu.nd.dronology.services.instances.flightmanager.FlightManagerService;
import edu.nd.dronology.services.instances.flightroute.FlightRouteplanningService;
import edu.nd.dronology.services.supervisor.SupervisorService;
import edu.nd.dronology.util.FileUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class DroneSimulatorServiceInstance extends AbstractFileTransmitServiceInstance<SimulatorScenarioInfo>
		implements IFileChangeNotifyable, IDroneSimulatorServiceInstance {

	private static final ILogger LOGGER = LoggerProvider.getLogger(DroneSimulatorServiceInstance.class);

	private static final int ORDER = 5;

	public static final String EXTENSION = DronologyConstants.EXTENSION_SIM_SCENARIO;

	private Collection<SimulatorScenarioCategoryInfo> categories = new ArrayList<>();

	private Map<String, ISimulatorScenario> scenarios = new HashMap<>();

	public DroneSimulatorServiceInstance() {
		super(ServiceIds.SERVICE_SIMULATOR, ""DroneSimulator Management"", EXTENSION);

		categories.add(new SimulatorScenarioCategoryInfo(""Default"", ""Default""));

	}

	@Override
	protected Class<?> getServiceClass() {
		return FlightRouteplanningService.class;
	}

	@Override
	protected int getOrder() {
		return ORDER;
	}

	@Override
	protected String getPropertyPath() {
		return null;
	}

	@Override
	protected void doStartService() throws Exception {
		reloadItems();
	}

	@Override
	protected void doStopService() throws Exception {
		fileManager.tearDown();
	}

	@Override
	public ServiceInfo getServiceInfo() {
		ServiceInfo sInfo = super.getServiceInfo();
		sInfo.addAttribute(ServiceInfo.ATTRIBUTE_TYPE, ServiceInfo.ATTRIBUTE_FILE);
		return sInfo;
	}

	@Override
	public SimulatorScenarioInfo createItem() throws DronologyServiceException {
		SimulatorScenarioPersistenceProvider persistor = SimulatorScenarioPersistenceProvider.getInstance();
		ISimulatorScenario simulatorScenario = DronologyElementFactory.createNewSimulatorScenario();
		simulatorScenario.setName(""New-SimulatorScenario"");
		String savePath = FileUtil.concat(storagePath, simulatorScenario.getId(), EXTENSION);

		try {
			persistor.saveItem(simulatorScenario, savePath);
		} catch (PersistenceException e) {
			throw new DronologyServiceException(""Error when creating flightpath: "" + e.getMessage());
		}
		return new SimulatorScenarioInfo(simulatorScenario.getName(), simulatorScenario.getId());
	}

	@Override
	protected String getPath() {
		String path = SupervisorService.getInstance().getSimScenarioLocation();
		return path;
	}

	@Override
	protected SimulatorScenarioInfo fromFile(String id, File file) throws Throwable {
		ISimulatorScenario atm = SimulatorScenarioPersistenceProvider.getInstance().loadItem(file.toURI().toURL());
		scenarios.put(id, atm);
		SimulatorScenarioInfo info = new SimulatorScenarioInfo(atm.getName(), id);

		return info;
	}

	@Override
	protected boolean hasProperties() {
		return false;
	}

	@Override
	public void notifyFileChange(Set<String> changed) {
		super.notifyFileChange(changed);
		for (String s : changed) {
			String id = s.replace(""."" + extension, """");
			if (!itemmap.containsKey(id)) {

			}
		}
	}

	@Override
	public void activateScenario(SimulatorScenarioInfo scenario) throws DronologyServiceException {
		ISimulatorScenario item = scenarios.get(scenario.getId());
		if (item == null) {
			throw new DronologyServiceException(""Scenario '"" + scenario.getId() + ""' not found"");
		}
		for (AssignedDrone drone : item.getAssignedDrones()) {
			DroneSetupService.getInstance().initializeDrones(new DroneInitializationInfo(drone.getName(),
					DroneMode.MODE_VIRTUAL, drone.getName(), drone.getStartCoordinate()));
		}

		for (String path : item.getAssignedFlightPaths()) {

			FlightRouteInfo info = FlightRouteplanningService.getInstance().getItem(path);

			List<Waypoint> coordds = new ArrayList<>(info.getWaypoints());
			List<Waypoint> waypoints = new ArrayList<>();
			for (Waypoint c : coordds) {
				waypoints.add(c);
			}
			try {
				FlightManagerService.getInstance().planFlight(info.getName(), waypoints);
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

	}

	@Override
	public Collection<SimulatorScenarioCategoryInfo> getCategories() {
		return Collections.unmodifiableCollection(categories);
	}
}
"
IPersistenceManager.java,"
package edu.nd.dronology.services.core.persistence;

import java.io.InputStream;
import java.io.OutputStream;

public interface IPersistenceManager<T> {
	
	public T open(InputStream fin) throws PersistenceException;

	public boolean save(T o, OutputStream fout) throws PersistenceException;
}
"
ReturnHomeMessage.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal.message;

public class ReturnHomeMessage extends AbstractMessage {
}
"
TakeoffTask.java,"package edu.nd.dronology.services.extensions.missionplanning.tasks;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

public class TakeoffTask extends AbstractMissionTask {

	private final LlaCoordinate coordinate;

	protected TakeoffTask(String uavID, LlaCoordinate coordinate) {
		super(uavID, coordinate.toString());
		this.coordinate = coordinate;
	}

	@Override
	public LlaCoordinate getWaypoint() {
		return coordinate;
	}
}"
IUAVMissionDescription.java,"package edu.nd.dronology.services.core.items;

import java.io.Serializable;
import java.util.List;

public interface IUAVMissionDescription {

	String getName();

	List<IUAVMissionTask> getTasks();

	String getDescription();

	void setDescription(String description);

	void setName(String name);

	void addAttribute(String key, Serializable value);

	Serializable getAttributes(String key);

	void addTask(IUAVMissionTask task);

	void addTask(IUAVMissionTask task, int index);

	boolean removeTask(int index);

	boolean removeTask(IUAVMissionTask task);

}
"
RoutePrimitive.java,"package edu.nd.dronology.services.extensions.areamapping.model;

import java.awt.geom.Point2D;
import java.awt.geom.Point2D.Double;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

import edu.nd.dronology.services.extensions.areamapping.internal.Geometry;
import edu.nd.dronology.services.extensions.areamapping.internal.ImageWaypoints;

public class RoutePrimitive{

	private List<Point2D.Double> routePrimitive;
	private ImageWaypoints imageWaypoints;
	private boolean downstreamDirection;
	public enum RouteType {
		CRISSCROSS,
		INNER_CRISSCROSS,
		RIVERBANK,
		PRIORITYAREA,
		HOME
	}
	private final RouteType type;
	private int routeWeight;
	
	public RoutePrimitive(RouteType type, int routeWeight) {
		this.type = type;
		this.routeWeight = routeWeight;
		routePrimitive = new Vector<Point2D.Double>();
		imageWaypoints = new ImageWaypoints();
		downstreamDirection = true;
	}
	
	public void addRouteWaypoint(Point2D.Double routeWaypoint) {
		routePrimitive.add(routeWaypoint);
	}
	
	public void reverseRoute() {
		Collections.reverse(routePrimitive);
		if(downstreamDirection) {
			downstreamDirection = false;
		} else {
			downstreamDirection = true;
		}
	}
	
	public boolean getDownstreamDirection() {
		return downstreamDirection;
	}
	
	public List<Point2D.Double> getRoute(){
		return Collections.unmodifiableList(routePrimitive);
	}
	
	public Point2D.Double getRouteStartPoint(){
		return routePrimitive.get(0);
	}
	
	public Point2D.Double getRouteEndPoint(){
		return routePrimitive.get(size()-1);
	}
	
	public double getRouteDistance() {
		return Geometry.routePrimitiveDistance(routePrimitive);
	}
	
	public Point2D.Double getRouteWaypoint(int entry){
		return routePrimitive.get(entry);
	}
	
	public void insertRouteWaypoint(int index, Point2D.Double waypoint) {
		routePrimitive.add(index, waypoint);
	}
	
	public void setRouteWaypoint(int index, Point2D.Double entry) {
		routePrimitive.set(index, entry);
	}
	
	public int size() {
		return routePrimitive.size();
	}
	
	public ImageWaypoints getIWP() {
		return imageWaypoints;
	}
	
	public RouteType getRouteType() {
		return type;
	}
	
	public int getRouteWeight() {
		return routeWeight;
	}
}
"
NedCommand.java,"package edu.nd.dronology.core.collisionavoidance.guidancecommands;

/**
 * A command that tells a UAV to fly in a direction for a specified amount of time.
 */
public class NedCommand extends Command {
    private final double north, east, down, time;

    /**
     * <p>
     * Creates a command that tells a UAV to fly in the direction given as a NED vector for the given amount of time.
     * </p>
     *
     * <p>
     * Each component of the NED vector is given in meters per second. The time parameter is given in seconds.
     * </p>
     *
     * <p>
     *     For example, to create a NedCommand that tells the UAV to fly north at 5 meters per second for 10 seconds.
     *     <pre>
     *         {@code
     *         NedCommand north = new NedCommand(5, 0, 0, 10);
     *         }
     *     </pre>
     * </p>
     *
     * @param north the north component of the velocity vector given in meters per second
     * @param east the east component of the velocity vector given in meters per second
     * @param down the down component of the velocity vector given in meters per second
     * @param time the amount of time to fly at the given velocity in seconds
     */
    public NedCommand(double north, double east, double down, double time) {
        this.north = north;
        this.east = east;
        this.down = down;
        this.time = time;
    }

    /**
     *
     * @return the north component of the velocity vector in meters per second
     */
    public double getNorth() {
        return north;
    }

    /**
     *
     * @return the east component of the velocity vector in meters per second
     */
    public double getEast() {
        return east;
    }

    /**
     *
     * @return the down component of the velocity vector in meters per second
     */
    public double getDown() {
        return down;
    }

    /**
     *
     * @return the amount of time to fly at the given velocity in seconds
     */
    public double getTime() {
        return time;
    }

    @Override
    public String toString() {
        return ""NedCommand("" + north + "" N, "" + east + "" E, "" + down +"" D, "" + time + "" seconds)"";
    }
}
"
AFInfoPanel.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import com.vaadin.ui.Button;
import com.vaadin.ui.Component;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Label;
import com.vaadin.ui.Notification;
import com.vaadin.ui.Panel;
import com.vaadin.ui.UI;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.Window;
import com.vaadin.ui.themes.ValoTheme;

import edu.nd.dronology.core.vehicle.IUAVProxy;
import edu.nd.dronology.services.core.remote.IDroneSetupRemoteService;
import edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;
import edu.nd.dronology.ui.vaadin.start.MyUI;
import edu.nd.dronology.ui.vaadin.utils.StyleConstants;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * This is the side panel that contains the AFInfoBoxes with the UAV information
 * 
 * @author Patrick Falvey
 *
 */

public class AFInfoPanel extends CustomComponent {
	private static final long serialVersionUID = -3663049148276256302L;
	private Panel panel = new Panel();
	private Button selectButton = new Button(""Select all"");
	private Button visibleButton = new Button(""Expand all"");
	private VerticalLayout content = new VerticalLayout();
	private int numUAVs = 0;
	private boolean selectAll = true;
	private boolean visible = false;
	private String focused = """";
	private AFMapViewOperations mapView = new AFMapViewOperations();
	private Collection<IUAVProxy> drones;
	private IDroneSetupRemoteService service;
	private BaseServiceProvider provider = MyUI.getProvider();
	private AFMissionOperations missionView = new AFMissionOperations(this);
	private static final ILogger LOGGER = LoggerProvider.getLogger(AFInfoPanel.class);

	public AFInfoPanel() { 

		panel.setCaption(Integer.toString(numUAVs) + "" Active UAVs"");
		panel.setContent(content);
		panel.addStyleName(StyleConstants.AF_INFO_PANEL);
		panel.addStyleName(StyleConstants.CONTROL_PANEL);

		HorizontalLayout buttons = new HorizontalLayout();
		VerticalLayout sideBar = new VerticalLayout();

		AFEmergencyComponent emergency = new AFEmergencyComponent();

		emergency.getHome().addClickListener(e -> { // sends all UAVs (or all checked UAVs) to their homes
			List<String> checked = this.getChecked();
			String message = """";
			boolean sendHome = true;
			if (checked.size() > 0) {
				if (checked.size() == 1) {
					for (int i = 1; i < numUAVs + 1; i++) {
						AFInfoBox box = (AFInfoBox) content.getComponent(i);
						if (box.getName().equals(checked.get(0))) {
							if (box.getStatus().equals(""ON_GROUND"")) {
								Notification.show(checked.get(0) + "" is already home."");
								sendHome = false;
							} else {
								message = ""Are you sure you want to send "" + checked.get(0) + "" to its home?"";
							}
						}
					}

				} else {
					String drones = """";
					for (int i = 0; i < checked.size() - 1; i++) {
						drones += checked.get(i) + "", "";
					}
					message = ""Are you sure you want to send "" + drones + ""and "" + checked.get(checked.size() - 1)
							+ "" to their homes?"";
				}
			} else {
				message = ""Are you sure to send all UAVs to their homes?"";
			}
			Window confirm = new Window(""Confirm"");
			confirm.addStyleName(""confirm_window"");
			VerticalLayout subContent = new VerticalLayout();
			HorizontalLayout subButtons = new HorizontalLayout();
			subButtons.addStyleName(""confirm_button_area"");
			Label label = new Label(message);
			Button yes = new Button(""Yes"");
			yes.addStyleName(""btn-danger"");
			Button no = new Button(""No"");

			yes.addClickListener(subEvent -> {
				UI.getCurrent().removeWindow(confirm);
				IFlightManagerRemoteService service;
				try {
					service = (IFlightManagerRemoteService) provider.getRemoteManager()
							.getService(IFlightManagerRemoteService.class);
					if (checked.size() > 0) {
						for (int i = 0; i < checked.size(); i++) {
							for (int j = 1; j < numUAVs + 1; j++) {
								AFInfoBox box = (AFInfoBox) content.getComponent(j);
								if (box.getName().equals(checked.get(i))) {
									if (!box.getStatus().equals(""ON_GROUND"")) {
										service.returnToHome(checked.get(i));
									}
								}
							}
						}
					} else {
						for (int i = 1; i < numUAVs + 1; i++) {
							AFInfoBox box = (AFInfoBox) content.getComponent(i);
							if (!box.getStatus().equals(""ON_GROUND""))
								service.returnToHome(box.getName());
						}
					}
				} catch (Exception exc) {
					exc.printStackTrace();
				}

			});

			no.addClickListener(subEvent -> {
				UI.getCurrent().removeWindow(confirm);
			});

			subButtons.addComponents(yes, no);
			subContent.addComponents(label, subButtons);
			confirm.setContent(subContent);
			confirm.setModal(true);
			confirm.setResizable(false);
			confirm.center();
			if (sendHome)
				UI.getCurrent().addWindow(confirm);

		});

		content.addLayoutClickListener(e -> { // determines if a box should be in focus
			Component testChild = e.getChildComponent();
			if (testChild.getClass() == AFInfoBox.class) {
				AFInfoBox child = (AFInfoBox) e.getChildComponent();
				if (!child.getCheckClick()) { // if the box was clicked but not the checkbox
					child.addStyleName(""info_box_focus"");
					child.setIsChecked(true);
					focused = child.getName();
					for (int i = 1; i < numUAVs + 1; i++) {
						AFInfoBox box = (AFInfoBox) content.getComponent(i);
						if (!box.getName().equals(child.getName())) {
							box.removeStyleName(""info_box_focus"");
							box.setIsChecked(false);
							box.setCheckClick(false);
						}
					}
				} else {
					child.removeStyleName(""info_box_focus"");
					if (focused.equals(child.getName()))
						focused = """";
				}
			}
		});

		sideBar.addComponents(panel, mapView, missionView, emergency);
		setCompositionRoot(sideBar);

		selectButton.addStyleName(ValoTheme.BUTTON_LINK);
		selectButton.addStyleName(StyleConstants.SMALL_BUTTON_LINK);
		visibleButton.addStyleName(ValoTheme.BUTTON_LINK);
		visibleButton.addStyleName(StyleConstants.SMALL_BUTTON_LINK);

		buttons.addComponents(selectButton, visibleButton);
		buttons.addStyleName(""af_uav_list_controls"");

		selectButton.addClickListener(e -> {
			if (selectAll) {
				selectAll(true);
				selectButton.setCaption(""Deselect all"");
				selectAll = false;
			} else {
				selectAll(false);
				selectButton.setCaption(""Select all"");
				selectAll = true;
			}
		});

		visibleButton.addClickListener(e -> {
			if (visible) {
				visible = false;
				setVisibility(true);
				visibleButton.setCaption(""Expand all"");
			} else {
				visible = true;
				setVisibility(false);
				visibleButton.setCaption(""Collapse all"");
			}
		});

		content.addComponent(buttons);
		numUAVs = content.getComponentCount() - 1;

		try {
			service = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);
			Collection<IUAVProxy> activeDrones = service.getActiveUAVs();
			drones = new ArrayList<>(activeDrones);
			// Collections.sort(drones);
			for (IUAVProxy e : drones) {
				addBox(false, new UAVStatusWrapper(e), false);
			}
		} catch (DronologyServiceException | RemoteException e1) {
			MyUI.setConnected(false);
			LOGGER.error(e1);
		}

	}

	public AFMapViewOperations getMapView() {
		return mapView;
	}

	public String getFocusedName() {
		return focused;
	}

	/**
	 * Adds a box to the panel
	 * 
	 * @param isChecked
	 * @param name
	 * @param status
	 * @param batteryLife
	 * @param healthColor
	 * @param lat
	 * @param lon
	 * @param alt
	 * @param speed
	 * @param hoverInPlace
	 */
	public void addBox(boolean isChecked, UAVStatusWrapper uavStatus, boolean hoverInPlace) {
		AFInfoBox box = new AFInfoBox(isChecked, uavStatus, hoverInPlace);
		box.createContents();
		content.addComponent(box);
		numUAVs = content.getComponentCount() - 1;
		panel.setCaption(Integer.toString(numUAVs) + "" Active UAVs"");
	}

	public void addBox() {
		AFInfoBox box = new AFInfoBox();
		content.addComponent(box);
		numUAVs = content.getComponentCount() - 1;
		panel.setCaption(Integer.toString(numUAVs) + "" Active UAVs"");
	}

	/**
	 * Removes a box from the panel
	 * 
	 * @param name
	 *          the name/ID of the drone
	 * @return returns true if successful. returns false if failed
	 */
	public boolean removeBox(String name) {
		for (int i = 1; i < numUAVs + 1; i++) {
			AFInfoBox box = (AFInfoBox) content.getComponent(i);
			if (box.getName().equals(name)) {
				content.removeComponent(box);
				numUAVs = content.getComponentCount() - 1;
				panel.setCaption(Integer.toString(numUAVs) + "" Active UAVs"");
				return true;
			}
		}
		return false;
	}

	public void selectAll(boolean select) {
		for (int i = 1; i < numUAVs + 1; i++) {
			AFInfoBox box = (AFInfoBox) content.getComponent(i);
			box.setIsChecked(select);
			if (!select && focused.equals(box.getName())) {
				box.removeStyleName(""info_box_focus"");
				box.setCheckClick(false);
				focused = """";
			}
		}
	}

	/**
	 * 
	 * @return a list of all drones that have their checkbox checked
	 */
	public List<String> getChecked() {
		List<String> names = new ArrayList<>();
		for (int i = 1; i < numUAVs + 1; i++) {
			AFInfoBox box = (AFInfoBox) content.getComponent(i);
			if (box.getIsChecked())
				names.add(box.getName());
		}
		return names;
	}

	/**
	 * 
	 * @return true if all the drones are checked
	 */
	private boolean getAllChecked() {
		boolean checked = true;
		for (int i = 1; i < numUAVs + 1; i++) {
			AFInfoBox box = (AFInfoBox) content.getComponent(i);
			if (!box.getIsChecked())
				checked = false;
		}
		return checked;
	}

	/**
	 * 
	 * @return true if all drones are not checked
	 */
	private boolean getAllNotChecked() {
		boolean notChecked = true;
		for (int i = 1; i < numUAVs + 1; i++) {
			AFInfoBox box = (AFInfoBox) content.getComponent(i);
			if (box.getIsChecked())
				notChecked = false;
		}
		return notChecked;
	}

	/**
	 * Expands or collapses all the boxes
	 * 
	 * @param visible
	 */
	public void setVisibility(boolean visible) {
		for (int i = 1; i < numUAVs + 1; i++) {
			AFInfoBox box = (AFInfoBox) content.getComponent(i);
			box.setBoxVisible(visible);
		}
	}

	/**
	 * 
	 * @return true if all boxes are expanded
	 */
	private boolean getAllVisible() {
		boolean visible = true;
		for (int i = 1; i < numUAVs + 1; i++) {
			AFInfoBox box = (AFInfoBox) content.getComponent(i);
			if (!box.getBoxVisible())
				visible = false;
		}
		return visible;
	}

	/**
	 * 
	 * @return true if all boxes are collapsed
	 */
	private boolean getAllNotVisible() {
		boolean notVisible = true;
		for (int i = 1; i < numUAVs + 1; i++) {
			AFInfoBox box = (AFInfoBox) content.getComponent(i);
			if (box.getBoxVisible())
				notVisible = false;
		}
		return notVisible;
	}

	public void setAllToHover() {
		for (int i = 1; i < numUAVs + 1; i++) {
			AFInfoBox box = (AFInfoBox) content.getComponent(i);
			box.setHoverInPlace(true);
		}
	}

	public VerticalLayout getBoxes() {
		return content;
	}

	public int getNumUAVS() {
		return numUAVs;
	}

	/**
	 * gets updated information from dronology about the UAV's location information and status. adds any new drones to the panel and removes any drones that were deactivated
	 */
	@SuppressWarnings(""deprecation"") 
	public void refreshDrones() {
		// update select/deselect all button
		if (this.getAllChecked() && selectButton.getCaption().equals(""Select all"") && numUAVs != 0) {
			selectButton.setCaption(""Deselect all"");
			selectAll = false;
		} else if (this.getAllNotChecked() && selectButton.getCaption().equals(""Deselect all"") && numUAVs != 0) {
			selectButton.setCaption(""Select all"");
			selectAll = true;
		}
		// update expand/collapse all button
		if (this.getAllVisible() && visibleButton.getCaption().equals(""Expand all"") && numUAVs != 0) {
			visibleButton.setCaption(""Collapse all"");
			visible = true;
		} else if (this.getAllNotVisible() && visibleButton.getCaption().equals(""Collapse all"") && numUAVs != 0) {
			visibleButton.setCaption(""Expand all"");
			visible = false;
		}
		try {

			Collection<IUAVProxy> newDrones = service.getActiveUAVs();
			/**
			 * add new drones to the panel
			 */
			if (newDrones.size() > drones.size()) {
				for (IUAVProxy e1 : newDrones) {
					boolean nameMatch = false;
					for (IUAVProxy e2 : drones) {
						if (e1.getID().equals(e2.getID())) {
							nameMatch = true;
						}
					}
					if (!nameMatch) {
						this.addBox(false, new UAVStatusWrapper(e1), false);
					}
				}
			}
			/**
			 * delete old drones from the panel
			 */
			if (newDrones.size() < drones.size()) {
				for (IUAVProxy old : drones) {
					boolean exists = false;
					for (IUAVProxy current : newDrones) {
						if (old.getID().equals(current.getID()))
							exists = true;
					}
					if (!exists) {
						for (int i = 1; i < numUAVs + 1; i++) {
							AFInfoBox box = (AFInfoBox) content.getComponent(i);
							if (old.getID().equals(box.getName()))
								this.removeBox(box.getName());
						}
					}
				}
			}
		} catch (RemoteException e1) {
			try {
				Notification.show(""Reconnecting..."");
				service = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);
			} catch (RemoteException | DronologyServiceException e) {
				MyUI.setConnected(false);
				Notification.show(""Reconnecting..."");
			}
			Notification.show(""Reconnecting..."");
			content.removeAllComponents();
			numUAVs = 0;
		}
		/**
		 * update current drones' status
		 */
		try {
			drones = service.getActiveUAVs();
			for (IUAVProxy e : drones) {
				for (int i = 1; i < numUAVs + 1; i++) {
					AFInfoBox box = (AFInfoBox) content.getComponent(i);
					if (e.getID().equals(box.getName())) {
						box.update(new UAVStatusWrapper(e));

					}
				}
			}
		} catch (RemoteException e1) {
			try {
				Notification.show(""Reconnecting..."");
				service = (IDroneSetupRemoteService) provider.getRemoteManager().getService(IDroneSetupRemoteService.class);
			} catch (RemoteException | DronologyServiceException e) {
				Notification.show(""Reconnecting..."");
			}
			Notification.show(""Reconnecting..."");
			content.removeAllComponents();
			numUAVs = 0;
		}
	}

	public void createContents() {
		// TODO Auto-generated method stub

	}

}
"
GetBaseCoordinatesMessage.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal.message;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

import java.util.concurrent.SynchronousQueue;

public class GetBaseCoordinatesMessage extends AbstractMessage {
    public final SynchronousQueue<LlaCoordinate> returnBox = new SynchronousQueue<>();
}
"
MonitoringDataHandler3.java,"package edu.nd.dronology.monitoring;

import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;

import edu.nd.dronology.core.monitoring.ArtifactIdentifier;
import edu.nd.dronology.core.monitoring.IMonitorableMessage;
import edu.nd.dronology.core.monitoring.IMonitoringDataHandler;
import edu.nd.dronology.monitoring.service.DroneMonitoringService;
import edu.nd.dronology.util.NamedThreadFactory;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class MonitoringDataHandler3 implements Runnable, IMonitoringDataHandler {

	private static final ILogger LOGGER = LoggerProvider.getLogger(MonitoringDataHandler3.class);
	private static final int NUM_THREADS = 10;
	private BlockingQueue<IMonitorableMessage> queue;
	private AtomicBoolean cont = new AtomicBoolean(true);

	private static final ExecutorService SERVICE_EXECUTOR = Executors.newFixedThreadPool(NUM_THREADS,
			new NamedThreadFactory(""SubscriberDistributionThreads""));

	public MonitoringDataHandler3() {
	}

	@Override
	public void run() {
		while (cont.get()) {

			try {
				IMonitorableMessage message = queue.take();

				ArtifactIdentifier<?> identifier = message.getIdentifier();

				Set<IRemoteMonitoringMessageHandler> handler = DroneMonitoringService.getInstance()
						.getSubscribedHandler(identifier);
				for (IRemoteMonitoringMessageHandler h : handler) {
					SERVICE_EXECUTOR.submit(new SendToSubscriberCallable(h, message));
				}

			} catch (Throwable e) {
				LOGGER.error(e);
			}

		}
	}

	@Override
	public void setQueue(BlockingQueue<IMonitorableMessage> queue) {
		this.queue = queue;

	}
}
"
UAVEquipmentTypeRegistrationXStreamPersistor.java,"package edu.nd.dronology.services.core.persistence.internal;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.nio.charset.Charset;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.io.xml.XppDriver;

import edu.nd.dronology.services.core.items.IUAVEquipmentTypeRegistration;
import edu.nd.dronology.services.core.persistence.DronologyPersistenceUtil;
import edu.nd.dronology.services.core.persistence.IPersistenceManager;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class UAVEquipmentTypeRegistrationXStreamPersistor implements IPersistenceManager<IUAVEquipmentTypeRegistration> {

	private static final XStream xstream = new XStream(new XppDriver());
	private static ILogger LOGGER = LoggerProvider.getLogger(UAVEquipmentTypeRegistrationXStreamPersistor.class);

	static final boolean useCompression = false;

	@Override
	public IUAVEquipmentTypeRegistration open(InputStream fin) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
	//	 xstream.setMode(XStream.);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");
		
		if (useCompression) {
			return loadedCompressedStream(fin);
		} else {
			return loadUncompressedStream(fin);
		}
	}

	private IUAVEquipmentTypeRegistration loadUncompressedStream(InputStream fin) throws PersistenceException {
		try {
			InputStreamReader reader = new InputStreamReader(new BufferedInputStream(fin), Charset.forName(""UTF-8""));
			Object model = xstream.fromXML(reader);
			return (IUAVEquipmentTypeRegistration) model;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (fin != null) {
					fin.close();
				}
			} catch (Exception e) {
				LOGGER.error(e);
			}
		}
	}

	private IUAVEquipmentTypeRegistration loadedCompressedStream(InputStream fin) throws PersistenceException {
		InputStream zIn = null;
		try {
			zIn = new GZIPInputStream(fin);
			Object model = xstream.fromXML(new BufferedReader(new InputStreamReader(zIn, ""UTF-8"")));

			return (IUAVEquipmentTypeRegistration) model;
		} catch (IOException e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (zIn != null) {
					zIn.close();
				}
				if (fin != null) {
					fin.close();
				}
			} catch (Exception e) {
				LOGGER.error(e);
			}

		}
	}
 
	@Override
	public boolean save(IUAVEquipmentTypeRegistration o, OutputStream fout) throws PersistenceException {
		DronologyPersistenceUtil.preprocessStream(xstream);
		// xstream.setMode(XStream.ID_REFERENCES);
		// xstream.addImplicitCollection(ImplMMEArtifactType.class, ""children"");
		// xstream.addImplicitMap(ImplMEEvent.class, ""relatedEvents"", ImplMEEvent.class, ""relatedEvents"");

		if (useCompression) {
			return saveCompressedStream(o, fout);
		} else {
			return saveUncompressedStream(o, fout);
		}

	}

	private boolean saveUncompressedStream(IUAVEquipmentTypeRegistration o, OutputStream fout) throws PersistenceException {
		OutputStreamWriter writer = null;
		try {
			writer = new OutputStreamWriter(new BufferedOutputStream(fout), Charset.forName(""UTF-8""));
			xstream.toXML(o, writer);
			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (writer != null) {
					writer.close();
				}
				if (fout != null) {
					fout.close();
				}
			} catch (IOException e) {
				LOGGER.error(e);
			}
		}

	}

	private boolean saveCompressedStream(IUAVEquipmentTypeRegistration o, OutputStream fout) throws PersistenceException {
		try {
			GZIPOutputStream zOut = new GZIPOutputStream(fout);
			xstream.toXML(o, new BufferedWriter(new OutputStreamWriter(zOut, ""UTF-8"")));

			zOut.close();
			fout.close();

			return true;
		} catch (Exception e) {
			throw new PersistenceException(e);
		}
	}

}
"
SyncConstants.java,"package edu.nd.dronology.services.extensions.missionplanning.sync;

/**
 * Synchronization IDs for predefined, built-in {@link SynchronizationPoint} .
 * 
 * @author Michael Vierhauser 
 * 
 * 
 *
 */
public class SyncConstants {
 
	public static final String LANDING_ASC_REACHED = ""SP-Landing-AscentTargetReached"";
	public static final String LANDING_LONLAT_REACHED = ""SP-Landing-LonLatReached"";
	public static final String LANDING_HOME_REACHED = ""SP-Landing-HomeReached"";

	public static final String TAKEOFF_ASC_REACHED = ""SP-TakeOff-AscentTargetReached"";
	public static final String TAKEOFF_LATLON_REACHED = ""SP-TakeOff-LonLatReached"";
	public static final String TAKEOFF_WP_REACHED = ""SP-TakeOff-FirstWayPointReached"";

}
"
IDroneCommandHandler.java,"package edu.nd.dronology.core.vehicle;

import edu.nd.dronology.core.IUAVPropertyUpdateNotifier;
import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.vehicle.commands.IDroneCommand;

public interface IDroneCommandHandler {
	
	
	public void sendCommand(IDroneCommand command) throws DroneException;

	void setStatusCallbackNotifier(String id, IUAVPropertyUpdateNotifier listener) throws DroneException;
	
	public String getHandlerId();

}
"
SimulatorFactory.java,"package edu.nd.dronology.core.simulator;

import edu.nd.dronology.core.simulator.nvecsimulator.NVECSimulator;
import edu.nd.dronology.core.simulator.simplesimulator.SimpleSimulator;
import edu.nd.dronology.core.vehicle.internal.VirtualDrone;

public class SimulatorFactory {

	private static final boolean USE_SIMPLE_SIMULATOR = true;

	public static IFlightSimulator getSimulator(VirtualDrone drone) {
		if (USE_SIMPLE_SIMULATOR) {
			return new SimpleSimulator(drone);
		} else {
			return new NVECSimulator(drone);
		}
	}

}
"
UAVStateChangeMessage.java,"//package edu.nd.dronology.core.monitoring.messages;
//
//import edu.nd.dronology.core.monitoring.ArtifactIdentifier;
//import edu.nd.dronology.core.monitoring.IMonitorableMessage;
//import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;
//import edu.nd.dronology.core.util.PreciseTimestamp;
//
//public class UAVStateChangeMessage implements IMonitorableMessage {
//
//	private String uavid;
//	private String oldstate;
//	private String newstate;
//	private final PreciseTimestamp timestamp;
//
//	public UAVStateChangeMessage(String uavid, String oldstate, String newstate) {
//		this.uavid = uavid;
//		timestamp = PreciseTimestamp.create();
//		this.oldstate = oldstate;
//		this.newstate = newstate;
//	}
//
//	@Override
//	public ArtifactIdentifier<?> getIdentifier() {
//		return new ArtifactIdentifier(ArtifactIdentifier.ROOT, ""INTERNAL"",MessageType.STATE_CHANGE.toString(), uavid);
//
//	}
//
//	public String getUavid() {
//		return uavid;
//	}
//
//	@Override
//	public String getData() {
//		return null;
//	}
//
//	@Override
//	public PreciseTimestamp getTimestamp() {
//		return timestamp;
//	}
//
//	@Override
//	public MessageType getType() {
//		return MessageType.STATE_CHANGE;
//	}
//
//}
"
IMissionPlanningRemoteService.java,"package edu.nd.dronology.services.core.remote;

import java.rmi.RemoteException;

import edu.nd.dronology.services.core.info.MissionInfo;
import edu.nd.dronology.services.core.info.UAVMappingInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

/**
 * 
 * @author Michael Vierhauser
 * 
 */
public interface IMissionPlanningRemoteService extends IRemoteableService, IFileTransmitRemoteService<MissionInfo>  {

	@Deprecated
	void executeMissionPlan(String mission) throws RemoteException, Exception;

	void cancelMission() throws RemoteException, DronologyServiceException;

	void executeMissionPlan(MissionInfo info) throws RemoteException, DronologyServiceException;
	
	void executeMissionPlan(MissionInfo info, UAVMappingInfo mapping) throws RemoteException, DronologyServiceException;

}
"
MessageMarshaller.java,"package edu.nd.dronology.core.monitoring;

import java.io.Serializable;

import edu.nd.dronology.core.flight.IFlightPlan;
import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage;
import edu.nd.dronology.core.monitoring.messages.UAVMonitorableMessage.MessageType;
import edu.nd.dronology.core.vehicle.DroneFlightStateManager.FlightMode;
import edu.nd.dronology.core.vehicle.commands.IDroneCommand;

public class MessageMarshaller {

	public static class StateWrapper implements Serializable {

		/**
		 * 
		 */
		private static final long serialVersionUID = -6332164623939457896L;
		private String oldstate;
		private String newstate;
		private String uavid;

		public StateWrapper(String uavid, FlightMode oldState, FlightMode newState) {
			this.uavid = uavid;
			this.oldstate = oldState.toString();
			this.newstate = newState.toString();
		}

	}

	public static IMonitorableMessage create(String droneId, FlightMode oldState, FlightMode newState) {
		// return new UAVStateChangeMessage(droneId, oldState.toString(),
		// newState.toString());
		return new UAVMonitorableMessage(MessageType.STATE_CHANGE, droneId,
				new StateWrapper(droneId, oldState, newState));
	}

	public static IMonitorableMessage createPlanActive(IFlightPlan plan) {
		// return new UAVPlanChangeMessage(plan.getDesignatedDroneId(), ""ACTIVATE"",
		// plan.getFlightID(),
		// plan.getStartTime(), plan.getEndTime());
		return new UAVMonitorableMessage(MessageType.PLAN_ACTIVATED, plan.getDesignatedDroneId(), plan);
	}

	public static IMonitorableMessage createPlanCompleted(IFlightPlan plan) {
		// return new UAVPlanChangeMessage(plan.getDesignatedDroneId(), ""COMPLETE"",
		// plan.getFlightID(),
		// plan.getStartTime(), plan.getEndTime());

		return new UAVMonitorableMessage(MessageType.PLAN_COMPLETE, plan.getDesignatedDroneId(), plan);

	}

	public static IMonitorableMessage createMessage(IDroneCommand cmd) {
		return new UAVMonitorableMessage(MessageType.COMMAND, cmd.getUAVId(), cmd);
	}

	public static IMonitorableMessage createMessage(MessageType type, String uavid, Serializable data) {
		return new UAVMonitorableMessage(type, uavid, data);
	}

	public static IMonitorableMessage createMessage(MessageType type, String uavid) {
		return createMessage(type, uavid, null);
	}

}
"
DronologyServiceException.java,"package edu.nd.dronology.services.core.util;


/**
 * 
 * Default exception that is thrown when any kind of exception occurs server-side Wraps technology specific exceptions such as JMS or RMI exceptions.
 * 
 * @author Michael Vierhauser
 * 
 */
public class DronologyServiceException extends Exception {

	/**
	 * 
	 */
	private static final long serialVersionUID = -4309389079690729311L;

	/**
	 * @param e
	 */
	public DronologyServiceException(Throwable e) {
		super(e);
	}

	/**
	 * @param message
	 */
	public DronologyServiceException(String message) {
		super(message);
	}
	
	/**
	 * @param message
	 * @param e
	 */
	public DronologyServiceException(String message, Exception e) {
		super(message,e);
	}

}
"
AMInfoBox.java,"package edu.nd.dronology.ui.vaadin.areamapping;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;

import com.vaadin.server.FileResource;
import com.vaadin.server.VaadinService;
import com.vaadin.ui.Button;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Label;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.themes.ValoTheme;

import edu.nd.dronology.services.core.info.AreaMappingInfo;
import edu.nd.dronology.ui.vaadin.areamapping.windows.AMUnsavedChangesConfirmation.ChangeType;

/**
 * Each Mapping has a different info box. It contains information about date creation. It also has buttons for editing or trashing a mapping.
 * 
 * @author Andrew Slavin
 *
 */


public class AMInfoBox extends CustomComponent {
	/**
	 * 
	 */
	private static final long serialVersionUID = 763381012380912332L;

	private AreaMappingInfo areaMappingInfo;

	private HorizontalLayout titleBar = new HorizontalLayout();

	// Create AMInfoBox in Area Mapping view -- with edit and delete buttons
	public AMInfoBox(AMInfoPanel infoPanel, AreaMappingInfo areaMappingInfo) {
		this(areaMappingInfo);

		// Imports images for buttons.
		String basepath = VaadinService.getCurrent().getBaseDirectory().getAbsolutePath();
		FileResource editIcon = new FileResource(new File(basepath + ""/VAADIN/img/edit.png""));
		FileResource trashIcon = new FileResource(new File(basepath + ""/VAADIN/img/trashcan.png""));

		Button editButton = new Button();
		Button trashButton = new Button();

		editButton.setIcon(editIcon);
		trashButton.setIcon(trashIcon);
		editButton.addStyleName(ValoTheme.BUTTON_ICON_ONLY);
		trashButton.addStyleName(ValoTheme.BUTTON_ICON_ONLY);
		
		// Adds listener to the delete button on the mapping box /
		trashButton.addListener(e -> {
			if (infoPanel.getControls().getMainLayout().getMapComponent().getMapUtilities().getSidesAreEditable() || infoPanel.getControls().getMainLayout().getMapComponent().getMapUtilities().getPrioritiesAreEditable()) {
				// Checks if the mapping is in edit mode.
				infoPanel.getControls().getMainLayout().getUnsavedChangesConfirmation().showWindow(
						infoPanel.getHighlightedAMInfoBox().getAreaMappingInfo().getName(), ChangeType.DELETE_MAPPING, e);
			} else {
				infoPanel.getControls().getMainLayout().getDeleteMappingConfirmation().showWindow(getAreaMappingInfo(),
						e);
			}
		});
		// A click on the edit button enables editing, unless edit mode is already
		// enabled, in which case the user is prompted about losing changes.
		editButton.addClickListener(e -> {
			if (!infoPanel.getControls().getMainLayout().getMapComponent().getMapUtilities().getSidesAreEditable() && !infoPanel.getControls().getMainLayout().getMapComponent().getMapUtilities().getPrioritiesAreEditable()) {
				// open edit mode choices window
				infoPanel.getControls().getMainLayout().switchMapping(this);
				infoPanel.getControls().getMainLayout().getMapComponent().getEditSidesController().enterEditMode();
			} else {
				if (infoPanel.getHighlightedAMInfoBox() != null
						&& areaMappingInfo.getId().equals(infoPanel.getHighlightedAMInfoBox().getId()))
					return;
				infoPanel.getControls().getMainLayout().getUnsavedChangesConfirmation().showWindow(
						infoPanel.getHighlightedAMInfoBox().getAreaMappingInfo().getName(), ChangeType.EDIT_ANOTHER, e, this, infoPanel);
			}
		});

		titleBar.addComponents(trashButton, editButton);
	}

	// set the creation and modification time
	public AMInfoBox(AreaMappingInfo areaMappingInfo) {
		this.areaMappingInfo = areaMappingInfo;
		SimpleDateFormat sdf = new SimpleDateFormat(""MMM d, yyyy, hh:mm aaa"");
		long creationTime = areaMappingInfo.getDateCreated();
		String creationFormatted = sdf.format(new Date(creationTime));
		long modifiedTime = areaMappingInfo.getDateModified();
		String modifiedFormatted = sdf.format(new Date(modifiedTime));

		this.addStyleName(""info_box"");
		this.addStyleName(""fr_info_box"");

		VerticalLayout mappingDescription = new VerticalLayout();
		mappingDescription.addStyleName(""detailed_info_well"");

		VerticalLayout allContent = new VerticalLayout();

		// Create name id label.
		Label nameIdLabel = new Label(areaMappingInfo.getName());
		nameIdLabel.addStyleName(""info_box_name"");

		// Creates 4 different labels
		Label createdLabel = new Label(""Created:  "" + creationFormatted);
		Label modifiedLabel = new Label(""Last Modified:  "" + modifiedFormatted);
		Label sideALabel = new Label(areaMappingInfo.getCoordinates(0).size() + "" side A coordinates"");
		Label sideBLabel = new Label(areaMappingInfo.getCoordinates(1).size() + "" side B coordinates"");
		
		mappingDescription.addComponents(createdLabel, modifiedLabel, sideALabel, sideBLabel);

		titleBar.addComponents(nameIdLabel);

		// Adds all content together and aligns the buttons on the right.
		allContent.addComponents(titleBar, mappingDescription);

		setCompositionRoot(allContent);
	}

	public AreaMappingInfo getAreaMappingInfo() {
		return areaMappingInfo;
	}

	// Gets the name of the route.
	public String getName() {
		return areaMappingInfo.getName();
	}

	// Gets the route id.
	@Override
	public String getId() {
		return areaMappingInfo.getId();
	}
}
"
AbstractDroneCommand.java,"package edu.nd.dronology.core.vehicle.commands;

import java.text.DateFormat;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

/**
 * 
 * Abstract base class for all commands sent to the GCS.<br>
 * Contains the id of the UAV and a unique command id.
 * 
 * @author Michael Vierhauser
 *
 */
@SuppressWarnings(""unused"")
public class AbstractDroneCommand implements IDroneCommand {

	/**
	 * 
	 */
	private static final long serialVersionUID = 4401634183653180024L;

	static final transient Gson GSON = new GsonBuilder().enableComplexMapKeySerialization().serializeNulls()
			.setDateFormat(DateFormat.LONG).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES).setVersion(1.0)
			.serializeSpecialFloatingPointValues().create();

	protected final Map<String, Object> data = new HashMap<>();

	private final String uavid;

	private final String command;
	private long sendtimestamp;
	private final String commandid;

	protected AbstractDroneCommand(String uavid, String command) {
		this.uavid = uavid;
		this.command = command;
		this.commandid = UUID.randomUUID().toString();
	}

	@Override
	public String toString() {
		return this.getClass().getSimpleName() + "" ["" + GSON.toJson(this) + ""]"";
	}

	@Override
	public String toJsonString() {
		return GSON.toJson(this);
	}

	@Override
	public void timestamp() {
		sendtimestamp = System.currentTimeMillis();
	}

	@Override
	public String getUAVId() {
		return uavid;
	}

}
"
FlightZoneException.java,"package edu.nd.dronology.core.exceptions;

/**
 * Supports customized flight zone exceptions
 * 
 * @author Jane Cleland-Huang
 * @version 0.1
 *
 */
public class FlightZoneException extends Throwable {
	/**
	* 
	*/
	private static final long serialVersionUID = 8522577350228262490L;

	public FlightZoneException(String msg) {
		super(msg);
	}

	public FlightZoneException(Throwable t) {
		super(t);
	}
}
"
IMissionPlanningServiceInstance.java,"package edu.nd.dronology.services.extensions.missionplanning.service.internal;

import edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;
import edu.nd.dronology.services.core.info.MissionInfo;
import edu.nd.dronology.services.core.info.UAVMappingInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public interface IMissionPlanningServiceInstance extends IFileTransmitServiceInstance<MissionInfo> {

	void executeMissionPlan(String mission) throws DronologyServiceException;

	void cancelMission() throws DronologyServiceException;

	void removeUAV(String uavid) throws DronologyServiceException;

	void executeMissionPlan(MissionInfo info) throws DronologyServiceException;

	void executeMissionPlan(MissionInfo mission, UAVMappingInfo mapping) throws DronologyServiceException;

}
"
DummyLockObject.java,"package edu.nd.dronology.core.util;

/**
 * Use as dummy object handy for ""synchronized(dummy)"" blocks.
 * 
 * @author Michael Vierhauser
 * 
 */
public class DummyLockObject {

}
"
ManagedDroneMessenger.java,"package edu.nd.dronology.core.vehicle.manageddroneinternal;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;
import edu.nd.dronology.core.collisionavoidance.DroneSnapshotOption;
import edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.flight.IFlightDirector;
import edu.nd.dronology.core.goal.AbstractGoal;
import edu.nd.dronology.core.vehicle.manageddroneinternal.message.*;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.SynchronousQueue;

public class ManagedDroneMessenger {

    private static final ILogger LOGGER = LoggerProvider.getLogger(ManagedDroneMessenger.class);
    private final ArrayBlockingQueue<AbstractMessage> mailbox;

    public ManagedDroneMessenger(ArrayBlockingQueue<AbstractMessage> mailbox) {
        this.mailbox = mailbox;
    }

    private void offerMessage(AbstractMessage msg) {
        if(!mailbox.offer(msg)) {
            LOGGER.warn(""Could not add message to mailbox "" + msg);
        }
    }

    private <T> T returnService(AbstractMessage msg, SynchronousQueue<T> returnBox) {
        try {
            mailbox.put(msg);
            return returnBox.take();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        throw new RuntimeException();
    }

    /**
     * <p>
     *  Gets the current position of the drone.
     * </p>
     *
     * <p>
     *     Note this sends a message and blocks while it waits to receive a return message from the managed drone with
     *     the coordinates. The time it takes for this method to run is indeterminate.
     * </p>
     * @return
     */
    public LlaCoordinate getCoordinates() {
        GetCoordinatesMessage msg = new GetCoordinatesMessage();
        return returnService(msg, msg.returnBox);
    }

    /**
     * Assigns a flight directive to the managed drone
     *
     * @param flightDirective
     */
    public void assignFlight(IFlightDirector flightDirective) {
        AssignFlightMessage msg = new AssignFlightMessage(flightDirective);
        offerMessage(msg);
    }

    /**
     * Removes an assigned flight
     */
    public void unassignFlight() {
        UnassignFlightMessage msg = new UnassignFlightMessage();
        offerMessage(msg);
    }

    /**
     * Tell the drone to fly home
     */
    public void returnHome() {
        ReturnHomeMessage msg = new ReturnHomeMessage();
        offerMessage(msg);
    }

    /**
     *
     * @param targetAltitude
     *          Sets target altitude for takeoff
     */
    public void setTargetAltitude(double targetAltitude) {
        SetTargetAltitudeMessage msg = new SetTargetAltitudeMessage(targetAltitude);
        offerMessage(msg);
    }

    /**
     * Tell the drone to takeoff
     */
    public void takeOff() {
        TakeOffMessage msg = new TakeOffMessage();
        offerMessage(msg);
    }

//    /**
//     *
//     * Get the drone's unique ID.
//     *  <p>
//     *     Note this sends a message and blocks while it waits to receive a return message from the managed drone with
//     *     the return value. The time it takes for this method to run is indeterminate.
//     * </p>
//     * @return unique drone ID
//     */
//    public String getDroneName() {
//        GetNameMessage msg = new GetNameMessage();
//        return returnService(msg, msg.returnBox);
//    }

    /**
     * Tell the drone to land. The drone will touch down on the ground.
     *
     */
    public void land() {
        LandMessage msg = new LandMessage();
        offerMessage(msg);
    }

    /**
     * Get the drone's base coordinates (its home location).
     *  <p>
     *     Note this sends a message and blocks while it waits to receive a return message from the managed drone with
     *     the return value. The time it takes for this method to run is indeterminate.
     * </p>
     * @return the managed drone's base coordinates
     */
    public LlaCoordinate getBaseCoordinates() {
        GetCoordinatesMessage msg = new GetCoordinatesMessage();
        return returnService(msg, msg.returnBox);
    }

    /**
     * Update the ManagedDrones list of commands.
     * @param commands The commands this drone should carry out
     */
    public void updateGuidance(List<Command> commands) {
        UpdateGuidanceMessage msg = new UpdateGuidanceMessage(commands);
        offerMessage(msg);
    }

    public void getSnapshot(ArrayBlockingQueue<DroneSnapshotOption> returnQueue) {
        GetSnapshotMessage msg = new GetSnapshotMessage(returnQueue);
        offerMessage(msg);
    }

    public void updateGoal(AbstractGoal goal) {
        GoalUpdateMessage msg = new GoalUpdateMessage(goal);
        offerMessage(msg);
    }
}
"
MissionPlanningServiceInstance.java,"package edu.nd.dronology.services.extensions.missionplanning.service.internal;

import java.io.File;
import java.net.MalformedURLException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;

import edu.nd.dronology.core.status.DronologyListenerManager;
import edu.nd.dronology.services.core.api.IFileChangeNotifyable;
import edu.nd.dronology.services.core.base.AbstractFileTransmitServiceInstance;
import edu.nd.dronology.services.core.info.MissionInfo;
import edu.nd.dronology.services.core.info.UAVMappingInfo;
import edu.nd.dronology.services.core.items.IMissionPlan;
import edu.nd.dronology.services.core.persistence.MissionPlanningPersistenceProvider;
import edu.nd.dronology.services.core.persistence.PersistenceException;
import edu.nd.dronology.services.core.util.DronologyConstants;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.services.core.util.ServiceIds;
import edu.nd.dronology.services.extensions.missionplanning.MissionExecutionException;
import edu.nd.dronology.services.extensions.missionplanning.plan.MissionController;
import edu.nd.dronology.services.extensions.missionplanning.sync.SynchronizationManager;
import edu.nd.dronology.services.instances.DronologyElementFactory;
import edu.nd.dronology.services.supervisor.SupervisorService;
import edu.nd.dronology.util.FileUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

public class MissionPlanningServiceInstance extends AbstractFileTransmitServiceInstance<MissionInfo>
		implements IFileChangeNotifyable, IMissionPlanningServiceInstance {

	private static final ILogger LOGGER = LoggerProvider.getLogger(MissionPlanningServiceInstance.class);

	public static final String EXTENSION = DronologyConstants.EXTENSION_MISSION;

	private DronologySeriviceListener listener;

	public MissionPlanningServiceInstance() {
		super(ServiceIds.SERVICE_MISSIONPLANNING, ""Mission Planning"", EXTENSION);
	}

	@Override
	protected Class<?> getServiceClass() {
		return MissionPlanningService.class;
	}

	@Override
	protected int getOrder() {
		// TODO Auto-generated method stub
		return 2;
	}

	@Override
	protected String getPropertyPath() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	protected void doStartService() throws Exception {
		reloadItems();
		registerListener();
	}

	private void registerListener() {
		listener = new DronologySeriviceListener();
		DronologyListenerManager.getInstance().addListener(listener);
		
	}

	@Override
	protected void doStopService() throws Exception {
		unregisterListener();

	}

	private void unregisterListener() {
		DronologyListenerManager.getInstance().removeListener(listener);
		
	}

	@Override
	public void executeMissionPlan(String mission) throws DronologyServiceException {
		try {
			MissionController.getInstance().executeMission(mission);
		} catch (MissionExecutionException e) {
			LOGGER.error(e);
			new DronologyServiceException(e.getMessage());
		}

	}

	@Override
	public void cancelMission() throws DronologyServiceException {
		try {
			MissionController.getInstance().cancelMission();
		} catch (MissionExecutionException e) {
			LOGGER.error(e);
			new DronologyServiceException(e.getMessage());
		}

	}

	@Override
	public void removeUAV(String uavid) throws DronologyServiceException {
		SynchronizationManager.getInstance().removeUAV(uavid);

	}

	@Override
	public MissionInfo createItem() throws DronologyServiceException {
		MissionPlanningPersistenceProvider persistor = MissionPlanningPersistenceProvider.getInstance();
		IMissionPlan missionPlan = MissionElementFactory.createNewMissionPlan();
		missionPlan.setName(""New-MissionPlan"");
		String savePath = FileUtil.concat(storagePath, missionPlan.getId(), EXTENSION);

		try {
			persistor.saveItem(missionPlan, savePath);
		} catch (PersistenceException e) {
			throw new DronologyServiceException(""Error when creating mission plan: "" + e.getMessage());
		}
		return new MissionInfo(missionPlan.getName(), missionPlan.getId());
	}

	@Override
	protected String getPath() {
		String path = SupervisorService.getInstance().getMissionPlanningLocation();
		return path;
	}

	@Override
	protected MissionInfo fromFile(String id, File file) throws Throwable {
		IMissionPlan atm = MissionPlanningPersistenceProvider.getInstance().loadItem(file.toURI().toURL());
		MissionInfo info = new MissionInfo(atm.getName(), id);

		BasicFileAttributes attr = Files.readAttributes(Paths.get(file.toURI()), BasicFileAttributes.class);
		info.setDateCreated(attr.creationTime().toMillis());
		info.setDateModified(attr.lastModifiedTime().toMillis());
		info.setDescription(atm.getDescription());
		return info;
	}

	@Override
	public void executeMissionPlan(MissionInfo info) throws DronologyServiceException {
		executeMissionPlan(info, new UAVMappingInfo());
	}

	@Override
	public void executeMissionPlan(MissionInfo info, UAVMappingInfo mapping) throws DronologyServiceException {
		try {
			File file = fileManager.getFile(info.getId());
			IMissionPlan mission = MissionPlanningPersistenceProvider.getInstance().loadItem(file.toURI().toURL());

			MissionController.getInstance().executeMission(mission,mapping);
		} catch (MissionExecutionException | MalformedURLException | PersistenceException e) {
			LOGGER.error(e);
			new DronologyServiceException(e.getMessage());
		}

	}

}
"
IAreaMapping.java,"package edu.nd.dronology.services.core.items;

import java.util.List;
import edu.nd.dronology.services.core.areamapping.EdgeLla;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public interface IAreaMapping extends IPersistableItem {

	String getDescription();

	void setDescription(String description);

	List<EdgeLla> getMappedPoints(Integer part);

	void addMappedArea(Integer part, List<EdgeLla> coordinates);

	void addMappedArea(Integer part, EdgeLla coordinate);

	void removeCoordinate(int part, EdgeLla coordinate);

	void addMappedLocation(IMappedItem item);
	
	List<IMappedItem> getLocationMappings();

	void removeMappedLocation(String id) throws DronologyServiceException;
	
	void setUpstream(Boolean upstream);
	
	Boolean getUpstream();
}
"
DronePair.java,"package edu.nd.dronology.core.collisionavoidance;

import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;

public class DronePair {
    public final DroneSnapshot a;
    public final DroneSnapshot b;

    public DronePair(DroneSnapshot a, DroneSnapshot b) {
        this.a = a;
        this.b = b;
    }

    public double findDistance() {
        return a.getPosition().distance(b.getPosition());
    }
}"
DroneMonitoringServiceRemoteFacade.java,"package edu.nd.dronology.monitoring.service;

import java.rmi.RemoteException;

import edu.nd.dronology.core.monitoring.ArtifactIdentifier;
import edu.nd.dronology.monitoring.IRemoteMonitoringMessageHandler;
import edu.nd.dronology.services.remote.AbstractRemoteFacade;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * 
 * Remote facade for monitoring UAVs<br>
 * Allows registering {@link IRemoteMonitoringMessageHandler} to subscribe to certain message types or topics<br>
 * 
 * 
 * @author Michael Vierhauser
 *
 */

public class DroneMonitoringServiceRemoteFacade extends AbstractRemoteFacade implements IDroneMonitoringRemoteService {
	/**
	 * 
	 */
	private static final long serialVersionUID = -4580658378477037955L;
	private static final ILogger LOGGER = LoggerProvider.getLogger(DroneMonitoringServiceRemoteFacade.class);
	private static volatile DroneMonitoringServiceRemoteFacade INSTANCE;

	protected DroneMonitoringServiceRemoteFacade() throws RemoteException {
		super(DroneMonitoringService.getInstance());
	}

	public static IDroneMonitoringRemoteService getInstance() throws RemoteException {
		if (INSTANCE == null) {
			synchronized (DroneMonitoringServiceRemoteFacade.class) {
				try {
					if (INSTANCE == null) {
						INSTANCE = new DroneMonitoringServiceRemoteFacade();
					}
				} catch (RemoteException e) {
					LOGGER.error(e);
				}
			}
		}
		return INSTANCE;

	}

	@Override
	public void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler) throws RemoteException {
		DroneMonitoringService.getInstance().registerMonitoringMessageHandler(handler);

	}

	@Override
	public void registerMonitoringMessageHandler(IRemoteMonitoringMessageHandler handler, ArtifactIdentifier identifier)
			throws RemoteException {
		DroneMonitoringService.getInstance().registerMonitoringMessageHandler(handler, identifier);

	}

	@Override
	public void setMonitoringFrequency(String uavid, Double frequency) throws RemoteException {
		DroneMonitoringService.getInstance().setMonitoringFrequency(uavid, frequency);

	}

}"
AFDragLayout.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import com.vaadin.event.Transferable;
import com.vaadin.event.dd.DragAndDropEvent;
import com.vaadin.event.dd.DropHandler;
import com.vaadin.event.dd.DropTarget;
import com.vaadin.event.dd.TargetDetails;
import com.vaadin.event.dd.acceptcriteria.AcceptCriterion;
import com.vaadin.event.dd.acceptcriteria.Not;
import com.vaadin.event.dd.acceptcriteria.SourceIsTarget;
import com.vaadin.shared.ui.dd.HorizontalDropLocation;
import com.vaadin.ui.AbstractOrderedLayout;
import com.vaadin.ui.Component;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.DragAndDropWrapper;
import com.vaadin.ui.VerticalLayout;

import edu.nd.dronology.services.core.info.FlightInfo;
import edu.nd.dronology.services.core.info.FlightPlanInfo;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;
import edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;
import edu.nd.dronology.ui.vaadin.flightroutes.FRInfoBox;
import edu.nd.dronology.ui.vaadin.start.MyUI;

/**
 * This is the drag and drop vertical layout in which the FRInfoBoxes are stored 
 * in the assign routes UI.  
 * 
 * @author Patrick Falvey 
 *
 */

public class AFDragLayout extends VerticalLayout {

	/**
	* 
	*/
	private static final long serialVersionUID = -978484208144577037L;
	private SortableLayout layout = new SortableLayout();
	private IFlightManagerRemoteService flightRouteService;
	private IFlightRouteplanningRemoteService flightInfoService;
	private BaseServiceProvider provider = MyUI.getProvider();
	private String UAVid;
	private int boxID = 88888; //arbitrary value so the component ID does not overlap boxIDs from AFAssignRouteComponent

	public AFDragLayout(String UAVid) {	
		this.UAVid = UAVid;
		layout.setSizeUndefined();
		for (Component component : createComponents()) {
			layout.addNewComponent(component);
		}

		addComponent(layout);
	}

	/**
	 * 
	 * @return list of pending plans for the UAV
	 */
	private List<Component> createComponents() {
		FlightInfo flightRouteInfo = null;
		Collection<FlightRouteInfo> items = null;
		try {
			flightRouteService = (IFlightManagerRemoteService) provider.getRemoteManager()
					.getService(IFlightManagerRemoteService.class);
			flightInfoService = (IFlightRouteplanningRemoteService) provider.getRemoteManager()
					.getService(IFlightRouteplanningRemoteService.class);
			flightRouteInfo = flightRouteService.getFlightInfo(UAVid);
			items = flightInfoService.getItems();
		} catch (RemoteException | DronologyServiceException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		List<Component> components = new ArrayList<>();
		
		for (FlightPlanInfo flight : flightRouteInfo.getPendingFlights()){ //convert plans into the FRInfoBoxes
			for (FlightRouteInfo info : items){
				String flightName = flight.getName().length() < info.getName().length() ? flight.getName() : 
					flight.getName().substring(flight.getName().length() - info.getName().length());
				if(flightName.equals(info.getName())){
					FRInfoBox box = new FRInfoBox(info);
					box.setId(Integer.toString(this.boxID));
					this.boxID++;
					components.add(box);
				}
			}
		}
		return components;
	}
	
	public SortableLayout getSortableLayout(){
		return this.layout;
	}
	
	public void addNewComponent(Component component){
		layout.addNewComponent(component);
	}
	
	@Override
	public void removeComponent(Component component){
		layout.removeComponent(component);
	}
	
	@Override
	public Component getComponent(int index){
		return layout.getComponent(index);
	}
	
	@Override
	public int getComponentCount(){
		return layout.getComponentCount();
	}
	
	@Override
	public int getComponentIndex(Component component){
		return layout.getComponentIndex(component);
	}
	public static class SortableLayout extends CustomComponent {
		/**
		* 
		*/
		private static final long serialVersionUID = 2763521051649448355L;
		private final AbstractOrderedLayout layout;
		private final DropHandler dropHandler;

		public SortableLayout() {
			layout = new VerticalLayout();
			dropHandler = new ReorderLayoutDropHandler(layout);

			DragAndDropWrapper pane = new DragAndDropWrapper(layout);
			setCompositionRoot(pane);
		}
		
		public VerticalLayout getVerticalLayout(){
			return (VerticalLayout) layout;
		}
		
		@Override
		public int getComponentCount(){
			return layout.getComponentCount();
		}
		
		public int getComponentIndex(Component component) {
			@SuppressWarnings(""deprecation"")
			Iterator<Component> componentIterator = layout.getComponentIterator();
			WrappedComponent next = null;
			int index = 0;
			while (componentIterator.hasNext()) { //important to compare with route name and component ID because some routes have the same name
				next = (WrappedComponent) componentIterator.next();
				if (((FRInfoBox) next.getContent()).getName().equals(((FRInfoBox) component).getName()) && component.getId().equals(next.getContent().getId())){
					return index;
				}
				else {
					index++;
				}
			}
			return -1;
		}

		public Component getComponent(int index) {
			WrappedComponent wrapper = (WrappedComponent) layout.getComponent(index);
			return wrapper.getContent();
		}
		
		public void addNewComponent(Component component) {
			WrappedComponent wrapper = new WrappedComponent(component, dropHandler);
			wrapper.setSizeUndefined();
			component.setWidth(""100%"");
			wrapper.setWidth(""100%"");
			layout.addComponent(wrapper);
		}
		
		public void removeComponent(Component component) {
			@SuppressWarnings(""deprecation"")
			Iterator<Component> componentIterator = layout.getComponentIterator();
			WrappedComponent next = null;
			boolean cont = true;
			while (cont && componentIterator.hasNext()) {
				next = (WrappedComponent) componentIterator.next();
				if (((FRInfoBox) next.getContent()).getName().equals(((FRInfoBox) component).getName()) && component.getId().equals(next.getContent().getId())){
					layout.removeComponent(next);
					cont = false;
				}
			}
		}
	}

	public static class WrappedComponent extends DragAndDropWrapper {

		/**
		* 
		*/
		private static final long serialVersionUID = -6051699334166210253L;
		private final DropHandler dropHandler;
		private Component content;

		public WrappedComponent(Component content, DropHandler dropHandler) {
			super(content);
			this.content = content;
			this.dropHandler = dropHandler;
			setDragStartMode(DragStartMode.WRAPPER);
		}

		@Override
		public DropHandler getDropHandler() {
			return dropHandler;
		}
		
		public Component getContent(){
			return this.content;
		}

	}

	private static class ReorderLayoutDropHandler implements DropHandler {

		/**
		* 
		*/
		private static final long serialVersionUID = 8500739235515201928L;
		private AbstractOrderedLayout layout;

		public ReorderLayoutDropHandler(AbstractOrderedLayout layout) {
			this.layout = layout;
		}

		@Override
		public AcceptCriterion getAcceptCriterion() {
			return new Not(SourceIsTarget.get());
		}

		@Override
		public void drop(DragAndDropEvent dropEvent) {  //logic to determine the position of the drag and dropped object
			Transferable transferable = dropEvent.getTransferable();
			Component sourceComponent = transferable.getSourceComponent();
			if (sourceComponent instanceof WrappedComponent) {
				TargetDetails dropTargetData = dropEvent.getTargetDetails();
				DropTarget target = dropTargetData.getTarget();

				boolean sourceWasAfterTarget = true;
				int index = 0;
				@SuppressWarnings(""deprecation"")
				Iterator<Component> componentIterator = layout.getComponentIterator();
				Component next = null;
				while (next != target && componentIterator.hasNext()) {
					next = componentIterator.next();
					if (next != sourceComponent) {
						index++;
					} else {
						sourceWasAfterTarget = false;
					}
				}
				if (next == null || next != target) {
					return;
				}

				if (dropTargetData.getData(""horizontalLocation"").equals(HorizontalDropLocation.CENTER.toString())) {
					if (sourceWasAfterTarget) {
						index--;
					}
				}

				else if (dropTargetData.getData(""horizontalLocation"").equals(HorizontalDropLocation.LEFT.toString())) {
					index--;
					if (index < 0) {
						index = 0;
					}
				}

				layout.removeComponent(sourceComponent);
				layout.addComponent(sourceComponent, index);
			}
		}
	}

}"
DroneException.java,"package edu.nd.dronology.core.exceptions;

/**
 * @author Michael
 *
 */
public class DroneException extends Exception {
	/**
	 * 
	 */
	private static final long serialVersionUID = -6599291683788888263L;

	/**
	* 
	*/

	public DroneException(String msg) {
		super(msg);
	}
}
"
SimulatorScenarioCategoryInfo.java,"package edu.nd.dronology.services.core.info;

public class SimulatorScenarioCategoryInfo extends RemoteInfoObject {

	/**
	 * 
	 */
	private static final long serialVersionUID = -7327376857430499641L;

	public SimulatorScenarioCategoryInfo(String name, String id) {
		super(name, id);
	}

}
"
AbstractRegisterableUnit.java,"package edu.nd.dronology.services.core.base;

import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

import edu.nd.dronology.services.core.info.UAVRegistrationInfo;
import edu.nd.dronology.services.core.util.UnitState;

/**
 * Abstract class for registerable units that register at the server.<br>
 * 
 * @author Michael Vierhauser
 * 
 */

public abstract class AbstractRegisterableUnit implements Serializable {

	private static final long serialVersionUID = 2983958174901066192L;
	/** The timestamp when the unit was created **/
	public static final String TIMESTAMP = ""timestamp"";
	/** The IP address of the sender **/
	public static String IP_ADDRESS = ""ipaddress"";
	/** The designated command port of the unit **/
	public static final String COMMAND_PORT = ""commandport"";
	/** Unregister flag **/
	public static final String UNREGISTER = ""unregister"";
	/** The current state of the unit **/
	public static String STATE = ""state"";
	protected final String ID;
	

	
	public static final  String HAS_REMOTEOBJECT = ""hasRemoteObject"";
	public static final String IS_MANAGED = ""isManaged"";
	
	protected final String hostname;
	private Map<String, String> attributes = new HashMap<>();

	protected AbstractRegisterableUnit(String ID, String hostname) {
		super();
		this.ID = ID;
		this.hostname = hostname;
		addAttribute(STATE, UnitState.UNKNOWN.name());
	}

	/**
	 * 
	 * @return The id of the unit.
	 */
	public String getID() {
		return ID;
	}

	/**
	 * 
	 * @return The hostname of the unit.
	 */
	public String getHost() {
		return hostname;
	}

	/**
	 * 
	 * @return A map of key-values of attributes.
	 */
	public Map<String, String> getAttributes() {
		return Collections.unmodifiableMap(attributes);
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = (prime * result) + ID.hashCode();
		return result;
	}

	@Override
	public boolean equals(Object thatObject) {
		if (this == thatObject) {
			return true;
		}
		if (thatObject == null) {
			return false;
		}
		if (getClass() != thatObject.getClass()) {
			return false;
		}
		AbstractRegisterableUnit other = (AbstractRegisterableUnit) thatObject;
		if (!other.ID.equals(this.ID)) {
			return false;
		}
		return true;
	}

	/**
	 * Adds a new attribute to the unit.
	 * 
	 * @param key
	 * @param value
	 */
	public void addAttribute(String key, String value) {
		attributes.put(key, value);
	}

	/**
	 * 
	 * @param key
	 * @return The attribute associated with the key.<br>
	 *         Retunrs {@code null} if no attribute exists for the give key.
	 */
	public String getAttribute(String key) {
		if (attributes.containsKey(key)) {
			return attributes.get(key);
		}
		return null;
	}
/**
 * 
 * @return The type of the unit as human readable string representation.
 */
	public abstract String getUnitType();

}
"
UAVAcknowledgeMessage.java,"package edu.nd.dronology.gstation.connector.messages;

import java.io.Serializable;

public class UAVAcknowledgeMessage extends AbstractUAVMessage<Object> implements Serializable {

	private static final long serialVersionUID = 1502042637906425729L;
	public static final String MESSAGE_TYPE = ""ack"";

	public UAVAcknowledgeMessage(String messagetype, String groundstationid, String uavid) {
		super(MESSAGE_TYPE, groundstationid, uavid);
	}

}
"
AbstractFlightPattern.java,"package edu.nd.dronology.services.extensions.missionplanning.patterns;

import edu.nd.dronology.services.extensions.missionplanning.sync.SynchronizationManager;
import edu.nd.dronology.services.extensions.missionplanning.tasks.IMissionTask;

/**
 * Base class for all predefined flight patterns that can be exanded
 * 
 * @author Michael Vierhauser
 *
 */
public abstract class AbstractFlightPattern implements IFlightPattern {

	protected SynchronizationManager synchPointMgr;
	private TaskList taskList = new TaskList();

	@Override
	public void initialize(SynchronizationManager synchPointMgr) {
		this.synchPointMgr = synchPointMgr;
		doCreateSyncPoints();
	}

	protected abstract void doCreateSyncPoints();

	protected void addSyncPoint(String pointname) {
		synchPointMgr.createSynchronizationPoint(pointname);

	}

	protected void addTask(IMissionTask task) {
		taskList.addTask(task);

	}

	@Override
	public TaskList getTaskList() {
		return taskList;
	}

}
"
RiverBank.java,"package edu.nd.dronology.services.extensions.areamapping.internal;

import java.awt.geom.Point2D;
import java.util.Collections;
import java.util.List;
import java.util.Vector;


public class RiverBank {
	private List<Point2D.Double> riverBank;
	
	public RiverBank() {
		riverBank = new Vector<Point2D.Double>();
	}
	
	public void add(Point2D.Double bankNode) {
		riverBank.add(bankNode);
	}
	
	public void add(int entry, Point2D.Double bankNode) {
		riverBank.add(entry,bankNode);
	}
	
	public void reverse() {
		Collections.reverse(riverBank);
	}
	
	public List<Point2D.Double> get(){
		return Collections.unmodifiableList(riverBank);
	}
	
	public Point2D.Double get(int entry){
		return riverBank.get(entry);
	}
	
	public int size() {
		return riverBank.size();
	}
}
"
ConnectionRequestMessage.java,"package edu.nd.dronology.gstation.connector.messages;

import java.io.Serializable;
/**
 * When a new GCS connects to Dronology it sends a {@link ConnectionRequestMessage}.
 * 
 * @author Michael Vierhauser
 *
 */
public class ConnectionRequestMessage extends AbstractUAVMessage<Object> implements Serializable {

	private static final long serialVersionUID = 1502042637906425729L;
	public static final String MESSAGE_TYPE = ""connect"";

	public ConnectionRequestMessage(String groundstationId) {
		super(MESSAGE_TYPE, groundstationId, groundstationId);
	}

	@Override 
	public void setType(String type) {
		this.type = type;

	}

}
"
UAVModeChangeMessage.java,"package edu.nd.dronology.gstation.connector.messages;

import java.io.Serializable;

/**
 * Monitoring message received from the GCS for a specific UAV.
 * 
 * @author Michael Vierhauser
 *
 */
public class UAVModeChangeMessage extends AbstractUAVMessage<Object> implements Serializable {

	private static final long serialVersionUID = 1502042637906425729L;
	public static final String MESSAGE_TYPE = ""modechange"";
	public static final String DATA = ""data"";
	public static final transient String MODE = ""mode"";
	public static final transient String GS_ID = ""groundstationid"";
	public static final transient String UAV_ID = ""uavid"";

	public UAVModeChangeMessage(String groundstationid, String uavid, String mode) {
		super(MESSAGE_TYPE, groundstationid, uavid);
		data.put(MODE, mode);
	}

	@Override
	public void setType(String type) {
		this.type = type;

	}

	public String getMode() {
		return data.get(MODE).toString();
	}

}
"
DroneType.java,"package edu.nd.dronology.core.fleet;

public enum DroneType {LEAD_DRONE, PLATOON_FOLLOWER}
"
ArtifactIdentifier.java,"package edu.nd.dronology.core.monitoring;

import java.io.Serializable;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

import edu.nd.dronology.util.NullUtil;

/**
 * A structured Identifier. Each object holds an id part and refers to child IDs
 * which in turn<br/> 
 * hold again one id part, etc, which altogether form the whole identifier.
 * <p/>
 * 
 * @author Michael Vierhauser
 * 
 */
public class ArtifactIdentifier<TYPE> implements Serializable {

	private static final long serialVersionUID = 9173775383058285758L;
	private static final String SEPARATOR = ""::"";
	public static final String ROOT = ""DRONOLOGY"";

	// Never null
	private final String id;
	// May be null, when this is the last part of an identifier.
	public static AtomicInteger COUNTER = new AtomicInteger(0);
 
	private final ArtifactIdentifier child;
	private Set<TYPE> attacheditems = new HashSet<>();

	/**
	 * 
	 * @param ids
	 *            The ids that will be mapped to root and child ArtifactIdentifier
	 */
	public ArtifactIdentifier(String... ids) {
		if (ids.length < 1) {
			throw new IllegalArgumentException(""At least 1 id is required"");
		}
		COUNTER.addAndGet(1);
		this.id = ids[0];
		NullUtil.checkNull(id);
		if (ids.length > 1) {
			child = new ArtifactIdentifier(Arrays.copyOfRange(ids, 1, ids.length));
		} else {
			child = null;
		}
	}

	/**
	 * 
	 * @return The id of the parent ArtifactIdentifier
	 */
	public synchronized String getId() {
		return id;
	}

	/**
	 * 
	 * @return The child ArtifactIdentifier
	 */
	public synchronized ArtifactIdentifier getChild() {
		return child;
	}

	/**
	 * Returns all artifact identifier concatenated (separated by ::)
	 */
	@Override
	public synchronized String toString() {
		if (child == null) {
			return id;
		}
		return String.format(""%s"" + SEPARATOR + ""%s"", id, child.toString());
	}

	@Override
	public synchronized int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((child == null) ? 0 : child.hashCode());
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		return result;
	}

	@Override
	public synchronized boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		ArtifactIdentifier other = (ArtifactIdentifier) obj;
		if (child == null) {
			if (other.child != null) {
				return false;
			}
		} else if (!child.equals(other.child)) {
			return false;
		}
		if (id == null) {
			if (other.id != null) {
				return false;
			}
		} else if (!id.equals(other.id)) {
			return false;
		}
		return true;
	}

	@Override
	protected void finalize() throws Throwable {
		try {
			COUNTER.addAndGet(-1);
		} finally {
			super.finalize();
		}
	}

	public Collection<TYPE> getAttachedItems() {
		return Collections.unmodifiableCollection(attacheditems);
	}

	public void attachItem(TYPE item) {
		attacheditems.add(item);

	}

	public void removeAttachedItem(TYPE handler) {
		attacheditems.remove(handler);

	}

	public void attachItems(Collection<TYPE> toAdd) {
		attacheditems.addAll(toAdd);

	}
}
"
PrioritySide.java,"package edu.nd.dronology.services.core.items;

public class PrioritySide extends MappedItem {

	/**
	 * 
	 */
	private static final long serialVersionUID = -3286441007471288294L;

	public PrioritySide(String id) {
		super(id);
	}

}
"
IRegionOfInterest.java,"package edu.nd.dronology.services.core.areamapping;

import java.util.List;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

public interface IRegionOfInterest {

	String getName();

	String getDescription();

	double getWeight();

	List<LlaCoordinate> getArea();
	
	String getAreaAttribute(String attributeName);

}"
TagList.java,"package edu.nd.dronology.services.core.items;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

public class TagList implements Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 3805379647109731039L;
	private List<String> tags = new ArrayList<>();

	public void add(String tag) {
		tags .add(tag);

	}

}
"
AreaMappingInfo.java,"
package edu.nd.dronology.services.core.info;

import java.util.LinkedList;
import java.util.Vector;

import edu.nd.dronology.services.core.areamapping.EdgeLla;

public class AreaMappingInfo extends RemoteInfoObject {

	/**
	 * 
	 */
	private static final long serialVersionUID = -8659534015844582331L;
	private Vector<LinkedList<EdgeLla>> coordinates = new Vector<>();
	private long dateCreated;
	private long dateModified;
	private double length;
	private String description;
	
	public AreaMappingInfo(String name, String id) {
		super(name, id);
		coordinates.add(0, new LinkedList<>());
		coordinates.add(1, new LinkedList<>());
	}
	
	public double getMappingLength() {
		return length;
	}
	
	public void addCoordinate(int part, EdgeLla coordinate) {
		coordinates.get(part).add(coordinate);
	}
	
	public void removeCoordinate(int part, EdgeLla coordinate) {
		coordinates.get(part).remove(coordinate);
	}
	
	public LinkedList<EdgeLla> getCoordinates(int part) {
		return coordinates.get(part);
	}

	public void setDateModified(long dateModified) {
		this.dateModified = dateModified;
	}

	public void setDateCreated(long dateCreated) {
		this.dateCreated = dateCreated;
	}

	public long getDateCreated() {
		return dateCreated;
	}

	public long getDateModified() {
		return dateModified;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

}
"
ArtifactIdentifierTree.java,"package edu.nd.dronology.monitoring.tree;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Set;

import edu.nd.dronology.core.monitoring.ArtifactIdentifier;
import edu.nd.dronology.util.NullUtil;

/**
 * Based on the structure of {@link ArtifactIdentifier} builds up a tree of the ""id parts"".
 * 
 * @author Michael Vierhauser
 * 
 */

public class ArtifactIdentifierTree {

	private final TreeNode root;

	public ArtifactIdentifierTree(final ArtifactIdentifier root) {
		if (root == null) {
			throw new IllegalArgumentException(""Parameter root can't be null!"");
		}
		this.root = new TreeNode(root);
	}

	public void clear() {
		root.clear();
	}

	/**
	 * Will add id to the tree by creating appropriate child elements, enabling {@link #getAllRelatedIdentifier(ArtifactIdentifier)}.
	 * 
	 * @param id
	 */
	public void add(final ArtifactIdentifier id) {
		NullUtil.checkNull(id);
		add(root, id, id);
	}

	/**
	 * Will step-wise create child elements based on the part-ids of ""current"".
	 * 
	 * @param parent
	 *          Node has to exist already.
	 * @param source
	 *          The original full identifier.
	 * @param current
	 *          The currently remaining id parts to be mapped into the tree.
	 * @return The next-step child node to the id.
	 */
	private TreeNode add(TreeNode parent, ArtifactIdentifier source, ArtifactIdentifier current) {
		NullUtil.checkNull(parent, current);
		// Construct an ident only from the first id part.
		ArtifactIdentifier art = new ArtifactIdentifier(current.getId());
		// Get an existing or create a new child node for this identifier.
		TreeNode child = parent.getChild(art);
		if (current.getChild() != null) {
			// If the id has more child parts.
			return add(child, source, current.getChild());
		}
		child.addElement(source);
		return child;
	}

	/**
	 * 
	 * @param id
	 * @return All {@link ArtifactIdentifier} currently in the tree and children of the given id.
	 */
	public Set<ArtifactIdentifier> getAllRelatedIdentifier(ArtifactIdentifier id) {
		NullUtil.checkNull(id);
		add(id);
		TreeNode matching = findMatchingNode(root.getChildren().get(new ArtifactIdentifier(id.getId())), id);
		return getChildren(matching);
	}

	/**
	 * 
	 * @param id
	 * @return All {@link ArtifactIdentifier} currently in the tree and children of the given id.
	 */
	public Set<ArtifactIdentifier> getParents(ArtifactIdentifier id) {
		NullUtil.checkNull(id);
		add(id);
		TreeNode matching = findMatchingNode(root.getChildren().get(new ArtifactIdentifier(id.getId())), id);
		return getParent(matching);
	}

	private Set<ArtifactIdentifier> getParent(TreeNode matching) {
		Set<ArtifactIdentifier> matches = new HashSet<>();
		if (matching == root) {
			return matches;
		}
		getParent(matching, matches);
		return matches;

	}

	private void getParent(TreeNode node, Set<ArtifactIdentifier> matches) {
		if (node == root) {
			return;
		}
		matches.addAll(node.getElements());
		getParent(node.getParent(), matches);
	}

	/**
	 * 
	 * @param matching
	 * @return Unmodifiable set-copy of all identifiers of all {@link TreeNode#getElements()} of all child treenodes of matching.
	 */
	private Set<ArtifactIdentifier> getChildren(TreeNode matching) {
		NullUtil.checkNull(matching);
		Set<ArtifactIdentifier> matches = new HashSet<>();
		// Add all elements from this node.
		matches.addAll(matching.getElements());
		// Recursively add all elements from child treenodes.
		for (Entry<ArtifactIdentifier, TreeNode> n : matching.getChildren().entrySet()) {
			matches.addAll(getChildren(n.getValue()));
		}
		return Collections.unmodifiableSet(matches);
	}

	/**
	 * Multi-step lookup to find a child/grandchild/etc that exactly matches the id.
	 * 
	 * @param parent
	 * @param id
	 * @return The node corresponding to the id.
	 */
	private TreeNode findMatchingNode(TreeNode parent, ArtifactIdentifier id) {
		if (id.getChild() == null) {
			return parent;
		}
		ArtifactIdentifier newArt = new ArtifactIdentifier(id.getChild().getId());
		return findMatchingNode(parent.getChildren().get(newArt), id.getChild());
	}

	@Override
	public String toString() {
		return ""ArtifactIdentifierTree [root="" + root + ""]"";
	}

	/**
	 * Log some diagnostic output.
	 */
	@SuppressWarnings(""unused"")
	private void toLog() {
		root.toLog();
	}


	public void remove(ArtifactIdentifier id) {
		TreeNode node = findMatchingNode(root, id);
		if (node != null && node.getChildren().size() == 0 && node.getParent() != null) {
			node.getParent().remove(node);
		}

	}

	public int size() {
		int size = 0;
		size += count(root.getChildren().values());
		return size;
	}

	private int count(Collection<TreeNode> values) {
		int count = 0;
		for (TreeNode n : values) {
			count += n.getChildren().size();
			count += count(n.getChildren().values());
		}
		return count;
	}
}
"
StrategyFactory.java,"package edu.nd.dronology.services.extensions.areamapping.selection;

import edu.nd.dronology.services.extensions.areamapping.selection.random.RandomRouteSelector;

public class StrategyFactory {

	public static IRouteSelectionStrategy getSelectionStrategy() {
		return new RandomRouteSelector();
	}

}
"
CoverageStatistics.java,"package edu.nd.dronology.services.extensions.areamapping.unused;
//package edu.nd.dronology.extensions.dynamicareacoverage.out;
//
//import java.nio.DoubleBuffer;
//
//public class CoverageStatistics {
//	private double coverage;
//	private double wastedEffort;
//	
//	public CoverageStatistics() {
//		coverage = 0;
//		wastedEffort = 0;
//	}
//	
//	public double getCoverage() {
//		return coverage;
//	}
//	
//	public double getWastedEffort() {
//		return wastedEffort;
//	}
//	
//	public void setCoverage(double coverageFraction) {
//		coverage = coverageFraction;
//	}
//	
//	public void setWastedEffort(double wastedEffortFraction) {
//		wastedEffort = wastedEffortFraction;
//	}
//}
"
DroneConnectorService.java,"package edu.nd.dronology.gstation.connector.service.connector;

import edu.nd.dronology.gstation.connector.GroundStationException;
import edu.nd.dronology.gstation.connector.GroundstationConnector;
import edu.nd.dronology.gstation.connector.messages.ConnectionRequestMessage;
import edu.nd.dronology.services.core.base.AbstractServerService;

public class DroneConnectorService extends AbstractServerService<IDroneConnectorServiceInstance> {

	private static volatile DroneConnectorService INSTANCE;

	protected DroneConnectorService() {
	}

	/**
	 * @return The singleton ConfigurationService instance
	 */
	public static DroneConnectorService getInstance() {
		if (INSTANCE == null) {
			synchronized (DroneConnectorService.class) {
				if (INSTANCE == null) {
					INSTANCE = new DroneConnectorService();
				}
			}
		}
		return INSTANCE;
	}

	@Override
	protected IDroneConnectorServiceInstance initServiceInstance() {
		return new DroneConnectorServiceInstance();
	}

	public void handleConnection(GroundstationConnector connector) {
		serviceInstance.handleConnection(connector);

	}

	public void registerConnection(GroundstationConnector connector, ConnectionRequestMessage msg)
			throws GroundStationException {
		serviceInstance.registerConnection(connector, msg);

	}

	public void unregisterConnection(String groundstationid) throws GroundStationException {
		serviceInstance.unregisterConnection(groundstationid); 

	}

}
"
AFMissionOperations.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import java.rmi.RemoteException;
import java.util.Map;

import com.vaadin.event.ContextClickEvent;
import com.vaadin.event.ContextClickEvent.ContextClickListener;
import com.vaadin.event.LayoutEvents.LayoutClickListener;
import com.vaadin.shared.MouseEventDetails;
import com.vaadin.ui.Button;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Label;
import com.vaadin.ui.NativeButton;
import com.vaadin.ui.UI;
import com.vaadin.ui.Upload;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.Window;

import edu.nd.dronology.services.core.info.MissionInfo;
import edu.nd.dronology.services.core.remote.IMissionPlanningRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.ui.vaadin.missionplanning.MPEditMissionHelpWindow;
import edu.nd.dronology.ui.vaadin.missionplanning.MPEditMissionWindow;
import edu.nd.dronology.ui.vaadin.missionplanning.MPInfoPanel;
import edu.nd.dronology.ui.vaadin.missionplanning.MPMapComponent;
import edu.nd.dronology.ui.vaadin.start.MyUI;

/**
 * This is the set of map operation buttons in the AFInfoPanel
 * 
 * @author Patrick Falvey
 *
 */

public class AFMissionOperations extends CustomComponent {

	private static final long serialVersionUID = -2249802562670339842L;
	private HorizontalLayout buttons = new HorizontalLayout();
	private Upload upload;
	private Button cancelMission = new Button(""Cancel Mission"");
	private Button executeMission=new Button(""Execute Mission"");
	//private AFChooseMissionWindow chooseMissionWindow;

	public AFMissionOperations(AFInfoPanel infoPanel) {
		VerticalLayout layout = new VerticalLayout();
		layout.addStyleName(""af_mission_group"");

		Label caption = new Label(""Mission Operations"");

	//	MissionHandler handler = new MissionHandler();
	//	upload = new Upload(null, handler.getReceiver());
	//	upload.setVisible(true);
	//	upload.addSucceededListener(handler.getReceiver());
	//	upload.setImmediateMode(true);
	//	upload.setButtonCaption(""Execute Mission"");
		cancelMission.addClickListener(e -> {
			cancelMisison();

		});
		executeMission.addClickListener( e ->{
			UI.getCurrent().addWindow(new AFChooseMissionWindow(infoPanel));
		});
		
	
		
	//	ContextClickListener myListener = new MyListener();
	//	upload.addContextClickListener(myListener);

		buttons.addComponents(executeMission, cancelMission);   //upload
		layout.addComponents(caption, buttons);

		setCompositionRoot(layout);
	}

	private void cancelMisison() {
		try {
			IMissionPlanningRemoteService service = (IMissionPlanningRemoteService) MyUI.getProvider()
					.getRemoteManager().getService(IMissionPlanningRemoteService.class);
			service.cancelMission();
		} catch (RemoteException | DronologyServiceException e) {
			MyUI.setConnected(false);
			e.printStackTrace();
		}

	}

	public void addOnClickListener(LayoutClickListener listener) {
		buttons.addLayoutClickListener(listener);
	}

	
//	private class MyListener implements ContextClickListener {

		/**
		 * 
		 */
	//	private static final long serialVersionUID = -1892418708777796487L;

	//	@Override
	//	public void contextClick(ContextClickEvent event) {
			// upload
	//		System.out.println(""CLICK!"");
	//		upload.submitUpload();
	//	}
	//}

}
"
IUAVTypeRegistrationServiceInstance.java,"package edu.nd.dronology.services.instances.registration.types;

import edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;
import edu.nd.dronology.services.core.info.UAVTypeRegistrationInfo;

public interface IUAVTypeRegistrationServiceInstance extends IFileTransmitServiceInstance<UAVTypeRegistrationInfo> {

	
}
"
SimpleMonitor.java,"package edu.nd.dronology.monitoring.simplechecker.monitor;

import edu.nd.dronology.core.monitoring.ArtifactIdentifier;

import edu.nd.dronology.monitoring.service.IDroneMonitoringRemoteService;
import edu.nd.dronology.monitoring.simplechecker.BaseServiceProvider;

public class SimpleMonitor {

	public static void main(String[] args) {

		MonitorDialog dialog = new MonitorDialog();
		new Thread(new Runnable() {

			@Override
			public void run() {
				dialog.main(args);
			}
		}).start();
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		BaseServiceProvider provider = new BaseServiceProvider();

		try {
			System.setProperty(""java.rmi.server.hostname"", ""localhost"");

			IDroneMonitoringRemoteService sevice = (IDroneMonitoringRemoteService) provider.getRemoteManager()
					.getService(IDroneMonitoringRemoteService.class);

			ArtifactIdentifier id = new ArtifactIdentifier(ArtifactIdentifier.ROOT, ""INTERNAL"", ""MISSION_WAYPOINT"");
			ArtifactIdentifier id2 = new ArtifactIdentifier(ArtifactIdentifier.ROOT, ""INTERNAL"", ""COLLISION"");
			RemoteMessageHandler handler = new RemoteMessageHandler(dialog);
			sevice.registerMonitoringMessageHandler(handler, id);
			sevice.registerMonitoringMessageHandler(handler, id2);
		} catch (Throwable e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
"
Geometry.java,"package edu.nd.dronology.services.extensions.areamapping.internal;




import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Vector;

import edu.nd.dronology.services.extensions.areamapping.model.RiverSubsegment;
import edu.nd.dronology.services.extensions.areamapping.model.RoutePrimitive;
import edu.nd.dronology.services.extensions.areamapping.util.Utilities;
public class Geometry {

    static final double RADIUS = 6373000.0;
    public static final double EPSILON = 0.000001;

    /**
     * This function calculates the angle between two points.
     * @param a
     * @param b
     * @return angle between two points
     */
    public static double getAngle(Point2D.Double a, Point2D.Double b) {
        double angle = 0;
        if(!(a.getX() == b.getX() || a.getY() == b.getY()))
        {
            angle = Math.atan2(b.getY() - a.getY(), b.getX() - a.getX()) ;
        }
        return angle;
    }

    /**
     * This function finds the midpoint between two points.
     * @param a
     * @param b
     * @return midpoint between two points.
     */
    public static Point2D.Double findMidpoint(Point2D.Double a, Point2D.Double b) {
        Point2D.Double mid = new Point2D.Double((a.getX()+b.getX())/2, (a.getY()+b.getY())/2);
        return mid;
    }


    /**
     * This function takes a point of gps coordinates and translates into cartesian coordinates.
     * X is latitude, Y is longitude, and centralLatitude is the latitude of a point in the river.
     * @param gpsPoint
     * @param centralLatitude
     * @return Point2D.Double of cartesian coordinates
     */
    public static Point2D.Double gpsToCartesian (Point2D.Double gpsPoint, double centralLatitude){
        Point2D.Double cartesianPoint = new Point2D.Double();

        double lat = Math.toRadians(gpsPoint.getX());
        double lon = Math.toRadians(gpsPoint.getY());
        double aspectRatio = Math.cos(Math.toRadians(centralLatitude));

        double xCartesian = RADIUS * lat;
        double yCartesian = RADIUS * lon * aspectRatio;

        cartesianPoint = new Point2D.Double(xCartesian,yCartesian);
        return cartesianPoint;
    }

    /*This function is the inverse of gpsToCartesian. */

    /**
     * This function performs the reverse operation of gpsToCartesian. It takes a point of cartesian coordinates
     * and translates them into gps coordinates.
     * @param cartesianPoint
     * @param centralLatitude
     * @return Point2D.Double of gps coordinates
     */
    public static Point2D.Double cartesianToGPS (Point2D.Double cartesianPoint, double centralLatitude) {
        Point2D.Double gpsPoint = new Point2D.Double();

        double xCartesian = cartesianPoint.getX();
        double yCartesian = cartesianPoint.getY();
        double aspectRatio = Math.cos(Math.toRadians(centralLatitude));

        double lat = Math.toDegrees(xCartesian / RADIUS);
        double lon = Math.toDegrees(yCartesian / (RADIUS * aspectRatio));

        gpsPoint = new Point2D.Double(lat, lon);
        return gpsPoint;
    }

    /**
     * This function finds the intersection point of two line segments
     * @param line1
     * @param line2
     * @return intersection point of the two line segments
     */
    public static Point2D.Double findLineIntersection(Line2D.Double line1, Line2D.Double line2){
        double m1, m2, b1, b2, xIntersection, yIntersection;
        
        m1 = (line1.getP2().getY() - line1.getP1().getY()) / (line1.getP2().getX() - line1.getP1().getX());
        m2 = (line2.getP2().getY() - line2.getP1().getY()) / (line2.getP2().getX() - line2.getP1().getX());
        
        if (m1 > 1000 || m1 < -1000){
            xIntersection = line1.getP1().getX();
            b2 = line2.getP1().getY() - (m2 * line2.getP1().getX());
            yIntersection = m2 * xIntersection + b2;
        }
        else if (m2 > 1000 || m2 < -1000){
            xIntersection = line2.getP1().getX();
            b1 = line1.getP1().getY() - (m1 * line1.getP1().getX());
            yIntersection = m1 * xIntersection + b1;
        }

        else if (m1 < EPSILON && m1 > -EPSILON) { //horizontal line
            yIntersection = line1.getP2().getY();
            b2 = line2.getP1().getY() - (m2 * line2.getP1().getX());
            xIntersection = (yIntersection - b2) / m2;
        }
        
        else if (m2 < EPSILON && m2 > -EPSILON) { //horizontal line
            yIntersection = line2.getP2().getY();
            b1 = line1.getP1().getY() - (m1 * line1.getP1().getX());
            xIntersection = (yIntersection - b1) / m1;
        }

        else {
            b1 = line1.getP1().getY() - (m1 * line1.getP1().getX());
            b2 = line2.getP1().getY() - (m2 * line2.getP1().getX());
            xIntersection = (b2-b1) / (m1-m2);
            yIntersection = m1 * ( (b2 - b1) / (m1 - m2) ) + b1;
        }

        return new Point2D.Double(xIntersection,yIntersection);
    }
    
    
    /**
     * This function finds the cartesian distance between two points
     * @param pointA
     * @param pointB
     * @return cartesian distance
     */
    public static double findCartesianDistance(Point2D.Double pointA, Point2D.Double pointB) {
    	return Math.sqrt(Math.pow((pointA.getX() - pointB.getX()), 2) + Math.pow((pointA.getY() - pointB.getY()), 2));
    }
    
    
    /**
     * This function uses a distance ratio to calculate a point a given distance along the path from one point to another
     * @param point1
     * @param point2
     * @param distanceRatio - desired distance/distance between the two points
     * @return
     */
    public static Point2D.Double findOffsetPoint(Point2D.Double point1, Point2D.Double point2, double distanceRatio){
    	Point2D.Double newPoint = new Point2D.Double();
    	newPoint.setLocation(((1-distanceRatio)*point1.getX() + distanceRatio*point2.getX()), ((1-distanceRatio)*point1.getY() + distanceRatio*point2.getY()));
    	return newPoint;
    }
    
    
    /**
     * This function calculates the total cartesian distance of a RoutePrimitive
     * @param route
     * @return cartesian distance
     */
    public static double routePrimitiveDistance(List<Point2D.Double> route) {
    	double totalDistance = 0;
    	for(int i = 0; i < route.size()-1; i++) {
    		totalDistance += findCartesianDistance(route.get(i), route.get(i+1));
    	}
    	return totalDistance;
    }
    
    
    /**
     * This function calculates the total cartesian distance of a RiverBank
     * @param bank
     * @return cartesian distance
     */
    public static double riverBankDistance(RiverBank bank) {
    	double totalDistance = 0;
    	for(int i = 0; i < bank.size()-1; i++) {
    		totalDistance += findCartesianDistance(bank.get(i), bank.get(i+1));
    	}
    	return totalDistance;
    }
    
    
    /**
     * This function calculates the area irregular polygon shape of the river segment
     * @param segment
     * @return area
     */
    public static double calculateRiverSegmentArea(RiverSubsegment segment) {
    	double area = 0;
    	List<Point2D.Double> bank1 = segment.get(0).get();
    	for(int i = 0; i < bank1.size()-1; i++) {
    		area += bank1.get(i).getY()*bank1.get(i+1).getX() - bank1.get(i).getX()*bank1.get(i+1).getY();
    	}
    	RiverBank bank2 = segment.get(1);
    	bank2.reverse();
    	area += bank1.get(bank1.size()-1).getY()*bank2.get(0).getX() - bank1.get(bank1.size()-1).getX()*bank2.get(0).getY();
    	for(int i = 0; i < bank2.size()-1; i++) {
    		area += bank2.get(i).getY()*bank2.get(i+1).getX() - bank2.get(i).getX()*bank2.get(i+1).getY();
    	}
    	area += bank2.get(bank2.size()-1).getY()*bank1.get(0).getX() - bank2.get(bank2.size()-1).getX()*bank1.get(0).getY();
    	area = area / 2;
    	bank2.reverse();    	
    	return Math.abs(area);
    }
    
    
    /**
     * This function calculates the maximum and minimum coordinate points of a simpleBoundingRectangle around the 
     * river segment
     * @param banks
     * @return vector containing maximum and minimum coordinate points
     */
    public static Vector<Point2D.Double> simpleRiverBoundingRectangle(List<RiverBank> banks) {
    	Vector<Point2D.Double> minMax = new Vector<>();
    	List<Point2D.Double> bank1 = banks.get(0).get();
    	List<Point2D.Double> bank2 = banks.get(1).get();
    	Point2D.Double minPoint = new Point2D.Double(Double.MAX_VALUE, Double.MAX_VALUE);
    	Point2D.Double maxPoint = new Point2D.Double(-Double.MAX_VALUE, -Double.MAX_VALUE);
    	minAndMaxPoints(minPoint, maxPoint, bank1);
    	minAndMaxPoints(minPoint, maxPoint, bank2);
    	minMax.add(minPoint);
    	minMax.add(maxPoint);
    	/*System.out.println(""["" + minPoint.getX() + "", "" + minPoint.getY() + ""]"");
    	System.out.println(""["" + minPoint.getX() + "", "" + maxPoint.getY() + ""]"");
    	System.out.println(""["" + maxPoint.getX() + "", "" + maxPoint.getY() + ""]"");
    	System.out.println(""["" + maxPoint.getX() + "", "" + minPoint.getY() + ""]"");*/
    	return minMax;
    }
    
    public static Vector<Point2D.Double> simplePriorityPolygonBoundingRectangle(List<Point2D.Double> polygonPoints) {
    	Vector<Point2D.Double> minMax = new Vector<>();
    	Point2D.Double minPoint = new Point2D.Double(Double.MAX_VALUE, Double.MAX_VALUE);
    	Point2D.Double maxPoint = new Point2D.Double(-Double.MAX_VALUE, -Double.MAX_VALUE);
    	minAndMaxPoints(minPoint, maxPoint, polygonPoints);
    	minMax.add(minPoint);
    	minMax.add(maxPoint);
    	/*System.out.println(""["" + minPoint.getX() + "", "" + minPoint.getY() + ""]"");
    	System.out.println(""["" + minPoint.getX() + "", "" + maxPoint.getY() + ""]"");
    	System.out.println(""["" + maxPoint.getX() + "", "" + maxPoint.getY() + ""]"");
    	System.out.println(""["" + maxPoint.getX() + "", "" + minPoint.getY() + ""]"");*/
    	return minMax;
    }
    
   
    /**
     * This function finds the minimum and maximum points in a RiverBank
     * @param minPoint
     * @param maxPoint
     * @param points
     */
    private static void minAndMaxPoints(Point2D.Double minPoint, Point2D.Double maxPoint, List<Point2D.Double> points) {
    	for(int i = 0; i < points.size(); i++) {
    		if(points.get(i).getX() < minPoint.getX()) {
    			minPoint.setLocation(points.get(i).getX(), minPoint.getY());
    		}
    		if(points.get(i).getX() > maxPoint.getX()) {
    			maxPoint.setLocation(points.get(i).getX(),maxPoint.getY());
    		}
    		if(points.get(i).getY() < minPoint.getY()) {
    			minPoint.setLocation(minPoint.getX(), points.get(i).getY());
    		}
    		if(points.get(i).getY() > maxPoint.getY()) {
    			maxPoint.setLocation(maxPoint.getX(), points.get(i).getY());
    		}
    	}
    }
    
    
    /**
     * This function finds the closest point in the opposite RoutePrimitive
     * @param point
     * @param opposingSide
     * @return closest opposing point
     */
    public static Point2D.Double findClosestOpposingPoint(Point2D.Double point, List<Point2D.Double> opposingSide) {
    	Point2D.Double destination = new Point2D.Double();
    	double distance = Double.MAX_VALUE;
    	double newDistance;
    	for(Point2D.Double node : opposingSide) {
    		newDistance = findCartesianDistance(point, node);
    		if(newDistance < distance){
    			distance = newDistance;
    			destination = node;
    		}
    	}
    	return destination;
    } 
    
    
    /**
     * This function inserts additional nodes into each RiverBank so that there is a node every 
     * APERATURE_WIDTH*OVERLAP_FACTOR.
     * @param bank
     * @param newPoints
     * @param APERATURE_WIDTH
     * @param OVERLAP_FACTOR
     * @param riverSegment
     * @return adjusted RiverBank
     */
    private static RiverBank findRiverBankOffset(RiverBank bank, List<Point2D.Double> newPoints, double APERATURE_WIDTH, double OVERLAP_FACTOR, Path2D.Double riverSegment){
		Point2D.Double newPoint = new Point2D.Double();
		Point2D.Double point1;
		Point2D.Double point2;
		RiverBank newBank = new RiverBank();
		double riverBankDistance;
		double traverseDistance = APERATURE_WIDTH*OVERLAP_FACTOR;
		double distanceRatio;
		double newTraverseDistance = 0;
		for(int i = 0; i < bank.size()-1; i++) {
			point1 = bank.get(i);
			point2 = bank.get(i+1);
			newBank.add(point1);
			riverBankDistance = Geometry.findCartesianDistance(point1, point2);
			if(newTraverseDistance != 0 && newTraverseDistance <= riverBankDistance) {
				distanceRatio = newTraverseDistance / riverBankDistance;
				newPoint = Geometry.findOffsetPoint(point1, point2, distanceRatio);
				newBank.add(newPoint);
				newPoints.add(newPoint);
				point1 = newPoint;
				riverBankDistance = riverBankDistance - newTraverseDistance;
				newTraverseDistance = 0;
			}
			while(traverseDistance <= riverBankDistance) {
					distanceRatio = traverseDistance / riverBankDistance;
					newPoint = Geometry.findOffsetPoint(point1, point2, distanceRatio);
					newBank.add(newPoint);
					newPoints.add(newPoint);
					riverBankDistance = riverBankDistance - traverseDistance;
					point1 = newPoint;
			} 
				newTraverseDistance = traverseDistance - riverBankDistance;
		}
		return newBank;
	}
    
    private static void sourcePointsStartAndEnd(Point2D.Double bank1Point, Point2D.Double bank2Point, SourcePoints newPoints, double APERATURE_HEIGHT, double OVERLAP_FACTOR) {
    	double traverseDistance = APERATURE_HEIGHT / 2;
    	double totalDistance = findCartesianDistance(bank1Point, bank2Point);
    	newPoints.addSourcePoint(findOffsetPoint(bank1Point, bank2Point, traverseDistance / totalDistance));
    }
    
    //trying to fix issue with whiteField.json
    /*private static Point2D.Double getProjectedPoint(double APERATURE_HEIGHT, double thetaO, Path2D.Double riverSegment, Point2D.Double bankNode){
    	double dx = (APERATURE_HEIGHT / 2) * Math.cos(thetaO);
		double dy = (APERATURE_HEIGHT / 2) * Math.sin(thetaO);
		double newX = bankNode.getX()+dx;
		double newY = bankNode.getY()+dy;
		Point2D.Double newPoint  = new Point2D.Double(newX, newY);
		if(!riverSegment.contains(newPoint)) {
			newPoint.setLocation(bankNode.getX()-dx, bankNode.getY()-dy);
		}
		if(!riverSegment.contains(newPoint)) {
			thetaO = thetaO - Math.PI;
			dx = (APERATURE_HEIGHT / 2) * Math.cos(thetaO);
			dy = (APERATURE_HEIGHT / 2) * Math.sin(thetaO);
			newX = bankNode.getX()+dx;
			newY = bankNode.getY()+dy;
			newPoint.setLocation(newX, newY);
		}
		if(!riverSegment.contains(newPoint)) {
			newPoint.setLocation(bankNode.getX()-dx, bankNode.getY()-dy);
		}
		if(!riverSegment.contains(newPoint)){
			System.out.println(""couldn't find a projected point"");
			return null;
		} else {
			return newPoint;
		}
    } */
    
    
    /**
     * This function projects the points in RiverBank out into the river segment and makes these points 
     * into a RoutePrimitive.
     * @param bank1
     * @param newPoints
     * @param APERATURE_WIDTH
     * @param OVERLAP_FACTOR
     * @param riverSegment
     * @return RoutePrimitive
     */
    private static SourcePoints projectPointsInwards(RiverBank bank1, RiverBank bank2, List<Point2D.Double> newPoints, double APERATURE_HEIGHT, double OVERLAP_FACTOR, Path2D.Double riverSegment) {
		SourcePoints newSourcePoints = new SourcePoints();
		double dx;
		double dy;
		double newX;
		double newY;
		HashSet<Point2D.Double> nodes = new HashSet<>(newPoints);
		sourcePointsStartAndEnd(bank1.get(0), bank2.get(0), newSourcePoints, APERATURE_HEIGHT, OVERLAP_FACTOR);
		for(int i = 0; i < bank1.size()-2; i++) {
			if(!nodes.contains(bank1.get(i+1))) {
				continue;
			}
			double theta1 = Geometry.getAngle(bank1.get(i), bank1.get(i+1));
			double theta2 = Geometry.getAngle(bank1.get(i+1), bank1.get(i+2));
			double theta = (theta1 + theta2) / 2;
			double thetaO;
			//this was trying to fix issue with whiteField.json
			/*if(theta1 == 0.0 && theta2 == 0.0) {
				thetaO = theta;
			} else {
				thetaO = theta + Math.PI / 2;
			}*/
			thetaO = theta + Math.PI / 2;
			dx = (APERATURE_HEIGHT / 2) * Math.cos(thetaO);
			dy = (APERATURE_HEIGHT / 2) * Math.sin(thetaO);
			newX = bank1.get(i+1).getX()+dx;
			newY = bank1.get(i+1).getY()+dy;
			Point2D.Double newPoint  = new Point2D.Double(newX, newY);
			if(!riverSegment.contains(newPoint)) {
				newPoint.setLocation(bank1.get(i+1).getX()-dx, bank1.get(i+1).getY()-dy);
			}
			if(!riverSegment.contains(newPoint)) {
				thetaO = theta - Math.PI / 2;
				dx = (APERATURE_HEIGHT / 2) * Math.cos(thetaO);
				dy = (APERATURE_HEIGHT / 2) * Math.sin(thetaO);
				newX = bank1.get(i+1).getX()+dx;
				newY = bank1.get(i+1).getY()+dy;
				newPoint.setLocation(newX, newY);
			}
			if(!riverSegment.contains(newPoint)) {
				newPoint.setLocation(bank1.get(i+1).getX()-dx, bank1.get(i+1).getY()-dy);
			}
			if(riverSegment.contains(newPoint)) {
				newSourcePoints.addSourcePoint(newPoint);
			} 
		}
		sourcePointsStartAndEnd(bank1.get(bank1.size()-1), bank2.get(bank2.size()-1), newSourcePoints, APERATURE_HEIGHT, OVERLAP_FACTOR);
		return newSourcePoints;
	}
    
    
    /**
     * This function creates route primitives parallel to the riverbanks inside the river segment.
     * @param APERATURE_WIDTH
     * @param OVERLAP_FACTOR
     * @param bankList
     * @return RoutePrimitive objects for both riverbanks
     */
    public static List<SourcePoints> generateSourcePoints(double APERATURE_WIDTH, double APERATURE_HEIGHT, double OVERLAP_FACTOR, List<RiverBank> bankList, boolean innerCrissCross){
    	List<SourcePoints> sourcePointsList = new ArrayList<>();
    	sourcePointsList.add(new SourcePoints());
    	sourcePointsList.add(new SourcePoints());
    	List<Point2D.Double> newPoints = new ArrayList<>();
		List<Point2D.Double> newPoints1 = new ArrayList<>();
		RiverBank bank1;
		RiverBank bank2;
		Path2D.Double riverSegment = Utilities.makeTotalRiverSegment(bankList);
		RiverSubsegment newRiver = new RiverSubsegment();

		bank1 = bankList.get(0);
		bank2 = bankList.get(1);
		bank1 = findRiverBankOffset(bank1, newPoints, APERATURE_WIDTH, OVERLAP_FACTOR, riverSegment);
		bank2 = findRiverBankOffset(bank2, newPoints1, APERATURE_WIDTH, OVERLAP_FACTOR, riverSegment);
		newRiver.add(bank1);  //what does this line actually do?
		newRiver.add(bank2);

		if(innerCrissCross) {
			sourcePointsList.set(0, projectPointsInwards(bank1, bank2, newPoints, APERATURE_HEIGHT * 2, OVERLAP_FACTOR, riverSegment));
			sourcePointsList.set(1, projectPointsInwards(bank2, bank1, newPoints1, APERATURE_HEIGHT * 2, OVERLAP_FACTOR, riverSegment));
		} else {
			sourcePointsList.set(0, projectPointsInwards(bank1, bank2, newPoints, APERATURE_HEIGHT, OVERLAP_FACTOR, riverSegment));
			sourcePointsList.set(1, projectPointsInwards(bank2, bank1, newPoints1, APERATURE_HEIGHT, OVERLAP_FACTOR, riverSegment));
		}
		return sourcePointsList;
    }
}"
SetGroundSpeedCommand.java,"package edu.nd.dronology.core.vehicle.commands;

public class SetGroundSpeedCommand extends AbstractDroneCommand implements IDroneCommand {

	/**
	 * 
	 * Command sent to the GCS for setting the groundspeed of the UAV.<br>
	 * Ground speed is specified in m/s.
	 * 
	 *  
	 * @author Michael Vierhauser
	 */
	private static final long serialVersionUID = -7987143017453423246L;

	public SetGroundSpeedCommand(String uavid, double speed) {
		super(uavid, CommandIds.SET_GROUND_SPEED_COMMAND);
		data.put(ATTRIBUTE_SPEED, speed);
	}
}
"
DistanceCalculator.java,"package edu.nd.dronology.core.simulator.simplesimulator;

import edu.nd.dronology.core.coordinate.LlaCoordinate;

public class DistanceCalculator {

	private static double distance(double lat1, double lon1, double lat2, double lon2, String unit) {
		double theta = lon1 - lon2;
		double dist = Math.sin(deg2rad(lat1)) * Math.sin(deg2rad(lat2))
				+ Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.cos(deg2rad(theta));
		dist = Math.acos(dist);
		dist = rad2deg(dist);
		dist = dist * 60 * 1.1515;
		if (unit == ""K"") {
			dist = dist * 1.609344;
		} else if (unit == ""N"") {
			dist = dist * 0.8684;
		}

		return (dist);
	}

	private static double deg2rad(double deg) {
		return (deg * Math.PI / 180.0);
	}

	private static double rad2deg(double rad) {
		return (rad * 180 / Math.PI);
	}

	public static double distance(LlaCoordinate currentPosition, LlaCoordinate targetPosition) {
		return distance(currentPosition.getLatitude(), currentPosition.getLongitude(), targetPosition.getLatitude(),
				targetPosition.getLongitude(), ""K"");
	}

}
"
SimulatorScenario.java,"package edu.nd.dronology.services.core.items;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;

public class SimulatorScenario implements ISimulatorScenario {

	private String name;
	private String id;
	private String category = ""Default"";
	private List<AssignedDrone> drones;
	private List<String> flightPaths;

	public SimulatorScenario() {
		id = UUID.randomUUID().toString();
		name = id;
		drones = new ArrayList<>();
		flightPaths = new ArrayList<>();
	}

	@Override
	public void setName(String name) {
		this.name = name;

	}

	@Override
	public String getId() {
		return id;
	}

	@Override
	public String getName() {
		return name;
	}

	@Override
	public String getDescription() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setDescription(String description) {
		// TODO Auto-generated method stub

	}

	@Override
	public String getCategory() {
		return category;
	}

	@Override
	public void setCategory(String category) {
		this.category = category;
	}

	@Override
	public List<AssignedDrone> getAssignedDrones() {
		return Collections.unmodifiableList(drones);
	}

	@Override
	public boolean addAssignedDrone(String droneId) {
		AssignedDrone toAdd = new AssignedDrone(droneId);
		if (drones.contains(toAdd)) {
			return false;
		}
		return drones.add(toAdd);
	}

	@Override
	public boolean addAssignedPath(String pathId) {
		if (flightPaths.contains(pathId)) {
			return false;
		}
		return flightPaths.add(pathId);
	}

	@Override
	public boolean removeAssignedDrone(String droneId) {
		AssignedDrone toRemove = new AssignedDrone(droneId);
		if (!drones.contains(toRemove)) {
			return false;
		}
		return drones.remove(toRemove);
	}

	@Override
	public boolean removeAssignedPath(String pathId) {
		if (!flightPaths.contains(pathId)) {
			return false;
		}
		return flightPaths.remove(pathId);
	}

	@Override
	public List<String> getAssignedFlightPaths() {
		return Collections.unmodifiableList(flightPaths);
	}

}
"
UAVEquipmentTypeRegistrationInfo.java,"package edu.nd.dronology.services.core.info;

import java.util.Collection;
import java.util.Collections;
import java.util.List;

public class UAVEquipmentTypeRegistrationInfo extends RemoteInfoObject {

	/**
	 * 
	 */
	private static final long serialVersionUID = 2844123024068335148L;
	private String type = ""Default"";
	private List<String> uavids;

	public UAVEquipmentTypeRegistrationInfo(String name, String id) {
		super(name, id);
	}

	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;

	}

}
"
ManagedDroneUpdateMessage.java,"package edu.nd.dronology.core.collisionavoidance.backendmessage;

import edu.nd.dronology.core.collisionavoidance.guidancecommands.Command;
import edu.nd.dronology.core.goal.IGoalSnapshot;
import edu.nd.dronology.core.vehicle.ManagedDrone;

import java.util.List;
import java.util.Set;

public class ManagedDroneUpdateMessage extends AbstractMessage {
    public final String name;
    public final List<Command> commandQueue;
    public final Set<IGoalSnapshot> goals;
    public final String state;
    public final ManagedDrone managedDrone;
    public ManagedDroneUpdateMessage(String name, List<Command> commandQueue, Set<IGoalSnapshot> goals, String state, ManagedDrone managedDrone) {
        this.name = name;
        this.commandQueue = commandQueue;
        this.goals = goals;
        this.state = state;
        this.managedDrone = managedDrone;
    }
}
"
IServiceListener.java,"package edu.nd.dronology.services.core.listener;

import edu.nd.dronology.services.core.api.IServiceInstance;
import edu.nd.dronology.services.core.api.ServiceStatus;

/**
 * Listener interface for notifying on status changes of a {@link IServiceInstance}
 * 
 *  
 * @author Michael Vierhauser
 * 
 */
public interface IServiceListener  {

	/**
	 * 
	 * @param newState The new status of the server process.
	 */
	public void statusChanged(ServiceStatus newState);

}
"
AreaMappingPersistenceProvider.java,"package edu.nd.dronology.services.core.persistence;

import edu.nd.dronology.services.core.items.IAreaMapping;
import edu.nd.dronology.services.core.persistence.internal.AreaMappingXStreamPersistor;
import edu.nd.dronology.services.core.persistence.internal.UAVRegistrationXStreamPersistor;


/**
 * Provider implementation for {@link IAreaMapping}.<br>
 * Details see {@link AbstractItemPersistenceProvider}
 * 
 * @author Michael Vierhauser
 * 
 */
public class AreaMappingPersistenceProvider extends AbstractItemPersistenceProvider<IAreaMapping> {

	public AreaMappingPersistenceProvider() {
		super();
	}

	@Override
	protected void initPersistor() {
		PERSISTOR = new AreaMappingXStreamPersistor();

	}

	@Override
	protected void initPersistor(String type) {
		initPersistor();
	}

	public static AreaMappingPersistenceProvider getInstance() {
		return new AreaMappingPersistenceProvider();
	}

}
"
AFMapViewOperations.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import com.vaadin.event.LayoutEvents.LayoutClickListener;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Label;
import com.vaadin.ui.NativeButton;
import com.vaadin.ui.Upload;
import com.vaadin.ui.VerticalLayout;

/**
 * This is the set of map operation buttons in the AFInfoPanel
 * 
 * @author Patrick Falvey
 *
 */

public class AFMapViewOperations extends CustomComponent {

	private static final long serialVersionUID = -2249802562670339842L;
	private HorizontalLayout buttons = new HorizontalLayout();

	// ""Follow Selected<br>UAVs on Map // ""View All UAVs<br>on Map""

	private NativeButton follow = new NativeButton(""Follow Selected UAVs"");
	private NativeButton viewAll = new NativeButton(""View All UAVs"");

	public AFMapViewOperations() {
		VerticalLayout layout = new VerticalLayout();
		layout.addStyleName(""af_operations_group"");

		Label caption = new Label(""Map View Operations"");
		follow.setCaptionAsHtml(true);
		viewAll.setCaptionAsHtml(true);

		buttons.addComponents(follow, viewAll);
		layout.addComponents(caption, buttons);

		setCompositionRoot(layout);
	}

	public NativeButton getFollowButton() {
		return follow;
	}

	public NativeButton getViewButton() {
		return viewAll;
	}

	public void addOnClickListener(LayoutClickListener listener) {
		buttons.addLayoutClickListener(listener);
	}
}
"
AbstractItemPersistenceProvider.java,"package edu.nd.dronology.services.core.persistence;

import java.io.File
;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;

import edu.nd.dronology.util.NullUtil;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * Abstract base class for all item factories.<br>
 * Provides methods for read/save of items
 * 
 * @author Michael Vierhauser
 * 
 * @param <ITEM>
 *          The interface of the persisted object
 */
public abstract class AbstractItemPersistenceProvider<ITEM> {

	/**
	 * The persistor
	 */
	protected IPersistenceManager<ITEM> PERSISTOR;
	private static final ILogger LOGGER = LoggerProvider.getLogger(AbstractItemPersistenceProvider.class);

	/**
	 * Default constructor
	 */
	public AbstractItemPersistenceProvider() {
		initPersistor();
	}

	public AbstractItemPersistenceProvider(String type) {
		initPersistor(type);
	}

	/**
	 * needs to be implemented in subclasses - initialized the used persistor
	 */
	protected abstract void initPersistor();
	
	protected abstract void initPersistor(String type);

	/**
	 * 
	 * @return a singleton instance of the persistor
	 */
	public static AbstractItemPersistenceProvider<?> getInstance() {
		return null;
	}

	/**
	 * Reads the item represented by resource
	 * 
	 * @param resource
	 * @return either the item represented by resource or an exception.
	 * @throws PersistenceException
	 */
	public ITEM loadItem(URL resource) throws PersistenceException {
		NullUtil.checkNull(resource);
		try {
			return loadItem(resource.openStream());
		} catch (IOException e) {
			throw new PersistenceException(e);
		}
	}

	/**
	 * Reads the item stored at the given path
	 * 
	 * @param path
	 * @return either the item located at the path or an exception.
	 * @throws PersistenceException
	 */
	public ITEM loadItem(String path) throws PersistenceException {
		NullUtil.checkNull(path);
		File f = new File(path);
		return loadItem(f);
	}
	
	public ITEM loadItem(File file)throws PersistenceException {
		FileInputStream fin;

		try {
			fin = new FileInputStream(file);
		} catch (FileNotFoundException e) {
			throw new PersistenceException(e);
		}
		return loadItem(fin);
	}

	/**
	 * Reads the item represented by the content
	 * 
	 * @param content
	 * @return either the item located by the content or an exception.
	 * @throws PersistenceException
	 */
	public ITEM loadItem(InputStream content) throws PersistenceException {
		NullUtil.checkNull(content);
		ITEM model = null;
		try {
			model = PERSISTOR.open(content);
		} catch (Exception e) {
			throw new PersistenceException(e);
		} finally {
			try {
				if (content != null) {
					content.close();
				}
			} catch (IOException e) {
				LOGGER.error(e);
			}
		}
		return model;
	}

	/**
	 * 
	 * @param model
	 *          The model object to save
	 * @param out
	 *          The ountput stream where to write the object.
	 * @return true if saving was successful.
	 * @throws PersistenceException
	 */
	public boolean saveItem(ITEM model, OutputStream out) throws PersistenceException {
		NullUtil.checkNull(model, out);
		boolean success = PERSISTOR.save(model, out);
		return success;
	}

	/**
	 * 
	 * @param item
	 *          The item object to save
	 * @param path
	 *          The path where to save the object.
	 * @return true if saving was successful.
	 * @throws PersistenceException
	 */
	public boolean saveItem(ITEM item, String path) throws PersistenceException {
		NullUtil.checkNull(item, path);
		File file = new File(path);
		FileOutputStream fout;
		try {
			fout = new FileOutputStream(file);
			boolean success = saveItem(item, fout);
			return success;
		} catch (FileNotFoundException e) {
			throw new PersistenceException(e);
		}
	}

}
"
IUAVRegistration.java,"package edu.nd.dronology.services.core.items;

import java.io.Serializable;

public interface IUAVRegistration extends IPersistableItem {

	String getDescription();

	void setType(String type);

	void setDescription(String description);

	String getType();

	Serializable getAttribute(String key);

	void addAttribute(String key, Serializable value);

	void setUAVImage(byte[] image);

	byte[] getImage();

}
"
IUAVEquipmentTypeRegistrationServiceInstance.java,"package edu.nd.dronology.services.instances.registration.equipment;

import edu.nd.dronology.services.core.api.IFileTransmitServiceInstance;
import edu.nd.dronology.services.core.info.UAVEquipmentTypeRegistrationInfo;

public interface IUAVEquipmentTypeRegistrationServiceInstance extends IFileTransmitServiceInstance<UAVEquipmentTypeRegistrationInfo> {

	
}
"
AFAssignRouteComponent.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;

import org.vaadin.teemu.switchui.Switch;

import com.vaadin.icons.VaadinIcons;
import com.vaadin.ui.Alignment;
import com.vaadin.ui.Button;
import com.vaadin.ui.Component;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Image;
import com.vaadin.ui.Label;
import com.vaadin.ui.Notification;
import com.vaadin.ui.Notification.Type;
import com.vaadin.ui.Panel;
import com.vaadin.ui.VerticalLayout;
import com.vaadin.ui.themes.ValoTheme;

import edu.nd.dronology.services.core.info.FlightInfo;
import edu.nd.dronology.services.core.info.FlightRouteInfo;
import edu.nd.dronology.services.core.remote.IFlightManagerRemoteService;
import edu.nd.dronology.services.core.remote.IFlightRouteplanningRemoteService;
import edu.nd.dronology.services.core.util.DronologyServiceException;
import edu.nd.dronology.ui.vaadin.activeflights.AFDragLayout.WrappedComponent;
import edu.nd.dronology.ui.vaadin.connector.BaseServiceProvider;
import edu.nd.dronology.ui.vaadin.flightroutes.FRInfoBox;
import edu.nd.dronology.ui.vaadin.flightroutes.FRMainLayout;
import edu.nd.dronology.ui.vaadin.start.MyUI;
import edu.nd.dronology.ui.vaadin.utils.ImageProvider;
import edu.nd.dronology.ui.vaadin.utils.StyleConstants;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * This is the UI for assigning new routes to a UAV
 * 
 * @author Patrick Falvey
 *  
 */ 

public class AFAssignRouteComponent extends CustomComponent {

	/**
	 * 
	 */
	private static final long serialVersionUID = -3476532205257979147L;

	private static final ILogger LOGGER = LoggerProvider.getLogger(AFAssignRouteComponent.class);

	private VerticalLayout content = new VerticalLayout();
	private HorizontalLayout topContent = new HorizontalLayout();
	private HorizontalLayout sideContent = new HorizontalLayout();
	private HorizontalLayout bottomButtons = new HorizontalLayout();
	private VerticalLayout sideButtons = new VerticalLayout(); 
	private AFDragLayout panelContent;
	private FRMainLayout frLayout = new FRMainLayout();
	private Panel sidePanel = new Panel();
	private Button cancel = new Button(""Cancel"");
	private Button apply = new Button(""Apply"");
	private Button left = new Button(""<"");
	private Button right = new Button("">"");
	private int numRoutes = 0;
	private Switch hoverSwitch = new Switch();
	private Button returnToHome = new Button(""Return to Home"");
	private int index = -1;
	private int boxID = 0;

	private BaseServiceProvider provider = MyUI.getProvider();
	private IFlightManagerRemoteService flightRouteService;
	private FlightInfo flightRouteInfo = null;
	private IFlightRouteplanningRemoteService flightInfoService;

	private Image droneImage;
	private UAVStatusWrapper uavStatus;

	public AFAssignRouteComponent(UAVStatusWrapper uavStatus) {
		this.uavStatus = uavStatus;
	}

	public void createContents() {
		this.addStyleName(StyleConstants.AF_ASSING_ROUTE);
		topContent.addStyleName(StyleConstants.AF_ASSING_ROUTE_TOP_CONTENT);
		sideContent.addStyleName(StyleConstants.AF_ASSING_ROUTE_MIDDLE_CONTENT);
		bottomButtons.addStyleName(StyleConstants.AF_ASSING_ROUTE_BOTTOM_CONTENT);

		panelContent = new AFDragLayout(uavStatus.getName());

		droneImage = ImageProvider.getDefaultUAVImage();
		VerticalLayout statusContent = new VerticalLayout();

		createStatusPannel(statusContent);

		try {
			flightRouteService = (IFlightManagerRemoteService) provider.getRemoteManager()
					.getService(IFlightManagerRemoteService.class);
			flightRouteInfo = flightRouteService.getFlightInfo(uavStatus.getName());
		} catch (RemoteException e) {
			MyUI.setConnected(false);
			LOGGER.error(e);
		} catch (Exception e) {
			LOGGER.error(e);
		}

		numRoutes = flightRouteInfo.getPendingFlights().size();

		createSidePannel(sidePanel);

		bottomButtons.addComponents(cancel, apply);
		apply.addStyleName(""btn-okay"");
		content.addComponents(topContent, sideContent, bottomButtons);

		setCompositionRoot(content);

	}

	private void createSidePannel(Panel sidePanel) {
		sidePanel.addStyleName(""fr_info_panel"");
		sidePanel.addStyleName(""control_panel"");
		sidePanel.setCaption(numRoutes + "" Routes Assigned"");
		apply.setEnabled(true); 

		sideButtons.addComponents(left, right);
		sideButtons.setComponentAlignment(left, Alignment.MIDDLE_CENTER);
		sideButtons.setComponentAlignment(right, Alignment.MIDDLE_CENTER);

		// when adding a route to be assigned
		left.addClickListener(e -> {
			if (frLayout.getControls().getInfoPanel().getHighlightedFRInfoBox() != null) {
				FlightRouteInfo selectedFlight = frLayout.getControls().getInfoPanel().getHighlightedFRInfoBox()
						.getFlightRouteInfo();
				if (selectedFlight.getWaypoints().size() < 1) {
					Notification.show(""There is no waypoint defined in "" + selectedFlight.getName()
							+ "". You cannot assign an empty route to a UAV."");
				} else {
					addRoute(selectedFlight);
				}
			} else
				Notification.show(""Please select route to assign."");
		});

		// when removing a route from the assigned list
		right.addClickListener(e -> {
			if (index != -1) {
				removeRoute(this.index);
				this.index = -1;
			} else
				Notification.show(""Please select assigned route to remove."");
		});

		// when clicking on a route, focus the box and show the route on the map on the right
		panelContent.getSortableLayout().getVerticalLayout().addLayoutClickListener(e -> {
			WrappedComponent child = (WrappedComponent) e.getChildComponent();
			Component childContent = child.getContent();
			if (panelContent.getComponentIndex(childContent) != -1) {
				((FRInfoBox) childContent).addStyleName(""info_box_focus"");
				frLayout.switchRoute(((FRInfoBox) childContent));
			}
			index = panelContent.getComponentIndex(childContent);

			int numComponents = panelContent.getComponentCount();

			// when one route is clicked, the others go back to default background color
			for (int i = 0; i < numComponents; i++) {
				if (i != index) {
					panelContent.getComponent(i).removeStyleName(""info_box_focus"");
				}
			}
		});
		
		// be able to add a route to the left with a double click
		frLayout.getControls().getInfoPanel().getRoutes().addLayoutClickListener(e -> {
			if (e.isDoubleClick()) {	
				if (frLayout.getControls().getInfoPanel().getHighlightedFRInfoBox() != null) {
					FlightRouteInfo selectedFlight = frLayout.getControls().getInfoPanel().getHighlightedFRInfoBox().getFlightRouteInfo();
					if (selectedFlight.getWaypoints().size() < 1) {
						Notification.show(""There is no waypoint defined in "" + selectedFlight.getName()
								+ "". You cannot assign an empty route to a UAV."");
					} else {
						addRoute(selectedFlight);
					}
				}
				else Notification.show(""Please select route to assign."");
			}
		});
		
		// be able to add a route to the right with a double click
		panelContent.getSortableLayout().getVerticalLayout().addLayoutClickListener(e -> {
			if (e.isDoubleClick()) {
				if (index != -1) {
					removeRoute(this.index);
					this.index = -1;
				} else
					Notification.show(""Please select assigned route to remove."");
			}
		});
	
		
		
		sidePanel.setContent(panelContent);
		sideContent.addComponents(sidePanel, sideButtons, frLayout);

	}

	private void createStatusPannel(VerticalLayout statusContent) {

		Label statusInfo1 = new Label();
		Label statusInfo2 = new Label();
		Label statusInfo3 = new Label();

		statusInfo1.setValue(""Assigning Routes for "" + uavStatus.getName());
		statusInfo1.addStyleName(""info_box_name"");
		statusInfo1.addStyleName(ValoTheme.LABEL_BOLD);
		statusInfo2.setValue(""Status: "" + uavStatus.getStatus());

		statusInfo3.setValue(""Battery Life: "" + uavStatus.getBatteryLife() + "" %"");
		statusContent.addComponents(statusInfo1, statusInfo2, statusInfo3);
		statusContent.setSpacing(false);
		Label health = new Label();
		health.setCaptionAsHtml(true);
		health.setCaption(""<span style=\'color: "" + uavStatus.getHealthColor() + "" !important;\'> ""
				+ VaadinIcons.CIRCLE.getHtml() + ""</span>"");
		if (uavStatus.getHealthColor().equals(""green""))
			health.setDescription(""Normally Functionable"");
		else if (uavStatus.getHealthColor().equals(""yellow""))
			health.setDescription(""Needs Attention"");
		else if (uavStatus.getHealthColor().equals(""red""))
			health.setDescription(""Needs Immediate Attention"");

		topContent.addComponents(droneImage, statusContent, health);
		topContent.setSpacing(false);

		VerticalLayout coordinates = new VerticalLayout();
		VerticalLayout altAndSpeed = new VerticalLayout();
		HorizontalLayout positionInfo = new HorizontalLayout();

		Label locationInfo1 = new Label();
		Label locationInfo2 = new Label();
		Label locationInfo3 = new Label();
		Label locationInfo4 = new Label();

		locationInfo1.setValue(""Latitude:\t"" + uavStatus.getLatitude());
		locationInfo2.setValue(""Longitude:\t"" + uavStatus.getLongitude());
		locationInfo3.setValue(""Altitude:\t"" + uavStatus.getAltitude() + "" meters"");

		locationInfo4.setValue(""Ground Speed:\t"" + uavStatus.getSpeed() + "" m/s"");

		coordinates.addComponents(locationInfo1, locationInfo2);
		altAndSpeed.addComponents(locationInfo3, locationInfo4);
		positionInfo.addComponents(coordinates, altAndSpeed);

		topContent.addComponent(positionInfo);

		VerticalLayout buttons = new VerticalLayout();

		HorizontalLayout bottomSwitch = new HorizontalLayout();
		Label caption = new Label(""Hover in Place"");
		bottomSwitch.addComponents(caption, hoverSwitch);

		buttons.addComponents(bottomSwitch, returnToHome);

		topContent.addComponent(buttons);

	}

	/**
	 * 
	 * @return in-order list of flight routes to be assigned to the UAV based on the order in the AFDragLayout
	 */
	public Collection<FlightRouteInfo> getRoutesToAssign() {
		Collection<FlightRouteInfo> current = new ArrayList<>();
		Collection<FlightRouteInfo> items = null;
		try {
			flightInfoService = (IFlightRouteplanningRemoteService) provider.getRemoteManager()
					.getService(IFlightRouteplanningRemoteService.class);
			items = flightInfoService.getItems();
		} catch (RemoteException | DronologyServiceException e) {
			MyUI.setConnected(false);
			LOGGER.error(e);
		}

		for (int i = 0; i < panelContent.getComponentCount(); i++) {
			FRInfoBox box = (FRInfoBox) panelContent.getComponent(i);
			for (FlightRouteInfo info : items) {
				if (box.getName().equals(info.getName())) {
					current.add(info);
				}
			}
		}

		return current;
	}

	public void addRoute(FlightRouteInfo routeInfo) {
		FRInfoBox box = new FRInfoBox(routeInfo);
		box.setId(Integer.toString(this.boxID));
		panelContent.addNewComponent(box);
		numRoutes += 1;
		sidePanel.setCaption(numRoutes + "" Routes Assigned"");
	}

	/**
	 * removes a route from the AFDragLayout
	 * 
	 * @param index
	 */
	public void removeRoute(int index) {
		panelContent.removeComponent(panelContent.getComponent(index));
		numRoutes -= 1;
		sidePanel.setCaption(numRoutes + "" Routes Assigned"");
	}

	public Button getCancel() {
		return cancel;
	} 

	public Button getApply() {
		return apply;
	}

	public Button getReturnToHome() {
		return returnToHome;
	}

	public Switch getHover() {
		return hoverSwitch;
	}

}
"
AbstractGoal.java,"package edu.nd.dronology.core.goal;

import java.util.Observable;
import java.util.Observer;




public abstract class AbstractGoal extends Observable implements Observer {

    public enum GoalState {
        PENDING,
        ACTIVE,
        COMPLETE,
        CANCELED
    }

    private GoalState state = GoalState.PENDING;

    public synchronized GoalState getState() {
        return state;
    }

    private synchronized void setState(GoalState newState) {
        this.state = newState;
        setChanged();
        notifyObservers();
    }

    public abstract IGoalSnapshot buildSnapshot();

    public void setPending() {
        setState(GoalState.PENDING);
    }

    public void setActive() {
        setState(GoalState.ACTIVE);
    }

    public void setCompleted() {
        setState(GoalState.COMPLETE);
    }

    public void setCanceled() {
        setState(GoalState.CANCELED);
    }
}
"
Onion.java,"package edu.nd.dronology.core.collisionavoidance.strategy;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;

import edu.nd.dronology.core.collisionavoidance.CollisionAvoidanceUtil;
import edu.nd.dronology.core.collisionavoidance.CollisionAvoider;
import edu.nd.dronology.core.collisionavoidance.DronePair;
import edu.nd.dronology.core.collisionavoidance.DroneSnapshot;
import edu.nd.dronology.core.collisionavoidance.strategy.onionbackend.DefaultAction;
import edu.nd.dronology.core.collisionavoidance.strategy.onionbackend.IAction;
import edu.nd.dronology.core.collisionavoidance.strategy.onionbackend.ILayer;
import edu.nd.dronology.core.goal.IGoalSnapshot;
import edu.nd.dronology.core.goal.WaypointGoalSnapshot;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;

/**
 * This approach uses a collection of layers to determine avoidance actions. The inner most layer stops the drones. The next layer out might slow them. 
 */
public class Onion implements CollisionAvoider {

    private static final ILogger LOGGER = LoggerProvider.getLogger(Onion.class);

    // List of layers, ordered inner most to outer most. 
    List<ILayer> layers;
    HashMap<String, DroneSnapshot> nameLookup = new HashMap<>();
    HashMap<String, Double> distanceLookup = new HashMap<>();
    HashMap<String, String> nearestNeighbor = new HashMap<>();
    final IAction defaultAction = new DefaultAction();

    public Onion(ILayer...layers) {
        this.layers = new ArrayList<>(Arrays.asList(layers));
        Collections.sort(this.layers, (ILayer l1, ILayer l2) -> {
            return Double.compare(l1.getTriggerDistance(), l2.getTriggerDistance());
        });
    }

	@Override
	public void avoid(ArrayList<DroneSnapshot> drones) {
        setupLookupTables(drones);
        for (DronePair pair : CollisionAvoidanceUtil.findPairs(drones)) {
            double distance = pair.findDistance();
            if (!distanceLookup.containsKey(pair.a.getName()) || 
                distance < distanceLookup.get(pair.a.getName())) {    
                
                distanceLookup.put(pair.a.getName(), distance);
                nearestNeighbor.put(pair.a.getName(), pair.b.getName());

            }
            if (!distanceLookup.containsKey(pair.b.getName()) ||
                distance < distanceLookup.get(pair.b.getName())) {
                
                distanceLookup.put(pair.b.getName(), distance);
                nearestNeighbor.put(pair.b.getName(), pair.a.getName());
            }
        }

        for (DroneSnapshot drone : drones) {
            IAction activeLayer = defaultAction;
            if (distanceLookup.size() != 0) {
                double distance = distanceLookup.get(drone.getName());
                ILayer layer = findInnerMostLayer(distance);
                if (layer != null) {
                    activeLayer = layer;
                    String neighbor = nearestNeighbor.get(drone.getName());
                    String msg = String.format(""Collision avoidance is taking action. %s is %.2f meters from %s"", drone.getName(), distance, neighbor);
                    LOGGER.warn(msg);
                }
            }
            activeLayer.applyAction(drone);
        }
    }

    private void setupLookupTables(ArrayList<DroneSnapshot> drones) {
        nameLookup.clear();
        distanceLookup.clear();
        nearestNeighbor.clear();
        for (DroneSnapshot drone : drones) {
            nameLookup.put(drone.getName(), drone);
        }
    }
    
    private ILayer findInnerMostLayer(double distance) {
        for (ILayer layer: layers) {
            if (layer.isTriggered(distance)) {
                return layer;
            }
        }
        return null;
    }

}"
PatternTask.java,"package edu.nd.dronology.services.extensions.missionplanning.tasks;

/**
 * A {@link PatternTask} represents a predefined pattern that is expanded when the mission is created.
 * 
 * @author Michael Vierhausers
 * 
 */
public class PatternTask extends AbstractMissionTask {

	protected PatternTask(String uavID, String taskName) {
		super(uavID, taskName);
	}
}"
DroneSimulatorService.java,"package edu.nd.dronology.services.instances.dronesimulator;

import java.util.Collection;
import java.util.List;

import edu.nd.dronology.services.core.base.AbstractFileTransmitServerService;
import edu.nd.dronology.services.core.info.SimulatorScenarioCategoryInfo;
import edu.nd.dronology.services.core.info.SimulatorScenarioInfo;
import edu.nd.dronology.services.core.util.DronologyServiceException;

public class DroneSimulatorService
		extends AbstractFileTransmitServerService<IDroneSimulatorServiceInstance, SimulatorScenarioInfo> {

	private static volatile DroneSimulatorService INSTANCE;

	protected DroneSimulatorService() {
		super();
	}

	/**
	 * @return The singleton ConfigurationService instance
	 */
	public static DroneSimulatorService getInstance() {
		if (INSTANCE == null) {
			synchronized (DroneSimulatorService.class) {
				if (INSTANCE == null) {
					INSTANCE = new DroneSimulatorService();
				}
			}
		}
		return INSTANCE;
	}

	@Override
	protected IDroneSimulatorServiceInstance initServiceInstance() {
		return new DroneSimulatorServiceInstance();
	}

	public void activateScenario(SimulatorScenarioInfo scenario) throws DronologyServiceException {
		serviceInstance.activateScenario(scenario);

	}

	public Collection<SimulatorScenarioCategoryInfo> getCategories() {
		return serviceInstance.getCategories();
	}

}
"
PhysicalDrone.java,"package edu.nd.dronology.core.vehicle.internal;

import java.util.Random;

import edu.nd.dronology.core.CoordinateChange;
import edu.nd.dronology.core.DronologyConstants;
import edu.nd.dronology.core.IUAVPropertyUpdateNotifier;
import edu.nd.dronology.core.collisionavoidance.DroneSnapshotInternal;
import edu.nd.dronology.core.coordinate.LlaCoordinate;
import edu.nd.dronology.core.exceptions.DroneException;
import edu.nd.dronology.core.exceptions.FlightZoneException;
import edu.nd.dronology.core.vehicle.AbstractDrone;
import edu.nd.dronology.core.vehicle.DroneFlightStateManager.FlightMode;
import edu.nd.dronology.core.vehicle.IDrone;
import edu.nd.dronology.core.vehicle.IDroneCommandHandler;
import edu.nd.dronology.core.vehicle.commands.AbstractDroneCommand;
import edu.nd.dronology.core.vehicle.commands.GoToCommand;
import edu.nd.dronology.core.vehicle.commands.LandCommand;
import edu.nd.dronology.core.vehicle.commands.SetGroundSpeedCommand;
import edu.nd.dronology.core.vehicle.commands.SetVelocityCommand;
import edu.nd.dronology.core.vehicle.commands.TakeoffCommand;
import net.mv.logging.ILogger;
import net.mv.logging.LoggerProvider;
import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;

/**
 * Representation of a physical UAV which either interacts with real hardware or the SITL simulated UAV.
 * 
 * @author Jane Cleland-Huang
 * 
 */
public class PhysicalDrone extends AbstractDrone implements IDrone, IUAVPropertyUpdateNotifier {

	private static final ILogger LOGGER = LoggerProvider.getLogger(PhysicalDrone.class);

	private IDroneCommandHandler baseStation;
	private String droneID;
	private LlaCoordinate currentTarget;
	private AbstractDroneCommand lastCommand = null;
	private volatile DroneSnapshotInternal latestDroneSnapshot;

	public PhysicalDrone(String drnName, IDroneCommandHandler baseStation) {
		super(drnName);
		this.baseStation = baseStation;
		currentTarget = new LlaCoordinate(0, 0, 0);
		try {
			droneID = drnName;
			baseStation.setStatusCallbackNotifier(droneID, this);
			droneStatus.setGroundstationId(baseStation.getHandlerId());
		} catch (Exception e) {
			LOGGER.error(e);
		}
	}

	@Override
	public double getLatitude() {
		return getCoordinates().getLatitude();
	}

	@Override
	public double getLongitude() {
		return getCoordinates().getLongitude();
	}

	@Override
	public double getAltitude() {
		return getCoordinates().getAltitude();
	}

	Random r = new Random();

	@Override
	public void flyTo(LlaCoordinate targetCoordinates, Double speed) {
		if (targetCoordinates != currentTarget) {
			// TODO: add some time limit for refreshing the information in case it didn't
			// properly get sent
			currentTarget = targetCoordinates;
			try { 
				LOGGER.missionInfo(droneID + "" Flying to new waypoint "" + targetCoordinates);
				sendCommand(new GoToCommand(droneID, targetCoordinates));

				if (speed != null && speed > 0) {
					sendCommand(new SetGroundSpeedCommand(droneID, speed));
				}
			} catch (DroneException e) {
				LOGGER.error(e);
			} 
		}

	}

	@Override
	public LlaCoordinate getCoordinates() {
		return droneStatus.getCoordinates();
	}

	@Override
	public void land() throws FlightZoneException {
		try {
			sendCommand(new LandCommand(droneID, LandCommand.MODE_LAND));
		} catch (DroneException e) {
			throw new FlightZoneException(e);
		}
	}

	@Override
	public void takeOff(double altitude) throws FlightZoneException {
		try {
			baseStation.sendCommand(new TakeoffCommand(droneID, altitude));
		} catch (DroneException e) {
			throw new FlightZoneException(e);
		}
	}

	@Override
	public double getBatteryStatus() {
		return droneStatus.getBatteryLevel();
	}

	@Override
	public boolean move(double i) {
		// update data from the server
		// TODO: this might not necessarily be the best place to update this
		// baseStation.getIncomingData();
		return !isDestinationReached(0);
		// TODO Auto-generated method stub

	}

	@Override
	public void setVoltageCheckPoint() {
		// TODO Auto-generated method stub

	}

	@Override
	@CoordinateChange
	public boolean isDestinationReached(int i) {
		double distancetotarget = Math.abs(currentPosition.distance(currentTarget));
		LOGGER.trace(droneID + "" - Distance to target:"" + distancetotarget);
		return distancetotarget < DronologyConstants.THRESHOLD_WAYPOINT_DISTANCE;
	}

	@Override
	public void update(LlaCoordinate location, double batteryLevel, double speed, Vector3D velocity, Vector3D attitude) {
		updateCoordinates(location);
		updateVelocity(speed);
		updateBatteryLevel(batteryLevel);
		updateCollisionAvoidance(location, velocity, attitude);

		super.setChanged();
		super.notifyObservers();
	}

	@Override
	public void updateCoordinates(LlaCoordinate location) {
		// LOGGER.info(""Coordinates updated"");
		super.setCoordinates(location);

	}

	@Override
	public void updateDroneState(String status) {
		LOGGER.info(status);

	}

	@Override
	public void setGroundSpeed(double speed) {
		try {
			baseStation.sendCommand(new SetGroundSpeedCommand(droneID, speed));
		} catch (DroneException e) {
			LOGGER.error(e);
		}
	}

	@Override
	public void setVelocity(double x, double y, double z) {
		try {
			baseStation.sendCommand(new SetVelocityCommand(droneID, x, y, z));
		} catch (DroneException e) {
			LOGGER.error(e);
		}
	}

	@Override
	public void updateBatteryLevel(double batteryLevel) {
		super.updateBatteryLevel(batteryLevel);
	}

	@Override
	public void updateVelocity(double velocity) {
		super.setVelocity(velocity);
	}

	@Override
	public void updateCollisionAvoidance(LlaCoordinate position, Vector3D velocity, Vector3D attitude) {
		DroneSnapshotInternal snapshot = new DroneSnapshotInternal(this.getDroneName(), position, velocity, attitude);
		this.latestDroneSnapshot = snapshot;
	}

	public DroneSnapshotInternal getLatestDroneSnapshot() {
		return latestDroneSnapshot;
	}

	@Override
	public void updateMode(String mode) {
		if (mode.equals(FlightMode.USER_CONTROLLED.toString())) {
			super.setUserControlled(); 
		}

	}

	@Override
	public void sendCommand(AbstractDroneCommand command) throws DroneException {
		synchronized (baseStation) {
			lastCommand = command;
			baseStation.sendCommand(command);
		}
	}

	@Override
	public void resendCommand() throws DroneException { 
		LOGGER.hwInfo(""Resending previous command for '"" + droneID + ""'"");
		synchronized (baseStation) {
			if (lastCommand == null) {
				LOGGER.hwFatal(""No command recorded for uav '"" + droneID + ""'"");
				throw new DroneException(""no previous command found"");
			}
			LOGGER.info(""Resending command for '"" + lastCommand + ""'"");
			sendCommand(lastCommand);
		}

	}
}
"
UAVStatusWrapper.java,"package edu.nd.dronology.ui.vaadin.activeflights;

import edu.nd.dronology.core.vehicle.IUAVProxy;

/**
 * Wrapper class for UAV data.,<br>
 * Provides uav status information (such as location, speed, etc.) in a properly formatted, ui friendly format.
 * 
 * @author Michael Vierhauser
 *
 */
public class UAVStatusWrapper {
	public static final String STATUS_GREEN = ""green"";

	private final String batteryLife;
	private final String speed;

	private final String healthColor;
	private final String status;
	private final String name;

	private String latitude;
	private String longitude;
	private String altitude;

	public UAVStatusWrapper(double batteryLife, double speed, double lat, double lon, double alt, String healthColor,
			String status, String name) {
		this.batteryLife = String.format(""%.2f"", batteryLife);
		this.speed = String.format(""%.2f"", speed);

		this.latitude = String.format(""%.5f"", lat);
		this.longitude = String.format(""%.5f"", lon);
		this.altitude = String.format(""%.2f"", alt);

		this.healthColor = healthColor;
		this.status = status;
		this.name = name;
	}

	public UAVStatusWrapper(IUAVProxy e) {
		this(e.getBatteryLevel(), e.getVelocity(), e.getLatitude(), e.getLongitude(), e.getAltitude(), STATUS_GREEN,
				e.getStatus(), e.getID());
	}

	public String getSpeed() {
		return speed;
	}

	public String getBatteryLife() {
		return batteryLife;
	}

	public String getLatitude() {
		return latitude;
	}

	public String getLongitude() {
		return longitude;
	}

	public String getAltitude() {
		return altitude;
	}

	public String getHealthColor() {
		return healthColor;
	}

	public String getStatus() {
		return status;
	}

	public String getName() {
		return name;
	}
}"
ILayer.java,"package edu.nd.dronology.core.collisionavoidance.strategy.onionbackend;

public interface ILayer extends IAction {
    /**
     * Given a distance, this method returns true if the layer should be triggered.
     */
    public boolean isTriggered(double distance);

    public double getTriggerDistance();

}"
